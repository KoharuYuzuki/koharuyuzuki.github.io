var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/@tensorflow/tfjs-core/dist/backends/backend.js
function notYetImplemented(kernelName) {
  throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` + `This kernel may not be supported by the tfjs backend you have chosen`);
}

class DataStorage {
  constructor(backend, dataMover) {
    this.backend = backend;
    this.dataMover = dataMover;
    this.data = new WeakMap;
    this.dataIdsCount = 0;
  }
  get(dataId) {
    if (!this.data.has(dataId)) {
      this.dataMover.moveData(this.backend, dataId);
    }
    return this.data.get(dataId);
  }
  set(dataId, value) {
    this.dataIdsCount++;
    this.data.set(dataId, value);
  }
  has(dataId) {
    return this.data.has(dataId);
  }
  delete(dataId) {
    this.dataIdsCount--;
    return this.data.delete(dataId);
  }
  numDataIds() {
    return this.dataIdsCount;
  }
}

class KernelBackend {
  refCount(dataId) {
    return notYetImplemented("refCount");
  }
  incRef(dataId) {
    return notYetImplemented("incRef");
  }
  timerAvailable() {
    return true;
  }
  time(f) {
    return notYetImplemented("time");
  }
  read(dataId) {
    return notYetImplemented("read");
  }
  readSync(dataId) {
    return notYetImplemented("readSync");
  }
  readToGPU(dataId, options) {
    return notYetImplemented("readToGPU");
  }
  numDataIds() {
    return notYetImplemented("numDataIds");
  }
  disposeData(dataId, force) {
    return notYetImplemented("disposeData");
  }
  write(values, shape, dtype) {
    return notYetImplemented("write");
  }
  move(dataId, values, shape, dtype, refCount) {
    return notYetImplemented("move");
  }
  createTensorFromGPUData(values, shape, dtype) {
    return notYetImplemented("createTensorFromGPUData");
  }
  memory() {
    return notYetImplemented("memory");
  }
  floatPrecision() {
    return notYetImplemented("floatPrecision");
  }
  epsilon() {
    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;
  }
  dispose() {
    return notYetImplemented("dispose");
  }
}
var EPSILON_FLOAT32 = 0.0000001, EPSILON_FLOAT16 = 0.0001;

// node_modules/@tensorflow/tfjs-core/dist/util_base.js
function shuffle(array) {
  let counter = array.length;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    swap(array, counter, index);
  }
}
function shuffleCombo(array, array2) {
  if (array.length !== array2.length) {
    throw new Error(`Array sizes must match to be shuffled together ` + `First array length was ${array.length}` + `Second array length was ${array2.length}`);
  }
  let counter = array.length;
  let index = 0;
  while (counter > 0) {
    index = Math.random() * counter | 0;
    counter--;
    swap(array, counter, index);
    swap(array2, counter, index);
  }
}
function clamp(min, x, max) {
  return Math.max(min, Math.min(x, max));
}
function nearestLargerEven(val) {
  return val % 2 === 0 ? val : val + 1;
}
function swap(object, left, right) {
  const temp = object[left];
  object[left] = object[right];
  object[right] = temp;
}
function sum(arr) {
  let sum2 = 0;
  for (let i = 0;i < arr.length; i++) {
    sum2 += arr[i];
  }
  return sum2;
}
function randUniform(a, b) {
  const r = Math.random();
  return b * r + (1 - r) * a;
}
function distSquared(a, b) {
  let result = 0;
  for (let i = 0;i < a.length; i++) {
    const diff = Number(a[i]) - Number(b[i]);
    result += diff * diff;
  }
  return result;
}
function assert(expr, msg) {
  if (!expr) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix = "") {
  assert(arraysEqual(shapeA, shapeB), () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
}
function assertNonNull(a) {
  assert(a != null, () => `The input to the tensor constructor must be a non-null value.`);
}
function sizeFromShape(shape) {
  if (shape.length === 0) {
    return 1;
  }
  let size = shape[0];
  for (let i = 1;i < shape.length; i++) {
    size *= shape[i];
  }
  return size;
}
function isScalarShape(shape) {
  return shape.length === 0;
}
function arraysEqualWithNull(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  if (n1 == null || n2 == null) {
    return false;
  }
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i = 0;i < n1.length; i++) {
    if (n1[i] !== null && n2[i] !== null && n1[i] !== n2[i]) {
      return false;
    }
  }
  return true;
}
function arraysEqual(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  if (n1 == null || n2 == null) {
    return false;
  }
  if (n1.length !== n2.length) {
    return false;
  }
  for (let i = 0;i < n1.length; i++) {
    if (n1[i] !== n2[i]) {
      return false;
    }
  }
  return true;
}
function isInt(a) {
  return a % 1 === 0;
}
function tanh(x) {
  if (Math.tanh != null) {
    return Math.tanh(x);
  }
  if (x === Infinity) {
    return 1;
  } else if (x === -Infinity) {
    return -1;
  } else {
    const e2x = Math.exp(2 * x);
    return (e2x - 1) / (e2x + 1);
  }
}
function sizeToSquarishShape(size) {
  const width = Math.ceil(Math.sqrt(size));
  return [width, Math.ceil(size / width)];
}
function createShuffledIndices(n) {
  const shuffledIndices = new Uint32Array(n);
  for (let i = 0;i < n; ++i) {
    shuffledIndices[i] = i;
  }
  shuffle(shuffledIndices);
  return shuffledIndices;
}
function rightPad(a, size) {
  if (size <= a.length) {
    return a;
  }
  return a + " ".repeat(size - a.length);
}
function repeatedTry(checkFn, delayFn = (counter) => 0, maxCounter, scheduleFn) {
  return new Promise((resolve, reject) => {
    let tryCount = 0;
    const tryFn = () => {
      if (checkFn()) {
        resolve();
        return;
      }
      tryCount++;
      const nextBackoff = delayFn(tryCount);
      if (maxCounter != null && tryCount >= maxCounter) {
        reject();
        return;
      }
      if (scheduleFn != null) {
        scheduleFn(tryFn, nextBackoff);
      } else {
        setTimeout(tryFn, nextBackoff);
      }
    };
    tryFn();
  });
}
function inferFromImplicitShape(shape, size) {
  let shapeProd = 1;
  let implicitIdx = -1;
  for (let i = 0;i < shape.length; ++i) {
    if (shape[i] >= 0) {
      shapeProd *= shape[i];
    } else if (shape[i] === -1) {
      if (implicitIdx !== -1) {
        throw Error(`Shapes can only have 1 implicit size. ` + `Found -1 at dim ${implicitIdx} and dim ${i}`);
      }
      implicitIdx = i;
    } else if (shape[i] < 0) {
      throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);
    }
  }
  if (implicitIdx === -1) {
    if (size > 0 && size !== shapeProd) {
      throw Error(`Size(${size}) must match the product of shape ${shape}`);
    }
    return shape;
  }
  if (shapeProd === 0) {
    throw Error(`Cannot infer the missing size in [${shape}] when ` + `there are 0 elements`);
  }
  if (size % shapeProd !== 0) {
    throw Error(`The implicit shape can't be a fractional number. ` + `Got ${size} / ${shapeProd}`);
  }
  const newShape = shape.slice();
  newShape[implicitIdx] = size / shapeProd;
  return newShape;
}
function parseAxisParam(axis, shape) {
  const rank = shape.length;
  axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);
  assert(axis.every((ax) => ax >= -rank && ax < rank), () => `All values in axis param must be in range [-${rank}, ${rank}) but ` + `got axis ${axis}`);
  assert(axis.every((ax) => isInt(ax)), () => `All values in axis param must be integers but ` + `got axis ${axis}`);
  return axis.map((a) => a < 0 ? rank + a : a);
}
function squeezeShape(shape, axis) {
  const newShape = [];
  const keptDims = [];
  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape).sort();
  let j = 0;
  for (let i = 0;i < shape.length; ++i) {
    if (axes != null) {
      if (axes[j] === i && shape[i] !== 1) {
        throw new Error(`Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);
      }
      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
        newShape.push(shape[i]);
        keptDims.push(i);
      }
      if (axes[j] <= i) {
        j++;
      }
    }
    if (shape[i] !== 1) {
      newShape.push(shape[i]);
      keptDims.push(i);
    }
  }
  return { newShape, keptDims };
}
function getTypedArrayFromDType(dtype, size) {
  return getArrayFromDType(dtype, size);
}
function getArrayFromDType(dtype, size) {
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size);
  } else if (dtype === "int32") {
    values = new Int32Array(size);
  } else if (dtype === "bool") {
    values = new Uint8Array(size);
  } else if (dtype === "string") {
    values = new Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  return values;
}
function checkConversionForErrors(vals, dtype) {
  for (let i = 0;i < vals.length; i++) {
    const num = vals[i];
    if (isNaN(num) || !isFinite(num)) {
      throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);
    }
  }
}
function isValidDtype(dtype) {
  return dtype === "bool" || dtype === "complex64" || dtype === "float32" || dtype === "int32" || dtype === "string";
}
function hasEncodingLoss(oldType, newType) {
  if (newType === "complex64") {
    return false;
  }
  if (newType === "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "int32" && oldType !== "float32" && oldType !== "complex64") {
    return false;
  }
  if (newType === "bool" && oldType === "bool") {
    return false;
  }
  return true;
}
function bytesPerElement(dtype) {
  if (dtype === "float32" || dtype === "int32") {
    return 4;
  } else if (dtype === "complex64") {
    return 8;
  } else if (dtype === "bool") {
    return 1;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function bytesFromStringArray(arr) {
  if (arr == null) {
    return 0;
  }
  let bytes = 0;
  arr.forEach((x) => bytes += x.length);
  return bytes;
}
function isString(value) {
  return typeof value === "string" || value instanceof String;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isNumber(value) {
  return typeof value === "number";
}
function inferDtype(values) {
  if (Array.isArray(values)) {
    return inferDtype(values[0]);
  }
  if (values instanceof Float32Array) {
    return "float32";
  } else if (values instanceof Int32Array || values instanceof Uint8Array || values instanceof Uint8ClampedArray) {
    return "int32";
  } else if (isNumber(values)) {
    return "float32";
  } else if (isString(values)) {
    return "string";
  } else if (isBoolean(values)) {
    return "bool";
  }
  return "float32";
}
function isFunction(f) {
  return !!(f && f.constructor && f.call && f.apply);
}
function nearestDivisor(size, start) {
  for (let i = start;i < size; ++i) {
    if (size % i === 0) {
      return i;
    }
  }
  return size;
}
function computeStrides(shape) {
  const rank = shape.length;
  if (rank < 2) {
    return [];
  }
  const strides = new Array(rank - 1);
  strides[rank - 2] = shape[rank - 1];
  for (let i = rank - 3;i >= 0; --i) {
    strides[i] = strides[i + 1] * shape[i + 1];
  }
  return strides;
}
function createNestedArray(offset, shape, a, isComplex = false) {
  const ret = new Array;
  if (shape.length === 1) {
    const d = shape[0] * (isComplex ? 2 : 1);
    for (let i = 0;i < d; i++) {
      ret[i] = a[offset + i];
    }
  } else {
    const d = shape[0];
    const rest = shape.slice(1);
    const len = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
    for (let i = 0;i < d; i++) {
      ret[i] = createNestedArray(offset + i * len, rest, a, isComplex);
    }
  }
  return ret;
}
function toNestedArray(shape, a, isComplex = false) {
  if (shape.length === 0) {
    return a[0];
  }
  const size = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);
  if (size === 0) {
    return [];
  }
  if (size !== a.length) {
    throw new Error(`[${shape}] does not match the input size ${a.length}${isComplex ? " for a complex tensor" : ""}.`);
  }
  return createNestedArray(0, shape, a, isComplex);
}
function convertBackendValuesAndArrayBuffer(data, dtype) {
  if (Array.isArray(data)) {
    return data;
  }
  if (dtype === "float32") {
    return data instanceof Float32Array ? data : new Float32Array(data);
  } else if (dtype === "int32") {
    return data instanceof Int32Array ? data : new Int32Array(data);
  } else if (dtype === "bool" || dtype === "string") {
    return Uint8Array.from(new Int32Array(data));
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function makeOnesTypedArray(size, dtype) {
  const array = makeZerosTypedArray(size, dtype);
  for (let i = 0;i < array.length; i++) {
    array[i] = 1;
  }
  return array;
}
function makeZerosTypedArray(size, dtype) {
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(size);
  } else if (dtype === "int32") {
    return new Int32Array(size);
  } else if (dtype === "bool") {
    return new Uint8Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function makeZerosNestedTypedArray(shape, dtype) {
  const size = shape.reduce((prev, curr) => prev * curr, 1);
  if (dtype == null || dtype === "float32") {
    return toNestedArray(shape, new Float32Array(size));
  } else if (dtype === "int32") {
    return toNestedArray(shape, new Int32Array(size));
  } else if (dtype === "bool") {
    return toNestedArray(shape, new Uint8Array(size));
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function assertNonNegativeIntegerDimensions(shape) {
  shape.forEach((dimSize) => {
    assert(Number.isInteger(dimSize) && dimSize >= 0, () => `Tensor must have a shape comprised of positive integers but got ` + `shape [${shape}].`);
  });
}
function locToIndex(locs, rank, strides) {
  if (rank === 0) {
    return 0;
  } else if (rank === 1) {
    return locs[0];
  }
  let index = locs[locs.length - 1];
  for (let i = 0;i < locs.length - 1; ++i) {
    index += strides[i] * locs[i];
  }
  return index;
}
function indexToLoc(index, rank, strides) {
  if (rank === 0) {
    return [];
  } else if (rank === 1) {
    return [index];
  }
  const locs = new Array(rank);
  for (let i = 0;i < locs.length - 1; ++i) {
    locs[i] = Math.floor(index / strides[i]);
    index -= locs[i] * strides[i];
  }
  locs[locs.length - 1] = index;
  return locs;
}
function isPromise(object) {
  return object && object.then && typeof object.then === "function";
}

// node_modules/@tensorflow/tfjs-core/dist/environment.js
function getQueryParams(queryString) {
  const params = {};
  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {
    decodeParam(params, t[0], t[1]);
    return t.join("=");
  });
  return params;
}
function decodeParam(params, name, value) {
  params[decodeURIComponent(name)] = decodeURIComponent(value || "");
}
function parseValue(flagName, value) {
  const lowerCaseValue = value.toLowerCase();
  if (lowerCaseValue === "true" || lowerCaseValue === "false") {
    return lowerCaseValue === "true";
  } else if (`${+lowerCaseValue}` === lowerCaseValue) {
    return +lowerCaseValue;
  } else {
    return value;
  }
}
function env() {
  return ENV;
}
function setEnvironmentGlobal(environment) {
  ENV = environment;
}

class Environment {
  constructor(global2) {
    this.global = global2;
    this.flags = {};
    this.flagRegistry = {};
    this.urlFlags = {};
    this.getQueryParams = getQueryParams;
    this.populateURLFlags();
  }
  setPlatform(platformName, platform) {
    if (this.platform != null) {
      if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
        console.warn(`Platform ${this.platformName} has already been set. ` + `Overwriting the platform with ${platformName}.`);
      }
    }
    this.platformName = platformName;
    this.platform = platform;
  }
  registerFlag(flagName, evaluationFn, setHook) {
    this.flagRegistry[flagName] = { evaluationFn, setHook };
    if (this.urlFlags[flagName] != null) {
      const flagValue = this.urlFlags[flagName];
      if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
        console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);
      }
      this.set(flagName, flagValue);
    }
  }
  async getAsync(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    this.flags[flagName] = await this.evaluateFlag(flagName);
    return this.flags[flagName];
  }
  get(flagName) {
    if (flagName in this.flags) {
      return this.flags[flagName];
    }
    const flagValue = this.evaluateFlag(flagName);
    if (isPromise(flagValue)) {
      throw new Error(`Flag ${flagName} cannot be synchronously evaluated. ` + `Please use getAsync() instead.`);
    }
    this.flags[flagName] = flagValue;
    return this.flags[flagName];
  }
  getNumber(flagName) {
    return this.get(flagName);
  }
  getBool(flagName) {
    return this.get(flagName);
  }
  getString(flagName) {
    return this.get(flagName);
  }
  getFlags() {
    return this.flags;
  }
  get features() {
    return this.flags;
  }
  set(flagName, value) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);
    }
    this.flags[flagName] = value;
    if (this.flagRegistry[flagName].setHook != null) {
      this.flagRegistry[flagName].setHook(value);
    }
  }
  evaluateFlag(flagName) {
    if (this.flagRegistry[flagName] == null) {
      throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);
    }
    return this.flagRegistry[flagName].evaluationFn();
  }
  setFlags(flags) {
    this.flags = Object.assign({}, flags);
  }
  reset() {
    this.flags = {};
    this.urlFlags = {};
    this.populateURLFlags();
  }
  populateURLFlags() {
    if (typeof this.global === "undefined" || typeof this.global.location === "undefined" || typeof this.global.location.search === "undefined") {
      return;
    }
    const urlParams = this.getQueryParams(this.global.location.search);
    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {
      const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(",");
      keyValues.forEach((keyValue) => {
        const [key, value] = keyValue.split(":");
        this.urlFlags[key] = parseValue(key, value);
      });
    }
  }
}
var TENSORFLOWJS_FLAGS_PREFIX = "tfjsflags", ENV = null;
var init_environment = () => {
};

// node_modules/@tensorflow/tfjs-core/dist/global_util.js
function getGlobalNamespace() {
  if (globalNameSpace == null) {
    let ns;
    if (typeof window !== "undefined") {
      ns = window;
    } else if (typeof global !== "undefined") {
      ns = global;
    } else if (typeof process !== "undefined") {
      ns = process;
    } else if (typeof self !== "undefined") {
      ns = self;
    } else {
      throw new Error("Could not find a global object");
    }
    globalNameSpace = ns;
  }
  return globalNameSpace;
}
function getGlobalMap() {
  const ns = getGlobalNamespace();
  if (ns._tfGlobals == null) {
    ns._tfGlobals = new Map;
  }
  return ns._tfGlobals;
}
function getGlobal(key, init) {
  const globalMap = getGlobalMap();
  if (globalMap.has(key)) {
    return globalMap.get(key);
  } else {
    const singleton = init();
    globalMap.set(key, singleton);
    return globalMap.get(key);
  }
}
var globalNameSpace;

// node_modules/@tensorflow/tfjs-core/dist/kernel_names.js
var Abs = "Abs", Acos = "Acos", Acosh = "Acosh", Add = "Add", AddN = "AddN", All = "All", Any = "Any", ArgMax = "ArgMax", ArgMin = "ArgMin", Asin = "Asin", Asinh = "Asinh", Atan = "Atan", Atanh = "Atanh", Atan2 = "Atan2", AvgPool = "AvgPool", AvgPoolGrad = "AvgPoolGrad", AvgPool3D = "AvgPool3D", AvgPool3DGrad = "AvgPool3DGrad", BatchMatMul = "BatchMatMul", BatchToSpaceND = "BatchToSpaceND", Bincount = "Bincount", BitwiseAnd = "BitwiseAnd", BroadcastTo = "BroadcastTo", BroadcastArgs = "BroadcastArgs", Cast = "Cast", Ceil = "Ceil", ClipByValue = "ClipByValue", Complex = "Complex", ComplexAbs = "ComplexAbs", Concat = "Concat", Conv2D = "Conv2D", Conv2DBackpropFilter = "Conv2DBackpropFilter", Conv2DBackpropInput = "Conv2DBackpropInput", Conv3D = "Conv3D", Conv3DBackpropFilterV2 = "Conv3DBackpropFilterV2", Conv3DBackpropInputV2 = "Conv3DBackpropInputV2", Cos = "Cos", Cosh = "Cosh", Cumprod = "Cumprod", Cumsum = "Cumsum", CropAndResize = "CropAndResize", DenseBincount = "DenseBincount", DepthToSpace = "DepthToSpace", DepthwiseConv2dNative = "DepthwiseConv2dNative", DepthwiseConv2dNativeBackpropFilter = "DepthwiseConv2dNativeBackpropFilter", DepthwiseConv2dNativeBackpropInput = "DepthwiseConv2dNativeBackpropInput", Diag = "Diag", Dilation2D = "Dilation2D", Dilation2DBackpropInput = "Dilation2DBackpropInput", Dilation2DBackpropFilter = "Dilation2DBackpropFilter", Draw = "Draw", RealDiv = "RealDiv", Einsum = "Einsum", Elu = "Elu", EluGrad = "EluGrad", Erf = "Erf", Equal = "Equal", Exp = "Exp", ExpandDims = "ExpandDims", Expm1 = "Expm1", FFT = "FFT", Fill = "Fill", FlipLeftRight = "FlipLeftRight", Floor = "Floor", FloorDiv = "FloorDiv", FusedBatchNorm = "FusedBatchNorm", GatherV2 = "GatherV2", GatherNd = "GatherNd", Greater = "Greater", GreaterEqual = "GreaterEqual", Identity = "Identity", IFFT = "IFFT", Imag = "Imag", IsFinite = "IsFinite", IsInf = "IsInf", IsNan = "IsNan", LeakyRelu = "LeakyRelu", Less = "Less", LessEqual = "LessEqual", LinSpace = "LinSpace", Log = "Log", Log1p = "Log1p", LogicalAnd = "LogicalAnd", LogicalNot = "LogicalNot", LogicalOr = "LogicalOr", LogicalXor = "LogicalXor", LogSoftmax = "LogSoftmax", LowerBound = "LowerBound", LRN = "LRN", LRNGrad = "LRNGrad", MatrixBandPart = "MatrixBandPart", Max = "Max", Maximum = "Maximum", MaxPool = "MaxPool", MaxPoolGrad = "MaxPoolGrad", MaxPool3D = "MaxPool3D", MaxPool3DGrad = "MaxPool3DGrad", MaxPoolWithArgmax = "MaxPoolWithArgmax", Mean = "Mean", Min = "Min", Minimum = "Minimum", MirrorPad = "MirrorPad", Mod = "Mod", Multinomial = "Multinomial", Multiply = "Multiply", Neg = "Neg", NotEqual = "NotEqual", NonMaxSuppressionV3 = "NonMaxSuppressionV3", NonMaxSuppressionV4 = "NonMaxSuppressionV4", NonMaxSuppressionV5 = "NonMaxSuppressionV5", OnesLike = "OnesLike", OneHot = "OneHot", Pack = "Pack", PadV2 = "PadV2", Pool = "Pool", Pow = "Pow", Prelu = "Prelu", Prod = "Prod", RaggedGather = "RaggedGather", RaggedRange = "RaggedRange", RaggedTensorToTensor = "RaggedTensorToTensor", Range = "Range", Real = "Real", Reciprocal = "Reciprocal", Relu = "Relu", Reshape = "Reshape", ResizeNearestNeighbor = "ResizeNearestNeighbor", ResizeNearestNeighborGrad = "ResizeNearestNeighborGrad", ResizeBilinear = "ResizeBilinear", ResizeBilinearGrad = "ResizeBilinearGrad", Relu6 = "Relu6", Reverse = "Reverse", Round = "Round", Rsqrt = "Rsqrt", ScatterNd = "ScatterNd", TensorScatterUpdate = "TensorScatterUpdate", SearchSorted = "SearchSorted", Select = "Select", Selu = "Selu", Slice = "Slice", Sin = "Sin", Sinh = "Sinh", Sign = "Sign", Sigmoid = "Sigmoid", Softplus = "Softplus", Sqrt = "Sqrt", Sum = "Sum", SpaceToBatchND = "SpaceToBatchND", SplitV = "SplitV", Softmax = "Softmax", SparseFillEmptyRows = "SparseFillEmptyRows", SparseReshape = "SparseReshape", SparseSegmentMean = "SparseSegmentMean", SparseSegmentSum = "SparseSegmentSum", SparseToDense = "SparseToDense", SquaredDifference = "SquaredDifference", Square = "Square", StaticRegexReplace = "StaticRegexReplace", StridedSlice = "StridedSlice", StringNGrams = "StringNGrams", StringSplit = "StringSplit", StringToHashBucketFast = "StringToHashBucketFast", Sub = "Sub", Tan = "Tan", Tanh = "Tanh", Tile = "Tile", TopK = "TopK", Transform = "Transform", Transpose = "Transpose", Unique = "Unique", Unpack = "Unpack", UnsortedSegmentSum = "UnsortedSegmentSum", UpperBound = "UpperBound", ZerosLike = "ZerosLike", Step = "Step", FromPixels = "FromPixels", RotateWithOffset = "RotateWithOffset", _FusedMatMul = "_FusedMatMul", FusedConv2D = "FusedConv2D", FusedDepthwiseConv2D = "FusedDepthwiseConv2D";

// node_modules/@tensorflow/tfjs-core/dist/log.js
function warn(...msg) {
  if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
    console.warn(...msg);
  }
}
function log(...msg) {
  if (!(env().getBool("IS_TEST") || env().getBool("PROD"))) {
    console.log(...msg);
  }
}
var init_log = __esm(() => {
  init_environment();
});

// node_modules/@tensorflow/tfjs-core/dist/kernel_registry.js
function getKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  return kernelRegistry.get(key);
}
function getGradient(kernelName) {
  return gradRegistry.get(kernelName);
}
function getKernelsForBackend(backendName) {
  const it = kernelRegistry.entries();
  const result = [];
  while (true) {
    const { done, value } = it.next();
    if (done) {
      break;
    }
    const [key, config] = value;
    const [backend] = key.split("_");
    if (backend === backendName) {
      result.push(config);
    }
  }
  return result;
}
function registerKernel(config) {
  const { kernelName, backendName } = config;
  const key = makeKey(kernelName, backendName);
  if (kernelRegistry.has(key)) {
    warn(`The kernel '${kernelName}' for backend ` + `'${backendName}' is already registered`);
  }
  kernelRegistry.set(key, config);
}
function registerGradient(config) {
  const { kernelName } = config;
  if (gradRegistry.has(kernelName)) {
    if (env().getBool("DEBUG")) {
      warn(`Overriding the gradient for '${kernelName}'`);
    }
  }
  gradRegistry.set(kernelName, config);
}
function unregisterKernel(kernelName, backendName) {
  const key = makeKey(kernelName, backendName);
  if (!kernelRegistry.has(key)) {
    throw new Error(`The kernel '${kernelName}' for backend ` + `'${backendName}' is not registered`);
  }
  kernelRegistry.delete(key);
}
function unregisterGradient(kernelName) {
  if (!gradRegistry.has(kernelName)) {
    throw new Error(`The gradient '${kernelName}' for backend is not registered`);
  }
  gradRegistry.delete(kernelName);
}
function copyRegisteredKernels(registeredBackendName, newBackendName) {
  const kernels = getKernelsForBackend(registeredBackendName);
  kernels.forEach((kernelConfig) => {
    const newKernelConfig = Object.assign({}, kernelConfig, { backendName: newBackendName });
    registerKernel(newKernelConfig);
  });
}
function makeKey(kernelName, backendName) {
  return `${backendName}_${kernelName}`;
}
var kernelRegistry, gradRegistry;
var init_kernel_registry = __esm(() => {
  init_environment();
  init_log();
  kernelRegistry = getGlobal("kernelRegistry", () => new Map);
  gradRegistry = getGlobal("gradRegistry", () => new Map);
});

// node_modules/@tensorflow/tfjs-core/dist/platforms/is_typed_array_browser.js
function isTypedArrayBrowser(a) {
  return a instanceof Float32Array || a instanceof Int32Array || a instanceof Uint8Array || a instanceof Uint8ClampedArray;
}

// node_modules/long/src/long.js
var require_long = __commonJS((exports, module) => {
  function Long(low, high, unsigned) {
    this.low = low | 0;
    this.high = high | 0;
    this.unsigned = !!unsigned;
  }
  function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
  }
  function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
      value >>>= 0;
      if (cache = 0 <= value && value < 256) {
        cachedObj = UINT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
      if (cache)
        UINT_CACHE[value] = obj;
      return obj;
    } else {
      value |= 0;
      if (cache = -128 <= value && value < 128) {
        cachedObj = INT_CACHE[value];
        if (cachedObj)
          return cachedObj;
      }
      obj = fromBits(value, value < 0 ? -1 : 0, false);
      if (cache)
        INT_CACHE[value] = obj;
      return obj;
    }
  }
  function fromNumber(value, unsigned) {
    if (isNaN(value))
      return unsigned ? UZERO : ZERO;
    if (unsigned) {
      if (value < 0)
        return UZERO;
      if (value >= TWO_PWR_64_DBL)
        return MAX_UNSIGNED_VALUE;
    } else {
      if (value <= -TWO_PWR_63_DBL)
        return MIN_VALUE;
      if (value + 1 >= TWO_PWR_63_DBL)
        return MAX_VALUE;
    }
    if (value < 0)
      return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
  }
  function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
  }
  function fromString(str, unsigned, radix) {
    if (str.length === 0)
      throw Error("empty string");
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
      return ZERO;
    if (typeof unsigned === "number") {
      radix = unsigned, unsigned = false;
    } else {
      unsigned = !!unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0)
      throw Error("interior hyphen");
    else if (p === 0) {
      return fromString(str.substring(1), unsigned, radix).neg();
    }
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for (var i = 0;i < str.length; i += 8) {
      var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
      if (size < 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).add(fromNumber(value));
      } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
      }
    }
    result.unsigned = unsigned;
    return result;
  }
  function fromValue(val, unsigned) {
    if (typeof val === "number")
      return fromNumber(val, unsigned);
    if (typeof val === "string")
      return fromString(val, unsigned);
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
  }
  module.exports = Long;
  var wasm = null;
  try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
      0,
      97,
      115,
      109,
      1,
      0,
      0,
      0,
      1,
      13,
      2,
      96,
      0,
      1,
      127,
      96,
      4,
      127,
      127,
      127,
      127,
      1,
      127,
      3,
      7,
      6,
      0,
      1,
      1,
      1,
      1,
      1,
      6,
      6,
      1,
      127,
      1,
      65,
      0,
      11,
      7,
      50,
      6,
      3,
      109,
      117,
      108,
      0,
      1,
      5,
      100,
      105,
      118,
      95,
      115,
      0,
      2,
      5,
      100,
      105,
      118,
      95,
      117,
      0,
      3,
      5,
      114,
      101,
      109,
      95,
      115,
      0,
      4,
      5,
      114,
      101,
      109,
      95,
      117,
      0,
      5,
      8,
      103,
      101,
      116,
      95,
      104,
      105,
      103,
      104,
      0,
      0,
      10,
      191,
      1,
      6,
      4,
      0,
      35,
      0,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      126,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      127,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      128,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      129,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11,
      36,
      1,
      1,
      126,
      32,
      0,
      173,
      32,
      1,
      173,
      66,
      32,
      134,
      132,
      32,
      2,
      173,
      32,
      3,
      173,
      66,
      32,
      134,
      132,
      130,
      34,
      4,
      66,
      32,
      135,
      167,
      36,
      0,
      32,
      4,
      167,
      11
    ])), {}).exports;
  } catch (e) {
  }
  Long.prototype.__isLong__;
  Object.defineProperty(Long.prototype, "__isLong__", { value: true });
  Long.isLong = isLong;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  Long.fromInt = fromInt;
  Long.fromNumber = fromNumber;
  Long.fromBits = fromBits;
  var pow_dbl = Math.pow;
  Long.fromString = fromString;
  Long.fromValue = fromValue;
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
  var ZERO = fromInt(0);
  Long.ZERO = ZERO;
  var UZERO = fromInt(0, true);
  Long.UZERO = UZERO;
  var ONE = fromInt(1);
  Long.ONE = ONE;
  var UONE = fromInt(1, true);
  Long.UONE = UONE;
  var NEG_ONE = fromInt(-1);
  Long.NEG_ONE = NEG_ONE;
  var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
  Long.MAX_VALUE = MAX_VALUE;
  var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
  var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
  Long.MIN_VALUE = MIN_VALUE;
  var LongPrototype = Long.prototype;
  LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
  };
  LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
      return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
  };
  LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
      throw RangeError("radix");
    if (this.isZero())
      return "0";
    if (this.isNegative()) {
      if (this.eq(MIN_VALUE)) {
        var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
      } else
        return "-" + this.neg().toString(radix);
    }
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while (true) {
      var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
      rem = remDiv;
      if (rem.isZero())
        return digits + result;
      else {
        while (digits.length < 6)
          digits = "0" + digits;
        result = "" + digits + result;
      }
    }
  };
  LongPrototype.getHighBits = function getHighBits() {
    return this.high;
  };
  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
  };
  LongPrototype.getLowBits = function getLowBits() {
    return this.low;
  };
  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
  };
  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative())
      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31;bit > 0; bit--)
      if ((val & 1 << bit) != 0)
        break;
    return this.high != 0 ? bit + 33 : bit + 1;
  };
  LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
  };
  LongPrototype.eqz = LongPrototype.isZero;
  LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
  };
  LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
  };
  LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
  };
  LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
  };
  LongPrototype.equals = function equals(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
      return false;
    return this.high === other.high && this.low === other.low;
  };
  LongPrototype.eq = LongPrototype.equals;
  LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(other);
  };
  LongPrototype.neq = LongPrototype.notEquals;
  LongPrototype.ne = LongPrototype.notEquals;
  LongPrototype.lessThan = function lessThan(other) {
    return this.comp(other) < 0;
  };
  LongPrototype.lt = LongPrototype.lessThan;
  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(other) <= 0;
  };
  LongPrototype.lte = LongPrototype.lessThanOrEqual;
  LongPrototype.le = LongPrototype.lessThanOrEqual;
  LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(other) > 0;
  };
  LongPrototype.gt = LongPrototype.greaterThan;
  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(other) >= 0;
  };
  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
  LongPrototype.compare = function compare(other) {
    if (!isLong(other))
      other = fromValue(other);
    if (this.eq(other))
      return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
      return -1;
    if (!thisNeg && otherNeg)
      return 1;
    if (!this.unsigned)
      return this.sub(other).isNegative() ? -1 : 1;
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
  };
  LongPrototype.comp = LongPrototype.compare;
  LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
      return MIN_VALUE;
    return this.not().add(ONE);
  };
  LongPrototype.neg = LongPrototype.negate;
  LongPrototype.add = function add(addend) {
    if (!isLong(addend))
      addend = fromValue(addend);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 65535;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 + b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
      subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
  };
  LongPrototype.sub = LongPrototype.subtract;
  LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
      return ZERO;
    if (!isLong(multiplier))
      multiplier = fromValue(multiplier);
    if (wasm) {
      var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (multiplier.isZero())
      return ZERO;
    if (this.eq(MIN_VALUE))
      return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
      return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
      if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
      else
        return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
      return this.mul(multiplier.neg()).neg();
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
      return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    var a48 = this.high >>> 16;
    var a32 = this.high & 65535;
    var a16 = this.low >>> 16;
    var a00 = this.low & 65535;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 65535;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 65535;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 65535;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 65535;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 65535;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 65535;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
  };
  LongPrototype.mul = LongPrototype.multiply;
  LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (divisor.isZero())
      throw Error("division by zero");
    if (wasm) {
      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
        return this;
      }
      var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    if (this.isZero())
      return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
      if (this.eq(MIN_VALUE)) {
        if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
          return MIN_VALUE;
        else if (divisor.eq(MIN_VALUE))
          return ONE;
        else {
          var halfThis = this.shr(1);
          approx = halfThis.div(divisor).shl(1);
          if (approx.eq(ZERO)) {
            return divisor.isNegative() ? ONE : NEG_ONE;
          } else {
            rem = this.sub(divisor.mul(approx));
            res = approx.add(rem.div(divisor));
            return res;
          }
        }
      } else if (divisor.eq(MIN_VALUE))
        return this.unsigned ? UZERO : ZERO;
      if (this.isNegative()) {
        if (divisor.isNegative())
          return this.neg().div(divisor.neg());
        return this.neg().div(divisor).neg();
      } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
      res = ZERO;
    } else {
      if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
      if (divisor.gt(this))
        return UZERO;
      if (divisor.gt(this.shru(1)))
        return UONE;
      res = UZERO;
    }
    rem = this;
    while (rem.gte(divisor)) {
      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
      var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
      while (approxRem.isNegative() || approxRem.gt(rem)) {
        approx -= delta;
        approxRes = fromNumber(approx, this.unsigned);
        approxRem = approxRes.mul(divisor);
      }
      if (approxRes.isZero())
        approxRes = ONE;
      res = res.add(approxRes);
      rem = rem.sub(approxRem);
    }
    return res;
  };
  LongPrototype.div = LongPrototype.divide;
  LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
      divisor = fromValue(divisor);
    if (wasm) {
      var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
      return fromBits(low, wasm.get_high(), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
  };
  LongPrototype.mod = LongPrototype.modulo;
  LongPrototype.rem = LongPrototype.modulo;
  LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
  };
  LongPrototype.and = function and(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
  };
  LongPrototype.or = function or(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
  };
  LongPrototype.xor = function xor(other) {
    if (!isLong(other))
      other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
  };
  LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else
      return fromBits(0, this.low << numBits - 32, this.unsigned);
  };
  LongPrototype.shl = LongPrototype.shiftLeft;
  LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
      return this;
    else if (numBits < 32)
      return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else
      return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
  };
  LongPrototype.shr = LongPrototype.shiftRight;
  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
      numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
      return this;
    else {
      var high = this.high;
      if (numBits < 32) {
        var low = this.low;
        return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
      } else if (numBits === 32)
        return fromBits(high, 0, this.unsigned);
      else
        return fromBits(high >>> numBits - 32, 0, this.unsigned);
    }
  };
  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
  LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
      return this;
    return fromBits(this.low, this.high, false);
  };
  LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
      return this;
    return fromBits(this.low, this.high, true);
  };
  LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
  };
  LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
      lo & 255,
      lo >>> 8 & 255,
      lo >>> 16 & 255,
      lo >>> 24,
      hi & 255,
      hi >>> 8 & 255,
      hi >>> 16 & 255,
      hi >>> 24
    ];
  };
  LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
      hi >>> 24,
      hi >>> 16 & 255,
      hi >>> 8 & 255,
      hi & 255,
      lo >>> 24,
      lo >>> 16 & 255,
      lo >>> 8 & 255,
      lo & 255
    ];
  };
  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
  };
  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
  };
  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/hash_util.js
function hexToLong(hex) {
  return Long.fromString(hex, true, 16);
}
function shiftMix(val) {
  return val.xor(val.shru(47));
}
function fetch2(s, offset, numBytes) {
  const bytes = s.slice(offset, offset + numBytes);
  return Long.fromBytes(Array.from(bytes), true, true);
}
function fetch64(s, offset) {
  return fetch2(s, offset, 8);
}
function fetch32(s, offset) {
  return fetch2(s, offset, 4);
}
function rotate64(val, shift) {
  return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));
}
function hashLen16(u, v, mul = hexToLong("9ddfea08eb382d69")) {
  let a = u.xor(v).mul(mul);
  a = a.xor(a.shru(47));
  let b = v.xor(a).mul(mul);
  b = b.xor(b.shru(47));
  b = b.mul(mul);
  return b;
}
function weakHashLen32WithSeeds(w, x, y, z, a, b) {
  a = a.add(w);
  b = rotate64(b.add(a).add(z), 21);
  const c = a;
  a = a.add(x);
  a = a.add(y);
  b = b.add(rotate64(a, 44));
  return [a.add(z), b.add(c)];
}
function weakHashLen32WithSeedsStr(s, offset, a, b) {
  return weakHashLen32WithSeeds(fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16), fetch64(s, offset + 24), a, b);
}
function hashLen0to16(s, len = s.length) {
  if (len >= 8) {
    const mul = k2.add(len * 2);
    const a = fetch64(s, 0).add(k2);
    const b = fetch64(s, len - 8);
    const c = rotate64(b, 37).mul(mul).add(a);
    const d = rotate64(a, 25).add(b).mul(mul);
    return hashLen16(c, d, mul);
  }
  if (len >= 4) {
    const mul = k2.add(len * 2);
    const a = fetch32(s, 0);
    return hashLen16(a.shl(3).add(len), fetch32(s, len - 4), mul);
  }
  if (len > 0) {
    const a = s[0];
    const b = s[len >> 1];
    const c = s[len - 1];
    const y = a + (b << 8);
    const z = len + (c << 2);
    return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);
  }
  return k2;
}
function hashLen17to32(s, len = s.length) {
  const mul = k2.add(len * 2);
  const a = fetch64(s, 0).mul(k1);
  const b = fetch64(s, 8);
  const c = fetch64(s, len - 8).mul(mul);
  const d = fetch64(s, len - 16).mul(k2);
  return hashLen16(rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d), a.add(rotate64(b.add(k2), 18)).add(c), mul);
}
function hashLen33to64(s, len = s.length) {
  const mul = k2.add(len * 2);
  const a = fetch64(s, 0).mul(k2);
  const b = fetch64(s, 8);
  const c = fetch64(s, len - 8).mul(mul);
  const d = fetch64(s, len - 16).mul(k2);
  const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);
  const z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul);
  const e = fetch64(s, 16).mul(mul);
  const f = fetch64(s, 24);
  const g = y.add(fetch64(s, len - 32)).mul(mul);
  const h = z.add(fetch64(s, len - 24)).mul(mul);
  return hashLen16(rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h), e.add(rotate64(f.add(a), 18)).add(g), mul);
}
function fingerPrint64(s, len = s.length) {
  const seed = Long.fromNumber(81, true);
  if (len <= 32) {
    if (len <= 16) {
      return hashLen0to16(s, len);
    } else {
      return hashLen17to32(s, len);
    }
  } else if (len <= 64) {
    return hashLen33to64(s, len);
  }
  let x = seed;
  let y = seed.mul(k1).add(113);
  let z = shiftMix(y.mul(k2).add(113)).mul(k2);
  let v = [Long.UZERO, Long.UZERO];
  let w = [Long.UZERO, Long.UZERO];
  x = x.mul(k2).add(fetch64(s, 0));
  let offset = 0;
  const end = (len - 1 >> 6) * 64;
  const last64 = end + (len - 1 & 63) - 63;
  do {
    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);
    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);
    x = x.xor(w[1]);
    y = y.add(v[0]).add(fetch64(s, offset + 40));
    z = rotate64(z.add(w[0]), 33).mul(k1);
    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));
    w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
    [z, x] = [x, z];
    offset += 64;
  } while (offset !== end);
  const mul = k1.add(z.and(255).shl(1));
  offset = last64;
  w[0] = w[0].add(len - 1 & 63);
  v[0] = v[0].add(w[0]);
  w[0] = w[0].add(v[0]);
  x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul);
  y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul);
  x = x.xor(w[1].mul(9));
  y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));
  z = rotate64(z.add(w[0]), 33).mul(mul);
  v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul), x.add(w[0]));
  w = weakHashLen32WithSeedsStr(s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));
  [z, x] = [x, z];
  return hashLen16(hashLen16(v[0], w[0], mul).add(shiftMix(y).mul(k0)).add(z), hashLen16(v[1], w[1], mul).add(x), mul);
}
var LongExports, Long, k0, k1, k2;
var init_hash_util = __esm(() => {
  LongExports = __toESM(require_long(), 1);
  Long = LongExports.default || LongExports;
  k0 = hexToLong("c3a5c85c97cb3127");
  k1 = hexToLong("b492b66fbe98f273");
  k2 = hexToLong("9ae16a3b2f90404f");
});

// node_modules/@tensorflow/tfjs-core/dist/util.js
var exports_util = {};
__export(exports_util, {
  toTypedArray: () => toTypedArray,
  toNestedArray: () => toNestedArray,
  tanh: () => tanh,
  swap: () => swap,
  sum: () => sum,
  squeezeShape: () => squeezeShape,
  sizeToSquarishShape: () => sizeToSquarishShape,
  sizeFromShape: () => sizeFromShape,
  shuffleCombo: () => shuffleCombo,
  shuffle: () => shuffle,
  rightPad: () => rightPad,
  repeatedTry: () => repeatedTry,
  randUniform: () => randUniform,
  parseAxisParam: () => parseAxisParam,
  now: () => now,
  nearestLargerEven: () => nearestLargerEven,
  nearestDivisor: () => nearestDivisor,
  makeZerosTypedArray: () => makeZerosTypedArray,
  makeZerosNestedTypedArray: () => makeZerosNestedTypedArray,
  makeOnesTypedArray: () => makeOnesTypedArray,
  locToIndex: () => locToIndex,
  isValidDtype: () => isValidDtype,
  isTypedArray: () => isTypedArray,
  isString: () => isString,
  isScalarShape: () => isScalarShape,
  isPromise: () => isPromise,
  isNumber: () => isNumber,
  isInt: () => isInt,
  isFunction: () => isFunction,
  isBoolean: () => isBoolean,
  inferFromImplicitShape: () => inferFromImplicitShape,
  inferDtype: () => inferDtype,
  indexToLoc: () => indexToLoc,
  hexToLong: () => hexToLong,
  hasEncodingLoss: () => hasEncodingLoss,
  getTypedArrayFromDType: () => getTypedArrayFromDType,
  getArrayFromDType: () => getArrayFromDType,
  flatten: () => flatten,
  fingerPrint64: () => fingerPrint64,
  fetch: () => fetch3,
  encodeString: () => encodeString,
  distSquared: () => distSquared,
  decodeString: () => decodeString,
  createShuffledIndices: () => createShuffledIndices,
  createScalarValue: () => createScalarValue,
  convertBackendValuesAndArrayBuffer: () => convertBackendValuesAndArrayBuffer,
  computeStrides: () => computeStrides,
  clamp: () => clamp,
  checkConversionForErrors: () => checkConversionForErrors,
  bytesPerElement: () => bytesPerElement,
  bytesFromStringArray: () => bytesFromStringArray,
  assertShapesMatch: () => assertShapesMatch,
  assertNonNull: () => assertNonNull,
  assertNonNegativeIntegerDimensions: () => assertNonNegativeIntegerDimensions,
  assert: () => assert,
  arraysEqualWithNull: () => arraysEqualWithNull,
  arraysEqual: () => arraysEqual
});
function createScalarValue(value, dtype) {
  if (dtype === "string") {
    return encodeString(value);
  }
  return toTypedArray([value], dtype);
}
function noConversionNeeded(a, dtype) {
  return a instanceof Float32Array && dtype === "float32" || a instanceof Int32Array && dtype === "int32" || a instanceof Uint8Array && dtype === "bool";
}
function toTypedArray(a, dtype) {
  if (dtype === "string") {
    throw new Error("Cannot convert a string[] to a TypedArray");
  }
  if (Array.isArray(a)) {
    a = flatten(a);
  }
  if (env().getBool("DEBUG")) {
    checkConversionForErrors(a, dtype);
  }
  if (noConversionNeeded(a, dtype)) {
    return a;
  }
  if (dtype == null || dtype === "float32" || dtype === "complex64") {
    return new Float32Array(a);
  } else if (dtype === "int32") {
    return new Int32Array(a);
  } else if (dtype === "bool") {
    const bool = new Uint8Array(a.length);
    for (let i = 0;i < bool.length; ++i) {
      if (Math.round(a[i]) !== 0) {
        bool[i] = 1;
      }
    }
    return bool;
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
}
function now() {
  return env().platform.now();
}
function fetch3(path, requestInits) {
  return env().platform.fetch(path, requestInits);
}
function encodeString(s, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.encode(s, encoding);
}
function decodeString(bytes, encoding = "utf-8") {
  encoding = encoding || "utf-8";
  return env().platform.decode(bytes, encoding);
}
function isTypedArray(a) {
  if (env().platform.isTypedArray != null) {
    return env().platform.isTypedArray(a);
  } else {
    return isTypedArrayBrowser(a);
  }
}
function flatten(arr, result = [], skipTypedArray = false) {
  if (result == null) {
    result = [];
  }
  if (typeof arr === "boolean" || typeof arr === "number" || typeof arr === "string" || isPromise(arr) || arr == null || isTypedArray(arr) && skipTypedArray) {
    result.push(arr);
  } else if (Array.isArray(arr) || isTypedArray(arr)) {
    for (let i = 0;i < arr.length; ++i) {
      flatten(arr[i], result, skipTypedArray);
    }
  } else {
    let maxIndex = -1;
    for (const key of Object.keys(arr)) {
      if (/^([1-9]+[0-9]*|0)$/.test(key)) {
        maxIndex = Math.max(maxIndex, Number(key));
      }
    }
    for (let i = 0;i <= maxIndex; i++) {
      flatten(arr[i], result, skipTypedArray);
    }
  }
  return result;
}
var init_util = __esm(() => {
  init_environment();
  init_hash_util();
});

// node_modules/@tensorflow/tfjs-core/dist/profiler.js
function checkComputationForErrors(vals, dtype, kernelName) {
  if (dtype !== "float32") {
    return false;
  }
  for (let i = 0;i < vals.length; i++) {
    const num = vals[i];
    if (isNaN(num) || !isFinite(num)) {
      console.warn(`Found ${num} in the result of '${kernelName}'`);
      return true;
    }
  }
  return false;
}

class Profiler {
  constructor(backendTimer, logger) {
    this.backendTimer = backendTimer;
    this.logger = logger;
    if (logger == null) {
      this.logger = new Logger;
    }
  }
  profileKernel(kernelName, inputs, f) {
    let outputs;
    const holdResultWrapperFn = () => {
      outputs = f();
    };
    let timer;
    const start = now();
    if (this.backendTimer.timerAvailable()) {
      timer = this.backendTimer.time(holdResultWrapperFn);
    } else {
      holdResultWrapperFn();
      for (const output of outputs) {
        output.dataSync();
      }
      timer = Promise.resolve({ kernelMs: now() - start });
    }
    if (env().getBool("CHECK_COMPUTATION_FOR_ERRORS")) {
      for (let i = 0;i < outputs.length; i++) {
        const output = outputs[i];
        output.data().then((tensorVals) => {
          checkComputationForErrors(tensorVals, output.dtype, kernelName);
        });
      }
    }
    const kernelProfile = {
      kernelName,
      outputs,
      inputs,
      timeMs: timer.then((timing) => timing.kernelMs),
      extraInfo: timer.then((timing) => timing.getExtraProfileInfo != null ? timing.getExtraProfileInfo() : "")
    };
    return kernelProfile;
  }
  logKernelProfile(kernelProfile) {
    const { kernelName, outputs, timeMs, inputs, extraInfo } = kernelProfile;
    outputs.forEach((result) => {
      Promise.all([result.data(), timeMs, extraInfo]).then((valueContainer) => {
        this.logger.logKernelProfile(kernelName, result, valueContainer[0], valueContainer[1], inputs, valueContainer[2]);
      });
    });
  }
}

class Logger {
  logKernelProfile(name, result, vals, timeMs, inputs, extraInfo) {
    const time = typeof timeMs === "number" ? rightPad(`${timeMs}ms`, 9) : timeMs["error"];
    const paddedName = rightPad(name, 25);
    const rank = result.rank;
    const size = result.size;
    const shape = rightPad(result.shape.toString(), 14);
    let inputShapesDescription = "";
    for (const name2 in inputs) {
      const input = inputs[name2];
      if (input != null) {
        const inputShape = input.shape || result.shape;
        const inputRank = inputShape.length;
        inputShapesDescription += `${name2}: ${inputRank}D ${inputRank > 0 ? inputShape : ""} `;
      }
    }
    console.log(`%c${paddedName}\t%c${time}\t%c${rank}D ${shape}\t%c${size}\t%c${inputShapesDescription}\t%c${extraInfo}`, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
}
var init_profiler = __esm(() => {
  init_environment();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/tape.js
function getFilteredNodesXToY(tape, xs, y) {
  const tensorsFromX = {};
  const nodesFromX = {};
  for (let i = 0;i < xs.length; i++) {
    tensorsFromX[xs[i].id] = true;
  }
  for (let i = 0;i < tape.length; i++) {
    const node = tape[i];
    const nodeInputs = node.inputs;
    for (const inputName in nodeInputs) {
      const input = nodeInputs[inputName];
      let anyInputFromX = false;
      for (let j = 0;j < xs.length; j++) {
        if (tensorsFromX[input.id]) {
          node.outputs.forEach((output) => tensorsFromX[output.id] = true);
          anyInputFromX = true;
          nodesFromX[node.id] = true;
          break;
        }
      }
      if (anyInputFromX) {
        break;
      }
    }
  }
  const tensorsLeadToY = {};
  tensorsLeadToY[y.id] = true;
  const nodesToY = {};
  for (let i = tape.length - 1;i >= 0; i--) {
    const node = tape[i];
    const nodeInputs = node.inputs;
    for (let j = 0;j < node.outputs.length; j++) {
      if (tensorsLeadToY[node.outputs[j].id]) {
        for (const inputName in nodeInputs) {
          tensorsLeadToY[nodeInputs[inputName].id] = true;
          nodesToY[node.id] = true;
        }
        break;
      }
    }
  }
  const filteredTape = [];
  for (let i = 0;i < tape.length; i++) {
    const node = tape[i];
    if (nodesFromX[node.id] && nodesToY[node.id]) {
      const prunedInputs = {};
      for (const inputName in node.inputs) {
        const nodeInput = node.inputs[inputName];
        if (tensorsFromX[nodeInput.id]) {
          prunedInputs[inputName] = nodeInput;
        }
      }
      const prunedNode = Object.assign({}, node);
      prunedNode.inputs = prunedInputs;
      prunedNode.outputs = node.outputs;
      filteredTape.push(prunedNode);
    }
  }
  return filteredTape;
}
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape, tidy, add) {
  for (let i = filteredTape.length - 1;i >= 0; i--) {
    const node = filteredTape[i];
    const dys = [];
    node.outputs.forEach((o) => {
      const gradTensor = tensorAccumulatedGradientMap[o.id];
      if (gradTensor != null) {
        dys.push(gradTensor);
      } else {
        dys.push(null);
      }
    });
    if (node.gradient == null) {
      throw new Error(`Cannot compute gradient: gradient function not found ` + `for ${node.kernelName}.`);
    }
    const inputGradients = node.gradient(dys);
    for (const inputName in node.inputs) {
      if (!(inputName in inputGradients)) {
        throw new Error(`Cannot backprop through input ${inputName}. ` + `Available gradients found: ${Object.keys(inputGradients)}.`);
      }
      const dx = tidy(() => inputGradients[inputName]());
      if (dx.dtype !== "float32") {
        throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` + `${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);
      }
      const x = node.inputs[inputName];
      if (!arraysEqual(dx.shape, x.shape)) {
        throw new Error(`Error in gradient for op ${node.kernelName}. The gradient of input ` + `'${inputName}' has shape '${dx.shape}', which does not match ` + `the shape of the input '${x.shape}'`);
      }
      if (tensorAccumulatedGradientMap[x.id] == null) {
        tensorAccumulatedGradientMap[x.id] = dx;
      } else {
        const curGradient = tensorAccumulatedGradientMap[x.id];
        tensorAccumulatedGradientMap[x.id] = add(curGradient, dx);
        curGradient.dispose();
      }
    }
  }
}
var init_tape = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/tensor_format.js
function tensorToString(vals, shape, dtype, verbose) {
  const strides = computeStrides(shape);
  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
  const rank = shape.length;
  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
  const lines = ["Tensor"];
  if (verbose) {
    lines.push(`  dtype: ${dtype}`);
    lines.push(`  rank: ${rank}`);
    lines.push(`  shape: [${shape}]`);
    lines.push(`  values:`);
  }
  lines.push(valsLines.map((l) => "    " + l).join("\n"));
  return lines.join("\n");
}
function computeMaxSizePerColumn(vals, shape, dtype, strides) {
  const n = sizeFromShape(shape);
  const numCols = strides[strides.length - 1];
  const padPerCol = new Array(numCols).fill(0);
  const rank = shape.length;
  const valuesOrTuples = dtype === "complex64" ? createComplexTuples(vals) : vals;
  if (rank > 1) {
    for (let row = 0;row < n / numCols; row++) {
      const offset = row * numCols;
      for (let j = 0;j < numCols; j++) {
        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
      }
    }
  }
  return padPerCol;
}
function valToString(val, pad, dtype) {
  let valStr;
  if (Array.isArray(val)) {
    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` + `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;
  } else if (isString(val)) {
    valStr = `'${val}'`;
  } else if (dtype === "bool") {
    valStr = boolNumToString(val);
  } else {
    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
  }
  return rightPad(valStr, pad);
}
function boolNumToString(v) {
  return v === 0 ? "false" : "true";
}
function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {
  const storagePerElement = dtype === "complex64" ? 2 : 1;
  const size = shape[0];
  const rank = shape.length;
  if (rank === 0) {
    if (dtype === "complex64") {
      const complexTuple = createComplexTuples(vals);
      return [valToString(complexTuple[0], 0, dtype)];
    }
    if (dtype === "bool") {
      return [boolNumToString(vals[0])];
    }
    return [vals[0].toString()];
  }
  if (rank === 1) {
    if (size > FORMAT_LIMIT_NUM_VALS) {
      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
      let firstVals = Array.from(vals.slice(0, firstValsSize));
      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));
      if (dtype === "complex64") {
        firstVals = createComplexTuples(firstVals);
        lastVals = createComplexTuples(lastVals);
      }
      return [
        "[" + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + ", ..., " + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(", ") + "]"
      ];
    }
    const displayVals = dtype === "complex64" ? createComplexTuples(vals) : Array.from(vals);
    return [
      "[" + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(", ") + "]"
    ];
  }
  const subshape = shape.slice(1);
  const substrides = strides.slice(1);
  const stride = strides[0] * storagePerElement;
  const lines = [];
  if (size > FORMAT_LIMIT_NUM_VALS) {
    for (let i = 0;i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
      const start = i * stride;
      const end = start + stride;
      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false));
    }
    lines.push("...");
    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS;i < size; i++) {
      const start = i * stride;
      const end = start + stride;
      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
    }
  } else {
    for (let i = 0;i < size; i++) {
      const start = i * stride;
      const end = start + stride;
      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1));
    }
  }
  const sep = rank === 2 ? "," : "";
  lines[0] = "[" + (size > 0 ? lines[0] + sep : "");
  for (let i = 1;i < lines.length - 1; i++) {
    lines[i] = " " + lines[i] + sep;
  }
  let newLineSep = ",\n";
  for (let i = 2;i < rank; i++) {
    newLineSep += "\n";
  }
  lines[lines.length - 1] = " " + lines[lines.length - 1] + "]" + (isLast ? "" : newLineSep);
  return lines;
}
function createComplexTuples(vals) {
  const complexTuples = [];
  for (let i = 0;i < vals.length; i += 2) {
    complexTuples.push([vals[i], vals[i + 1]]);
  }
  return complexTuples;
}
var FORMAT_LIMIT_NUM_VALS = 20, FORMAT_NUM_FIRST_LAST_VALS = 3, FORMAT_NUM_SIG_DIGITS = 7;
var init_tensor_format = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/tensor.js
function setTensorTracker(fn) {
  trackerFn = fn;
}
function setOpHandler(handler) {
  opHandler = handler;
}
function setDeprecationWarningFn(fn) {
  deprecationWarningFn = fn;
}
function getGlobalTensorClass() {
  return getGlobal("Tensor", () => {
    return Tensor;
  });
}

class TensorBuffer {
  constructor(shape, dtype, values) {
    this.dtype = dtype;
    this.shape = shape.slice();
    this.size = sizeFromShape(shape);
    if (values != null) {
      const n = values.length;
      assert(n === this.size, () => `Length of values '${n}' does not match the size ` + `inferred by the shape '${this.size}'.`);
    }
    if (dtype === "complex64") {
      throw new Error(`complex64 dtype TensorBuffers are not supported. Please create ` + `a TensorBuffer for the real and imaginary parts separately and ` + `call tf.complex(real, imag).`);
    }
    this.values = values || getArrayFromDType(dtype, this.size);
    this.strides = computeStrides(shape);
  }
  set(value, ...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must ` + `match the rank (${this.rank})`);
    const index = this.locToIndex(locs);
    this.values[index] = value;
  }
  get(...locs) {
    if (locs.length === 0) {
      locs = [0];
    }
    let i = 0;
    for (const loc of locs) {
      if (loc < 0 || loc >= this.shape[i]) {
        const msg = `Requested out of range element at ${locs}. ` + `  Buffer shape=${this.shape}`;
        throw new Error(msg);
      }
      i++;
    }
    let index = locs[locs.length - 1];
    for (let i2 = 0;i2 < locs.length - 1; ++i2) {
      index += this.strides[i2] * locs[i2];
    }
    return this.values[index];
  }
  locToIndex(locs) {
    if (this.rank === 0) {
      return 0;
    } else if (this.rank === 1) {
      return locs[0];
    }
    let index = locs[locs.length - 1];
    for (let i = 0;i < locs.length - 1; ++i) {
      index += this.strides[i] * locs[i];
    }
    return index;
  }
  indexToLoc(index) {
    if (this.rank === 0) {
      return [];
    } else if (this.rank === 1) {
      return [index];
    }
    const locs = new Array(this.shape.length);
    for (let i = 0;i < locs.length - 1; ++i) {
      locs[i] = Math.floor(index / this.strides[i]);
      index -= locs[i] * this.strides[i];
    }
    locs[locs.length - 1] = index;
    return locs;
  }
  get rank() {
    return this.shape.length;
  }
  toTensor() {
    return trackerFn().makeTensor(this.values, this.shape, this.dtype);
  }
}

class Tensor {
  constructor(shape, dtype, dataId, id) {
    this.kept = false;
    this.isDisposedInternal = false;
    this.shape = shape.slice();
    this.dtype = dtype || "float32";
    this.size = sizeFromShape(shape);
    this.strides = computeStrides(shape);
    this.dataId = dataId;
    this.id = id;
    this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
  }
  get rank() {
    return this.shape.length;
  }
  async buffer() {
    const vals = await this.data();
    return opHandler.buffer(this.shape, this.dtype, vals);
  }
  bufferSync() {
    return opHandler.buffer(this.shape, this.dtype, this.dataSync());
  }
  async array() {
    const vals = await this.data();
    return toNestedArray(this.shape, vals, this.dtype === "complex64");
  }
  arraySync() {
    return toNestedArray(this.shape, this.dataSync(), this.dtype === "complex64");
  }
  async data() {
    this.throwIfDisposed();
    const data = trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      const bytes = await data;
      try {
        return bytes.map((b) => decodeString(b));
      } catch (_a) {
        throw new Error("Failed to decode the string bytes into utf-8. " + "To get the original bytes, call tensor.bytes().");
      }
    }
    return data;
  }
  dataToGPU(options) {
    this.throwIfDisposed();
    return trackerFn().readToGPU(this.dataId, options);
  }
  dataSync() {
    this.throwIfDisposed();
    const data = trackerFn().readSync(this.dataId);
    if (this.dtype === "string") {
      try {
        return data.map((b) => decodeString(b));
      } catch (_a) {
        throw new Error("Failed to decode the string bytes into utf-8. " + "To get the original bytes, call tensor.bytes().");
      }
    }
    return data;
  }
  async bytes() {
    this.throwIfDisposed();
    const data = await trackerFn().read(this.dataId);
    if (this.dtype === "string") {
      return data;
    } else {
      return new Uint8Array(data.buffer);
    }
  }
  dispose() {
    if (this.isDisposed) {
      return;
    }
    if (this.kerasMask) {
      this.kerasMask.dispose();
    }
    trackerFn().disposeTensor(this);
    this.isDisposedInternal = true;
  }
  get isDisposed() {
    return this.isDisposedInternal;
  }
  throwIfDisposed() {
    if (this.isDisposed) {
      throw new Error(`Tensor is disposed.`);
    }
  }
  print(verbose = false) {
    return opHandler.print(this, verbose);
  }
  clone() {
    this.throwIfDisposed();
    return opHandler.clone(this);
  }
  toString(verbose = false) {
    const vals = this.dataSync();
    return tensorToString(vals, this.shape, this.dtype, verbose);
  }
  cast(dtype) {
    this.throwIfDisposed();
    return opHandler.cast(this, dtype);
  }
  variable(trainable = true, name, dtype) {
    this.throwIfDisposed();
    return trackerFn().makeVariable(this, trainable, name, dtype);
  }
}
var trackerFn = null, opHandler = null, deprecationWarningFn = null, Variable;
var init_tensor = __esm(() => {
  init_tensor_format();
  init_util();
  init_util();
  Object.defineProperty(Tensor, Symbol.hasInstance, {
    value: (instance) => {
      return !!instance && instance.data != null && instance.dataSync != null && instance.throwIfDisposed != null;
    }
  });
  getGlobalTensorClass();
  Variable = class Variable extends Tensor {
    constructor(initialValue, trainable, name, tensorId) {
      super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);
      this.trainable = trainable;
      this.name = name;
    }
    assign(newValue) {
      if (newValue.dtype !== this.dtype) {
        throw new Error(`dtype of the new value (${newValue.dtype}) and ` + `previous value (${this.dtype}) must match`);
      }
      if (!arraysEqual(newValue.shape, this.shape)) {
        throw new Error(`shape of the new value (${newValue.shape}) and ` + `previous value (${this.shape}) must match`);
      }
      trackerFn().disposeTensor(this);
      this.dataId = newValue.dataId;
      trackerFn().incRef(this, null);
    }
    dispose() {
      trackerFn().disposeVariable(this);
      this.isDisposedInternal = true;
    }
  };
  Object.defineProperty(Variable, Symbol.hasInstance, {
    value: (instance) => {
      return instance instanceof Tensor && instance.assign != null && instance.assign instanceof Function;
    }
  });
});

// node_modules/@tensorflow/tfjs-core/dist/types.js
function upcastType(typeA, typeB) {
  if (typeA === "string" || typeB === "string") {
    if (typeA === "string" && typeB === "string") {
      return "string";
    }
    throw new Error(`Can not upcast ${typeA} with ${typeB}`);
  }
  return upcastTypeMap[typeA][typeB];
}
function sumOutType(type) {
  return upcastType(type, "int32");
}
function isWebGLData(values) {
  return values != null && typeof values === "object" && "texture" in values && values.texture instanceof WebGLTexture;
}
function isWebGPUData(values) {
  return typeof GPUBuffer !== "undefined" && values != null && typeof values === "object" && "buffer" in values && values.buffer instanceof GPUBuffer;
}
var Rank, UpcastInt32AndMap, UpcastBoolAndMap, UpcastFloat32AndMap, UpcastComplex64AndMap, upcastTypeMap;
var init_types = __esm(() => {
  (function(Rank2) {
    Rank2["R0"] = "R0";
    Rank2["R1"] = "R1";
    Rank2["R2"] = "R2";
    Rank2["R3"] = "R3";
    Rank2["R4"] = "R4";
    Rank2["R5"] = "R5";
    Rank2["R6"] = "R6";
  })(Rank || (Rank = {}));
  (function(UpcastInt32AndMap2) {
    UpcastInt32AndMap2["float32"] = "float32";
    UpcastInt32AndMap2["int32"] = "int32";
    UpcastInt32AndMap2["bool"] = "int32";
    UpcastInt32AndMap2["complex64"] = "complex64";
  })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
  (function(UpcastBoolAndMap2) {
    UpcastBoolAndMap2["float32"] = "float32";
    UpcastBoolAndMap2["int32"] = "int32";
    UpcastBoolAndMap2["bool"] = "bool";
    UpcastBoolAndMap2["complex64"] = "complex64";
  })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
  (function(UpcastFloat32AndMap2) {
    UpcastFloat32AndMap2["float32"] = "float32";
    UpcastFloat32AndMap2["int32"] = "float32";
    UpcastFloat32AndMap2["bool"] = "float32";
    UpcastFloat32AndMap2["complex64"] = "complex64";
  })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
  (function(UpcastComplex64AndMap2) {
    UpcastComplex64AndMap2["float32"] = "complex64";
    UpcastComplex64AndMap2["int32"] = "complex64";
    UpcastComplex64AndMap2["bool"] = "complex64";
    UpcastComplex64AndMap2["complex64"] = "complex64";
  })(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
  upcastTypeMap = {
    float32: UpcastFloat32AndMap,
    int32: UpcastInt32AndMap,
    bool: UpcastBoolAndMap,
    complex64: UpcastComplex64AndMap
  };
});

// node_modules/@tensorflow/tfjs-core/dist/tensor_util.js
var exports_tensor_util = {};
__export(exports_tensor_util, {
  makeTypesMatch: () => makeTypesMatch,
  isTensorInList: () => isTensorInList,
  getTensorsInContainer: () => getTensorsInContainer,
  assertTypesMatch: () => assertTypesMatch
});
function makeTypesMatch(a, b) {
  if (a.dtype === b.dtype) {
    return [a, b];
  }
  const dtype = upcastType(a.dtype, b.dtype);
  return [a.cast(dtype), b.cast(dtype)];
}
function assertTypesMatch(a, b) {
  assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and` + ` second(${b.dtype}) input must match`);
}
function isTensorInList(tensor2, tensorList) {
  return tensorList.some((x) => x.id === tensor2.id);
}
function getTensorsInContainer(result) {
  const list = [];
  const seen = new Set;
  walkTensorContainer(result, list, seen);
  return list;
}
function walkTensorContainer(container, list, seen) {
  if (container == null) {
    return;
  }
  if (container instanceof Tensor) {
    list.push(container);
    return;
  }
  if (!isIterable(container)) {
    return;
  }
  const iterable = container;
  for (const k in iterable) {
    const val = iterable[k];
    if (!seen.has(val)) {
      seen.add(val);
      walkTensorContainer(val, list, seen);
    }
  }
}
function isIterable(obj) {
  return Array.isArray(obj) || typeof obj === "object";
}
var init_tensor_util = __esm(() => {
  init_tensor();
  init_types();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/engine.js
function isRegisteredKernelInvocation(kernelInvocation) {
  return kernelInvocation.kernelName != null;
}
function ones(shape) {
  const values = makeOnesTypedArray(sizeFromShape(shape), "float32");
  return ENGINE.makeTensor(values, shape, "float32");
}
function getOrMakeEngine() {
  const ns = getGlobalNamespace();
  if (ns._tfengine == null) {
    const environment6 = new Environment(ns);
    ns._tfengine = new Engine(environment6);
  }
  setEnvironmentGlobal(ns._tfengine.ENV);
  setTensorTracker(() => ns._tfengine);
  return ns._tfengine;
}
function add(a, b) {
  const inputs = { a, b };
  return ENGINE.runKernel(Add, inputs);
}

class EngineState {
  constructor() {
    this.registeredVariables = {};
    this.nextTapeNodeId = 0;
    this.numBytes = 0;
    this.numTensors = 0;
    this.numStringTensors = 0;
    this.numDataBuffers = 0;
    this.gradientDepth = 0;
    this.kernelDepth = 0;
    this.scopeStack = [];
    this.numDataMovesStack = [];
    this.nextScopeId = 0;
    this.tensorInfo = new WeakMap;
    this.profiling = false;
    this.activeProfile = {
      newBytes: 0,
      newTensors: 0,
      peakBytes: 0,
      kernels: [],
      result: null,
      get kernelNames() {
        return Array.from(new Set(this.kernels.map((k) => k.name)));
      }
    };
  }
  dispose() {
    for (const variableName in this.registeredVariables) {
      this.registeredVariables[variableName].dispose();
    }
  }
}

class Engine {
  constructor(ENV2) {
    this.ENV = ENV2;
    this.registry = {};
    this.registryFactory = {};
    this.pendingBackendInitId = 0;
    this.state = new EngineState;
  }
  async ready() {
    if (this.pendingBackendInit != null) {
      return this.pendingBackendInit.then(() => {
      });
    }
    if (this.backendInstance != null) {
      return;
    }
    const sortedBackends = this.getSortedBackends();
    for (let i = 0;i < sortedBackends.length; i++) {
      const backendName = sortedBackends[i];
      const success = await this.initializeBackend(backendName).success;
      if (success) {
        await this.setBackend(backendName);
        return;
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations ` + `failed.`);
  }
  get backend() {
    if (this.pendingBackendInit != null) {
      throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make ` + `sure to await tf.ready() or await tf.setBackend() before calling ` + `other methods`);
    }
    if (this.backendInstance == null) {
      const { name, asyncInit } = this.initializeBackendsAndReturnBest();
      if (asyncInit) {
        throw new Error(`The highest priority backend '${name}' has not yet been ` + `initialized. Make sure to await tf.ready() or ` + `await tf.setBackend() before calling other methods`);
      }
      this.setBackend(name);
    }
    return this.backendInstance;
  }
  backendNames() {
    return Object.keys(this.registryFactory);
  }
  findBackend(backendName) {
    if (!(backendName in this.registry)) {
      if (backendName in this.registryFactory) {
        const { asyncInit } = this.initializeBackend(backendName);
        if (asyncInit) {
          return null;
        }
      } else {
        return null;
      }
    }
    return this.registry[backendName];
  }
  findBackendFactory(backendName) {
    if (!(backendName in this.registryFactory)) {
      return null;
    }
    return this.registryFactory[backendName].factory;
  }
  registerBackend(backendName, factory, priority = 1) {
    if (backendName in this.registryFactory) {
      warn(`${backendName} backend was already registered. ` + `Reusing existing backend factory.`);
      return false;
    }
    this.registryFactory[backendName] = { factory, priority };
    return true;
  }
  async setBackend(backendName) {
    if (this.registryFactory[backendName] == null) {
      throw new Error(`Backend name '${backendName}' not found in registry`);
    }
    this.backendName = backendName;
    if (this.registry[backendName] == null) {
      this.backendInstance = null;
      const { success, asyncInit } = this.initializeBackend(backendName);
      const result = asyncInit ? await success : success;
      if (!result) {
        return false;
      }
    }
    this.backendInstance = this.registry[backendName];
    this.setupRegisteredKernels();
    this.profiler = new Profiler(this.backendInstance);
    return true;
  }
  setupRegisteredKernels() {
    const kernels = getKernelsForBackend(this.backendName);
    kernels.forEach((kernel) => {
      if (kernel.setupFunc != null) {
        kernel.setupFunc(this.backendInstance);
      }
    });
  }
  disposeRegisteredKernels(backendName) {
    const kernels = getKernelsForBackend(backendName);
    kernels.forEach((kernel) => {
      if (kernel.disposeFunc != null) {
        kernel.disposeFunc(this.registry[backendName]);
      }
    });
  }
  initializeBackend(backendName) {
    const registryFactoryEntry = this.registryFactory[backendName];
    if (registryFactoryEntry == null) {
      throw new Error(`Cannot initialize backend ${backendName}, no registration found.`);
    }
    try {
      const backend2 = registryFactoryEntry.factory();
      if (backend2 && !(backend2 instanceof KernelBackend) && typeof backend2.then === "function") {
        const promiseId = ++this.pendingBackendInitId;
        const success = backend2.then((backendInstance) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.registry[backendName] = backendInstance;
          this.pendingBackendInit = null;
          return true;
        }).catch((err) => {
          if (promiseId < this.pendingBackendInitId) {
            return false;
          }
          this.pendingBackendInit = null;
          warn(`Initialization of backend ${backendName} failed`);
          warn(err.stack || err.message);
          return false;
        });
        this.pendingBackendInit = success;
        return { success, asyncInit: true };
      } else {
        this.registry[backendName] = backend2;
        return { success: true, asyncInit: false };
      }
    } catch (err) {
      warn(`Initialization of backend ${backendName} failed`);
      warn(err.stack || err.message);
      return { success: false, asyncInit: false };
    }
  }
  removeBackend(backendName) {
    if (!(backendName in this.registryFactory)) {
      throw new Error(`${backendName} backend not found in registry`);
    }
    if (this.backendName === backendName && this.pendingBackendInit != null) {
      this.pendingBackendInitId++;
    }
    if (backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    delete this.registryFactory[backendName];
    if (this.backendName === backendName) {
      this.pendingBackendInit = null;
      this.backendName = null;
      this.backendInstance = null;
    }
  }
  getSortedBackends() {
    if (Object.keys(this.registryFactory).length === 0) {
      throw new Error("No backend found in registry.");
    }
    return Object.keys(this.registryFactory).sort((a, b) => {
      return this.registryFactory[b].priority - this.registryFactory[a].priority;
    });
  }
  initializeBackendsAndReturnBest() {
    const sortedBackends = this.getSortedBackends();
    for (let i = 0;i < sortedBackends.length; i++) {
      const backendName = sortedBackends[i];
      const { success, asyncInit } = this.initializeBackend(backendName);
      if (asyncInit || success) {
        return { name: backendName, asyncInit };
      }
    }
    throw new Error(`Could not initialize any backends, all backend initializations ` + `failed.`);
  }
  moveData(backend2, dataId) {
    const info = this.state.tensorInfo.get(dataId);
    const srcBackend = info.backend;
    const values = this.readSync(dataId);
    const refCount = srcBackend.refCount(dataId);
    srcBackend.disposeData(dataId, true);
    info.backend = backend2;
    backend2.move(dataId, values, info.shape, info.dtype, refCount);
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
  }
  tidy(nameOrFn, fn) {
    let name = null;
    if (fn == null) {
      if (typeof nameOrFn !== "function") {
        throw new Error("Please provide a function to tidy()");
      }
      fn = nameOrFn;
    } else {
      if (typeof nameOrFn !== "string" && !(nameOrFn instanceof String)) {
        throw new Error("When calling with two arguments, the first argument " + "to tidy() must be a string");
      }
      if (typeof fn !== "function") {
        throw new Error("When calling with two arguments, the 2nd argument " + "to tidy() must be a function");
      }
      name = nameOrFn;
    }
    let result;
    return this.scopedRun(() => this.startScope(name), () => this.endScope(result), () => {
      result = fn();
      if (result instanceof Promise) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      return result;
    });
  }
  scopedRun(start, end, f) {
    start();
    try {
      const res = f();
      end();
      return res;
    } catch (ex) {
      end();
      throw ex;
    }
  }
  nextTensorId() {
    return Engine.nextTensorId++;
  }
  nextVariableId() {
    return Engine.nextVariableId++;
  }
  clone(x) {
    const y = ENGINE.runKernel(Identity, { x });
    const inputs = { x };
    const grad = (dy) => ({
      x: () => {
        const dtype = "float32";
        const gradInputs = { x: dy };
        const attrs = { dtype };
        return ENGINE.runKernel(Cast, gradInputs, attrs);
      }
    });
    const saved = [];
    this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});
    return y;
  }
  runKernel(kernelName, inputs, attrs) {
    if (this.backendName == null) {
      this.backend;
    }
    const hasKernel = getKernel(kernelName, this.backendName) != null;
    if (!hasKernel) {
      throw new Error(`Kernel '${kernelName}' not registered for backend '${this.backendName}'`);
    }
    return this.runKernelFunc({ kernelName, inputs, attrs });
  }
  shouldCheckForMemLeaks() {
    return this.ENV.getBool("IS_TEST");
  }
  checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos) {
    const numDataIdsAfter = this.backend.numDataIds();
    let numOutputDataIds = 0;
    outInfos.forEach((info) => {
      numOutputDataIds += info.dtype === "complex64" ? 3 : 1;
    });
    const numMoves = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];
    const dataIdsLeaked = numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;
    if (dataIdsLeaked > 0) {
      throw new Error(`Backend '${this.backendName}' has an internal memory leak ` + `(${dataIdsLeaked} data ids) after running '${kernelName}'`);
    }
  }
  runKernelFunc(kernelParams) {
    let outputs;
    let saved = [];
    const isTapeOn = this.isTapeOn();
    const startingBytecount = this.state.numBytes;
    const startingNumTensors = this.state.numTensors;
    if (this.shouldCheckForMemLeaks()) {
      this.state.numDataMovesStack.push(0);
    }
    let kernelFunc;
    if (this.backendName == null) {
      this.backend;
    }
    let out;
    const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ? kernelParams.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
    if (isRegisteredKernelInvocation(kernelParams)) {
      const { kernelName, inputs: inputs2, attrs: attrs2 } = kernelParams;
      if (this.backendName == null) {
        this.backend;
      }
      const kernel = getKernel(kernelName, this.backendName);
      assert(kernel != null, () => `Cannot find registered kernel '${kernelName}' for backend '${this.backendName}'`);
      kernelFunc = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = kernel.kernelFunc({ inputs: inputs2, attrs: attrs2, backend: this.backend });
        const outInfos = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);
        }
        const outTensors = outInfos.map((outInfo) => {
          if (outInfo.rank != null) {
            return outInfo;
          }
          return this.makeTensorFromTensorInfo(outInfo);
        });
        if (isTapeOn) {
          const tensorsToSave = this.getTensorsForGradient(kernelName, inputs2, outTensors);
          saved = this.saveTensorsForBackwardMode(tensorsToSave);
        }
        return outTensors;
      };
    } else {
      const { forwardFunc } = kernelParams;
      const saveFunc = (tensors) => {
        if (!isTapeOn) {
          return;
        }
        saved = tensors.map((tensor3) => this.keep(this.clone(tensor3)));
      };
      kernelFunc = () => {
        const numDataIdsBefore = this.backend.numDataIds();
        out = this.tidy(() => forwardFunc(this.backend, saveFunc));
        const outs = Array.isArray(out) ? out : [out];
        if (this.shouldCheckForMemLeaks()) {
          this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);
        }
        return outs;
      };
    }
    const { inputs, attrs } = kernelParams;
    const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ? null : kernelParams.backwardsFunc;
    let kernelProfile;
    this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
      if (!this.ENV.getBool("DEBUG") && !this.state.profiling) {
        outputs = kernelFunc();
      } else {
        kernelProfile = this.profiler.profileKernel(kernelOrScopeName, inputs, () => kernelFunc());
        if (this.ENV.getBool("DEBUG")) {
          this.profiler.logKernelProfile(kernelProfile);
        }
        outputs = kernelProfile.outputs;
      }
    });
    if (isTapeOn) {
      this.addTapeNode(kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);
    }
    if (this.state.profiling) {
      this.state.activeProfile.kernels.push({
        name: kernelOrScopeName,
        bytesAdded: this.state.numBytes - startingBytecount,
        totalBytesSnapshot: this.state.numBytes,
        tensorsAdded: this.state.numTensors - startingNumTensors,
        totalTensorsSnapshot: this.state.numTensors,
        inputShapes: Object.keys(inputs).map((key) => inputs[key] != null ? inputs[key].shape : null),
        outputShapes: outputs.map((item) => item.shape),
        kernelTimeMs: kernelProfile.timeMs,
        extraInfo: kernelProfile.extraInfo
      });
    }
    return Array.isArray(out) ? outputs : outputs[0];
  }
  saveTensorsForBackwardMode(tensors) {
    const saved = tensors.map((tensor3) => this.keep(this.clone(tensor3)));
    return saved;
  }
  getTensorsForGradient(kernelName, inputs, outputs) {
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      const inputsToSave = gradConfig.inputsToSave || [];
      const outputsToSave = gradConfig.outputsToSave || [];
      let inputTensorsToSave;
      if (gradConfig.saveAllInputs) {
        assert(Array.isArray(inputs), () => "saveAllInputs is true, expected inputs to be an array.");
        inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);
      } else {
        inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);
      }
      const outputTensorsToSave = outputs.filter((_, i) => outputsToSave[i]);
      return inputTensorsToSave.concat(outputTensorsToSave);
    }
    return [];
  }
  makeTensor(values, shape, dtype, backend2) {
    if (values == null) {
      throw new Error("Values passed to engine.makeTensor() are null");
    }
    dtype = dtype || "float32";
    backend2 = backend2 || this.backend;
    let backendVals = values;
    if (dtype === "string" && isString(values[0])) {
      backendVals = values.map((d) => encodeString(d));
    }
    const dataId = backend2.write(backendVals, shape, dtype);
    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.trackTensor(t, backend2);
    if (dtype === "string") {
      const info = this.state.tensorInfo.get(dataId);
      const newBytes = bytesFromStringArray(backendVals);
      this.state.numBytes += newBytes - info.bytes;
      info.bytes = newBytes;
    }
    return t;
  }
  makeTensorFromDataId(dataId, shape, dtype, backend2) {
    dtype = dtype || "float32";
    const tensorInfo = { dataId, shape, dtype };
    return this.makeTensorFromTensorInfo(tensorInfo, backend2);
  }
  makeTensorFromTensorInfo(tensorInfo, backend2) {
    const { dataId, shape, dtype } = tensorInfo;
    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());
    this.trackTensor(t, backend2);
    return t;
  }
  makeVariable(initialValue, trainable = true, name, dtype) {
    name = name || this.nextVariableId().toString();
    if (dtype != null && dtype !== initialValue.dtype) {
      initialValue = initialValue.cast(dtype);
    }
    const v = new Variable(initialValue, trainable, name, this.nextTensorId());
    if (this.state.registeredVariables[v.name] != null) {
      throw new Error(`Variable with name ${v.name} was already registered`);
    }
    this.state.registeredVariables[v.name] = v;
    this.incRef(v, this.backend);
    return v;
  }
  trackTensor(a, backend2) {
    this.state.numTensors++;
    if (a.dtype === "string") {
      this.state.numStringTensors++;
    }
    let bytes = 0;
    if (a.dtype !== "complex64" && a.dtype !== "string") {
      bytes = a.size * bytesPerElement(a.dtype);
    }
    this.state.numBytes += bytes;
    if (!this.state.tensorInfo.has(a.dataId)) {
      this.state.numDataBuffers++;
      this.state.tensorInfo.set(a.dataId, {
        backend: backend2 || this.backend,
        dtype: a.dtype,
        shape: a.shape,
        bytes
      });
    }
    if (!(a instanceof Variable)) {
      this.track(a);
    }
  }
  incRef(a, backend2) {
    this.trackTensor(a, backend2);
    this.backend.incRef(a.dataId);
  }
  removeDataId(dataId, backend2) {
    if (this.state.tensorInfo.has(dataId) && this.state.tensorInfo.get(dataId).backend === backend2) {
      this.state.tensorInfo.delete(dataId);
      this.state.numDataBuffers--;
    }
  }
  disposeTensor(a) {
    if (!this.state.tensorInfo.has(a.dataId)) {
      return;
    }
    const info = this.state.tensorInfo.get(a.dataId);
    this.state.numTensors--;
    if (a.dtype === "string") {
      this.state.numStringTensors--;
      this.state.numBytes -= info.bytes;
    }
    if (a.dtype !== "complex64" && a.dtype !== "string") {
      const bytes = a.size * bytesPerElement(a.dtype);
      this.state.numBytes -= bytes;
    }
    if (info.backend.disposeData(a.dataId)) {
      this.removeDataId(a.dataId, info.backend);
    }
  }
  disposeVariables() {
    for (const varName in this.state.registeredVariables) {
      const v = this.state.registeredVariables[varName];
      this.disposeVariable(v);
    }
  }
  disposeVariable(v) {
    this.disposeTensor(v);
    if (this.state.registeredVariables[v.name] != null) {
      delete this.state.registeredVariables[v.name];
    }
  }
  memory() {
    const info = this.backend.memory();
    info.numTensors = this.state.numTensors;
    info.numDataBuffers = this.state.numDataBuffers;
    info.numBytes = this.state.numBytes;
    if (this.state.numStringTensors > 0) {
      info.unreliable = true;
      if (info.reasons == null) {
        info.reasons = [];
      }
      info.reasons.push("Memory usage by string tensors is approximate " + "(2 bytes per character)");
    }
    return info;
  }
  async profile(query) {
    this.state.profiling = true;
    const startBytes = this.state.numBytes;
    const startNumTensors = this.state.numTensors;
    this.state.activeProfile.kernels = [];
    this.state.activeProfile.result = await query();
    this.state.profiling = false;
    this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map((d) => d.totalBytesSnapshot));
    this.state.activeProfile.newBytes = this.state.numBytes - startBytes;
    this.state.activeProfile.newTensors = this.state.numTensors - startNumTensors;
    for (const kernel of this.state.activeProfile.kernels) {
      kernel.kernelTimeMs = await kernel.kernelTimeMs;
      kernel.extraInfo = await kernel.extraInfo;
    }
    return this.state.activeProfile;
  }
  isTapeOn() {
    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
  }
  addTapeNode(kernelName, inputs, outputs, gradientsFunc, saved, attrs) {
    const tapeNode = { id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved };
    const gradConfig = getGradient(kernelName);
    if (gradConfig != null) {
      gradientsFunc = gradConfig.gradFunc;
    }
    if (gradientsFunc != null) {
      tapeNode.gradient = (dys) => {
        dys = dys.map((dy, i) => {
          if (dy == null) {
            const output = outputs[i];
            const vals = makeZerosTypedArray(output.size, output.dtype);
            return this.makeTensor(vals, output.shape, output.dtype);
          }
          return dy;
        });
        return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);
      };
    }
    this.state.activeTape.push(tapeNode);
  }
  keep(result) {
    result.kept = true;
    return result;
  }
  startTape() {
    if (this.state.gradientDepth === 0) {
      this.state.activeTape = [];
    }
    this.state.gradientDepth++;
  }
  endTape() {
    this.state.gradientDepth--;
  }
  startScope(name) {
    const scopeInfo = {
      track: [],
      name: "unnamed scope",
      id: this.state.nextScopeId++
    };
    if (name) {
      scopeInfo.name = name;
    }
    this.state.scopeStack.push(scopeInfo);
    this.state.activeScope = scopeInfo;
  }
  endScope(result) {
    const tensorsToTrackInParent = getTensorsInContainer(result);
    const tensorsToTrackInParentSet = new Set(tensorsToTrackInParent.map((t) => t.id));
    for (let i = 0;i < this.state.activeScope.track.length; i++) {
      const tensor3 = this.state.activeScope.track[i];
      if (!tensor3.kept && !tensorsToTrackInParentSet.has(tensor3.id)) {
        tensor3.dispose();
      }
    }
    const oldScope = this.state.scopeStack.pop();
    this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1];
    tensorsToTrackInParent.forEach((tensor3) => {
      if (!tensor3.kept && tensor3.scopeId === oldScope.id) {
        this.track(tensor3);
      }
    });
  }
  gradients(f, xs, dy, allowNoGradients = false) {
    assert(xs.length > 0, () => "gradients() received an empty list of xs.");
    if (dy != null && dy.dtype !== "float32") {
      throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);
    }
    const y = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", f));
    assert(y instanceof Tensor, () => "The result y returned by f() must be a tensor.");
    const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);
    if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
      throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure " + "that the f you passed encloses all operations that lead from x " + "to y.");
    }
    return this.tidy("backward", () => {
      const accumulatedGradientMap = {};
      accumulatedGradientMap[y.id] = dy == null ? ones(y.shape) : dy;
      backpropagateGradients(accumulatedGradientMap, filteredTape, (f2) => this.tidy(f2), add);
      const grads = xs.map((x) => accumulatedGradientMap[x.id]);
      if (this.state.gradientDepth === 0) {
        this.state.activeTape.forEach((node) => {
          for (const tensor3 of node.saved) {
            tensor3.dispose();
          }
        });
        this.state.activeTape = null;
      }
      return { value: y, grads };
    });
  }
  customGrad(f) {
    assert(isFunction(f), () => "The f passed in customGrad(f) must be a function.");
    return (...inputs) => {
      assert(inputs.every((t) => t instanceof Tensor), () => "The args passed in customGrad(f)(x1, x2,...) must all be " + "tensors");
      let res;
      const inputMap = {};
      inputs.forEach((input, i) => {
        inputMap[i] = input;
      });
      const forwardFunc = (_, save) => {
        res = f(...[...inputs, save]);
        assert(res.value instanceof Tensor, () => "The function f passed in customGrad(f) must return an " + "object where `obj.value` is a tensor");
        assert(isFunction(res.gradFunc), () => "The function f passed in customGrad(f) must return an " + "object where `obj.gradFunc` is a function.");
        return res.value;
      };
      const backwardsFunc = (dy, saved) => {
        const gradRes = res.gradFunc(dy, saved);
        const grads = Array.isArray(gradRes) ? gradRes : [gradRes];
        assert(grads.length === inputs.length, () => "The function f passed in customGrad(f) must return an " + "object where `obj.gradFunc` is a function that returns " + "the same number of tensors as inputs passed to f(...).");
        assert(grads.every((t) => t instanceof Tensor), () => "The function f passed in customGrad(f) must return an " + "object where `obj.gradFunc` is a function that returns " + "a list of only tensors.");
        const gradMap = {};
        grads.forEach((grad, i) => {
          gradMap[i] = () => grad;
        });
        return gradMap;
      };
      return this.runKernelFunc({
        forwardFunc,
        backwardsFunc,
        inputs: inputMap
      });
    };
  }
  readSync(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.readSync(dataId);
  }
  read(dataId) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.read(dataId);
  }
  readToGPU(dataId, options) {
    const info = this.state.tensorInfo.get(dataId);
    return info.backend.readToGPU(dataId, options);
  }
  async time(query) {
    const start = now();
    const timingInfo = await this.backend.time(query);
    timingInfo.wallMs = now() - start;
    return timingInfo;
  }
  track(result) {
    if (this.state.activeScope != null) {
      result.scopeId = this.state.activeScope.id;
      this.state.activeScope.track.push(result);
    }
    return result;
  }
  get registeredVariables() {
    return this.state.registeredVariables;
  }
  reset() {
    this.pendingBackendInitId++;
    this.state.dispose();
    this.ENV.reset();
    this.state = new EngineState;
    for (const backendName in this.registry) {
      this.disposeRegisteredKernels(backendName);
      this.registry[backendName].dispose();
      delete this.registry[backendName];
    }
    this.backendName = null;
    this.backendInstance = null;
    this.pendingBackendInit = null;
  }
}
var ENGINE;
var init_engine = __esm(() => {
  init_environment();
  init_kernel_registry();
  init_log();
  init_profiler();
  init_tape();
  init_tensor();
  init_tensor_util();
  init_util();
  init_util();
  Engine.nextTensorId = 0;
  Engine.nextVariableId = 0;
  ENGINE = getOrMakeEngine();
});

// node_modules/@tensorflow/tfjs-core/dist/device_util.js
var exports_device_util = {};
__export(exports_device_util, {
  mockIsMobile: () => mockIsMobile,
  isMobile: () => isMobile,
  isBrowser: () => isBrowser
});
function _isNavigatorDefined() {
  return typeof navigator !== "undefined" && navigator != null;
}
function mockIsMobile(value) {
  isMobileMockValue = value;
}
function isMobile(nav) {
  if (isMobileMockValue !== undefined) {
    return isMobileMockValue;
  }
  if (nav || _isNavigatorDefined()) {
    if (!nav) {
      nav = navigator;
    }
    if (nav.product === "ReactNative") {
      return true;
    }
    const a = nav.userAgent || nav.vendor || (typeof window !== "undefined" ? window.opera : "");
    if (!a) {
      const navAny = nav;
      return navAny.userAgentData && navAny.userAgentData.mobile;
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4));
  }
  return false;
}
function isBrowser() {
  return typeof window !== "undefined" && window.document != null || typeof WorkerGlobalScope !== "undefined";
}
var isMobileMockValue;

// node_modules/@tensorflow/tfjs-core/dist/flags.js
var ENV2;
var init_flags = __esm(() => {
  init_engine();
  init_environment();
  ENV2 = env();
  ENV2.registerFlag("DEBUG", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Debugging mode is ON. The output of every math call will " + "be downloaded to CPU and checked for NaNs. " + "This significantly impacts performance.");
    }
  });
  ENV2.registerFlag("IS_BROWSER", () => isBrowser());
  ENV2.registerFlag("IS_NODE", () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined");
  ENV2.registerFlag("IS_CHROME", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor));
  ENV2.registerFlag("IS_SAFARI", () => typeof navigator !== "undefined" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor));
  ENV2.registerFlag("PROD", () => false);
  ENV2.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => ENV2.getBool("DEBUG"));
  ENV2.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => true);
  ENV2.registerFlag("IS_TEST", () => false);
  ENV2.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => ENV2.getBool("DEBUG"));
  ENV2.registerFlag("WRAP_TO_IMAGEBITMAP", () => false);
  ENV2.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false);
  ENV2.registerFlag("USE_SETTIMEOUTCUSTOM", () => false);
});

// node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js
function inferShape(val, dtype) {
  let firstElem = val;
  if (isTypedArray(val)) {
    return dtype === "string" ? [] : [val.length];
  }
  if (isWebGLData(val)) {
    const usedChannels = val.channels || "RGBA";
    return [val.height, val.width * usedChannels.length];
  } else if (isWebGPUData(val)) {
    return [val.buffer.size / (dtype == null ? 4 : bytesPerElement(dtype))];
  }
  if (!Array.isArray(val)) {
    return [];
  }
  const shape = [];
  while (Array.isArray(firstElem) || isTypedArray(firstElem) && dtype !== "string") {
    shape.push(firstElem.length);
    firstElem = firstElem[0];
  }
  if (Array.isArray(val) && env().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")) {
    deepAssertShapeConsistency(val, shape, []);
  }
  return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
  indices = indices || [];
  if (!Array.isArray(val) && !isTypedArray(val)) {
    assert(shape.length === 0, () => `Element arr[${indices.join("][")}] is a primitive, ` + `but should be an array/TypedArray of ${shape[0]} elements`);
    return;
  }
  assert(shape.length > 0, () => `Element arr[${indices.join("][")}] should be a primitive, ` + `but is an array of ${val.length} elements`);
  assert(val.length === shape[0], () => `Element arr[${indices.join("][")}] should have ${shape[0]} ` + `elements, but has ${val.length} elements`);
  const subShape = shape.slice(1);
  for (let i = 0;i < val.length; ++i) {
    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
  }
}
function assertDtype(expectedDtype, actualDType, argName, functionName) {
  if (expectedDtype === "string_or_numeric") {
    return;
  }
  if (expectedDtype == null) {
    throw new Error(`Expected dtype cannot be null.`);
  }
  if (expectedDtype !== "numeric" && expectedDtype !== actualDType || expectedDtype === "numeric" && actualDType === "string") {
    throw new Error(`Argument '${argName}' passed to '${functionName}' must ` + `be ${expectedDtype} tensor, but got ${actualDType} tensor`);
  }
}
function convertToTensor(x, argName, functionName, parseAsDtype = "numeric") {
  if (x instanceof getGlobalTensorClass()) {
    assertDtype(parseAsDtype, x.dtype, argName, functionName);
    return x;
  }
  let inferredDtype = inferDtype(x);
  if (inferredDtype !== "string" && ["bool", "int32", "float32"].indexOf(parseAsDtype) >= 0) {
    inferredDtype = parseAsDtype;
  }
  assertDtype(parseAsDtype, inferredDtype, argName, functionName);
  if (x == null || !isTypedArray(x) && !Array.isArray(x) && typeof x !== "number" && typeof x !== "boolean" && typeof x !== "string") {
    const type = x == null ? "null" : x.constructor.name;
    throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` + `Tensor or TensorLike, but got '${type}'`);
  }
  const inferredShape = inferShape(x, inferredDtype);
  if (!isTypedArray(x) && !Array.isArray(x)) {
    x = [x];
  }
  const skipTypedArray = true;
  const values = inferredDtype !== "string" ? toTypedArray(x, inferredDtype) : flatten(x, [], skipTypedArray);
  return ENGINE.makeTensor(values, inferredShape, inferredDtype);
}
function convertToTensorArray(arg, argName, functionName, parseAsDtype = "numeric") {
  if (!Array.isArray(arg)) {
    throw new Error(`Argument ${argName} passed to ${functionName} must be a ` + "`Tensor[]` or `TensorLike[]`");
  }
  const tensors = arg;
  return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));
}
var init_tensor_util_env = __esm(() => {
  init_engine();
  init_environment();
  init_tensor();
  init_types();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/operation.js
function op(f) {
  const keys = Object.keys(f);
  if (keys.length !== 1) {
    throw new Error(`Please provide an object with a single key ` + `(operation name) mapping to a function. Got an object with ` + `${keys.length} keys.`);
  }
  let opName = keys[0];
  const fn = f[opName];
  if (opName.endsWith("_")) {
    opName = opName.substring(0, opName.length - 1);
  }
  opName = opName + OP_SCOPE_SUFFIX;
  const f2 = (...args) => {
    ENGINE.startScope(opName);
    try {
      const result = fn(...args);
      if (isPromise(result)) {
        console.error("Cannot return a Promise inside of tidy.");
      }
      ENGINE.endScope(result);
      return result;
    } catch (ex) {
      ENGINE.endScope(null);
      throw ex;
    }
  };
  Object.defineProperty(f2, "name", { value: opName, configurable: true });
  return f2;
}
var OP_SCOPE_SUFFIX = "__op";
var init_operation = __esm(() => {
  init_engine();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/complex.js
function complex_(real, imag) {
  const $real = convertToTensor(real, "real", "complex");
  const $imag = convertToTensor(imag, "imag", "complex");
  assertShapesMatch($real.shape, $imag.shape, `real and imag shapes, ${$real.shape} and ${$imag.shape}, ` + `must match in call to tf.complex().`);
  const inputs = { real: $real, imag: $imag };
  return ENGINE.runKernel(Complex, inputs);
}
var complex;
var init_complex = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  complex = op({ complex_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js
function makeTensor(values, shape, inferredShape, dtype) {
  if (dtype == null) {
    dtype = inferDtype(values);
  } else if (dtype === "complex64") {
    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);
  }
  if (isWebGPUData(values) || isWebGLData(values)) {
    if (dtype !== "float32" && dtype !== "int32") {
      throw new Error(`Creating tensor from GPU data only supports ` + `'float32'|'int32' dtype, while the dtype is ${dtype}.`);
    }
    return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);
  }
  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== "number" && typeof values !== "boolean" && typeof values !== "string") {
    throw new Error("values passed to tensor(values) must be a number/boolean/string or " + "an array of numbers/booleans/strings, or a TypedArray");
  }
  if (shape != null) {
    assertNonNegativeIntegerDimensions(shape);
    const providedSize = sizeFromShape(shape);
    const inferredSize = sizeFromShape(inferredShape);
    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);
    for (let i = 0;i < inferredShape.length; ++i) {
      const inferred = inferredShape[i];
      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;
      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);
    }
  }
  if (!isTypedArray(values) && !Array.isArray(values)) {
    values = [values];
  }
  shape = shape || inferredShape;
  values = dtype !== "string" ? toTypedArray(values, dtype) : flatten(values, [], true);
  return ENGINE.makeTensor(values, shape, dtype);
}
var init_tensor_ops_util = __esm(() => {
  init_engine();
  init_types();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor.js
function tensor4(values, shape, dtype) {
  const inferredShape = inferShape(values, dtype);
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor2 = __esm(() => {
  init_tensor_util_env();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/io/types.js
var DTYPE_VALUE_SIZE_MAP;
var init_types2 = __esm(() => {
  DTYPE_VALUE_SIZE_MAP = {
    float32: 4,
    float16: 2,
    int32: 4,
    uint16: 2,
    uint8: 1,
    bool: 1,
    complex64: 8
  };
});

// node_modules/@tensorflow/tfjs-core/dist/io/composite_array_buffer.js
function search(sortedArray, compare) {
  let min = 0;
  let max = sortedArray.length;
  while (min <= max) {
    const middle = Math.floor((max - min) / 2) + min;
    const side = compare(sortedArray[middle]);
    if (side === 0) {
      return middle;
    } else if (side < 0) {
      max = middle;
    } else {
      min = middle + 1;
    }
  }
  return -1;
}

class CompositeArrayBuffer {
  static join(buffers) {
    return new CompositeArrayBuffer(buffers).slice();
  }
  constructor(buffers) {
    this.shards = [];
    this.previousShardIndex = 0;
    if (buffers == null) {
      return;
    }
    if (!(buffers instanceof Array)) {
      buffers = [buffers];
    }
    buffers = buffers.map((bufferOrTypedArray) => {
      if (isTypedArray(bufferOrTypedArray)) {
        return bufferOrTypedArray.buffer;
      }
      return bufferOrTypedArray;
    });
    if (buffers.length === 0) {
      return;
    }
    this.bufferUniformSize = buffers[0].byteLength;
    let start = 0;
    for (let i = 0;i < buffers.length; i++) {
      const buffer = buffers[i];
      if (i !== buffers.length - 1 && buffer.byteLength !== this.bufferUniformSize) {
        this.bufferUniformSize = undefined;
      }
      const end = start + buffer.byteLength;
      this.shards.push({ buffer, start, end });
      start = end;
    }
    if (this.shards.length === 0) {
      this.byteLength = 0;
    }
    this.byteLength = this.shards[this.shards.length - 1].end;
  }
  slice(start = 0, end = this.byteLength) {
    if (this.shards.length === 0) {
      return new ArrayBuffer(0);
    }
    start = isNaN(Number(start)) ? 0 : start;
    end = isNaN(Number(end)) ? 0 : end;
    start = Math.max(0, start);
    end = Math.min(this.byteLength, end);
    if (end <= start) {
      return new ArrayBuffer(0);
    }
    const startShardIndex = this.findShardForByte(start);
    if (startShardIndex === -1) {
      throw new Error(`Could not find start shard for byte ${start}`);
    }
    const size = end - start;
    const outputBuffer = new ArrayBuffer(size);
    const outputArray = new Uint8Array(outputBuffer);
    let sliced = 0;
    for (let i = startShardIndex;i < this.shards.length; i++) {
      const shard = this.shards[i];
      const globalStart = start + sliced;
      const localStart = globalStart - shard.start;
      const outputStart = sliced;
      const globalEnd = Math.min(end, shard.end);
      const localEnd = globalEnd - shard.start;
      const outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);
      outputArray.set(outputSlice, outputStart);
      sliced += outputSlice.length;
      if (end < shard.end) {
        break;
      }
    }
    return outputBuffer;
  }
  findShardForByte(byteIndex) {
    if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {
      return -1;
    }
    if (this.bufferUniformSize != null) {
      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);
      return this.previousShardIndex;
    }
    function check(shard) {
      if (byteIndex < shard.start) {
        return -1;
      }
      if (byteIndex >= shard.end) {
        return 1;
      }
      return 0;
    }
    if (check(this.shards[this.previousShardIndex]) === 0) {
      return this.previousShardIndex;
    }
    const index = search(this.shards, check);
    if (index === -1) {
      return -1;
    }
    this.previousShardIndex = index;
    return this.previousShardIndex;
  }
}
var init_composite_array_buffer = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/globals.js
function enableProdMode() {
  env().set("PROD", true);
}
function enableDebugMode() {
  env().set("DEBUG", true);
}
function disableDeprecationWarnings() {
  env().set("DEPRECATION_WARNINGS_ENABLED", false);
  console.warn(`TensorFlow.js deprecation warnings have been disabled.`);
}
function deprecationWarn(msg) {
  if (env().getBool("DEPRECATION_WARNINGS_ENABLED")) {
    console.warn(msg + " You can disable deprecation warnings with " + "tf.disableDeprecationWarnings().");
  }
}
function disposeVariables() {
  ENGINE.disposeVariables();
}
function engine7() {
  return ENGINE;
}
function memory() {
  return ENGINE.memory();
}
function profile(f) {
  return ENGINE.profile(f);
}
function tidy(nameOrFn, fn) {
  return ENGINE.tidy(nameOrFn, fn);
}
function dispose(container) {
  const tensors = getTensorsInContainer(container);
  tensors.forEach((tensor6) => tensor6.dispose());
}
function keep(result) {
  return ENGINE.keep(result);
}
function time(f) {
  return ENGINE.time(f);
}
function setBackend(backendName) {
  return ENGINE.setBackend(backendName);
}
function ready() {
  return ENGINE.ready();
}
function getBackend() {
  return ENGINE.backendName;
}
function removeBackend(name) {
  ENGINE.removeBackend(name);
}
function findBackend(name) {
  return ENGINE.findBackend(name);
}
function findBackendFactory(name) {
  return ENGINE.findBackendFactory(name);
}
function registerBackend(name, factory, priority = 1) {
  return ENGINE.registerBackend(name, factory, priority);
}
function backend2() {
  return ENGINE.backend;
}
function setPlatform(platformName, platform) {
  env().setPlatform(platformName, platform);
}
var init_globals = __esm(() => {
  init_engine();
  init_environment();
  init_tensor();
  init_tensor_util();
  setDeprecationWarningFn(deprecationWarn);
});

// node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js
async function encodeWeights(tensors, group) {
  const specs = [];
  const dataPromises = [];
  const names = Array.isArray(tensors) ? tensors.map((tensor7) => tensor7.name) : Object.keys(tensors);
  for (let i = 0;i < names.length; ++i) {
    const name = names[i];
    const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];
    if (t.dtype !== "float32" && t.dtype !== "int32" && t.dtype !== "bool" && t.dtype !== "string" && t.dtype !== "complex64") {
      throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
    }
    const spec = { name, shape: t.shape, dtype: t.dtype };
    if (t.dtype === "string") {
      const utf8bytes = new Promise(async (resolve) => {
        const vals = await t.bytes();
        const totalNumBytes = vals.reduce((p, c) => p + c.length, 0) + NUM_BYTES_STRING_LENGTH * vals.length;
        const bytes = new Uint8Array(totalNumBytes);
        let offset = 0;
        for (let i2 = 0;i2 < vals.length; i2++) {
          const val = vals[i2];
          const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
          bytes.set(bytesOfLength, offset);
          offset += NUM_BYTES_STRING_LENGTH;
          bytes.set(val, offset);
          offset += val.length;
        }
        resolve(bytes);
      });
      dataPromises.push(utf8bytes);
    } else {
      dataPromises.push(t.data());
    }
    if (group != null) {
      spec.group = group;
    }
    specs.push(spec);
  }
  const tensorValues = await Promise.all(dataPromises);
  return { data: concatenateTypedArrays(tensorValues), specs };
}
function decodeWeights(weightData, specs) {
  const compositeBuffer = new CompositeArrayBuffer(weightData);
  const out = {};
  let offset = 0;
  for (const spec of specs) {
    const byteLength = getWeightBytelength(spec, (start, end) => {
      return compositeBuffer.slice(offset + start, offset + end);
    });
    out[spec.name] = decodeWeight(spec, compositeBuffer.slice(offset, offset + byteLength));
    offset += byteLength;
  }
  return out;
}
function getWeightBytelength(spec, slice) {
  const size = sizeFromShape(spec.shape);
  let bytesPerValue;
  if ("quantization" in spec) {
    const quantization = spec.quantization;
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
  } else if (spec.dtype === "string") {
    let byteLength = 0;
    for (let i = 0;i < size; i++) {
      byteLength += NUM_BYTES_STRING_LENGTH + new Uint32Array(slice(byteLength, byteLength + NUM_BYTES_STRING_LENGTH))[0];
    }
    return byteLength;
  } else {
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[spec.dtype];
  }
  return size * bytesPerValue;
}
async function getWeightBytelengthAsync(spec, slice) {
  const size = sizeFromShape(spec.shape);
  let bytesPerValue;
  if ("quantization" in spec) {
    const quantization = spec.quantization;
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
  } else if (spec.dtype === "string") {
    let byteLength = 0;
    for (let i = 0;i < size; i++) {
      byteLength += NUM_BYTES_STRING_LENGTH + new Uint32Array(await slice(byteLength, byteLength + NUM_BYTES_STRING_LENGTH))[0];
    }
    return byteLength;
  } else {
    bytesPerValue = DTYPE_VALUE_SIZE_MAP[spec.dtype];
  }
  return size * bytesPerValue;
}
function decodeWeight(spec, byteBuffer) {
  const name = spec.name;
  const dtype = spec.dtype;
  const shape = spec.shape;
  const size = sizeFromShape(shape);
  let values;
  let offset = 0;
  if ("quantization" in spec) {
    const quantization = spec.quantization;
    if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
      if (!(("min" in quantization) && ("scale" in quantization))) {
        throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} ` + `doesn't have corresponding metadata min and scale.`);
      }
    } else if (quantization.dtype === "float16") {
      if (dtype !== "float32") {
        throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} ` + `which only supports weights of type float32 not ${dtype}.`);
      }
    } else {
      throw new Error(`Weight ${spec.name} has unknown ` + `quantization dtype ${quantization.dtype}. ` + `Supported quantization dtypes are: ` + `'uint8', 'uint16', and 'float16'.`);
    }
    const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
    const quantizedArray = quantization.dtype === "uint8" ? new Uint8Array(byteBuffer) : new Uint16Array(byteBuffer);
    if (dtype === "float32") {
      if (quantization.dtype === "uint8" || quantization.dtype === "uint16") {
        values = new Float32Array(quantizedArray.length);
        for (let i = 0;i < quantizedArray.length; i++) {
          const v = quantizedArray[i];
          values[i] = v * quantization.scale + quantization.min;
        }
      } else if (quantization.dtype === "float16") {
        const float16Decode = getFloat16Decoder();
        values = float16Decode(quantizedArray);
      } else {
        throw new Error(`Unsupported quantization type ${quantization.dtype} ` + `for weight type float32.`);
      }
    } else if (dtype === "int32") {
      if (quantization.dtype !== "uint8" && quantization.dtype !== "uint16") {
        throw new Error(`Unsupported quantization type ${quantization.dtype} ` + `for weight type int32.`);
      }
      values = new Int32Array(quantizedArray.length);
      for (let i = 0;i < quantizedArray.length; i++) {
        const v = quantizedArray[i];
        values[i] = Math.round(v * quantization.scale + quantization.min);
      }
    } else {
      throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
    }
    offset += size * quantizationSizeFactor;
  } else if (dtype === "string") {
    const size2 = sizeFromShape(spec.shape);
    values = [];
    for (let i = 0;i < size2; i++) {
      const byteLength = new Uint32Array(byteBuffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
      offset += NUM_BYTES_STRING_LENGTH;
      const bytes = new Uint8Array(byteBuffer.slice(offset, offset + byteLength));
      values.push(bytes);
      offset += byteLength;
    }
  } else {
    const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
    if (dtype === "float32") {
      values = new Float32Array(byteBuffer);
    } else if (dtype === "int32") {
      values = new Int32Array(byteBuffer);
    } else if (dtype === "bool") {
      values = new Uint8Array(byteBuffer);
    } else if (dtype === "complex64") {
      values = new Float32Array(byteBuffer);
      const real = new Float32Array(values.length / 2);
      const image = new Float32Array(values.length / 2);
      for (let i = 0;i < real.length; i++) {
        real[i] = values[i * 2];
        image[i] = values[i * 2 + 1];
      }
      const realTensor = tensor4(real, shape, "float32");
      const imageTensor = tensor4(image, shape, "float32");
      const complexTensor = complex(realTensor, imageTensor);
      realTensor.dispose();
      imageTensor.dispose();
      return complexTensor;
    } else {
      throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
    }
    offset += size * dtypeFactor;
  }
  return tensor4(values, shape, dtype);
}
async function readToLength(reader, initialData, length) {
  let data = new Uint8Array(initialData);
  while (data.byteLength < length) {
    const { done, value } = await reader.read();
    if (done && value == null) {
      const missing = length - data.byteLength;
      throw new Error(`Reader is done but ${missing} bytes are still expected`);
    }
    const newData = new Uint8Array(data.length + value.byteLength);
    newData.set(data, 0);
    newData.set(new Uint8Array(value), data.length);
    data = newData;
  }
  return data.buffer;
}
async function decodeWeightsStream(weightStream, specs) {
  const tensors = {};
  const reader = weightStream.getReader();
  let data = new ArrayBuffer(0);
  for (const spec of specs) {
    const byteLength = await getWeightBytelengthAsync(spec, async (start, end) => {
      data = await readToLength(reader, data, end);
      return data.slice(start, end);
    });
    data = await readToLength(reader, data, byteLength);
    const tensorData = data.slice(0, byteLength);
    data = data.slice(byteLength);
    const weightTensor = decodeWeight(spec, tensorData);
    tensors[spec.name] = weightTensor;
    if (getBackend() === "webgpu") {
      const b = backend2();
      if ("uploadToGPU" in b && sizeFromShape(weightTensor.shape) >= env().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")) {
        b.uploadToGPU(weightTensor.dataId);
      }
    }
  }
  return tensors;
}
function concatenateTypedArrays(xs) {
  if (xs === null) {
    throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
  }
  let totalByteLength = 0;
  const normalizedXs = [];
  xs.forEach((x) => {
    totalByteLength += x.byteLength;
    normalizedXs.push(x.byteLength === x.buffer.byteLength ? x : new x.constructor(x));
    if (!(x instanceof Float32Array || x instanceof Int32Array || x instanceof Uint8Array)) {
      throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
    }
  });
  const y = new Uint8Array(totalByteLength);
  let offset = 0;
  normalizedXs.forEach((x) => {
    y.set(new Uint8Array(x.buffer), offset);
    offset += x.byteLength;
  });
  return y.buffer;
}
function stringByteLength(str) {
  if (useNodeBuffer) {
    return Buffer.byteLength(str, "utf8");
  }
  return new Blob([str]).size;
}
function arrayBufferToBase64String(buffer) {
  if (useNodeBuffer) {
    return Buffer.from(buffer).toString("base64");
  }
  const buf = new Uint8Array(buffer);
  let s = "";
  for (let i = 0, l = buf.length;i < l; i++) {
    s += String.fromCharCode(buf[i]);
  }
  return btoa(s);
}
function base64StringToArrayBuffer(str) {
  if (useNodeBuffer) {
    const buf = Buffer.from(str, "base64");
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
  }
  const s = atob(str);
  const buffer = new Uint8Array(s.length);
  for (let i = 0;i < s.length; ++i) {
    buffer.set([s.charCodeAt(i)], i);
  }
  return buffer.buffer;
}
function concatenateArrayBuffers(buffers) {
  return CompositeArrayBuffer.join(buffers);
}
function basename(path) {
  const SEPARATOR = "/";
  path = path.trim();
  while (path.endsWith(SEPARATOR)) {
    path = path.slice(0, path.length - 1);
  }
  const items = path.split(SEPARATOR);
  return items[items.length - 1];
}
function getModelJSONForModelArtifacts(artifacts, manifest) {
  const result = {
    modelTopology: artifacts.modelTopology,
    format: artifacts.format,
    generatedBy: artifacts.generatedBy,
    convertedBy: artifacts.convertedBy,
    weightsManifest: manifest
  };
  if (artifacts.signature != null) {
    result.signature = artifacts.signature;
  }
  if (artifacts.userDefinedMetadata != null) {
    result.userDefinedMetadata = artifacts.userDefinedMetadata;
  }
  if (artifacts.modelInitializer != null) {
    result.modelInitializer = artifacts.modelInitializer;
  }
  if (artifacts.initializerSignature != null) {
    result.initializerSignature = artifacts.initializerSignature;
  }
  if (artifacts.trainingConfig != null) {
    result.trainingConfig = artifacts.trainingConfig;
  }
  return result;
}
function getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData) {
  const modelArtifacts = {
    modelTopology: modelJSON.modelTopology,
    format: modelJSON.format,
    generatedBy: modelJSON.generatedBy,
    convertedBy: modelJSON.convertedBy
  };
  if (modelJSON.trainingConfig != null) {
    modelArtifacts.trainingConfig = modelJSON.trainingConfig;
  }
  if (modelJSON.weightsManifest != null) {
    if (!weightSpecs) {
      throw new Error("modelJSON has weightsManifest but weightSpecs is null");
    }
    if (!weightData) {
      throw new Error("modelJSON has weightsManifest but weightData is null");
    }
    modelArtifacts.weightSpecs = weightSpecs;
    modelArtifacts.weightData = weightData;
  }
  if (modelJSON.signature != null) {
    modelArtifacts.signature = modelJSON.signature;
  }
  if (modelJSON.userDefinedMetadata != null) {
    modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
  }
  if (modelJSON.modelInitializer != null) {
    modelArtifacts.modelInitializer = modelJSON.modelInitializer;
  }
  if (modelJSON.initializerSignature != null) {
    modelArtifacts.initializerSignature = modelJSON.initializerSignature;
  }
  return modelArtifacts;
}
async function getModelArtifactsForJSON(modelJSON, loadWeights) {
  let weightSpecs;
  let weightData;
  if (modelJSON.weightsManifest != null) {
    [weightSpecs, weightData] = await loadWeights(modelJSON.weightsManifest);
  }
  return getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData);
}
function getModelArtifactsInfoForJSON(modelArtifacts) {
  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
    throw new Error("Expected JSON model topology, received ArrayBuffer.");
  }
  return {
    dateSaved: new Date,
    modelTopologyType: "JSON",
    modelTopologyBytes: modelArtifacts.modelTopology == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
    weightSpecsBytes: modelArtifacts.weightSpecs == null ? 0 : stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
    weightDataBytes: modelArtifacts.weightData == null ? 0 : new CompositeArrayBuffer(modelArtifacts.weightData).byteLength
  };
}
function getWeightSpecs(weightsManifest) {
  const weightSpecs = [];
  for (const entry of weightsManifest) {
    weightSpecs.push(...entry.weights);
  }
  return weightSpecs;
}
function computeFloat16MantisaTable() {
  const convertMantissa = (i) => {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      e -= 8388608;
      m <<= 1;
    }
    m &= ~8388608;
    e += 947912704;
    return m | e;
  };
  const mantisaTable = new Uint32Array(2048);
  mantisaTable[0] = 0;
  for (let i = 1;i < 1024; i++) {
    mantisaTable[i] = convertMantissa(i);
  }
  for (let i = 1024;i < 2048; i++) {
    mantisaTable[i] = 939524096 + (i - 1024 << 13);
  }
  return mantisaTable;
}
function computeFloat16ExponentTable() {
  const exponentTable = new Uint32Array(64);
  exponentTable[0] = 0;
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  exponentTable[63] = 3347054592;
  for (let i = 1;i < 31; i++) {
    exponentTable[i] = i << 23;
  }
  for (let i = 33;i < 63; i++) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  return exponentTable;
}
function computeFloat16OffsetTable() {
  const offsetTable = new Uint32Array(64);
  for (let i = 0;i < 64; i++) {
    offsetTable[i] = 1024;
  }
  offsetTable[0] = offsetTable[32] = 0;
  return offsetTable;
}
function getFloat16Decoder() {
  const mantisaTable = computeFloat16MantisaTable();
  const exponentTable = computeFloat16ExponentTable();
  const offsetTable = computeFloat16OffsetTable();
  return (quantizedArray) => {
    const buffer = new ArrayBuffer(4 * quantizedArray.length);
    const bufferUint32View = new Uint32Array(buffer);
    for (let index = 0;index < quantizedArray.length; index++) {
      const float16Bits = quantizedArray[index];
      const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 1023)] + exponentTable[float16Bits >> 10];
      bufferUint32View[index] = float32Bits;
    }
    return new Float32Array(buffer);
  };
}
var NUM_BYTES_STRING_LENGTH = 4, useNodeBuffer;
var init_io_utils = __esm(() => {
  init_complex();
  init_tensor2();
  init_util();
  init_types2();
  init_composite_array_buffer();
  init_globals();
  init_environment();
  init_globals();
  useNodeBuffer = typeof Buffer !== "undefined" && (typeof Blob === "undefined" || typeof atob === "undefined" || typeof btoa === "undefined");
});

// node_modules/@tensorflow/tfjs-core/dist/io/router_registry.js
class IORouterRegistry {
  constructor() {
    this.saveRouters = [];
    this.loadRouters = [];
  }
  static getInstance() {
    if (IORouterRegistry.instance == null) {
      IORouterRegistry.instance = new IORouterRegistry;
    }
    return IORouterRegistry.instance;
  }
  static registerSaveRouter(saveRouter) {
    IORouterRegistry.getInstance().saveRouters.push(saveRouter);
  }
  static registerLoadRouter(loadRouter) {
    IORouterRegistry.getInstance().loadRouters.push(loadRouter);
  }
  static getSaveHandlers(url) {
    return IORouterRegistry.getHandlers(url, "save");
  }
  static getLoadHandlers(url, loadOptions) {
    return IORouterRegistry.getHandlers(url, "load", loadOptions);
  }
  static getHandlers(url, handlerType, loadOptions) {
    const validHandlers = [];
    const routers = handlerType === "load" ? IORouterRegistry.getInstance().loadRouters : IORouterRegistry.getInstance().saveRouters;
    routers.forEach((router) => {
      const handler = router(url, loadOptions);
      if (handler !== null) {
        validHandlers.push(handler);
      }
    });
    return validHandlers;
  }
}
var registerSaveRouter = (loudRouter) => IORouterRegistry.registerSaveRouter(loudRouter), registerLoadRouter = (loudRouter) => IORouterRegistry.registerLoadRouter(loudRouter), getSaveHandlers = (url) => IORouterRegistry.getSaveHandlers(url), getLoadHandlers = (url, loadOptions) => IORouterRegistry.getLoadHandlers(url, loadOptions);

// node_modules/@tensorflow/tfjs-core/dist/io/indexed_db.js
function getIndexedDBFactory() {
  if (!env().getBool("IS_BROWSER")) {
    throw new Error("Failed to obtain IndexedDB factory because the current environment" + "is not a web browser.");
  }
  const theWindow = typeof window === "undefined" ? self : window;
  const factory = theWindow.indexedDB || theWindow.mozIndexedDB || theWindow.webkitIndexedDB || theWindow.msIndexedDB || theWindow.shimIndexedDB;
  if (factory == null) {
    throw new Error("The current browser does not appear to support IndexedDB.");
  }
  return factory;
}
function setUpDatabase(openRequest) {
  const db = openRequest.result;
  db.createObjectStore(MODEL_STORE_NAME, { keyPath: "modelPath" });
  db.createObjectStore(INFO_STORE_NAME, { keyPath: "modelPath" });
}
function browserIndexedDB(modelPath) {
  return new BrowserIndexedDB(modelPath);
}
function maybeStripScheme(key) {
  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ? key.slice(BrowserIndexedDB.URL_SCHEME.length) : key;
}

class BrowserIndexedDB {
  constructor(modelPath) {
    this.indexedDB = getIndexedDBFactory();
    if (modelPath == null || !modelPath) {
      throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    }
    this.modelPath = modelPath;
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserLocalStorage.save() does not support saving model topology " + "in binary formats yet.");
    }
    return this.databaseAction(this.modelPath, modelArtifacts);
  }
  async load() {
    return this.databaseAction(this.modelPath);
  }
  databaseAction(modelPath, modelArtifacts) {
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        if (modelArtifacts == null) {
          const modelTx = db.transaction(MODEL_STORE_NAME, "readonly");
          const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
          const getRequest = modelStore.get(this.modelPath);
          getRequest.onsuccess = () => {
            if (getRequest.result == null) {
              db.close();
              return reject(new Error(`Cannot find model with path '${this.modelPath}' ` + `in IndexedDB.`));
            } else {
              resolve(getRequest.result.modelArtifacts);
            }
          };
          getRequest.onerror = (error) => {
            db.close();
            return reject(getRequest.error);
          };
          modelTx.oncomplete = () => db.close();
        } else {
          modelArtifacts.weightData = CompositeArrayBuffer.join(modelArtifacts.weightData);
          const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
          const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
          let infoStore = infoTx.objectStore(INFO_STORE_NAME);
          let putInfoRequest;
          try {
            putInfoRequest = infoStore.put({ modelPath: this.modelPath, modelArtifactsInfo });
          } catch (error) {
            return reject(error);
          }
          let modelTx;
          putInfoRequest.onsuccess = () => {
            modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
            let putModelRequest;
            try {
              putModelRequest = modelStore.put({
                modelPath: this.modelPath,
                modelArtifacts,
                modelArtifactsInfo
              });
            } catch (error) {
              return reject(error);
            }
            putModelRequest.onsuccess = () => resolve({ modelArtifactsInfo });
            putModelRequest.onerror = (error) => {
              infoStore = infoTx.objectStore(INFO_STORE_NAME);
              const deleteInfoRequest = infoStore.delete(this.modelPath);
              deleteInfoRequest.onsuccess = () => {
                db.close();
                return reject(putModelRequest.error);
              };
              deleteInfoRequest.onerror = (error2) => {
                db.close();
                return reject(putModelRequest.error);
              };
            };
          };
          putInfoRequest.onerror = (error) => {
            db.close();
            return reject(putInfoRequest.error);
          };
          infoTx.oncomplete = () => {
            if (modelTx == null) {
              db.close();
            } else {
              modelTx.oncomplete = () => db.close();
            }
          };
        }
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
}

class BrowserIndexedDBManager {
  constructor() {
    this.indexedDB = getIndexedDBFactory();
  }
  async listModels() {
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        const tx = db.transaction(INFO_STORE_NAME, "readonly");
        const store = tx.objectStore(INFO_STORE_NAME);
        const getAllInfoRequest = store.getAll();
        getAllInfoRequest.onsuccess = () => {
          const out = {};
          for (const item of getAllInfoRequest.result) {
            out[item.modelPath] = item.modelArtifactsInfo;
          }
          resolve(out);
        };
        getAllInfoRequest.onerror = (error) => {
          db.close();
          return reject(getAllInfoRequest.error);
        };
        tx.oncomplete = () => db.close();
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
  async removeModel(path) {
    path = maybeStripScheme(path);
    return new Promise((resolve, reject) => {
      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);
      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);
      openRequest.onsuccess = () => {
        const db = openRequest.result;
        const infoTx = db.transaction(INFO_STORE_NAME, "readwrite");
        const infoStore = infoTx.objectStore(INFO_STORE_NAME);
        const getInfoRequest = infoStore.get(path);
        let modelTx;
        getInfoRequest.onsuccess = () => {
          if (getInfoRequest.result == null) {
            db.close();
            return reject(new Error(`Cannot find model with path '${path}' ` + `in IndexedDB.`));
          } else {
            const deleteInfoRequest = infoStore.delete(path);
            const deleteModelData = () => {
              modelTx = db.transaction(MODEL_STORE_NAME, "readwrite");
              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);
              const deleteModelRequest = modelStore.delete(path);
              deleteModelRequest.onsuccess = () => resolve(getInfoRequest.result.modelArtifactsInfo);
              deleteModelRequest.onerror = (error) => reject(getInfoRequest.error);
            };
            deleteInfoRequest.onsuccess = deleteModelData;
            deleteInfoRequest.onerror = (error) => {
              deleteModelData();
              db.close();
              return reject(getInfoRequest.error);
            };
          }
        };
        getInfoRequest.onerror = (error) => {
          db.close();
          return reject(getInfoRequest.error);
        };
        infoTx.oncomplete = () => {
          if (modelTx == null) {
            db.close();
          } else {
            modelTx.oncomplete = () => db.close();
          }
        };
      };
      openRequest.onerror = (error) => reject(openRequest.error);
    });
  }
}
var DATABASE_NAME = "tensorflowjs", DATABASE_VERSION = 1, MODEL_STORE_NAME = "models_store", INFO_STORE_NAME = "model_info_store", indexedDBRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {
      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
var init_indexed_db = __esm(() => {
  init_flags();
  init_environment();
  init_io_utils();
  init_composite_array_buffer();
  BrowserIndexedDB.URL_SCHEME = "indexeddb://";
  IORouterRegistry.registerSaveRouter(indexedDBRouter);
  IORouterRegistry.registerLoadRouter(indexedDBRouter);
});

// node_modules/@tensorflow/tfjs-core/dist/io/local_storage.js
function getModelKeys(path) {
  return {
    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),
    topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),
    weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),
    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),
    modelMetadata: [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)
  };
}
function removeItems(keys) {
  for (const key of Object.values(keys)) {
    window.localStorage.removeItem(key);
  }
}
function getModelPathFromKey(key) {
  const items = key.split(PATH_SEPARATOR);
  if (items.length < 3) {
    throw new Error(`Invalid key format: ${key}`);
  }
  return items.slice(1, items.length - 1).join(PATH_SEPARATOR);
}
function maybeStripScheme2(key) {
  return key.startsWith(BrowserLocalStorage.URL_SCHEME) ? key.slice(BrowserLocalStorage.URL_SCHEME.length) : key;
}
function browserLocalStorage(modelPath) {
  return new BrowserLocalStorage(modelPath);
}

class BrowserLocalStorage {
  constructor(modelPath) {
    if (!env().getBool("IS_BROWSER") || typeof window === "undefined" || typeof window.localStorage === "undefined") {
      throw new Error("The current environment does not support local storage.");
    }
    this.LS = window.localStorage;
    if (modelPath == null || !modelPath) {
      throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    }
    this.modelPath = modelPath;
    this.keys = getModelKeys(this.modelPath);
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserLocalStorage.save() does not support saving model topology " + "in binary formats yet.");
    } else {
      const topology = JSON.stringify(modelArtifacts.modelTopology);
      const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);
      const modelArtifactsInfo = getModelArtifactsInfoForJSON(modelArtifacts);
      const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
      try {
        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));
        this.LS.setItem(this.keys.topology, topology);
        this.LS.setItem(this.keys.weightSpecs, weightSpecs);
        this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(weightBuffer));
        const metadata = {
          format: modelArtifacts.format,
          generatedBy: modelArtifacts.generatedBy,
          convertedBy: modelArtifacts.convertedBy,
          signature: modelArtifacts.signature != null ? modelArtifacts.signature : undefined,
          userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ? modelArtifacts.userDefinedMetadata : undefined,
          modelInitializer: modelArtifacts.modelInitializer != null ? modelArtifacts.modelInitializer : undefined,
          initializerSignature: modelArtifacts.initializerSignature != null ? modelArtifacts.initializerSignature : undefined,
          trainingConfig: modelArtifacts.trainingConfig != null ? modelArtifacts.trainingConfig : undefined
        };
        this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));
        return { modelArtifactsInfo };
      } catch (err) {
        removeItems(this.keys);
        throw new Error(`Failed to save model '${this.modelPath}' to local storage: ` + `size quota being exceeded is a possible cause of this failure: ` + `modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, ` + `weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, ` + `weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);
      }
    }
  }
  async load() {
    const info = JSON.parse(this.LS.getItem(this.keys.info));
    if (info == null) {
      throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
    }
    if (info.modelTopologyType !== "JSON") {
      throw new Error("BrowserLocalStorage does not support loading non-JSON model " + "topology yet.");
    }
    const out = {};
    const topology = JSON.parse(this.LS.getItem(this.keys.topology));
    if (topology == null) {
      throw new Error(`In local storage, the topology of model '${this.modelPath}' ` + `is missing.`);
    }
    out.modelTopology = topology;
    const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
    if (weightSpecs == null) {
      throw new Error(`In local storage, the weight specs of model '${this.modelPath}' ` + `are missing.`);
    }
    out.weightSpecs = weightSpecs;
    const metadataString = this.LS.getItem(this.keys.modelMetadata);
    if (metadataString != null) {
      const metadata = JSON.parse(metadataString);
      out.format = metadata.format;
      out.generatedBy = metadata.generatedBy;
      out.convertedBy = metadata.convertedBy;
      if (metadata.signature != null) {
        out.signature = metadata.signature;
      }
      if (metadata.userDefinedMetadata != null) {
        out.userDefinedMetadata = metadata.userDefinedMetadata;
      }
      if (metadata.modelInitializer != null) {
        out.modelInitializer = metadata.modelInitializer;
      }
      if (metadata.initializerSignature != null) {
        out.initializerSignature = metadata.initializerSignature;
      }
      if (metadata.trainingConfig != null) {
        out.trainingConfig = metadata.trainingConfig;
      }
    }
    const weightDataBase64 = this.LS.getItem(this.keys.weightData);
    if (weightDataBase64 == null) {
      throw new Error(`In local storage, the binary weight values of model ` + `'${this.modelPath}' are missing.`);
    }
    out.weightData = base64StringToArrayBuffer(weightDataBase64);
    return out;
  }
}

class BrowserLocalStorageManager {
  constructor() {
    assert(env().getBool("IS_BROWSER"), () => "Current environment is not a web browser");
    assert(typeof window === "undefined" || typeof window.localStorage !== "undefined", () => "Current browser does not appear to support localStorage");
    this.LS = window.localStorage;
  }
  async listModels() {
    const out = {};
    const prefix = PATH_PREFIX + PATH_SEPARATOR;
    const suffix = PATH_SEPARATOR + INFO_SUFFIX;
    for (let i = 0;i < this.LS.length; ++i) {
      const key = this.LS.key(i);
      if (key.startsWith(prefix) && key.endsWith(suffix)) {
        const modelPath = getModelPathFromKey(key);
        out[modelPath] = JSON.parse(this.LS.getItem(key));
      }
    }
    return out;
  }
  async removeModel(path) {
    path = maybeStripScheme2(path);
    const keys = getModelKeys(path);
    if (this.LS.getItem(keys.info) == null) {
      throw new Error(`Cannot find model at path '${path}'`);
    }
    const info = JSON.parse(this.LS.getItem(keys.info));
    removeItems(keys);
    return info;
  }
}
var PATH_SEPARATOR = "/", PATH_PREFIX = "tensorflowjs_models", INFO_SUFFIX = "info", MODEL_TOPOLOGY_SUFFIX = "model_topology", WEIGHT_SPECS_SUFFIX = "weight_specs", WEIGHT_DATA_SUFFIX = "weight_data", MODEL_METADATA_SUFFIX = "model_metadata", localStorageRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {
      return browserLocalStorage(url.slice(BrowserLocalStorage.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
var init_local_storage = __esm(() => {
  init_flags();
  init_environment();
  init_util();
  init_io_utils();
  init_composite_array_buffer();
  BrowserLocalStorage.URL_SCHEME = "localstorage://";
  IORouterRegistry.registerSaveRouter(localStorageRouter);
  IORouterRegistry.registerLoadRouter(localStorageRouter);
});

// node_modules/@tensorflow/tfjs-core/dist/io/model_management.js
function parseURL(url) {
  if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {
    throw new Error(`The url string provided does not contain a scheme. ` + `Supported schemes are: ` + `${ModelStoreManagerRegistry.getSchemes().join(",")}`);
  }
  return {
    scheme: url.split(URL_SCHEME_SUFFIX)[0],
    path: url.split(URL_SCHEME_SUFFIX)[1]
  };
}
async function cloneModelInternal(sourceURL, destURL, deleteSource = false) {
  assert(sourceURL !== destURL, () => `Old path and new path are the same: '${sourceURL}'`);
  const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);
  assert(loadHandlers.length > 0, () => `Copying failed because no load handler is found for source URL ${sourceURL}.`);
  assert(loadHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) ` + `load handlers for source URL ${sourceURL}.`);
  const loadHandler = loadHandlers[0];
  const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);
  assert(saveHandlers.length > 0, () => `Copying failed because no save handler is found for destination ` + `URL ${destURL}.`);
  assert(saveHandlers.length < 2, () => `Copying failed because more than one (${loadHandlers.length}) ` + `save handlers for destination URL ${destURL}.`);
  const saveHandler = saveHandlers[0];
  const sourceScheme = parseURL(sourceURL).scheme;
  const sourcePath = parseURL(sourceURL).path;
  const sameMedium = sourceScheme === parseURL(sourceURL).scheme;
  const modelArtifacts = await loadHandler.load();
  if (deleteSource && sameMedium) {
    await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
  }
  const saveResult = await saveHandler.save(modelArtifacts);
  if (deleteSource && !sameMedium) {
    await ModelStoreManagerRegistry.getManager(sourceScheme).removeModel(sourcePath);
  }
  return saveResult.modelArtifactsInfo;
}
async function listModels() {
  const schemes = ModelStoreManagerRegistry.getSchemes();
  const out = {};
  for (const scheme of schemes) {
    const schemeOut = await ModelStoreManagerRegistry.getManager(scheme).listModels();
    for (const path in schemeOut) {
      const url = scheme + URL_SCHEME_SUFFIX + path;
      out[url] = schemeOut[path];
    }
  }
  return out;
}
async function removeModel(url) {
  const schemeAndPath = parseURL(url);
  const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);
  return manager.removeModel(schemeAndPath.path);
}
async function copyModel(sourceURL, destURL) {
  const deleteSource = false;
  return cloneModelInternal(sourceURL, destURL, deleteSource);
}
async function moveModel(sourceURL, destURL) {
  const deleteSource = true;
  return cloneModelInternal(sourceURL, destURL, deleteSource);
}

class ModelStoreManagerRegistry {
  constructor() {
    this.managers = {};
  }
  static getInstance() {
    if (ModelStoreManagerRegistry.instance == null) {
      ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry;
    }
    return ModelStoreManagerRegistry.instance;
  }
  static registerManager(scheme, manager) {
    assert(scheme != null, () => "scheme must not be undefined or null.");
    if (scheme.endsWith(URL_SCHEME_SUFFIX)) {
      scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));
    }
    assert(scheme.length > 0, () => "scheme must not be an empty string.");
    const registry = ModelStoreManagerRegistry.getInstance();
    assert(registry.managers[scheme] == null, () => `A model store manager is already registered for scheme '${scheme}'.`);
    registry.managers[scheme] = manager;
  }
  static getManager(scheme) {
    const manager = ModelStoreManagerRegistry.getInstance().managers[scheme];
    if (manager == null) {
      throw new Error(`Cannot find model manager for scheme '${scheme}'`);
    }
    return manager;
  }
  static getSchemes() {
    return Object.keys(ModelStoreManagerRegistry.getInstance().managers);
  }
}
var URL_SCHEME_SUFFIX = "://";
var init_model_management = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/platforms/platform_browser.js
class PlatformBrowser {
  constructor() {
    this.messageName = "setTimeoutCustom";
    this.functionRefs = [];
    this.handledMessageCount = 0;
    this.hasEventListener = false;
  }
  fetch(path, init) {
    return fetch(path, init);
  }
  now() {
    return performance.now();
  }
  encode(text, encoding) {
    if (encoding !== "utf-8" && encoding !== "utf8") {
      throw new Error(`Browser's encoder only supports utf-8, but got ${encoding}`);
    }
    if (this.textEncoder == null) {
      this.textEncoder = new TextEncoder;
    }
    return this.textEncoder.encode(text);
  }
  decode(bytes, encoding) {
    return new TextDecoder(encoding).decode(bytes);
  }
  setTimeoutCustom(functionRef, delay) {
    if (typeof window === "undefined" || !env().getBool("USE_SETTIMEOUTCUSTOM")) {
      setTimeout(functionRef, delay);
      return;
    }
    this.functionRefs.push(functionRef);
    setTimeout(() => {
      window.postMessage({ name: this.messageName, index: this.functionRefs.length - 1 }, "*");
    }, delay);
    if (!this.hasEventListener) {
      this.hasEventListener = true;
      window.addEventListener("message", (event) => {
        if (event.source === window && event.data.name === this.messageName) {
          event.stopPropagation();
          const functionRef2 = this.functionRefs[event.data.index];
          functionRef2();
          this.handledMessageCount++;
          if (this.handledMessageCount === this.functionRefs.length) {
            this.functionRefs = [];
            this.handledMessageCount = 0;
          }
        }
      }, true);
    }
  }
  isTypedArray(a) {
    return isTypedArrayBrowser(a);
  }
}
var init_platform_browser = __esm(() => {
  init_flags();
  init_environment();
  init_indexed_db();
  init_local_storage();
  init_model_management();
  if (env().get("IS_BROWSER")) {
    env().setPlatform("browser", new PlatformBrowser);
    try {
      ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager);
    } catch (err) {
    }
    try {
      ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager);
    } catch (err) {
    }
  }
});

// node:util
var exports_util2 = {};
__export(exports_util2, {
  default: () => so,
  TextEncoder: () => st,
  TextDecoder: () => ct
});
var pt, dr, lt, gt, dt, bt, p = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), At = (r, e) => {
  for (var t in e)
    dr(r, t, { get: e[t], enumerable: true });
}, gr = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o of gt(e))
      !bt.call(r, o) && o !== t && dr(r, o, { get: () => e[o], enumerable: !(n = lt(e, o)) || n.enumerable });
  return r;
}, F = (r, e, t) => (gr(r, e, "default"), t && gr(t, e, "default")), mt = (r, e, t) => (t = r != null ? pt(dt(r)) : {}, gr(e || !r || !r.__esModule ? dr(t, "default", { value: r, enumerable: true }) : t, r)), br, N, Zr, Kr, V, re, H, ce, Y, Ae, Se, Pe, Fr, Br, Ur, Rr, qe, rt, tt, nt, yt, E, st, ct, so;
var init_util2 = __esm(() => {
  pt = Object.create;
  dr = Object.defineProperty;
  lt = Object.getOwnPropertyDescriptor;
  gt = Object.getOwnPropertyNames;
  dt = Object.getPrototypeOf;
  bt = Object.prototype.hasOwnProperty;
  br = p((po, Vr) => {
    Vr.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var e = {}, t = Symbol("test"), n = Object(t);
      if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var o = 42;
      e[t] = o;
      for (t in e)
        return false;
      if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
        return false;
      var i = Object.getOwnPropertySymbols(e);
      if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a = Object.getOwnPropertyDescriptor(e, t);
        if (a.value !== o || a.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  N = p((lo, Jr) => {
    var ht = br();
    Jr.exports = function() {
      return ht() && !!Symbol.toStringTag;
    };
  });
  Zr = p((go, Hr) => {
    var Lr = typeof Symbol < "u" && Symbol, St = br();
    Hr.exports = function() {
      return typeof Lr != "function" || typeof Symbol != "function" || typeof Lr("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : St();
    };
  });
  Kr = p((bo, Yr) => {
    var vt = "Function.prototype.bind called on incompatible ", Ar = Array.prototype.slice, Ot = Object.prototype.toString, jt = "[object Function]";
    Yr.exports = function(e) {
      var t = this;
      if (typeof t != "function" || Ot.call(t) !== jt)
        throw new TypeError(vt + t);
      for (var n = Ar.call(arguments, 1), o, i = function() {
        if (this instanceof o) {
          var g = t.apply(this, n.concat(Ar.call(arguments)));
          return Object(g) === g ? g : this;
        } else
          return t.apply(e, n.concat(Ar.call(arguments)));
      }, a = Math.max(0, t.length - n.length), f = [], c = 0;c < a; c++)
        f.push("$" + c);
      if (o = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(i), t.prototype) {
        var l = function() {
        };
        l.prototype = t.prototype, o.prototype = new l, l.prototype = null;
      }
      return o;
    };
  });
  V = p((Ao, Qr) => {
    var Pt = Kr();
    Qr.exports = Function.prototype.bind || Pt;
  });
  re = p((mo, Xr) => {
    var wt = V();
    Xr.exports = wt.call(Function.call, Object.prototype.hasOwnProperty);
  });
  H = p((ho, ie) => {
    var s, x = SyntaxError, oe = Function, U = TypeError, mr = function(r) {
      try {
        return oe('"use strict"; return (' + r + ").constructor;")();
      } catch {
      }
    }, v = Object.getOwnPropertyDescriptor;
    if (v)
      try {
        v({}, "");
      } catch {
        v = null;
      }
    var hr = function() {
      throw new U;
    }, Et = v ? function() {
      try {
        return arguments.callee, hr;
      } catch {
        try {
          return v(arguments, "callee").get;
        } catch {
          return hr;
        }
      }
    }() : hr, I = Zr()(), m = Object.getPrototypeOf || function(r) {
      return r.__proto__;
    }, B = {}, Tt = typeof Uint8Array > "u" ? s : m(Uint8Array), O = { "%AggregateError%": typeof AggregateError > "u" ? s : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? s : ArrayBuffer, "%ArrayIteratorPrototype%": I ? m([][Symbol.iterator]()) : s, "%AsyncFromSyncIteratorPrototype%": s, "%AsyncFunction%": B, "%AsyncGenerator%": B, "%AsyncGeneratorFunction%": B, "%AsyncIteratorPrototype%": B, "%Atomics%": typeof Atomics > "u" ? s : Atomics, "%BigInt%": typeof BigInt > "u" ? s : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? s : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? s : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? s : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? s : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? s : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? s : FinalizationRegistry, "%Function%": oe, "%GeneratorFunction%": B, "%Int8Array%": typeof Int8Array > "u" ? s : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? s : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? s : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": I ? m(m([][Symbol.iterator]())) : s, "%JSON%": typeof JSON == "object" ? JSON : s, "%Map%": typeof Map > "u" ? s : Map, "%MapIteratorPrototype%": typeof Map > "u" || !I ? s : m(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? s : Promise, "%Proxy%": typeof Proxy > "u" ? s : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? s : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? s : Set, "%SetIteratorPrototype%": typeof Set > "u" || !I ? s : m(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? s : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": I ? m(""[Symbol.iterator]()) : s, "%Symbol%": I ? Symbol : s, "%SyntaxError%": x, "%ThrowTypeError%": Et, "%TypedArray%": Tt, "%TypeError%": U, "%Uint8Array%": typeof Uint8Array > "u" ? s : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? s : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? s : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? s : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? s : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? s : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? s : WeakSet };
    try {
      null.error;
    } catch (r) {
      ee = m(m(r)), O["%Error.prototype%"] = ee;
    }
    var ee, Ft = function r(e) {
      var t;
      if (e === "%AsyncFunction%")
        t = mr("async function () {}");
      else if (e === "%GeneratorFunction%")
        t = mr("function* () {}");
      else if (e === "%AsyncGeneratorFunction%")
        t = mr("async function* () {}");
      else if (e === "%AsyncGenerator%") {
        var n = r("%AsyncGeneratorFunction%");
        n && (t = n.prototype);
      } else if (e === "%AsyncIteratorPrototype%") {
        var o = r("%AsyncGenerator%");
        o && (t = m(o.prototype));
      }
      return O[e] = t, t;
    }, te = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C = V(), J = re(), It = C.call(Function.call, Array.prototype.concat), Bt = C.call(Function.apply, Array.prototype.splice), ne = C.call(Function.call, String.prototype.replace), L = C.call(Function.call, String.prototype.slice), Ut = C.call(Function.call, RegExp.prototype.exec), xt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Dt = /\\(\\)?/g, Rt = function(e) {
      var t = L(e, 0, 1), n = L(e, -1);
      if (t === "%" && n !== "%")
        throw new x("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && t !== "%")
        throw new x("invalid intrinsic syntax, expected opening `%`");
      var o = [];
      return ne(e, xt, function(i, a, f, c) {
        o[o.length] = f ? ne(c, Dt, "$1") : a || i;
      }), o;
    }, kt = function(e, t) {
      var n = e, o;
      if (J(te, n) && (o = te[n], n = "%" + o[0] + "%"), J(O, n)) {
        var i = O[n];
        if (i === B && (i = Ft(n)), typeof i > "u" && !t)
          throw new U("intrinsic " + e + " exists, but is not available. Please file an issue!");
        return { alias: o, name: n, value: i };
      }
      throw new x("intrinsic " + e + " does not exist!");
    };
    ie.exports = function(e, t) {
      if (typeof e != "string" || e.length === 0)
        throw new U("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t != "boolean")
        throw new U('"allowMissing" argument must be a boolean');
      if (Ut(/^%?[^%]*%?$/, e) === null)
        throw new x("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var n = Rt(e), o = n.length > 0 ? n[0] : "", i = kt("%" + o + "%", t), a = i.name, f = i.value, c = false, l = i.alias;
      l && (o = l[0], Bt(n, It([0, 1], l)));
      for (var g = 1, S = true;g < n.length; g += 1) {
        var d = n[g], T = L(d, 0, 1), _ = L(d, -1);
        if ((T === '"' || T === "'" || T === "`" || _ === '"' || _ === "'" || _ === "`") && T !== _)
          throw new x("property names with quotes must have matching quotes");
        if ((d === "constructor" || !S) && (c = true), o += "." + d, a = "%" + o + "%", J(O, a))
          f = O[a];
        else if (f != null) {
          if (!(d in f)) {
            if (!t)
              throw new U("base intrinsic for " + e + " exists, but the property is not available.");
            return;
          }
          if (v && g + 1 >= n.length) {
            var z = v(f, d);
            S = !!z, S && "get" in z && !("originalValue" in z.get) ? f = z.get : f = f[d];
          } else
            S = J(f, d), f = f[d];
          S && !c && (O[a] = f);
        }
      }
      return f;
    };
  });
  ce = p((So, Z) => {
    var Sr = V(), D = H(), ue = D("%Function.prototype.apply%"), ye = D("%Function.prototype.call%"), se = D("%Reflect.apply%", true) || Sr.call(ye, ue), ae = D("%Object.getOwnPropertyDescriptor%", true), j = D("%Object.defineProperty%", true), Mt = D("%Math.max%");
    if (j)
      try {
        j({}, "a", { value: 1 });
      } catch {
        j = null;
      }
    Z.exports = function(e) {
      var t = se(Sr, ye, arguments);
      if (ae && j) {
        var n = ae(t, "length");
        n.configurable && j(t, "length", { value: 1 + Mt(0, e.length - (arguments.length - 1)) });
      }
      return t;
    };
    var fe = function() {
      return se(Sr, ue, arguments);
    };
    j ? j(Z.exports, "apply", { value: fe }) : Z.exports.apply = fe;
  });
  Y = p((vo, ge) => {
    var pe = H(), le = ce(), Nt = le(pe("String.prototype.indexOf"));
    ge.exports = function(e, t) {
      var n = pe(e, !!t);
      return typeof n == "function" && Nt(e, ".prototype.") > -1 ? le(n) : n;
    };
  });
  Ae = p((Oo, be) => {
    var Ct = N()(), $t = Y(), vr = $t("Object.prototype.toString"), K = function(e) {
      return Ct && e && typeof e == "object" && Symbol.toStringTag in e ? false : vr(e) === "[object Arguments]";
    }, de = function(e) {
      return K(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && vr(e) !== "[object Array]" && vr(e.callee) === "[object Function]";
    }, qt = function() {
      return K(arguments);
    }();
    K.isLegacyArguments = de;
    be.exports = qt ? K : de;
  });
  Se = p((jo, he) => {
    var Gt = Object.prototype.toString, Wt = Function.prototype.toString, _t = /^\s*(?:function)?\*/, me = N()(), Or = Object.getPrototypeOf, zt = function() {
      if (!me)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {
      }
    }, jr;
    he.exports = function(e) {
      if (typeof e != "function")
        return false;
      if (_t.test(Wt.call(e)))
        return true;
      if (!me) {
        var t = Gt.call(e);
        return t === "[object GeneratorFunction]";
      }
      if (!Or)
        return false;
      if (typeof jr > "u") {
        var n = zt();
        jr = n ? Or(n) : false;
      }
      return Or(e) === jr;
    };
  });
  Pe = p((Po, je) => {
    var Oe = Function.prototype.toString, R = typeof Reflect == "object" && Reflect !== null && Reflect.apply, wr, Q;
    if (typeof R == "function" && typeof Object.defineProperty == "function")
      try {
        wr = Object.defineProperty({}, "length", { get: function() {
          throw Q;
        } }), Q = {}, R(function() {
          throw 42;
        }, null, wr);
      } catch (r) {
        r !== Q && (R = null);
      }
    else
      R = null;
    var Vt = /^\s*class\b/, Er = function(e) {
      try {
        var t = Oe.call(e);
        return Vt.test(t);
      } catch {
        return false;
      }
    }, Pr = function(e) {
      try {
        return Er(e) ? false : (Oe.call(e), true);
      } catch {
        return false;
      }
    }, X = Object.prototype.toString, Jt = "[object Object]", Lt = "[object Function]", Ht = "[object GeneratorFunction]", Zt = "[object HTMLAllCollection]", Yt = "[object HTML document.all class]", Kt = "[object HTMLCollection]", Qt = typeof Symbol == "function" && !!Symbol.toStringTag, Xt = !(0 in [,]), Tr = function() {
      return false;
    };
    typeof document == "object" && (ve = document.all, X.call(ve) === X.call(document.all) && (Tr = function(e) {
      if ((Xt || !e) && (typeof e > "u" || typeof e == "object"))
        try {
          var t = X.call(e);
          return (t === Zt || t === Yt || t === Kt || t === Jt) && e("") == null;
        } catch {
        }
      return false;
    }));
    var ve;
    je.exports = R ? function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      try {
        R(e, null, wr);
      } catch (t) {
        if (t !== Q)
          return false;
      }
      return !Er(e) && Pr(e);
    } : function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      if (Qt)
        return Pr(e);
      if (Er(e))
        return false;
      var t = X.call(e);
      return t !== Lt && t !== Ht && !/^\[object HTML/.test(t) ? false : Pr(e);
    };
  });
  Fr = p((wo, Ee) => {
    var rn = Pe(), en = Object.prototype.toString, we = Object.prototype.hasOwnProperty, tn = function(e, t, n) {
      for (var o = 0, i = e.length;o < i; o++)
        we.call(e, o) && (n == null ? t(e[o], o, e) : t.call(n, e[o], o, e));
    }, nn = function(e, t, n) {
      for (var o = 0, i = e.length;o < i; o++)
        n == null ? t(e.charAt(o), o, e) : t.call(n, e.charAt(o), o, e);
    }, on = function(e, t, n) {
      for (var o in e)
        we.call(e, o) && (n == null ? t(e[o], o, e) : t.call(n, e[o], o, e));
    }, an = function(e, t, n) {
      if (!rn(t))
        throw new TypeError("iterator must be a function");
      var o;
      arguments.length >= 3 && (o = n), en.call(e) === "[object Array]" ? tn(e, t, o) : typeof e == "string" ? nn(e, t, o) : on(e, t, o);
    };
    Ee.exports = an;
  });
  Br = p((Eo, Te) => {
    var Ir = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], fn = typeof globalThis > "u" ? global : globalThis;
    Te.exports = function() {
      for (var e = [], t = 0;t < Ir.length; t++)
        typeof fn[Ir[t]] == "function" && (e[e.length] = Ir[t]);
      return e;
    };
  });
  Ur = p((To, Fe) => {
    var un = H(), rr = un("%Object.getOwnPropertyDescriptor%", true);
    if (rr)
      try {
        rr([], "length");
      } catch {
        rr = null;
      }
    Fe.exports = rr;
  });
  Rr = p((Fo, De) => {
    var Ie = Fr(), yn = Br(), Dr = Y(), sn = Dr("Object.prototype.toString"), Be = N()(), er = Ur(), cn = typeof globalThis > "u" ? global : globalThis, Ue = yn(), pn = Dr("Array.prototype.indexOf", true) || function(e, t) {
      for (var n = 0;n < e.length; n += 1)
        if (e[n] === t)
          return n;
      return -1;
    }, ln = Dr("String.prototype.slice"), xe = {}, xr = Object.getPrototypeOf;
    Be && er && xr && Ie(Ue, function(r) {
      var e = new cn[r];
      if (Symbol.toStringTag in e) {
        var t = xr(e), n = er(t, Symbol.toStringTag);
        if (!n) {
          var o = xr(t);
          n = er(o, Symbol.toStringTag);
        }
        xe[r] = n.get;
      }
    });
    var gn = function(e) {
      var t = false;
      return Ie(xe, function(n, o) {
        if (!t)
          try {
            t = n.call(e) === o;
          } catch {
          }
      }), t;
    };
    De.exports = function(e) {
      if (!e || typeof e != "object")
        return false;
      if (!Be || !(Symbol.toStringTag in e)) {
        var t = ln(sn(e), 8, -1);
        return pn(Ue, t) > -1;
      }
      return er ? gn(e) : false;
    };
  });
  qe = p((Io, $e) => {
    var ke = Fr(), dn = Br(), Me = Y(), kr = Ur(), bn = Me("Object.prototype.toString"), Ne = N()(), Re = typeof globalThis > "u" ? global : globalThis, An = dn(), mn = Me("String.prototype.slice"), Ce = {}, Mr = Object.getPrototypeOf;
    Ne && kr && Mr && ke(An, function(r) {
      if (typeof Re[r] == "function") {
        var e = new Re[r];
        if (Symbol.toStringTag in e) {
          var t = Mr(e), n = kr(t, Symbol.toStringTag);
          if (!n) {
            var o = Mr(t);
            n = kr(o, Symbol.toStringTag);
          }
          Ce[r] = n.get;
        }
      }
    });
    var hn = function(e) {
      var t = false;
      return ke(Ce, function(n, o) {
        if (!t)
          try {
            var i = n.call(e);
            i === o && (t = i);
          } catch {
          }
      }), t;
    }, Sn = Rr();
    $e.exports = function(e) {
      return Sn(e) ? !Ne || !(Symbol.toStringTag in e) ? mn(bn(e), 8, -1) : hn(e) : false;
    };
  });
  rt = p((u) => {
    var vn = Ae(), On = Se(), A = qe(), Ge = Rr();
    function k(r) {
      return r.call.bind(r);
    }
    var We = typeof BigInt < "u", _e = typeof Symbol < "u", b = k(Object.prototype.toString), jn = k(Number.prototype.valueOf), Pn = k(String.prototype.valueOf), wn = k(Boolean.prototype.valueOf);
    We && (ze = k(BigInt.prototype.valueOf));
    var ze;
    _e && (Ve = k(Symbol.prototype.valueOf));
    var Ve;
    function q(r, e) {
      if (typeof r != "object")
        return false;
      try {
        return e(r), true;
      } catch {
        return false;
      }
    }
    u.isArgumentsObject = vn;
    u.isGeneratorFunction = On;
    u.isTypedArray = Ge;
    function En(r) {
      return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
    }
    u.isPromise = En;
    function Tn(r) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Ge(r) || Le(r);
    }
    u.isArrayBufferView = Tn;
    function Fn(r) {
      return A(r) === "Uint8Array";
    }
    u.isUint8Array = Fn;
    function In(r) {
      return A(r) === "Uint8ClampedArray";
    }
    u.isUint8ClampedArray = In;
    function Bn(r) {
      return A(r) === "Uint16Array";
    }
    u.isUint16Array = Bn;
    function Un(r) {
      return A(r) === "Uint32Array";
    }
    u.isUint32Array = Un;
    function xn(r) {
      return A(r) === "Int8Array";
    }
    u.isInt8Array = xn;
    function Dn(r) {
      return A(r) === "Int16Array";
    }
    u.isInt16Array = Dn;
    function Rn(r) {
      return A(r) === "Int32Array";
    }
    u.isInt32Array = Rn;
    function kn(r) {
      return A(r) === "Float32Array";
    }
    u.isFloat32Array = kn;
    function Mn(r) {
      return A(r) === "Float64Array";
    }
    u.isFloat64Array = Mn;
    function Nn(r) {
      return A(r) === "BigInt64Array";
    }
    u.isBigInt64Array = Nn;
    function Cn(r) {
      return A(r) === "BigUint64Array";
    }
    u.isBigUint64Array = Cn;
    function tr(r) {
      return b(r) === "[object Map]";
    }
    tr.working = typeof Map < "u" && tr(new Map);
    function $n(r) {
      return typeof Map > "u" ? false : tr.working ? tr(r) : r instanceof Map;
    }
    u.isMap = $n;
    function nr(r) {
      return b(r) === "[object Set]";
    }
    nr.working = typeof Set < "u" && nr(new Set);
    function qn(r) {
      return typeof Set > "u" ? false : nr.working ? nr(r) : r instanceof Set;
    }
    u.isSet = qn;
    function or(r) {
      return b(r) === "[object WeakMap]";
    }
    or.working = typeof WeakMap < "u" && or(new WeakMap);
    function Gn(r) {
      return typeof WeakMap > "u" ? false : or.working ? or(r) : r instanceof WeakMap;
    }
    u.isWeakMap = Gn;
    function Cr(r) {
      return b(r) === "[object WeakSet]";
    }
    Cr.working = typeof WeakSet < "u" && Cr(new WeakSet);
    function Wn(r) {
      return Cr(r);
    }
    u.isWeakSet = Wn;
    function ir(r) {
      return b(r) === "[object ArrayBuffer]";
    }
    ir.working = typeof ArrayBuffer < "u" && ir(new ArrayBuffer);
    function Je(r) {
      return typeof ArrayBuffer > "u" ? false : ir.working ? ir(r) : r instanceof ArrayBuffer;
    }
    u.isArrayBuffer = Je;
    function ar(r) {
      return b(r) === "[object DataView]";
    }
    ar.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ar(new DataView(new ArrayBuffer(1), 0, 1));
    function Le(r) {
      return typeof DataView > "u" ? false : ar.working ? ar(r) : r instanceof DataView;
    }
    u.isDataView = Le;
    var Nr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
    function $(r) {
      return b(r) === "[object SharedArrayBuffer]";
    }
    function He(r) {
      return typeof Nr > "u" ? false : (typeof $.working > "u" && ($.working = $(new Nr)), $.working ? $(r) : r instanceof Nr);
    }
    u.isSharedArrayBuffer = He;
    function _n(r) {
      return b(r) === "[object AsyncFunction]";
    }
    u.isAsyncFunction = _n;
    function zn(r) {
      return b(r) === "[object Map Iterator]";
    }
    u.isMapIterator = zn;
    function Vn(r) {
      return b(r) === "[object Set Iterator]";
    }
    u.isSetIterator = Vn;
    function Jn(r) {
      return b(r) === "[object Generator]";
    }
    u.isGeneratorObject = Jn;
    function Ln(r) {
      return b(r) === "[object WebAssembly.Module]";
    }
    u.isWebAssemblyCompiledModule = Ln;
    function Ze(r) {
      return q(r, jn);
    }
    u.isNumberObject = Ze;
    function Ye(r) {
      return q(r, Pn);
    }
    u.isStringObject = Ye;
    function Ke(r) {
      return q(r, wn);
    }
    u.isBooleanObject = Ke;
    function Qe(r) {
      return We && q(r, ze);
    }
    u.isBigIntObject = Qe;
    function Xe(r) {
      return _e && q(r, Ve);
    }
    u.isSymbolObject = Xe;
    function Hn(r) {
      return Ze(r) || Ye(r) || Ke(r) || Qe(r) || Xe(r);
    }
    u.isBoxedPrimitive = Hn;
    function Zn(r) {
      return typeof Uint8Array < "u" && (Je(r) || He(r));
    }
    u.isAnyArrayBuffer = Zn;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
      Object.defineProperty(u, r, { enumerable: false, value: function() {
        throw new Error(r + " is not supported in userland");
      } });
    });
  });
  tt = p((Uo, et) => {
    et.exports = function(e) {
      return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
    };
  });
  nt = p((xo, $r) => {
    typeof Object.create == "function" ? $r.exports = function(e, t) {
      t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : $r.exports = function(e, t) {
      if (t) {
        e.super_ = t;
        var n = function() {
        };
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
      }
    };
  });
  yt = p((y) => {
    var ot = Object.getOwnPropertyDescriptors || function(e) {
      for (var t = Object.keys(e), n = {}, o = 0;o < t.length; o++)
        n[t[o]] = Object.getOwnPropertyDescriptor(e, t[o]);
      return n;
    }, Yn = /%[sdj%]/g;
    y.format = function(r) {
      if (!lr(r)) {
        for (var e = [], t = 0;t < arguments.length; t++)
          e.push(h(arguments[t]));
        return e.join(" ");
      }
      for (var t = 1, n = arguments, o = n.length, i = String(r).replace(Yn, function(f) {
        if (f === "%%")
          return "%";
        if (t >= o)
          return f;
        switch (f) {
          case "%s":
            return String(n[t++]);
          case "%d":
            return Number(n[t++]);
          case "%j":
            try {
              return JSON.stringify(n[t++]);
            } catch {
              return "[Circular]";
            }
          default:
            return f;
        }
      }), a = n[t];t < o; a = n[++t])
        pr(a) || !M(a) ? i += " " + a : i += " " + h(a);
      return i;
    };
    y.deprecate = function(r, e) {
      if (typeof process < "u" && process.noDeprecation === true)
        return r;
      if (typeof process > "u")
        return function() {
          return y.deprecate(r, e).apply(this, arguments);
        };
      var t = false;
      function n() {
        if (!t) {
          if (process.throwDeprecation)
            throw new Error(e);
          process.traceDeprecation ? console.trace(e) : console.error(e), t = true;
        }
        return r.apply(this, arguments);
      }
      return n;
    };
    var fr = {}, it = /^$/;
    process.env.NODE_DEBUG && (ur = process.env.NODE_DEBUG, ur = ur.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), it = new RegExp("^" + ur + "$", "i"));
    var ur;
    y.debuglog = function(r) {
      if (r = r.toUpperCase(), !fr[r])
        if (it.test(r)) {
          var e = process.pid;
          fr[r] = function() {
            var t = y.format.apply(y, arguments);
            console.error("%s %d: %s", r, e, t);
          };
        } else
          fr[r] = function() {
          };
      return fr[r];
    };
    function h(r, e) {
      var t = { seen: [], stylize: Qn };
      return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), _r(e) ? t.showHidden = e : e && y._extend(t, e), w(t.showHidden) && (t.showHidden = false), w(t.depth) && (t.depth = 2), w(t.colors) && (t.colors = false), w(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Kn), sr(t, r, t.depth);
    }
    y.inspect = h;
    h.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    h.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function Kn(r, e) {
      var t = h.styles[e];
      return t ? "\x1B[" + h.colors[t][0] + "m" + r + "\x1B[" + h.colors[t][1] + "m" : r;
    }
    function Qn(r, e) {
      return r;
    }
    function Xn(r) {
      var e = {};
      return r.forEach(function(t, n) {
        e[t] = true;
      }), e;
    }
    function sr(r, e, t) {
      if (r.customInspect && e && yr(e.inspect) && e.inspect !== y.inspect && !(e.constructor && e.constructor.prototype === e)) {
        var n = e.inspect(t, r);
        return lr(n) || (n = sr(r, n, t)), n;
      }
      var o = ro(r, e);
      if (o)
        return o;
      var i = Object.keys(e), a = Xn(i);
      if (r.showHidden && (i = Object.getOwnPropertyNames(e)), W(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
        return qr(e);
      if (i.length === 0) {
        if (yr(e)) {
          var f = e.name ? ": " + e.name : "";
          return r.stylize("[Function" + f + "]", "special");
        }
        if (G(e))
          return r.stylize(RegExp.prototype.toString.call(e), "regexp");
        if (cr(e))
          return r.stylize(Date.prototype.toString.call(e), "date");
        if (W(e))
          return qr(e);
      }
      var c = "", l = false, g = ["{", "}"];
      if (at(e) && (l = true, g = ["[", "]"]), yr(e)) {
        var S = e.name ? ": " + e.name : "";
        c = " [Function" + S + "]";
      }
      if (G(e) && (c = " " + RegExp.prototype.toString.call(e)), cr(e) && (c = " " + Date.prototype.toUTCString.call(e)), W(e) && (c = " " + qr(e)), i.length === 0 && (!l || e.length == 0))
        return g[0] + c + g[1];
      if (t < 0)
        return G(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
      r.seen.push(e);
      var d;
      return l ? d = eo(r, e, t, a, i) : d = i.map(function(T) {
        return Wr(r, e, t, a, T, l);
      }), r.seen.pop(), to(d, c, g);
    }
    function ro(r, e) {
      if (w(e))
        return r.stylize("undefined", "undefined");
      if (lr(e)) {
        var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return r.stylize(t, "string");
      }
      if (ft(e))
        return r.stylize("" + e, "number");
      if (_r(e))
        return r.stylize("" + e, "boolean");
      if (pr(e))
        return r.stylize("null", "null");
    }
    function qr(r) {
      return "[" + Error.prototype.toString.call(r) + "]";
    }
    function eo(r, e, t, n, o) {
      for (var i = [], a = 0, f = e.length;a < f; ++a)
        ut(e, String(a)) ? i.push(Wr(r, e, t, n, String(a), true)) : i.push("");
      return o.forEach(function(c) {
        c.match(/^\d+$/) || i.push(Wr(r, e, t, n, c, true));
      }), i;
    }
    function Wr(r, e, t, n, o, i) {
      var a, f, c;
      if (c = Object.getOwnPropertyDescriptor(e, o) || { value: e[o] }, c.get ? c.set ? f = r.stylize("[Getter/Setter]", "special") : f = r.stylize("[Getter]", "special") : c.set && (f = r.stylize("[Setter]", "special")), ut(n, o) || (a = "[" + o + "]"), f || (r.seen.indexOf(c.value) < 0 ? (pr(t) ? f = sr(r, c.value, null) : f = sr(r, c.value, t - 1), f.indexOf(`
`) > -1 && (i ? f = f.split(`
`).map(function(l) {
        return "  " + l;
      }).join(`
`).slice(2) : f = `
` + f.split(`
`).map(function(l) {
        return "   " + l;
      }).join(`
`))) : f = r.stylize("[Circular]", "special")), w(a)) {
        if (i && o.match(/^\d+$/))
          return f;
        a = JSON.stringify("" + o), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.slice(1, -1), a = r.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = r.stylize(a, "string"));
      }
      return a + ": " + f;
    }
    function to(r, e, t) {
      var n = 0, o = r.reduce(function(i, a) {
        return n++, a.indexOf(`
`) >= 0 && n++, i + a.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return o > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
    }
    y.types = rt();
    function at(r) {
      return Array.isArray(r);
    }
    y.isArray = at;
    function _r(r) {
      return typeof r == "boolean";
    }
    y.isBoolean = _r;
    function pr(r) {
      return r === null;
    }
    y.isNull = pr;
    function no(r) {
      return r == null;
    }
    y.isNullOrUndefined = no;
    function ft(r) {
      return typeof r == "number";
    }
    y.isNumber = ft;
    function lr(r) {
      return typeof r == "string";
    }
    y.isString = lr;
    function oo(r) {
      return typeof r == "symbol";
    }
    y.isSymbol = oo;
    function w(r) {
      return r === undefined;
    }
    y.isUndefined = w;
    function G(r) {
      return M(r) && zr(r) === "[object RegExp]";
    }
    y.isRegExp = G;
    y.types.isRegExp = G;
    function M(r) {
      return typeof r == "object" && r !== null;
    }
    y.isObject = M;
    function cr(r) {
      return M(r) && zr(r) === "[object Date]";
    }
    y.isDate = cr;
    y.types.isDate = cr;
    function W(r) {
      return M(r) && (zr(r) === "[object Error]" || r instanceof Error);
    }
    y.isError = W;
    y.types.isNativeError = W;
    function yr(r) {
      return typeof r == "function";
    }
    y.isFunction = yr;
    function io(r) {
      return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
    }
    y.isPrimitive = io;
    y.isBuffer = tt();
    function zr(r) {
      return Object.prototype.toString.call(r);
    }
    function Gr(r) {
      return r < 10 ? "0" + r.toString(10) : r.toString(10);
    }
    var ao = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function fo() {
      var r = new Date, e = [Gr(r.getHours()), Gr(r.getMinutes()), Gr(r.getSeconds())].join(":");
      return [r.getDate(), ao[r.getMonth()], e].join(" ");
    }
    y.log = function() {
      console.log("%s - %s", fo(), y.format.apply(y, arguments));
    };
    y.inherits = nt();
    y._extend = function(r, e) {
      if (!e || !M(e))
        return r;
      for (var t = Object.keys(e), n = t.length;n--; )
        r[t[n]] = e[t[n]];
      return r;
    };
    function ut(r, e) {
      return Object.prototype.hasOwnProperty.call(r, e);
    }
    var P = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
    y.promisify = function(e) {
      if (typeof e != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (P && e[P]) {
        var t = e[P];
        if (typeof t != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, P, { value: t, enumerable: false, writable: false, configurable: true }), t;
      }
      function t() {
        for (var n, o, i = new Promise(function(c, l) {
          n = c, o = l;
        }), a = [], f = 0;f < arguments.length; f++)
          a.push(arguments[f]);
        a.push(function(c, l) {
          c ? o(c) : n(l);
        });
        try {
          e.apply(this, a);
        } catch (c) {
          o(c);
        }
        return i;
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P && Object.defineProperty(t, P, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, ot(e));
    };
    y.promisify.custom = P;
    function uo(r, e) {
      if (!r) {
        var t = new Error("Promise was rejected with a falsy value");
        t.reason = r, r = t;
      }
      return e(r);
    }
    function yo(r) {
      if (typeof r != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function e() {
        for (var t = [], n = 0;n < arguments.length; n++)
          t.push(arguments[n]);
        var o = t.pop();
        if (typeof o != "function")
          throw new TypeError("The last argument must be of type Function");
        var i = this, a = function() {
          return o.apply(i, arguments);
        };
        r.apply(this, t).then(function(f) {
          process.nextTick(a.bind(null, null, f));
        }, function(f) {
          process.nextTick(uo.bind(null, f, a));
        });
      }
      return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, ot(r)), e;
    }
    y.callbackify = yo;
  });
  E = {};
  At(E, { TextDecoder: () => ct, TextEncoder: () => st, default: () => so });
  F(E, mt(yt()));
  st = globalThis.TextEncoder;
  ct = globalThis.TextDecoder;
  so = { TextEncoder: st, TextDecoder: ct };
});

// node_modules/@tensorflow/tfjs-core/dist/platforms/platform_node.js
class PlatformNode {
  constructor() {
    this.util = (init_util2(), __toCommonJS(exports_util2));
    this.textEncoder = new this.util.TextEncoder;
  }
  fetch(path, requestInits) {
    if (env().global.fetch != null) {
      return env().global.fetch(path, requestInits);
    }
    if (systemFetch == null) {
      systemFetch = getNodeFetch.importFetch();
    }
    return systemFetch(path, requestInits);
  }
  now() {
    const time2 = process.hrtime();
    return time2[0] * 1000 + time2[1] / 1e6;
  }
  encode(text, encoding) {
    if (encoding !== "utf-8" && encoding !== "utf8") {
      throw new Error(`Node built-in encoder only supports utf-8, but got ${encoding}`);
    }
    return this.textEncoder.encode(text);
  }
  decode(bytes, encoding) {
    if (bytes.length === 0) {
      return "";
    }
    return new this.util.TextDecoder(encoding).decode(bytes);
  }
  isTypedArray(a) {
    return this.util.types.isFloat32Array(a) || this.util.types.isInt32Array(a) || this.util.types.isUint8Array(a) || this.util.types.isUint8ClampedArray(a);
  }
}
var getNodeFetch, systemFetch;
var init_platform_node = __esm(() => {
  init_environment();
  getNodeFetch = {
    importFetch: () => (()=>({}))
  };
  if (env().get("IS_NODE") && !env().get("IS_BROWSER")) {
    env().setPlatform("node", new PlatformNode);
  }
});

// node_modules/@tensorflow/tfjs-core/dist/ops/buffer.js
function buffer(shape, dtype = "float32", values) {
  dtype = dtype || "float32";
  assertNonNegativeIntegerDimensions(shape);
  return new TensorBuffer(shape, dtype, values);
}
var init_buffer = __esm(() => {
  init_tensor();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/cast.js
function cast_(x, dtype) {
  const $x = convertToTensor(x, "x", "cast");
  if (!isValidDtype(dtype)) {
    throw new Error(`Failed to cast to unknown dtype ${dtype}`);
  }
  if (dtype === "string" && $x.dtype !== "string" || dtype !== "string" && $x.dtype === "string") {
    throw new Error("Only strings can be casted to strings");
  }
  const inputs = { x: $x };
  const attrs = { dtype };
  return ENGINE.runKernel(Cast, inputs, attrs);
}
var cast;
var init_cast = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  cast = op({ cast_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/clone.js
function clone_(x) {
  const $x = convertToTensor(x, "x", "clone", "string_or_numeric");
  const inputs = { x: $x };
  return ENGINE.runKernel(Identity, inputs);
}
var clone;
var init_clone = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  clone = op({ clone_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/print.js
function print(x, verbose = false) {
  console.log(x.toString(verbose));
}

// node_modules/@tensorflow/tfjs-core/dist/base_side_effects.js
var opHandler2;
var init_base_side_effects = __esm(() => {
  init_engine();
  init_flags();
  init_platform_browser();
  init_platform_node();
  init_buffer();
  init_cast();
  init_clone();
  init_tensor();
  getOrMakeEngine();
  opHandler2 = {
    buffer,
    cast,
    clone,
    print
  };
  setOpHandler(opHandler2);
});

// node_modules/@tensorflow/tfjs-core/dist/ops/add.js
function add_(a, b) {
  let $a = convertToTensor(a, "a", "add");
  let $b = convertToTensor(b, "b", "add");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Add, inputs);
}
var add2;
var init_add = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  add2 = op({ add_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/floorDiv.js
function floorDiv_(a, b) {
  let $a = convertToTensor(a, "a", "floorDiv");
  let $b = convertToTensor(b, "b", "floorDiv");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(FloorDiv, inputs);
}
var floorDiv;
var init_floorDiv = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  floorDiv = op({ floorDiv_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/div.js
function div_(a, b) {
  let $a = convertToTensor(a, "a", "div");
  let $b = convertToTensor(b, "b", "div");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "int32" && $b.dtype === "int32") {
    return floorDiv($a, $b);
  }
  const inputs = { a: $a, b: $b };
  const attrs = {};
  return ENGINE.runKernel(RealDiv, inputs, attrs);
}
var div;
var init_div = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_floorDiv();
  init_operation();
  div = op({ div_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/mul.js
function mul_(a, b) {
  let $a = convertToTensor(a, "a", "mul");
  let $b = convertToTensor(b, "b", "mul");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Multiply, inputs);
}
var mul;
var init_mul = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  mul = op({ mul_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/abs.js
function abs_(x) {
  const $x = convertToTensor(x, "x", "abs");
  if ($x.dtype === "complex64") {
    const inputs = { x: $x };
    return ENGINE.runKernel(ComplexAbs, inputs);
  } else {
    const inputs = { x: $x };
    return ENGINE.runKernel(Abs, inputs);
  }
}
var abs;
var init_abs = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  abs = op({ abs_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/acos.js
function acos_(x) {
  const $x = convertToTensor(x, "x", "acos");
  const inputs = { x: $x };
  return ENGINE.runKernel(Acos, inputs);
}
var acos;
var init_acos = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  acos = op({ acos_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/acosh.js
function acosh_(x) {
  const $x = convertToTensor(x, "x", "acosh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Acosh, inputs);
}
var acosh;
var init_acosh = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  acosh = op({ acosh_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/add_n.js
function addN_(tensors) {
  assert(Array.isArray(tensors), () => "The argument passed to tf.addN() must be a list of tensors");
  assert(tensors.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ` + `${tensors.length}`);
  const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, "addN"));
  const firstTensor = $tensors[0];
  $tensors.forEach((t) => {
    if (t.dtype !== firstTensor.dtype) {
      throw new Error("All tensors passed to tf.addN() must have the same dtype");
    }
  });
  $tensors.forEach((t) => {
    if (!arraysEqual(t.shape, firstTensor.shape)) {
      throw new Error("All tensors passed to tf.addN() must have the same shape");
    }
  });
  const inputs = $tensors;
  return ENGINE.runKernel(AddN, inputs);
}
var addN;
var init_add_n = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  addN = op({ addN_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/all.js
function all_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "all", "bool");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(All, inputs, attrs);
}
var all;
var init_all = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  all = op({ all_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/any.js
function any_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "any", "bool");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Any, inputs, attrs);
}
var any;
var init_any = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  any = op({ any_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/arg_max.js
function argMax_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "argMax");
  const inputs = { x: $x };
  const attrs = { axis };
  return ENGINE.runKernel(ArgMax, inputs, attrs);
}
var argMax;
var init_arg_max = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  argMax = op({ argMax_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/arg_min.js
function argMin_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "argMin");
  const inputs = { x: $x };
  const attrs = { axis };
  return ENGINE.runKernel(ArgMin, inputs, attrs);
}
var argMin;
var init_arg_min = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  argMin = op({ argMin_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/asin.js
function asin_(x) {
  const $x = convertToTensor(x, "x", "asin");
  const inputs = { x: $x };
  return ENGINE.runKernel(Asin, inputs);
}
var asin;
var init_asin = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  asin = op({ asin_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/asinh.js
function asinh_(x) {
  const $x = convertToTensor(x, "x", "asinh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Asinh, inputs);
}
var asinh;
var init_asinh = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  asinh = op({ asinh_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/atan.js
function atan_(x) {
  const $x = convertToTensor(x, "x", "atan");
  const inputs = { x: $x };
  return ENGINE.runKernel(Atan, inputs);
}
var atan;
var init_atan = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  atan = op({ atan_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/atan2.js
function atan2_(a, b) {
  let $a = convertToTensor(a, "a", "atan2");
  let $b = convertToTensor(b, "b", "atan2");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Atan2, inputs);
}
var atan2;
var init_atan2 = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  atan2 = op({ atan2_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/atanh.js
function atanh_(x) {
  const $x = convertToTensor(x, "x", "atanh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Atanh, inputs);
}
var atanh;
var init_atanh = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  atanh = op({ atanh_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv_util.js
function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = "NHWC", dilations) {
  const inputChannels = inputShape[3];
  const $filterShape = [...filterShape, inputChannels];
  const $dataFormat = convertConv2DDataFormat(dataFormat);
  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null, null, $dataFormat);
}
function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = "channelsLast") {
  const [filterHeight, filterWidth] = parseTupleParam(filterSize);
  let filterShape;
  if (dataFormat === "channelsLast") {
    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
  } else if (dataFormat === "channelsFirst") {
    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = "NDHWC") {
  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);
  let filterShape;
  let $dataFormat;
  if (dataFormat === "NDHWC") {
    $dataFormat = "channelsLast";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];
  } else if (dataFormat === "NCDHW") {
    $dataFormat = "channelsFirst";
    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);
}
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = "channelsLast") {
  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideHeight, strideWidth] = parseTupleParam(strides);
  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const { padInfo, outHeight, outWidth } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inHeight,
    inWidth,
    inChannels,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideHeight,
    strideWidth,
    filterHeight,
    filterWidth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = "channelsLast", roundingMode) {
  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];
  if (dataFormat === "channelsLast") {
    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
  } else if (dataFormat === "channelsFirst") {
    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
  const [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
  const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);
  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
  let outShape;
  if (dataFormat === "channelsFirst") {
    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
  } else if (dataFormat === "channelsLast") {
    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
  }
  return {
    batchSize,
    dataFormat,
    inDepth,
    inHeight,
    inWidth,
    inChannels,
    outDepth,
    outHeight,
    outWidth,
    outChannels,
    padInfo,
    strideDepth,
    strideHeight,
    strideWidth,
    filterDepth,
    filterHeight,
    filterWidth,
    effectiveFilterDepth,
    effectiveFilterHeight,
    effectiveFilterWidth,
    dilationDepth,
    dilationHeight,
    dilationWidth,
    inShape,
    outShape,
    filterShape
  };
}
function computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
  }
  const inputRows = inShape[0];
  const inputCols = inShape[1];
  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
  return [outputRows, outputCols];
}
function computeOutputShape4D(inShape, filterShape, outChannels, strides, zeroPad, roundingMode) {
  if (zeroPad == null) {
    zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
  }
  const outShape = [0, 0, 0, outChannels];
  for (let index = 0;index < 3; index++) {
    if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
      outShape[index] = round((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1, roundingMode);
    }
  }
  return outShape;
}
function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {
  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
}
function parseTupleParam(param) {
  if (typeof param === "number") {
    return [param, param, param];
  }
  if (param.length === 2) {
    return [param[0], param[1], 1];
  }
  return param;
}
function parse3TupleParam(param) {
  return typeof param === "number" ? [param, param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
  if (dilation <= 1) {
    return filterSize;
  }
  return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {
  let padInfo;
  let outHeight;
  let outWidth;
  if (typeof pad === "number") {
    const padType = pad === 0 ? "VALID" : "NUMBER";
    padInfo = { top: pad, bottom: pad, left: pad, right: pad, type: padType };
    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);
    outHeight = outShape[0];
    outWidth = outShape[1];
  } else if (pad === "same") {
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);
    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = { top, bottom, left, right, type: "SAME" };
  } else if (pad === "valid") {
    padInfo = { top: 0, bottom: 0, left: 0, right: 0, type: "VALID" };
    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
  } else if (typeof pad === "object") {
    const top = dataFormat === "channelsLast" ? pad[1][0] : pad[2][0];
    const bottom = dataFormat === "channelsLast" ? pad[1][1] : pad[2][1];
    const left = dataFormat === "channelsLast" ? pad[2][0] : pad[3][0];
    const right = dataFormat === "channelsLast" ? pad[2][1] : pad[3][1];
    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? "VALID" : "EXPLICIT";
    padInfo = { top, bottom, left, right, type: padType };
    outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);
    outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);
  } else {
    throw Error(`Unknown padding parameter: ${pad}`);
  }
  return { padInfo, outHeight, outWidth };
}
function get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {
  let padInfo;
  let outDepth;
  let outHeight;
  let outWidth;
  if (pad === "valid") {
    pad = 0;
  }
  if (typeof pad === "number") {
    const padType = pad === 0 ? "VALID" : "NUMBER";
    padInfo = {
      top: pad,
      bottom: pad,
      left: pad,
      right: pad,
      front: pad,
      back: pad,
      type: padType
    };
    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], [filterDepth, filterHeight, filterWidth], 1, [strideDepth, strideHeight, strideWidth], pad, roundingMode);
    outDepth = outShape[0];
    outHeight = outShape[1];
    outWidth = outShape[2];
  } else if (pad === "same") {
    outDepth = Math.ceil(inDepth / strideDepth);
    outHeight = Math.ceil(inHeight / strideHeight);
    outWidth = Math.ceil(inWidth / strideWidth);
    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
    const front = Math.floor(padAlongDepth / 2);
    const back = padAlongDepth - front;
    const top = Math.floor(padAlongHeight / 2);
    const bottom = padAlongHeight - top;
    const left = Math.floor(padAlongWidth / 2);
    const right = padAlongWidth - left;
    padInfo = { top, bottom, left, right, front, back, type: "SAME" };
  } else {
    throw Error(`Unknown padding parameter: ${pad}`);
  }
  return { padInfo, outDepth, outHeight, outWidth };
}
function round(value, roundingMode) {
  if (!roundingMode) {
    return Math.trunc(value);
  }
  switch (roundingMode) {
    case "round":
      return Math.round(value);
    case "ceil":
      return Math.ceil(value);
    case "floor":
      return Math.floor(value);
    default:
      throw new Error(`Unknown roundingMode ${roundingMode}`);
  }
}
function tupleValuesAreOne(param) {
  const [dimA, dimB, dimC] = parseTupleParam(param);
  return dimA === 1 && dimB === 1 && dimC === 1;
}
function eitherStridesOrDilationsAreOne(strides, dilations) {
  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);
}
function stridesOrDilationsArePositive(values) {
  return parseTupleParam(values).every((value) => value > 0);
}
function convertConv2DDataFormat(dataFormat) {
  if (dataFormat === "NHWC") {
    return "channelsLast";
  } else if (dataFormat === "NCHW") {
    return "channelsFirst";
  } else {
    throw new Error(`Unknown dataFormat ${dataFormat}`);
  }
}
function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {
  if (dimRoundingMode != null) {
    if (typeof pad === "string") {
      throw Error(`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);
    } else if (typeof pad === "number") {
      assert(isInt(pad), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);
    } else if (typeof pad === "object") {
      pad.forEach((p2) => {
        p2.forEach((v) => {
          assert(isInt(v), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);
        });
      });
    } else {
      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);
    }
  }
}
var init_conv_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reshape.js
function reshape_(x, shape) {
  const $x = convertToTensor(x, "x", "reshape", "string_or_numeric");
  const inputs = { x: $x };
  const attrs = { shape };
  return ENGINE.runKernel(Reshape, inputs, attrs);
}
var reshape;
var init_reshape = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  reshape = op({ reshape_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool.js
function avgPool_(x, filterSize, strides, pad, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "avgPool", "float32");
  const dilations = 1;
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in avgPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);
  checkPadOnDimRoundingMode("avgPool", pad, dimRoundingMode);
  const inputs = { x: x4D };
  const attrs = { filterSize, strides, pad, dimRoundingMode };
  let res = ENGINE.runKernel(AvgPool, inputs, attrs);
  res = cast(res, $x.dtype);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var avgPool;
var init_avg_pool = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_cast();
  init_conv_util();
  init_operation();
  init_reshape();
  avgPool = op({ avgPool_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_3d.js
function avgPool3d_(x, filterSize, strides, pad, dimRoundingMode, dataFormat = "NDHWC") {
  const $x = convertToTensor(x, "x", "avgPool3d", "float32");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
  assert(dataFormat === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, ` + `but got dataFormat of ${dataFormat}`);
  assert(typeof strides === "number" && strides > 0 || Array.isArray(strides) && strides[0] > 0 && strides[1] > 0 && strides[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${strides}'`);
  checkPadOnDimRoundingMode("avgPool3d", pad, dimRoundingMode);
  const inputs = { x: x5D };
  const attrs = { filterSize, strides, pad, dimRoundingMode, dataFormat };
  let res = ENGINE.runKernel(AvgPool3D, inputs, attrs);
  res = cast(res, x5D.dtype);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
var avgPool3d;
var init_avg_pool_3d = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_cast();
  init_conv_util();
  init_operation();
  init_reshape();
  avgPool3d = op({ avgPool3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/concat.js
function concat_(tensors, axis = 0) {
  assert(tensors.length >= 1, () => "Pass at least one tensor to concat");
  const $tensors = convertToTensorArray(tensors, "tensors", "concat", "string_or_numeric");
  if ($tensors[0].dtype === "complex64") {
    $tensors.forEach((tensor9) => {
      if (tensor9.dtype !== "complex64") {
        throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${tensor9.dtype}. `);
      }
    });
  }
  if ($tensors.length === 1) {
    return clone($tensors[0]);
  }
  const inputs = $tensors;
  const attr = { axis };
  return ENGINE.runKernel(Concat, inputs, attr);
}
var concat;
var init_concat = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_clone();
  init_operation();
  concat = op({ concat_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/mat_mul.js
function matMul_(a, b, transposeA = false, transposeB = false) {
  let $a = convertToTensor(a, "a", "matMul");
  let $b = convertToTensor(b, "b", "matMul");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  const attrs = { transposeA, transposeB };
  return ENGINE.runKernel(BatchMatMul, inputs, attrs);
}
var matMul;
var init_mat_mul = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  matMul = op({ matMul_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sigmoid.js
function sigmoid_(x) {
  const $x = convertToTensor(x, "x", "sigmoid", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sigmoid, inputs);
}
var sigmoid;
var init_sigmoid = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sigmoid = op({ sigmoid_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/slice.js
function slice_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice", "string_or_numeric");
  if ($x.rank === 0) {
    throw new Error("Slicing scalar is not possible");
  }
  const inputs = { x: $x };
  const attrs = { begin, size };
  return ENGINE.runKernel(Slice, inputs, attrs);
}
var slice;
var init_slice = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  slice = op({ slice_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tanh.js
function tanh_(x) {
  const $x = convertToTensor(x, "x", "tanh", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Tanh, inputs);
}
var tanh2;
var init_tanh = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  tanh2 = op({ tanh_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/basic_lstm_cell.js
function basicLSTMCell_(forgetBias, lstmKernel, lstmBias, data, c, h) {
  const $forgetBias = convertToTensor(forgetBias, "forgetBias", "basicLSTMCell");
  const $lstmKernel = convertToTensor(lstmKernel, "lstmKernel", "basicLSTMCell");
  const $lstmBias = convertToTensor(lstmBias, "lstmBias", "basicLSTMCell");
  const $data = convertToTensor(data, "data", "basicLSTMCell");
  const $c = convertToTensor(c, "c", "basicLSTMCell");
  const $h = convertToTensor(h, "h", "basicLSTMCell");
  const combined = concat([$data, $h], 1);
  const weighted = matMul(combined, $lstmKernel);
  const res = add2(weighted, $lstmBias);
  const batchSize = res.shape[0];
  const sliceCols = res.shape[1] / 4;
  const sliceSize = [batchSize, sliceCols];
  const i = slice(res, [0, 0], sliceSize);
  const j = slice(res, [0, sliceCols], sliceSize);
  const f = slice(res, [0, sliceCols * 2], sliceSize);
  const o = slice(res, [0, sliceCols * 3], sliceSize);
  const newC = add2(mul(sigmoid(i), tanh2(j)), mul($c, sigmoid(add2($forgetBias, f))));
  const newH = mul(tanh2(newC), sigmoid(o));
  return [newC, newH];
}
var basicLSTMCell;
var init_basic_lstm_cell = __esm(() => {
  init_tensor_util_env();
  init_add();
  init_concat();
  init_mat_mul();
  init_mul();
  init_operation();
  init_sigmoid();
  init_slice();
  init_tanh();
  basicLSTMCell = op({ basicLSTMCell_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/batch_to_space_nd.js
function batchToSpaceND_(x, blockShape, crops) {
  const $x = convertToTensor(x, "x", "batchToSpaceND");
  const prod = blockShape.reduce((a, b) => a * b);
  assert($x.rank >= 1 + blockShape.length, () => `input rank is ${$x.rank} but should be > than blockShape.length ${blockShape.length}`);
  assert(crops.length === blockShape.length, () => `crops.length is ${crops.length} but should be equal to blockShape.length  ${blockShape.length}`);
  assert($x.shape[0] % prod === 0, () => `input tensor batch is ${$x.shape[0]} but is not divisible by the product of ` + `the elements of blockShape ${blockShape.join(" * ")} === ${prod}`);
  const inputs = { x: $x };
  const attrs = { blockShape, crops };
  return ENGINE.runKernel(BatchToSpaceND, inputs, attrs);
}
var batchToSpaceND;
var init_batch_to_space_nd = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  batchToSpaceND = op({ batchToSpaceND_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm_util.js
function xAs4D(x) {
  let x4D;
  if (x.rank === 0 || x.rank === 1) {
    x4D = reshape(x, [1, 1, 1, x.size]);
  } else if (x.rank === 2) {
    x4D = reshape(x, [1, 1, x.shape[0], x.shape[1]]);
  } else if (x.rank === 3) {
    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
  } else {
    x4D = x;
  }
  return x4D;
}
var init_batchnorm_util = __esm(() => {
  init_reshape();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm.js
function batchNorm_(x, mean, variance, offset, scale, varianceEpsilon) {
  if (varianceEpsilon == null) {
    varianceEpsilon = 0.001;
  }
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale != null) {
    $scale = convertToTensor(scale, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($mean.rank === $variance.rank, () => "Batch normalization gradient requires mean and variance to have " + "equal ranks.");
  assert($offset == null || $mean.rank === $offset.rank, () => "Batch normalization gradient requires mean and offset to have " + "equal ranks.");
  assert($scale == null || $mean.rank === $scale.rank, () => "Batch normalization gradient requires mean and scale to have " + "equal ranks.");
  const x4D = xAs4D($x);
  const inputs = {
    x: x4D,
    scale: $scale,
    offset: $offset,
    mean: $mean,
    variance: $variance
  };
  const attrs = { varianceEpsilon };
  const res = ENGINE.runKernel(FusedBatchNorm, inputs, attrs);
  return reshape(res, $x.shape);
}
var batchNorm;
var init_batchnorm = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_batchnorm_util();
  init_operation();
  init_reshape();
  batchNorm = op({ batchNorm_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm2d.js
function batchNorm2d_(x, mean, variance, offset, scale, varianceEpsilon) {
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale != null) {
    $scale = convertToTensor(scale, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ` + `${$x.rank}.`);
  assert($mean.rank === 2 || $mean.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but ` + `got rank ${$mean.rank}.`);
  assert($variance.rank === 2 || $variance.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 ` + `but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 2 || $scale.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 ` + `but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 2 || $offset.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 ` + `but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
var batchNorm2d;
var init_batchnorm2d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_batchnorm();
  init_operation();
  batchNorm2d = op({ batchNorm2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm3d.js
function batchNorm3d_(x, mean, variance, offset, scale, varianceEpsilon) {
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale != null) {
    $scale = convertToTensor(scale, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ` + `${$x.rank}.`);
  assert($mean.rank === 3 || $mean.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but ` + `got rank ${$mean.rank}.`);
  assert($variance.rank === 3 || $variance.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 ` + `but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 3 || $scale.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 ` + `but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 3 || $offset.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 ` + `but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
var batchNorm3d;
var init_batchnorm3d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_batchnorm();
  init_operation();
  batchNorm3d = op({ batchNorm3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/batchnorm4d.js
function batchNorm4d_(x, mean, variance, offset, scale, varianceEpsilon) {
  const $x = convertToTensor(x, "x", "batchNorm");
  const $mean = convertToTensor(mean, "mean", "batchNorm");
  const $variance = convertToTensor(variance, "variance", "batchNorm");
  let $scale;
  if (scale != null) {
    $scale = convertToTensor(scale, "scale", "batchNorm");
  }
  let $offset;
  if (offset != null) {
    $offset = convertToTensor(offset, "offset", "batchNorm");
  }
  assert($x.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ` + `${$x.rank}.`);
  assert($mean.rank === 4 || $mean.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but ` + `got rank ${$mean.rank}.`);
  assert($variance.rank === 4 || $variance.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 ` + `but got rank ${$variance.rank}.`);
  if ($scale != null) {
    assert($scale.rank === 4 || $scale.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 ` + `but got rank ${$scale.rank}.`);
  }
  if ($offset != null) {
    assert($offset.rank === 4 || $offset.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 ` + `but got rank ${$offset.rank}.`);
  }
  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);
}
var batchNorm4d;
var init_batchnorm4d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_batchnorm();
  init_operation();
  batchNorm4d = op({ batchNorm4d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/bincount.js
function bincount_(x, weights, size) {
  const $x = convertToTensor(x, "x", "bincount");
  const $weights = convertToTensor(weights, "weights", "bincount");
  assert($x.dtype === "int32", () => `Error in bincount: input ` + `dtype must be int32, but got ${$x.dtype}`);
  assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
  assert($weights.size === $x.size || $weights.size === 0, () => `Error in bincount: weights must have the same size as input or` + `0-length, but got input shape: ${$x.shape}, weights shape: ` + `${$weights.shape}.`);
  const inputs = { x: $x, weights: $weights };
  const attrs = { size };
  return ENGINE.runKernel(Bincount, inputs, attrs);
}
var bincount;
var init_bincount = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  bincount = op({ bincount_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/bitwise_and.js
function bitwiseAnd_(x, y) {
  const $x = convertToTensor(x, "x", "bitwiseAnd");
  const $y = convertToTensor(y, "y", "bitwiseAnd");
  if (!arraysEqual($x.shape, $y.shape)) {
    throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${$x.shape}, y: ${$y.shape}`);
  }
  if ($x.dtype !== "int32" || $y.dtype !== "int32") {
    throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${$x.dtype} and type of y: ${$y.dtype}`);
  }
  const inputs = { a: $x, b: $y };
  return ENGINE.runKernel(BitwiseAnd, inputs);
}
var bitwiseAnd;
var init_bitwise_and = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  bitwiseAnd = op({ bitwiseAnd_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_args.js
function broadcastArgs_(s0, s1) {
  const shape1Input = convertToTensor(s0, "s0", "broadcastArgs", "int32");
  const shape2Input = convertToTensor(s1, "s1", "broadcastArgs", "int32");
  if (shape1Input.rank !== 1) {
    throw new Error("broadcastArgs(): first input must be a vector (rank=1). " + `Has rank ${shape1Input.rank}`);
  }
  if (shape2Input.rank !== 1) {
    throw new Error("broadcastArgs(): second input must be a vector (rank=1). " + `Has rank ${shape2Input.rank}`);
  }
  const inputs = { s0: shape1Input, s1: shape2Input };
  return ENGINE.runKernel(BroadcastArgs, inputs);
}
var broadcastArgs;
var init_broadcast_args = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  broadcastArgs = op({ broadcastArgs_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_to.js
function broadcastTo_(x, shape) {
  let input = convertToTensor(x, "broadcastTo", "x");
  const xShape = input.shape;
  assertNonNegativeIntegerDimensions(shape);
  if (shape.length < input.rank) {
    throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${input.rank}.`);
  }
  if (shape.length > input.rank) {
    const newShape = input.shape.slice();
    while (newShape.length < shape.length) {
      newShape.unshift(1);
    }
    input = reshape(input, newShape);
  }
  const inputShape = input.shape;
  const reps = Array.from(shape);
  for (let i = shape.length - 1;i >= 0; i--) {
    if (inputShape[i] === shape[i]) {
      reps[i] = 1;
    } else if (input.shape[i] !== 1) {
      throw new Error(`broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);
    }
  }
  const axes = reps.map((n, i) => n > 1 ? i : -1).filter((i) => i >= 0);
  if (axes.length === 0) {
    return clone(input);
  }
  const inputs = { x: input };
  const attrs = { reps };
  return ENGINE.runKernel(Tile, inputs, attrs);
}
var broadcastTo;
var init_broadcast_to = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_clone();
  init_operation();
  init_reshape();
  broadcastTo = op({ broadcastTo_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ceil.js
function ceil_(x) {
  const $x = convertToTensor(x, "x", "ceil", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Ceil, inputs);
}
var ceil;
var init_ceil = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  ceil = op({ ceil_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fill.js
function fill(shape, value, dtype) {
  assertNonNegativeIntegerDimensions(shape);
  dtype = dtype || inferDtype(value);
  const attrs = { shape, value, dtype };
  return ENGINE.runKernel(Fill, {}, attrs);
}
var init_fill = __esm(() => {
  init_engine();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/clip_by_value.js
function clipByValue_(x, clipValueMin, clipValueMax) {
  const $x = convertToTensor(x, "x", "clipByValue");
  assert(clipValueMin <= clipValueMax, () => `Error in clip: min (${clipValueMin}) must be ` + `less than or equal to max (${clipValueMax}).`);
  if (clipValueMin === clipValueMax) {
    return fill($x.shape, clipValueMin, $x.dtype);
  }
  const inputs = { x: $x };
  const attrs = { clipValueMin, clipValueMax };
  return ENGINE.runKernel(ClipByValue, inputs, attrs);
}
var clipByValue;
var init_clip_by_value = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_fill();
  init_operation();
  clipByValue = op({ clipByValue_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/concat_1d.js
function concat1d_(tensors) {
  return concat(tensors, 0);
}
var concat1d;
var init_concat_1d = __esm(() => {
  init_concat();
  init_operation();
  concat1d = op({ concat1d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/concat_2d.js
function concat2d_(tensors, axis) {
  return concat(tensors, axis);
}
var concat2d;
var init_concat_2d = __esm(() => {
  init_concat();
  init_operation();
  concat2d = op({ concat2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/concat_3d.js
function concat3d_(tensors, axis) {
  return concat(tensors, axis);
}
var concat3d;
var init_concat_3d = __esm(() => {
  init_concat();
  init_operation();
  concat3d = op({ concat3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/concat_4d.js
function concat4d_(tensors, axis) {
  return concat(tensors, axis);
}
var concat4d;
var init_concat_4d = __esm(() => {
  init_concat();
  init_operation();
  concat4d = op({ concat4d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv2d.js
function conv2d_(x, filter, strides, pad, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
  const $x = convertToTensor(x, "x", "conv2d", "float32");
  const $filter = convertToTensor(filter, "filter", "conv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ` + `${$filter.rank}.`);
  checkPadOnDimRoundingMode("conv2d", pad, dimRoundingMode);
  const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert(inDepth === $filter.shape[2], () => `Error in conv2d: depth of input (${inDepth}) must match ` + `input depth for filter ${$filter.shape[2]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in conv2D: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  assert(stridesOrDilationsArePositive(dilations), () => "Error in conv2D: Dilated rates should be larger than 0.");
  assert(stridesOrDilationsArePositive(strides), () => "Error in conv2D: Strides should be larger than 0.");
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad, dataFormat, dilations, dimRoundingMode };
  const res = ENGINE.runKernel(Conv2D, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var conv2d;
var init_conv2d = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  conv2d = op({ conv2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv1d.js
function conv1d_(x, filter, stride, pad, dataFormat = "NWC", dilation = 1, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "conv1d");
  const $filter = convertToTensor(filter, "filter", "conv1d");
  let x3D = $x;
  let reshapedTo3D = false;
  if ($x.rank === 2) {
    reshapedTo3D = true;
    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);
  }
  assert(x3D.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);
  assert($filter.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ` + `${$filter.rank}.`);
  checkPadOnDimRoundingMode("conv1d", pad, dimRoundingMode);
  assert(x3D.shape[2] === $filter.shape[1], () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` + `input depth for filter ${$filter.shape[1]}.`);
  assert(eitherStridesOrDilationsAreOne(stride, dilation), () => "Error in conv1D: Either stride or dilation must be 1. " + `Got stride ${stride} and dilation '${dilation}'`);
  assert(stridesOrDilationsArePositive(dilation), () => "Error in conv1D: Dilated rates should be larger than 0.");
  assert(stridesOrDilationsArePositive(stride), () => "Error in conv1D: Stride should be larger than 0.");
  assert(dataFormat === "NWC", () => `Error in conv1d: got dataFormat of ${dataFormat} but only NWC is currently supported.`);
  const filter4D = reshape($filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);
  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);
  const strides = [1, stride];
  const dilations = [1, dilation];
  const conv2dDataFormat = "NHWC";
  const res = conv2d(input4D, filter4D, strides, pad, conv2dDataFormat, dilations, dimRoundingMode);
  if (reshapedTo3D) {
    return reshape(res, [res.shape[2], res.shape[3]]);
  }
  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]);
}
var conv1d;
var init_conv1d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_conv2d();
  init_conv_util();
  init_operation();
  init_reshape();
  conv1d = op({ conv1d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_backprop_input.js
function conv2DBackpropInput_(xShape, dy, filter, strides, pad, dataFormat = "NHWC", dimRoundingMode) {
  assert(xShape.length === dy.rank, () => `Length of inShape ` + `(${xShape.length}) and rank of dy (${dy.rank}) must match`);
  let xShape4D = xShape;
  let dy4D = dy;
  let reshapedTo4D = false;
  if (dy.rank === 3) {
    reshapedTo4D = true;
    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);
    xShape4D = [1, xShape[0], xShape[1], xShape[2]];
  }
  assert(xShape4D.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ` + `${xShape4D.length}.`);
  assert(dy4D.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got ` + `rank ${dy4D.rank}`);
  assert(filter.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got ` + `rank ${filter.rank}`);
  const inDepth = dataFormat === "NHWC" ? xShape4D[3] : xShape4D[1];
  const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
  assert(inDepth === filter.shape[2], () => `Error in conv2dDerInput: depth of input (${inDepth}) must ` + `match input depth for filter ${filter.shape[2]}.`);
  assert(outDepth === filter.shape[3], () => `Error in conv2dDerInput: depth of output (${outDepth}) must ` + `match output depth for filter ${filter.shape[3]}.`);
  checkPadOnDimRoundingMode("conv2dDerInput", pad, dimRoundingMode);
  const inputs = { dy: dy4D, filter };
  const attrs = { strides, pad, dataFormat, dimRoundingMode, inputShape: xShape4D };
  const res = ENGINE.runKernel(Conv2DBackpropInput, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var conv2DBackpropInput;
var init_conv2d_backprop_input = __esm(() => {
  init_engine();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  conv2DBackpropInput = op({ conv2DBackpropInput_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_transpose.js
function conv2dTranspose_(x, filter, outputShape, strides, pad, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "conv2dTranspose");
  const $filter = convertToTensor(filter, "filter", "conv2dTranspose");
  return conv2DBackpropInput(outputShape, $x, $filter, strides, pad, "NHWC", dimRoundingMode);
}
var conv2dTranspose;
var init_conv2d_transpose = __esm(() => {
  init_tensor_util_env();
  init_conv2d_backprop_input();
  init_operation();
  conv2dTranspose = op({ conv2dTranspose_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv3d.js
function conv3d_(x, filter, strides, pad, dataFormat = "NDHWC", dilations = [1, 1, 1]) {
  const $x = convertToTensor(x, "x", "conv3d");
  const $filter = convertToTensor(filter, "filter", "conv3d");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);
  assert($filter.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ` + `${$filter.rank}.`);
  assert(x5D.shape[4] === $filter.shape[3], () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match ` + `input depth for filter ${$filter.shape[3]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in conv3D: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  assert(dataFormat === "NDHWC", () => `Error in conv3d: got dataFormat of ${dataFormat} but only NDHWC is currently supported.`);
  assert(stridesOrDilationsArePositive(dilations), () => "Error in conv3D: Dilated rates should be larger than 0.");
  assert(stridesOrDilationsArePositive(strides), () => "Error in conv3D: Strides should be larger than 0.");
  const inputs = { x: x5D, filter: $filter };
  const attrs = { strides, pad, dataFormat, dilations };
  const res = ENGINE.runKernel(Conv3D, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
var conv3d;
var init_conv3d = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  conv3d = op({ conv3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_backprop_input.js
function conv3DBackpropInput_(xShape, dy, filter, strides, pad) {
  assert(xShape.length === dy.rank, () => `Length of inShape ` + `(${xShape.length}) and rank of dy (${dy.rank}) must match`);
  let xShape5D = xShape;
  let dy5D = dy;
  let reshapedTo5D = false;
  if (dy.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);
    xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];
  }
  const inDepth = xShape5D[4];
  const outDepth = dy5D.shape[4];
  assert(xShape5D.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ` + `${xShape5D.length}.`);
  assert(dy5D.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got ` + `rank ${dy5D.rank}`);
  assert(filter.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got ` + `rank ${filter.rank}`);
  assert(inDepth === filter.shape[3], () => `Error in conv3dDerInput: depth of input (${inDepth}) must ` + `match input depth for filter ${filter.shape[3]}.`);
  assert(outDepth === filter.shape[4], () => `Error in conv3dDerInput: depth of output (${outDepth}) must ` + `match output depth for filter ${filter.shape[4]}.`);
  const inputs = { dy: dy5D, filter };
  const attrs = { pad, strides, inputShape: xShape5D };
  const res = ENGINE.runKernel(Conv3DBackpropInputV2, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
var conv3DBackpropInput;
var init_conv3d_backprop_input = __esm(() => {
  init_engine();
  init_util();
  init_operation();
  init_reshape();
  conv3DBackpropInput = op({ conv3DBackpropInput_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_transpose.js
function conv3dTranspose_(x, filter, outputShape, strides, pad) {
  const $x = convertToTensor(x, "x", "conv3dTranspose");
  const $filter = convertToTensor(filter, "filter", "conv3dTranspose");
  return conv3DBackpropInput(outputShape, $x, $filter, strides, pad);
}
var conv3dTranspose;
var init_conv3d_transpose = __esm(() => {
  init_tensor_util_env();
  init_conv3d_backprop_input();
  init_operation();
  conv3dTranspose = op({ conv3dTranspose_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/cos.js
function cos_(x) {
  const $x = convertToTensor(x, "x", "cos", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Cos, inputs);
}
var cos;
var init_cos = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  cos = op({ cos_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/cosh.js
function cosh_(x) {
  const $x = convertToTensor(x, "x", "cosh", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Cosh, inputs);
}
var cosh;
var init_cosh = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  cosh = op({ cosh_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/cumprod.js
function cumprod_(x, axis = 0, exclusive = false, reverse = false) {
  const $x = convertToTensor(x, "x", "cumprod");
  const inputs = { x: $x };
  const attrs = { axis, exclusive, reverse };
  return ENGINE.runKernel(Cumprod, inputs, attrs);
}
var cumprod;
var init_cumprod = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  cumprod = op({ cumprod_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/cumsum.js
function cumsum_(x, axis = 0, exclusive = false, reverse = false) {
  const $x = convertToTensor(x, "x", "cumsum");
  const inputs = { x: $x };
  const attrs = { axis, exclusive, reverse };
  return ENGINE.runKernel(Cumsum, inputs, attrs);
}
var cumsum;
var init_cumsum = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  cumsum = op({ cumsum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/dense_bincount.js
function denseBincount_(x, weights, size, binaryOutput = false) {
  const $x = convertToTensor(x, "x", "denseBincount");
  const $weights = convertToTensor(weights, "weights", "denseBincount");
  assert($x.dtype === "int32", () => `Error in denseBincount: input ` + `dtype must be int32, but got ${$x.dtype}`);
  assert($x.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got ` + `rank ${$x.rank}.`);
  assert(size >= 0, () => `size must be non-negative, but got ${size}.`);
  assert($weights.size === $x.size || $weights.size === 0, () => `Error in denseBincount: weights must have the same shape as x or ` + `0-length, but got x shape: ${$x.shape}, weights shape: ` + `${$weights.shape}.`);
  const inputs = { x: $x, weights: $weights };
  const attrs = { size, binaryOutput };
  return ENGINE.runKernel(DenseBincount, inputs, attrs);
}
var denseBincount;
var init_dense_bincount = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  denseBincount = op({ denseBincount_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/depth_to_space.js
function depthToSpace_(x, blockSize, dataFormat = "NHWC") {
  const $x = convertToTensor(x, "x", "depthToSpace", "float32");
  const inputHeight = dataFormat === "NHWC" ? $x.shape[1] : $x.shape[2];
  const inputWidth = dataFormat === "NHWC" ? $x.shape[2] : $x.shape[3];
  const inputDepth = dataFormat === "NHWC" ? $x.shape[3] : $x.shape[1];
  assert(blockSize > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${blockSize}`);
  assert(inputHeight * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputHeight} and ${blockSize}  for depthToSpace with input shape
    ${$x.shape}`);
  assert(inputWidth * blockSize >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${inputWidth} and ${blockSize} for depthToSpace with input shape
        ${$x.shape}`);
  assert(inputDepth % (blockSize * blockSize) === 0, () => `Dimension size must be evenly divisible by ${blockSize * blockSize} but is ${inputDepth} for depthToSpace with input shape ${$x.shape}`);
  const inputs = { x: $x };
  const attrs = { blockSize, dataFormat };
  return ENGINE.runKernel(DepthToSpace, inputs, attrs);
}
var depthToSpace;
var init_depth_to_space = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  depthToSpace = op({ depthToSpace_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d.js
function depthwiseConv2d_(x, filter, strides, pad, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode) {
  const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
  const $filter = convertToTensor(filter, "filter", "depthwiseConv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got ` + `rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ` + `${$filter.rank}.`);
  const inChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert(inChannels === $filter.shape[2], () => `Error in depthwiseConv2d: number of input channels ` + `(${inChannels}) must match the inChannels dimension in ` + `filter ${$filter.shape[2]}.`);
  checkPadOnDimRoundingMode("depthwiseConv2d", pad, dimRoundingMode);
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad, dataFormat, dilations, dimRoundingMode };
  const res = ENGINE.runKernel(DepthwiseConv2dNative, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var depthwiseConv2d;
var init_depthwise_conv2d = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  depthwiseConv2d = op({ depthwiseConv2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/diag.js
function diag_(x) {
  const $x = convertToTensor(x, "x", "diag");
  const inputs = { x: $x };
  return ENGINE.runKernel(Diag, inputs);
}
var diag;
var init_diag = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  diag = op({ diag_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/dilation2d.js
function dilation2d_(x, filter, strides, pad, dilations = [1, 1], dataFormat = "NHWC") {
  const $x = convertToTensor(x, "x", "dilation2d");
  const $filter = convertToTensor(filter, "filter", "dilation2d");
  assert($x.rank === 3 || $x.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ` + `${$x.rank}.`);
  assert($filter.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ` + `${$filter.rank}.`);
  assert(dataFormat === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, ` + `but got dataFormat of ${dataFormat}`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
    reshapedTo4D = true;
  }
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${x4D.shape[3]} vs ${$filter.shape[2]}`);
  const inputs = { x: x4D, filter: $filter };
  const attrs = { strides, pad, dilations };
  const res = ENGINE.runKernel(Dilation2D, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var dilation2d;
var init_dilation2d = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reshape();
  dilation2d = op({ dilation2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/broadcast_util.js
var exports_broadcast_util = {};
__export(exports_broadcast_util, {
  getReductionAxes: () => getReductionAxes,
  getBroadcastDims: () => getBroadcastDims,
  assertAndGetBroadcastShape: () => assertAndGetBroadcastShape
});
function getBroadcastDims(inShape, outShape) {
  const inRank = inShape.length;
  const dims = [];
  for (let i = 0;i < inRank; i++) {
    const dim = inRank - 1 - i;
    const a = inShape[dim] || 1;
    const b = outShape[outShape.length - 1 - i] || 1;
    if (b > 1 && a === 1) {
      dims.unshift(dim);
    }
  }
  return dims;
}
function getReductionAxes(inShape, outShape) {
  const result = [];
  for (let i = 0;i < outShape.length; i++) {
    const inDim = inShape[inShape.length - i - 1];
    const outAxis = outShape.length - i - 1;
    const outDim = outShape[outAxis];
    if (inDim == null || inDim === 1 && outDim > 1) {
      result.unshift(outAxis);
    }
  }
  return result;
}
function assertAndGetBroadcastShape(shapeA, shapeB) {
  const l = Math.max(shapeA.length, shapeB.length);
  const result = new Array(l);
  for (let i = 0;i < l; i++) {
    let a = shapeA[shapeA.length - i - 1];
    if (a == null) {
      a = 1;
    }
    let b = shapeB[shapeB.length - i - 1];
    if (b == null) {
      b = 1;
    }
    if (a === 1) {
      result[l - i - 1] = b;
    } else if (b === 1) {
      result[l - i - 1] = a;
    } else if (a !== b) {
      const errMsg = `Operands could not be broadcast together with shapes ` + `${shapeA} and ${shapeB}.`;
      throw Error(errMsg);
    } else {
      result[l - i - 1] = a;
    }
  }
  return result;
}

// node_modules/@tensorflow/tfjs-core/dist/ops/equal.js
function equal_(a, b) {
  let $a = convertToTensor(a, "a", "equal", "string_or_numeric");
  let $b = convertToTensor(b, "b", "equal", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Equal, inputs);
}
var equal;
var init_equal = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  equal = op({ equal_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/where.js
function where_(condition, a, b) {
  const $a = convertToTensor(a, "a", "where");
  const $b = convertToTensor(b, "b", "where");
  const $condition = convertToTensor(condition, "condition", "where", "bool");
  const broadcastShape = assertAndGetBroadcastShape(assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);
  const $broadcastedCondition = broadcastTo($condition, broadcastShape);
  const $broadcastedA = broadcastTo($a, broadcastShape);
  const $broadcastedB = broadcastTo($b, broadcastShape);
  const inputs = {
    condition: $broadcastedCondition,
    t: $broadcastedA,
    e: $broadcastedB
  };
  return ENGINE.runKernel(Select, inputs);
}
var where;
var init_where = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_broadcast_to();
  init_operation();
  where = op({ where_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/zeros_like.js
function zerosLike_(x) {
  const $x = convertToTensor(x, "x", "zerosLike");
  const inputs = { x: $x };
  return ENGINE.runKernel(ZerosLike, inputs);
}
var zerosLike;
var init_zeros_like = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  zerosLike = op({ zerosLike_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/div_no_nan.js
function divNoNan_(a, b) {
  let $a = convertToTensor(a, "a", "div");
  let $b = convertToTensor(b, "b", "div");
  [$a, $b] = makeTypesMatch($a, $b);
  const divResult = div($a, $b);
  const zeros = zerosLike(divResult);
  const bEqualsZero = equal($b, zeros);
  return where(bEqualsZero, zeros, divResult);
}
var divNoNan;
var init_div_no_nan = __esm(() => {
  init_tensor_util();
  init_tensor_util_env();
  init_div();
  init_equal();
  init_operation();
  init_where();
  init_zeros_like();
  divNoNan = op({ divNoNan_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/dot.js
function dot_(t1, t2) {
  const $t1 = convertToTensor(t1, "t1", "dot");
  const $t2 = convertToTensor(t2, "t2", "dot");
  assert(($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ` + `${$t1.rank} and ${$t2.rank}.`);
  const t1Inner = $t1.rank === 1 ? $t1.size : $t1.shape[1];
  const t2Inner = $t2.rank === 1 ? $t2.size : $t2.shape[0];
  assert(t1Inner === t2Inner, () => `Error in dot: inner dimensions of inputs must match, but got ` + `${t1Inner} and ${t2Inner}.`);
  if ($t1.rank === 1 && $t2.rank === 1) {
    const t12D = reshape($t1, [1, -1]);
    const t22D = reshape($t2, [-1, 1]);
    const t1t2 = matMul(t12D, t22D);
    return reshape(t1t2, []);
  } else if ($t1.rank === 1 && $t2.rank === 2) {
    const t12D = reshape($t1, [1, -1]);
    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
    const t1t2 = matMul(t12D, t22D);
    return reshape(t1t2, [t1t2.size]);
  } else if ($t1.rank === 2 && $t2.rank === 1) {
    const t22D = reshape($t2, [-1, 1]);
    const t1t2 = matMul($t1, t22D);
    return reshape(t1t2, [t1t2.size]);
  } else {
    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);
    const t1t2 = matMul($t1, t22D);
    return t1t2;
  }
}
var dot;
var init_dot = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_mat_mul();
  init_operation();
  init_reshape();
  dot = op({ dot_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/einsum.js
function einsum_(equation, ...tensors) {
  const $tensors = tensors.map((t, i) => convertToTensor(t, `tensors${i}`, "einsum"));
  const attrs = { equation };
  return ENGINE.runKernel(Einsum, $tensors, attrs);
}
var einsum;
var init_einsum = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  einsum = op({ einsum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/elu.js
function elu_(x) {
  const $x = convertToTensor(x, "x", "elu", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Elu, inputs);
}
var elu;
var init_elu = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  elu = op({ elu_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ensure_shape.js
function ensureShape_(x, shape) {
  const $x = convertToTensor(x, "x", "ensureShape", "string_or_numeric");
  if (!arraysEqualWithNull($x.shape, shape)) {
    throw new Error(`EnsureShape: Shape of tensor ${$x.shape} is not compatible with expected shape ${shape}`);
  }
  return x;
}
var ensureShape;
var init_ensure_shape = __esm(() => {
  init_tensor_util_env();
  init_operation();
  ensureShape = op({ ensureShape_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/erf.js
function erf_(x) {
  let $x = convertToTensor(x, "x", "erf");
  assert($x.dtype === "int32" || $x.dtype === "float32", () => "Input dtype must be `int32` or `float32`.");
  if ($x.dtype === "int32") {
    $x = cast($x, "float32");
  }
  const inputs = { x: $x };
  return ENGINE.runKernel(Erf, inputs);
}
var erf;
var init_erf = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_cast();
  init_operation();
  erf = op({ erf_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/axis_util.js
function axesAreInnerMostDims(axes, rank) {
  for (let i = 0;i < axes.length; ++i) {
    if (axes[axes.length - i - 1] !== rank - 1 - i) {
      return false;
    }
  }
  return true;
}
function combineLocations(outputLoc, reduceLoc, axes) {
  const rank = outputLoc.length + reduceLoc.length;
  const loc = [];
  let outIdx = 0;
  let reduceIdx = 0;
  for (let dim = 0;dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      loc.push(outputLoc[outIdx++]);
    } else {
      loc.push(reduceLoc[reduceIdx++]);
    }
  }
  return loc;
}
function computeOutAndReduceShapes(aShape, axes) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0;dim < rank; dim++) {
    if (axes.indexOf(dim) === -1) {
      outShape.push(aShape[dim]);
    }
  }
  const reduceShape = axes.map((dim) => aShape[dim]);
  return [outShape, reduceShape];
}
function expandShapeToKeepDim(shape, axes) {
  const reduceSubShape = axes.map((x) => 1);
  return combineLocations(shape, reduceSubShape, axes);
}
function assertAxesAreInnerMostDims(msg, axes, rank) {
  assert(axesAreInnerMostDims(axes, rank), () => `${msg} supports only inner-most axes for now. ` + `Got axes ${axes} and rank-${rank} input.`);
}
function getAxesPermutation(axes, rank) {
  if (axesAreInnerMostDims(axes, rank)) {
    return null;
  }
  const result = [];
  for (let i = 0;i < rank; ++i) {
    if (axes.indexOf(i) === -1) {
      result.push(i);
    }
  }
  axes.forEach((axis) => result.push(axis));
  return result;
}
function getUndoAxesPermutation(axes) {
  return axes.map((axis, i) => [i, axis]).sort((a, b) => a[1] - b[1]).map((x) => x[0]);
}
function getInnerMostAxes(numAxes, rank) {
  const res = [];
  for (let i = rank - numAxes;i < rank; ++i) {
    res.push(i);
  }
  return res;
}
var init_axis_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/max.js
function max_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "max");
  const inputs = { x: $x };
  const attrs = { reductionIndices: axis, keepDims };
  return ENGINE.runKernel(Max, inputs, attrs);
}
var max;
var init_max = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  max = op({ max_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/min.js
function min_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "min");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Min, inputs, attrs);
}
var min;
var init_min = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  min = op({ min_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pow.js
function pow_(base, exp) {
  let $base = convertToTensor(base, "base", "pow");
  let $exp = convertToTensor(exp, "exp", "pow");
  [$base, $exp] = makeTypesMatch($base, $exp);
  const inputs = { a: $base, b: $exp };
  return ENGINE.runKernel(Pow, inputs);
}
var pow;
var init_pow = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  pow = op({ pow_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/scalar.js
function scalar(value, dtype) {
  if ((isTypedArray(value) && dtype !== "string" || Array.isArray(value)) && dtype !== "complex64") {
    throw new Error("Error creating a new Scalar: value must be a primitive " + "(number|boolean|string)");
  }
  if (dtype === "string" && isTypedArray(value) && !(value instanceof Uint8Array)) {
    throw new Error("When making a scalar from encoded string, " + "the value must be `Uint8Array`.");
  }
  const shape = [];
  const inferredShape = [];
  return makeTensor(value, shape, inferredShape, dtype);
}
var init_scalar = __esm(() => {
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sqrt.js
function sqrt_(x) {
  const $x = convertToTensor(x, "x", "sqrt", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sqrt, inputs);
}
var sqrt;
var init_sqrt = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sqrt = op({ sqrt_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/square.js
function square_(x) {
  const $x = convertToTensor(x, "x", "square");
  const attrs = {};
  return ENGINE.runKernel("Square", { x: $x }, attrs);
}
var square;
var init_square = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  square = op({ square_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sum.js
function sum_(x, axis = null, keepDims = false) {
  let $x = convertToTensor(x, "x", "sum");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Sum, inputs, attrs);
}
var sum2;
var init_sum = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_cast();
  init_operation();
  sum2 = op({ sum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/norm.js
function norm_(x, ord = "euclidean", axis = null, keepDims = false) {
  x = convertToTensor(x, "x", "norm");
  const norm = normImpl(x, ord, axis);
  let keepDimsShape = norm.shape;
  if (keepDims) {
    const axes = parseAxisParam(axis, x.shape);
    keepDimsShape = expandShapeToKeepDim(norm.shape, axes);
  }
  return reshape(norm, keepDimsShape);
}
function normImpl(x, p2, axis = null) {
  if (x.rank === 0) {
    return abs(x);
  }
  if (x.rank !== 1 && axis === null) {
    return normImpl(reshape(x, [-1]), p2, axis);
  }
  if (x.rank === 1 || typeof axis === "number" || Array.isArray(axis) && axis.length === 1) {
    if (p2 === 1) {
      return sum2(abs(x), axis);
    }
    if (p2 === Infinity) {
      return max(abs(x), axis);
    }
    if (p2 === -Infinity) {
      return min(abs(x), axis);
    }
    if (p2 === "euclidean" || p2 === 2) {
      return sqrt(sum2(pow(abs(x), scalar(2, "int32")), axis));
    }
    throw new Error(`Error in norm: invalid ord value: ${p2}`);
  }
  if (Array.isArray(axis) && axis.length === 2) {
    if (p2 === 1) {
      return max(sum2(abs(x), axis[0]), axis[1] - 1);
    }
    if (p2 === Infinity) {
      return max(sum2(abs(x), axis[1]), axis[0]);
    }
    if (p2 === -Infinity) {
      return min(sum2(abs(x), axis[1]), axis[0]);
    }
    if (p2 === "fro" || p2 === "euclidean") {
      return sqrt(sum2(square(x), axis));
    }
    throw new Error(`Error in norm: invalid ord value: ${p2}`);
  }
  throw new Error(`Error in norm: invalid axis: ${axis}`);
}
var norm;
var init_norm = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_abs();
  init_axis_util();
  init_max();
  init_min();
  init_operation();
  init_pow();
  init_reshape();
  init_scalar();
  init_sqrt();
  init_square();
  init_sum();
  norm = op({ norm_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/euclidean_norm.js
function euclideanNorm_(x, axis = null, keepDims = false) {
  return norm(x, "euclidean", axis, keepDims);
}
var euclideanNorm;
var init_euclidean_norm = __esm(() => {
  init_norm();
  init_operation();
  euclideanNorm = op({ euclideanNorm_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/exp.js
function exp_(x) {
  const $x = convertToTensor(x, "x", "exp");
  const inputs = { x: $x };
  return ENGINE.runKernel(Exp, inputs);
}
var exp;
var init_exp = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  exp = op({ exp_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/expand_dims.js
function expandDims_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "expandDims", "string_or_numeric");
  assert(axis <= $x.rank, () => "Axis must be <= rank of the tensor");
  const inputs = { input: $x };
  const attrs = { dim: axis };
  return ENGINE.runKernel(ExpandDims, inputs, attrs);
}
var expandDims;
var init_expand_dims = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  expandDims = op({ expandDims_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/expm1.js
function expm1_(x) {
  const $x = convertToTensor(x, "x", "expm1");
  const inputs = { x: $x };
  return ENGINE.runKernel(Expm1, inputs);
}
var expm1;
var init_expm1 = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  expm1 = op({ expm1_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tile.js
function tile_(x, reps) {
  const $x = convertToTensor(x, "x", "tile", "string_or_numeric");
  assert($x.rank === reps.length, () => `Error in transpose: rank of input ${$x.rank} ` + `must match length of reps ${reps}.`);
  const inputs = { x: $x };
  const attrs = { reps };
  return ENGINE.runKernel(Tile, inputs, attrs);
}
var tile;
var init_tile = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  tile = op({ tile_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/eye.js
function eye_(numRows, numColumns, batchShape, dtype = "float32") {
  if (numColumns == null) {
    numColumns = numRows;
  }
  const buff = buffer([numRows, numColumns], dtype);
  const n = numRows <= numColumns ? numRows : numColumns;
  for (let i = 0;i < n; ++i) {
    buff.set(1, i, i);
  }
  const out = reshape(buff.toTensor(), [numRows, numColumns]);
  if (batchShape == null) {
    return out;
  } else {
    if (batchShape.length === 1) {
      return tile(expandDims(out, 0), [batchShape[0], 1, 1]);
    } else if (batchShape.length === 2) {
      return tile(expandDims(expandDims(out, 0), 0), [batchShape[0], batchShape[1], 1, 1]);
    } else if (batchShape.length === 3) {
      return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [
        batchShape[0],
        batchShape[1],
        batchShape[2],
        1,
        1
      ]);
    } else {
      throw new Error(`eye() currently supports only 1D and 2D ` + `batchShapes, but received ${batchShape.length}D.`);
    }
  }
}
var eye;
var init_eye = __esm(() => {
  init_buffer();
  init_expand_dims();
  init_operation();
  init_reshape();
  init_tile();
  eye = op({ eye_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/floor.js
function floor_(x) {
  const $x = convertToTensor(x, "x", "floor", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Floor, inputs);
}
var floor;
var init_floor = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  floor = op({ floor_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/gather.js
function gather_(x, indices, axis = 0, batchDims = 0) {
  const $x = convertToTensor(x, "x", "gather");
  const $indices = convertToTensor(indices, "indices", "gather", "int32");
  const inputs = { x: $x, indices: $indices };
  const attrs = { axis, batchDims };
  return ENGINE.runKernel(GatherV2, inputs, attrs);
}
var gather;
var init_gather = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  gather = op({ gather_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/greater.js
function greater_(a, b) {
  let $a = convertToTensor(a, "a", "greater", "string_or_numeric");
  let $b = convertToTensor(b, "b", "greater", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Greater, inputs);
}
var greater;
var init_greater = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  greater = op({ greater_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/greater_equal.js
function greaterEqual_(a, b) {
  let $a = convertToTensor(a, "a", "greaterEqual", "string_or_numeric");
  let $b = convertToTensor(b, "b", "greaterEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(GreaterEqual, inputs);
}
var greaterEqual;
var init_greater_equal = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  greaterEqual = op({ greaterEqual_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/imag.js
function imag_(input) {
  const $input = convertToTensor(input, "input", "imag");
  const inputs = { input: $input };
  return ENGINE.runKernel(Imag, inputs);
}
var imag;
var init_imag = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  imag = op({ imag_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/is_finite.js
function isFinite_(x) {
  const $x = convertToTensor(x, "x", "isFinite");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsFinite, inputs);
}
var isFinite2;
var init_is_finite = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  isFinite2 = op({ isFinite_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/is_inf.js
function isInf_(x) {
  const $x = convertToTensor(x, "x", "isInf");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsInf, inputs);
}
var isInf;
var init_is_inf = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  isInf = op({ isInf_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/is_nan.js
function isNaN_(x) {
  const $x = convertToTensor(x, "x", "isNaN");
  const inputs = { x: $x };
  return ENGINE.runKernel(IsNan, inputs);
}
var isNaN2;
var init_is_nan = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  isNaN2 = op({ isNaN_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/leaky_relu.js
function leakyRelu_(x, alpha = 0.2) {
  const $x = convertToTensor(x, "x", "leakyRelu");
  const inputs = { x: $x };
  const attrs = { alpha };
  return ENGINE.runKernel(LeakyRelu, inputs, attrs);
}
var leakyRelu;
var init_leaky_relu = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  leakyRelu = op({ leakyRelu_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/less.js
function less_(a, b) {
  let $a = convertToTensor(a, "a", "less", "string_or_numeric");
  let $b = convertToTensor(b, "b", "less", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Less, inputs);
}
var less;
var init_less = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  less = op({ less_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/less_equal.js
function lessEqual_(a, b) {
  let $a = convertToTensor(a, "a", "lessEqual", "string_or_numeric");
  let $b = convertToTensor(b, "b", "lessEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LessEqual, inputs);
}
var lessEqual;
var init_less_equal = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  lessEqual = op({ lessEqual_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/linspace.js
function linspace(start, stop, num) {
  if (num <= 0) {
    throw new Error("The number of values should be positive.");
  }
  const attrs = { start, stop, num };
  return ENGINE.runKernel(LinSpace, {}, attrs);
}
var init_linspace = __esm(() => {
  init_engine();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/local_response_normalization.js
function localResponseNormalization_(x, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
  const $x = convertToTensor(x, "x", "localResponseNormalization");
  assert($x.rank === 4 || $x.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${$x.rank}.`);
  assert(isInt(depthRadius), () => `Error in localResponseNormalization: depthRadius must be an ` + `integer but got depthRadius ${depthRadius}.`);
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  const inputs = { x: x4D };
  const attrs = { depthRadius, bias, alpha, beta };
  const res = ENGINE.runKernel(LRN, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  } else {
    return res;
  }
}
var localResponseNormalization;
var init_local_response_normalization = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reshape();
  localResponseNormalization = op({ localResponseNormalization_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/log.js
function log_(x) {
  const $x = convertToTensor(x, "x", "log", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Log, inputs);
}
var log2;
var init_log2 = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  log2 = op({ log_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/log1p.js
function log1p_(x) {
  const $x = convertToTensor(x, "x", "log1p");
  const inputs = { x: $x };
  return ENGINE.runKernel(Log1p, inputs);
}
var log1p;
var init_log1p = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  log1p = op({ log1p_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients.js
function grad(f) {
  assert(isFunction(f), () => "The f passed in grad(f) must be a function");
  return (x, dy) => {
    const $x = convertToTensor(x, "x", "tf.grad", "string_or_numeric");
    const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grad") : null;
    return ENGINE.tidy(() => {
      const { value, grads } = ENGINE.gradients(() => f($x), [$x], $dy);
      if ($dy != null) {
        assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape " + "returned by f(x)");
      }
      checkGrads(grads);
      return grads[0];
    });
  };
}
function grads(f) {
  assert(isFunction(f), () => "The f passed in grads(f) must be a function");
  return (args, dy) => {
    assert(Array.isArray(args), () => "The args passed in grads(f)(args) must be an array " + "of `Tensor`s or `TensorLike`s");
    const $args = convertToTensorArray(args, "args", "tf.grads", "string_or_numeric");
    const $dy = dy != null ? convertToTensor(dy, "dy", "tf.grads") : null;
    return ENGINE.tidy(() => {
      const { value, grads: grads2 } = ENGINE.gradients(() => f(...$args), $args, $dy);
      if ($dy != null) {
        assertShapesMatch(value.shape, $dy.shape, "The shape of dy passed in grads(f)([x1,...], dy) must " + "match the shape returned by f([x1,...])");
      }
      checkGrads(grads2);
      return grads2;
    });
  };
}
function valueAndGrad(f) {
  assert(isFunction(f), () => "The f passed in valueAndGrad(f) must be a function");
  return (x, dy) => {
    assert(x instanceof Tensor, () => "The x passed in valueAndGrad(f)(x) must be a tensor");
    assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
    const { grads: grads2, value } = ENGINE.gradients(() => f(x), [x], dy);
    checkGrads(grads2);
    return { grad: grads2[0], value };
  };
}
function valueAndGrads(f) {
  assert(isFunction(f), () => "The f passed in valueAndGrads(f) must be a function");
  return (args, dy) => {
    assert(Array.isArray(args) && args.every((arg) => arg instanceof Tensor), () => "The args passed in valueAndGrads(f)(args) must be array of " + "tensors");
    assert(dy == null || dy instanceof Tensor, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
    const res = ENGINE.gradients(() => f(...args), args, dy);
    if (dy != null) {
      assertShapesMatch(res.value.shape, dy.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must " + "match the shape returned by f([x1,...])");
    }
    checkGrads(res.grads);
    return res;
  };
}
function variableGrads(f, varList) {
  assert(isFunction(f), () => "The f passed in variableGrads(f) must be a function");
  assert(varList == null || Array.isArray(varList) && varList.every((v) => v instanceof Variable), () => "The varList passed in variableGrads(f, varList) must be an array " + "of variables");
  const specifiedVarList = varList != null;
  if (!specifiedVarList) {
    varList = [];
    for (const varName in ENGINE.registeredVariables) {
      varList.push(ENGINE.registeredVariables[varName]);
    }
  }
  const specifiedNonTrainable = specifiedVarList ? varList.filter((variable) => !variable.trainable) : null;
  const originalVarCount = varList.length;
  varList = varList.filter((variable) => variable.trainable);
  assert(varList.length > 0, () => `variableGrads() expects at least one of the input variables to ` + `be trainable, but none of the ${originalVarCount} variables is ` + `trainable.`);
  const allowNoGradients = true;
  const { value, grads: grads2 } = ENGINE.gradients(f, varList, null, allowNoGradients);
  assert(grads2.some((g) => g != null), () => "Cannot find a connection between any variable and the result of " + "the loss function y=f(x). Please make sure the operations that " + "use variables are inside the function f passed to minimize().");
  assert(value.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it ` + `returned a rank-${value.rank} tensor`);
  const namedGrads = {};
  varList.forEach((v, i) => {
    if (grads2[i] != null) {
      namedGrads[v.name] = grads2[i];
    }
  });
  if (specifiedNonTrainable != null) {
    specifiedNonTrainable.forEach((v) => namedGrads[v.name] = null);
  }
  return { value, grads: namedGrads };
}
function customGrad(f) {
  return ENGINE.customGrad(f);
}
function checkGrads(grads2) {
  const numNullGradients = grads2.filter((g) => g == null).length;
  if (numNullGradients > 0) {
    throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
  }
}
var init_gradients = __esm(() => {
  init_engine();
  init_tensor();
  init_tensor_util_env();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/neg.js
function neg_(x) {
  const $x = convertToTensor(x, "x", "neg");
  const inputs = { x: $x };
  return ENGINE.runKernel(Neg, inputs);
}
var neg;
var init_neg = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  neg = op({ neg_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/softplus.js
function softplus_(x) {
  const $x = convertToTensor(x, "x", "softplus");
  const inputs = { x: $x };
  return ENGINE.runKernel(Softplus, inputs);
}
var softplus;
var init_softplus = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  softplus = op({ softplus_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/log_sigmoid.js
function logSigmoid_(x) {
  const $x = convertToTensor(x, "x", "logSigmoid");
  const customOp = customGrad((x2) => {
    const value = neg(softplus(neg(x2)));
    const gradFunc = (dy) => {
      const derX = mul(dy, sigmoid(neg(x2)));
      return derX;
    };
    return { value, gradFunc };
  });
  return customOp($x);
}
var logSigmoid;
var init_log_sigmoid = __esm(() => {
  init_gradients();
  init_tensor_util_env();
  init_mul();
  init_neg();
  init_operation();
  init_sigmoid();
  init_softplus();
  logSigmoid = op({ logSigmoid_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sub.js
function sub_(a, b) {
  let $a = convertToTensor(a, "a", "sub");
  let $b = convertToTensor(b, "b", "sub");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Sub, inputs);
}
var sub;
var init_sub = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  sub = op({ sub_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/log_softmax.js
function logSoftmax_(logits, axis = -1) {
  const $logits = convertToTensor(logits, "logits", "logSoftmax");
  if (axis === -1) {
    axis = $logits.rank - 1;
  }
  if (axis !== $logits.rank - 1) {
    throw Error("Log Softmax along a non-last dimension is not yet supported. " + `Logits was rank ${$logits.rank} and axis was ${axis}`);
  }
  const customOp = customGrad((logits2, save) => {
    const keepDims = true;
    const xMax = max(logits2, axis, true);
    const shifted = sub(logits2, xMax);
    const value = sub(cast(shifted, "float32"), log2(sum2(exp(shifted), axis, keepDims)));
    save([value]);
    const gradFunc = (dy, saved) => {
      const [value2] = saved;
      const keepDims2 = true;
      const softmax = exp(value2);
      return sub(dy, mul(sum2(dy, axis, keepDims2), softmax));
    };
    return { value, gradFunc };
  });
  return customOp($logits);
}
var logSoftmax;
var init_log_softmax = __esm(() => {
  init_gradients();
  init_tensor_util_env();
  init_cast();
  init_exp();
  init_log2();
  init_max();
  init_mul();
  init_operation();
  init_sub();
  init_sum();
  logSoftmax = op({ logSoftmax_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/log_sum_exp.js
function logSumExp_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "logSumExp");
  const axes = parseAxisParam(axis, $x.shape);
  const xMax = max($x, axes, true);
  const a = sub($x, xMax);
  const b = exp(a);
  const c = sum2(b, axes);
  const d = log2(c);
  const res = add2(reshape(xMax, d.shape), d);
  if (keepDims) {
    const newShape = expandShapeToKeepDim(res.shape, axes);
    return reshape(res, newShape);
  }
  return res;
}
var logSumExp;
var init_log_sum_exp = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_add();
  init_axis_util();
  init_exp();
  init_log2();
  init_max();
  init_operation();
  init_reshape();
  init_sub();
  init_sum();
  logSumExp = op({ logSumExp_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/logical_and.js
function logicalAnd_(a, b) {
  const $a = convertToTensor(a, "a", "logicalAnd", "bool");
  const $b = convertToTensor(b, "b", "logicalAnd", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LogicalAnd, inputs);
}
var logicalAnd;
var init_logical_and = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  logicalAnd = op({ logicalAnd_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/logical_not.js
function logicalNot_(x) {
  const $x = convertToTensor(x, "x", "logicalNot", "bool");
  const inputs = { x: $x };
  return ENGINE.runKernel(LogicalNot, inputs);
}
var logicalNot;
var init_logical_not = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  logicalNot = op({ logicalNot_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/logical_or.js
function logicalOr_(a, b) {
  const $a = convertToTensor(a, "a", "logicalOr", "bool");
  const $b = convertToTensor(b, "b", "logicalOr", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(LogicalOr, inputs);
}
var logicalOr;
var init_logical_or = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  logicalOr = op({ logicalOr_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/logical_xor.js
function logicalXor_(a, b) {
  const $a = convertToTensor(a, "a", "logicalXor", "bool");
  const $b = convertToTensor(b, "b", "logicalXor", "bool");
  assertAndGetBroadcastShape($a.shape, $b.shape);
  return logicalAnd(logicalOr(a, b), logicalNot(logicalAnd(a, b)));
}
var logicalXor;
var init_logical_xor = __esm(() => {
  init_tensor_util_env();
  init_logical_and();
  init_logical_not();
  init_logical_or();
  init_operation();
  logicalXor = op({ logicalXor_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/search_sorted.js
function searchSorted_(sortedSequence, values, side = "left") {
  const $sortedSequence = convertToTensor(sortedSequence, "sortedSequence", "searchSorted");
  const $values = convertToTensor(values, "values", "searchSorted");
  const sequenceSize = $sortedSequence.shape[$sortedSequence.shape.length - 1];
  const valuesSize = $values.shape[$values.shape.length - 1];
  const $sortedSequence2D = reshape($sortedSequence, [-1, sequenceSize]);
  const $values2D = reshape($values, [-1, valuesSize]);
  if ($sortedSequence2D.rank < 2) {
    throw new Error(`Sorted input argument must be at least 2-dimensional`);
  }
  if ($sortedSequence2D.shape[0] !== $values2D.shape[0]) {
    throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);
  }
  if (sizeFromShape($values2D.shape) >= INT32_MAX) {
    throw new Error(`values tensor size must less than ${INT32_MAX}`);
  }
  if ($sortedSequence2D.shape[1] >= INT32_MAX) {
    throw new Error(`trailing dim_size must less than ${INT32_MAX} for int32 output type, was ${$sortedSequence2D.shape[1]}`);
  }
  const inputs = {
    sortedSequence: $sortedSequence2D,
    values: $values2D
  };
  const attrs = { side };
  return ENGINE.runKernel(SearchSorted, inputs, attrs);
}
var INT32_MAX = 2147483648, searchSorted;
var init_search_sorted = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  init_reshape();
  searchSorted = op({ searchSorted_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/lower_bound.js
function lowerBound(sortedSequence, values) {
  return searchSorted(sortedSequence, values, "left");
}
var init_lower_bound = __esm(() => {
  init_search_sorted();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/max_pool.js
function maxPool_(x, filterSize, strides, pad, dimRoundingMode) {
  const $x = convertToTensor(x, "x", "maxPool");
  const dilations = 1;
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  checkPadOnDimRoundingMode("maxPool", pad, dimRoundingMode);
  const inputs = { x: x4D };
  const attrs = { filterSize, strides, pad, dimRoundingMode };
  const res = ENGINE.runKernel(MaxPool, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var maxPool;
var init_max_pool = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  maxPool = op({ maxPool_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_3d.js
function maxPool3d_(x, filterSize = [1, 1, 1], strides, pad, dimRoundingMode, dataFormat = "NDHWC") {
  const $x = convertToTensor(x, "x", "maxPool3d");
  let x5D = $x;
  let reshapedTo5D = false;
  if ($x.rank === 4) {
    reshapedTo5D = true;
    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);
  assert(dataFormat === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, ` + `but got dataFormat of ${dataFormat}`);
  checkPadOnDimRoundingMode("maxPool3d", pad, dimRoundingMode);
  const inputs = { x: x5D };
  const attrs = { filterSize, strides, pad, dimRoundingMode, dataFormat };
  const res = ENGINE.runKernel(MaxPool3D, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
var maxPool3d;
var init_max_pool_3d = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  maxPool3d = op({ maxPool3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_with_argmax.js
function maxPoolWithArgmax_(x, filterSize, strides, pad, includeBatchInIndex = false) {
  const $x = convertToTensor(x, "x", "maxPoolWithArgmax");
  const inputs = { x: $x };
  const attrs = { filterSize, strides, pad, includeBatchInIndex };
  const result = ENGINE.runKernel(MaxPoolWithArgmax, inputs, attrs);
  return { result: result[0], indexes: result[1] };
}
var maxPoolWithArgmax;
var init_max_pool_with_argmax = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  maxPoolWithArgmax = op({ maxPoolWithArgmax_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/maximum.js
function maximum_(a, b) {
  let $a = convertToTensor(a, "a", "maximum");
  let $b = convertToTensor(b, "b", "maximum");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "bool") {
    $a = cast($a, "int32");
    $b = cast($b, "int32");
  }
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Maximum, inputs);
}
var maximum;
var init_maximum = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_cast();
  init_operation();
  maximum = op({ maximum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/mean.js
function mean_(x, axis = null, keepDims = false) {
  const $x = convertToTensor(x, "x", "mean");
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Mean, inputs, attrs);
}
var mean;
var init_mean = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  mean = op({ mean_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/zeros.js
function zeros(shape, dtype = "float32") {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype === "complex64") {
    const real = zeros(shape, "float32");
    const imag2 = zeros(shape, "float32");
    return complex(real, imag2);
  }
  const values = makeZerosTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
var init_zeros = __esm(() => {
  init_engine();
  init_util();
  init_complex();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ones.js
function ones2(shape, dtype = "float32") {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype === "complex64") {
    const real = ones2(shape, "float32");
    const imag2 = zeros(shape, "float32");
    return complex(real, imag2);
  }
  const values = makeOnesTypedArray(sizeFromShape(shape), dtype);
  return ENGINE.makeTensor(values, shape, dtype);
}
var init_ones = __esm(() => {
  init_engine();
  init_util();
  init_complex();
  init_zeros();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/meshgrid.js
function meshgrid(x, y, { indexing = "xy" } = {}) {
  if (indexing !== "xy" && indexing !== "ij") {
    throw new TypeError(`${indexing} is not a valid third argument to meshgrid`);
  }
  if (x === undefined) {
    return [];
  }
  let $x = convertToTensor(x, "x", "meshgrid", x instanceof Tensor ? x.dtype : "float32");
  if (y === undefined) {
    return [$x];
  }
  let $y = convertToTensor(y, "y", "meshgrid", y instanceof Tensor ? y.dtype : "float32");
  const w = sizeFromShape($x.shape);
  const h = sizeFromShape($y.shape);
  if (indexing === "xy") {
    $x = reshape($x, [1, -1]);
    $y = reshape($y, [-1, 1]);
    return [
      matMul(ones2([h, 1], $x.dtype), $x),
      matMul($y, ones2([1, w], $y.dtype))
    ];
  }
  $x = reshape($x, [-1, 1]);
  $y = reshape($y, [1, -1]);
  return [
    matMul($x, ones2([1, h], $x.dtype)),
    matMul(ones2([w, 1], $y.dtype), $y)
  ];
}
var init_meshgrid = __esm(() => {
  init_mat_mul();
  init_ones();
  init_reshape();
  init_tensor();
  init_tensor_util_env();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/minimum.js
function minimum_(a, b) {
  let $a = convertToTensor(a, "a", "minimum");
  let $b = convertToTensor(b, "b", "minimum");
  [$a, $b] = makeTypesMatch($a, $b);
  if ($a.dtype === "bool") {
    $a = cast($a, "int32");
    $b = cast($b, "int32");
  }
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Minimum, inputs);
}
var minimum;
var init_minimum = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_cast();
  init_operation();
  minimum = op({ minimum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/mirror_pad.js
function mirrorPad_(x, paddings, mode) {
  assert(mode === "reflect" || mode === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. ` + `Got ${mode}.`);
  const $x = convertToTensor(x, "x", "mirrorPad");
  if ($x.rank === 0) {
    throw new Error("mirrorPad(scalar) is not defined. " + "Pass non-scalar to mirrorPad");
  }
  assert(paddings.length === $x.rank, () => `Padding doesn't match input. Must be ${$x.rank}. ` + `Got ${paddings.length}.`);
  const shapeOffset = mode === "reflect" ? 1 : 0;
  for (let i = 0;i < $x.rank; i++) {
    assert(paddings[i].length === 2, () => `Invalid number of paddings. Must be length of 2 each.`);
    assert(paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset && paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset, () => `Padding in dimension ${i} cannot be greater than or equal ` + `to ${$x.shape[i] - shapeOffset} or less than 0 for input of ` + `shape ${$x.shape}`);
  }
  const attrs = { paddings, mode };
  const inputs = { x: $x };
  return ENGINE.runKernel(MirrorPad, inputs, attrs);
}
var mirrorPad;
var init_mirror_pad = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  mirrorPad = op({ mirrorPad_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/mod.js
function mod_(a, b) {
  let $a = convertToTensor(a, "a", "mod");
  let $b = convertToTensor(b, "b", "mod");
  [$a, $b] = makeTypesMatch($a, $b);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(Mod, inputs);
}
var mod;
var init_mod = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  mod = op({ mod_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/moments.js
function moments_(x, axis = null, keepDims = false) {
  x = convertToTensor(x, "x", "moments");
  const axes = parseAxisParam(axis, x.shape);
  const xMean = mean(x, axes, keepDims);
  let keepDimsShape = xMean.shape;
  if (!keepDims) {
    keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);
  }
  const devSquared = square(sub(cast(x, "float32"), reshape(xMean, keepDimsShape)));
  const variance = mean(devSquared, axes, keepDims);
  return { mean: xMean, variance };
}
var moments;
var init_moments = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_axis_util();
  init_cast();
  init_mean();
  init_operation();
  init_reshape();
  init_square();
  init_sub();
  moments = op({ moments_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/multi_rnn_cell.js
function multiRNNCell_(lstmCells, data, c, h) {
  const $data = convertToTensor(data, "data", "multiRNNCell");
  const $c = convertToTensorArray(c, "c", "multiRNNCell");
  const $h = convertToTensorArray(h, "h", "multiRNNCell");
  let input = $data;
  const newStates = [];
  for (let i = 0;i < lstmCells.length; i++) {
    const output = lstmCells[i](input, $c[i], $h[i]);
    newStates.push(output[0]);
    newStates.push(output[1]);
    input = output[1];
  }
  const newC = [];
  const newH = [];
  for (let i = 0;i < newStates.length; i += 2) {
    newC.push(newStates[i]);
    newH.push(newStates[i + 1]);
  }
  return [newC, newH];
}
var multiRNNCell;
var init_multi_rnn_cell = __esm(() => {
  init_tensor_util_env();
  init_operation();
  multiRNNCell = op({ multiRNNCell_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/multinomial.js
function multinomial_(logits, numSamples, seed, normalized = false) {
  const $logits = convertToTensor(logits, "logits", "multinomial");
  const numOutcomes = $logits.size;
  const origRank = $logits.rank;
  if (numOutcomes < 2) {
    throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ` + `${numOutcomes}.`);
  }
  if (origRank > 2) {
    throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);
  }
  seed = seed || Math.random();
  const logits2D = origRank === 1 ? reshape($logits, [1, -1]) : $logits;
  const inputs = { logits: logits2D };
  const attrs = { numSamples, seed, normalized };
  const res = ENGINE.runKernel(Multinomial, inputs, attrs);
  return origRank === 1 ? reshape(res, [res.size]) : res;
}
var multinomial;
var init_multinomial = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  init_reshape();
  multinomial = op({ multinomial_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/not_equal.js
function notEqual_(a, b) {
  let $a = convertToTensor(a, "a", "notEqual", "string_or_numeric");
  let $b = convertToTensor(b, "b", "notEqual", "string_or_numeric");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  return ENGINE.runKernel(NotEqual, inputs);
}
var notEqual;
var init_not_equal = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  notEqual = op({ notEqual_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/one_hot.js
function oneHot_(indices, depth, onValue = 1, offValue = 0, dtype = "int32") {
  if (depth < 2) {
    throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);
  }
  const $indices = convertToTensor(indices, "indices", "oneHot", "int32");
  const inputs = { indices: $indices };
  const attrs = { dtype, depth, onValue, offValue };
  return ENGINE.runKernel(OneHot, inputs, attrs);
}
var oneHot;
var init_one_hot = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  oneHot = op({ oneHot_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ones_like.js
function onesLike_(x) {
  const $x = convertToTensor(x, "x", "onesLike");
  const inputs = { x: $x };
  return ENGINE.runKernel(OnesLike, inputs);
}
var onesLike;
var init_ones_like = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  onesLike = op({ onesLike_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/outer_product.js
function outerProduct_(v1, v2) {
  const $v1 = convertToTensor(v1, "v1", "outerProduct");
  const $v2 = convertToTensor(v2, "v2", "outerProduct");
  assert($v1.rank === 1 && $v2.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ` + `${$v1.rank} and ${$v2.rank}.`);
  const v12D = reshape($v1, [-1, 1]);
  const v22D = reshape($v2, [1, -1]);
  return matMul(v12D, v22D);
}
var outerProduct;
var init_outer_product = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_mat_mul();
  init_operation();
  init_reshape();
  outerProduct = op({ outerProduct_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pad.js
function pad_(x, paddings, constantValue = 0) {
  const $x = convertToTensor(x, "x", "pad");
  if ($x.rank === 0) {
    throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  }
  const attrs = { paddings, constantValue };
  const inputs = { x: $x };
  return ENGINE.runKernel(PadV2, inputs, attrs);
}
var pad;
var init_pad = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  pad = op({ pad_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pad1d.js
function pad1d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 2, () => "Invalid number of paddings. Must be length of 2.");
  return pad(x, [paddings], constantValue);
}
var pad1d;
var init_pad1d = __esm(() => {
  init_util();
  init_operation();
  init_pad();
  pad1d = op({ pad1d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pad2d.js
function pad2d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 2 && paddings[0].length === 2 && paddings[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x, paddings, constantValue);
}
var pad2d;
var init_pad2d = __esm(() => {
  init_util();
  init_operation();
  init_pad();
  pad2d = op({ pad2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pad3d.js
function pad3d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 3 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x, paddings, constantValue);
}
var pad3d;
var init_pad3d = __esm(() => {
  init_util();
  init_operation();
  init_pad();
  pad3d = op({ pad3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pad4d.js
function pad4d_(x, paddings, constantValue = 0) {
  assert(paddings.length === 4 && paddings[0].length === 2 && paddings[1].length === 2 && paddings[2].length === 2 && paddings[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each.");
  return pad(x, paddings, constantValue);
}
var pad4d;
var init_pad4d = __esm(() => {
  init_util();
  init_operation();
  init_pad();
  pad4d = op({ pad4d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js
function spaceToBatchND_(x, blockShape, paddings) {
  const $x = convertToTensor(x, "x", "spaceToBatchND");
  assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);
  assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);
  assert($x.shape.reduce((a, b, i) => {
    if (i > 0 && i <= blockShape.length) {
      return a && (b + paddings[i - 1][0] + paddings[i - 1][1]) % blockShape[i - 1] === 0;
    }
    return a;
  }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);
  const inputs = { x: $x };
  const attrs = { blockShape, paddings };
  return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);
}
var spaceToBatchND;
var init_space_to_batch_nd = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  spaceToBatchND = op({ spaceToBatchND_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/pool.js
function pool_(input, windowShape, poolingType, pad6, dilations, strides, dimRoundingMode) {
  if (dilations == null) {
    dilations = [1, 1];
  }
  if (strides == null) {
    strides = 1;
  }
  if (pad6 === 0) {
    pad6 = "valid";
  }
  const $x = convertToTensor(input, "x", "maxPool");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in pool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = computePool2DInfo(x4D.shape, windowShape, strides, dilations, pad6);
  const dilation = [convInfo.dilationHeight, convInfo.dilationWidth];
  let basePadding;
  if (pad6 === "same") {
    basePadding = withSpaceToBatchBasePaddings([convInfo.filterHeight, convInfo.filterWidth], dilation);
  } else {
    basePadding = [[0, 0], [0, 0]];
  }
  const isDilationOne = dilation[0] === 1 && dilation[1] === 1;
  const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings([convInfo.inHeight, convInfo.inWidth], dilation, basePadding);
  const convertedPad = isDilationOne ? pad6 : "valid";
  const convertedX = isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);
  const forwardOp = poolingType === "avg" ? () => avgPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode) : () => maxPool(convertedX, windowShape, strides, convertedPad, dimRoundingMode);
  const y = forwardOp();
  const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
function requiredSpaceToBatchPaddings(inputShape, blockShape, basePadding) {
  const padStart = basePadding.map((b) => b[0]);
  const origPadEnd = basePadding.map((b) => b[1]);
  const fullInputShape = inputShape.concat(padStart, origPadEnd);
  const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);
  const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);
  const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);
  const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);
  return [paddings, crops];
}
function withSpaceToBatchBasePaddings(filterShape, dilation) {
  const dilatedFilterShape = filterShape.map((s, i) => {
    return s + (s - 1) * (dilation[i] - 1);
  });
  const padExtraShape = dilatedFilterShape.map((s) => s - 1);
  const padExtraStart = padExtraShape.map((s) => Math.floor(s / 2));
  const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);
  return padExtraShape.map((_, i) => {
    return [padExtraStart[i], padExtraEnd[i]];
  });
}
var pool;
var init_pool = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_avg_pool();
  init_batch_to_space_nd();
  init_conv_util();
  init_max_pool();
  init_operation();
  init_reshape();
  init_space_to_batch_nd();
  pool = op({ pool_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/prelu.js
function prelu_(x, alpha) {
  const $x = convertToTensor(x, "x", "prelu");
  const $alpha = convertToTensor(alpha, "alpha", "prelu");
  const inputs = { x: $x, alpha: $alpha };
  return ENGINE.runKernel(Prelu, inputs);
}
var prelu;
var init_prelu = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  prelu = op({ prelu_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/prod.js
function prod_(x, axis = null, keepDims = false) {
  let $x = convertToTensor(x, "x", "prod");
  if ($x.dtype === "bool") {
    $x = cast($x, "int32");
  }
  const inputs = { x: $x };
  const attrs = { axis, keepDims };
  return ENGINE.runKernel(Prod, inputs, attrs);
}
var prod;
var init_prod = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_cast();
  init_operation();
  prod = op({ prod_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ragged_gather.js
function raggedGather_(paramsNestedSplits, paramsDenseValues, indices, outputRaggedRank) {
  const $paramsNestedSplits = paramsNestedSplits.map((t, i) => convertToTensor(t, `tensors${i}`, "raggedGather", "int32"));
  const $paramsDenseValues = convertToTensor(paramsDenseValues, "paramsDenseValues", "raggedGather");
  const $indices = convertToTensor(indices, "indices", "raggedGather", "int32");
  const inputs = {
    paramsNestedSplits: $paramsNestedSplits,
    paramsDenseValues: $paramsDenseValues,
    indices: $indices
  };
  const attrs = { outputRaggedRank };
  const result = ENGINE.runKernel(RaggedGather, inputs, attrs);
  return {
    outputNestedSplits: result.slice(0, result.length - 1),
    outputDenseValues: result[result.length - 1]
  };
}
var raggedGather;
var init_ragged_gather = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  raggedGather = op({ raggedGather_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ragged_range.js
function raggedRange_(starts, limits, deltas) {
  const $starts = convertToTensor(starts, "starts", "raggedRange");
  const $limits = convertToTensor(limits, "limits", "raggedRange", $starts.dtype);
  const $deltas = convertToTensor(deltas, "deltas", "raggedRange", $starts.dtype);
  const inputs = {
    starts: $starts,
    limits: $limits,
    deltas: $deltas
  };
  const result = ENGINE.runKernel(RaggedRange, inputs);
  return {
    rtNestedSplits: result[0],
    rtDenseValues: result[1]
  };
}
var raggedRange;
var init_ragged_range = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  raggedRange = op({ raggedRange_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ragged_tensor_to_tensor.js
function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {
  const $shape = convertToTensor(shape, "shape", "raggedTensorToTensor", "int32");
  const $values = convertToTensor(values, "values", "raggedTensorToTensor");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "raggedTensorToTensor", $values.dtype);
  const $rowPartitionTensors = rowPartitionTensors.map((t, i) => convertToTensor(t, `tensors${i}`, "raggedTensorToTensor", "int32"));
  const inputs = {
    shape: $shape,
    values: $values,
    defaultValue: $defaultValue,
    rowPartitionTensors: $rowPartitionTensors
  };
  const attrs = { rowPartitionTypes };
  return ENGINE.runKernel(RaggedTensorToTensor, inputs, attrs);
}
var raggedTensorToTensor;
var init_ragged_tensor_to_tensor = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  raggedTensorToTensor = op({ raggedTensorToTensor_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/rand.js
function rand_(shape, randFunction, dtype) {
  assertNonNegativeIntegerDimensions(shape);
  const size = sizeFromShape(shape);
  let values = null;
  if (dtype == null || dtype === "float32") {
    values = new Float32Array(size);
  } else if (dtype === "int32") {
    values = new Int32Array(size);
  } else if (dtype === "bool") {
    values = new Uint8Array(size);
  } else {
    throw new Error(`Unknown data type ${dtype}`);
  }
  for (let i = 0;i < size; i++) {
    values[i] = randFunction();
  }
  return ENGINE.makeTensor(values, shape, dtype);
}
var rand;
var init_rand = __esm(() => {
  init_engine();
  init_util();
  init_operation();
  rand = op({ rand_ });
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 0.00000000023283064365386963;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 0.00000000000000011102230246251565;
      };
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i = 0;i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 4294967296;
        }
        return (n >>> 0) * 0.00000000023283064365386963;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { x: X, i } = me, t, v, w;
        t = X[i];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i] = v;
        me.i = i + 1 & 7;
        return v;
      };
      function init(me2, seed2) {
        var j, w, X = [];
        if (seed2 === (seed2 | 0)) {
          w = X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0;j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0;j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          w = X[7] = -1;
        else
          w = X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256;j > 0; --j) {
          me2.next();
        }
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var { w, X, i } = me, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i + 34 & 127];
        t = X[i = i + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i] = v ^ t;
        me.i = i;
        return v + (w ^ w >>> 16) | 0;
      };
      function init(me2, seed2) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\0";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i = 0, j = -32;j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i = t == 0 ? i + 1 : 0;
          }
        }
        if (i >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i = 127;
        for (j = 4 * 128;j > 0; --j) {
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i;
      }
      init(me, seed);
    }
    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date;
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS((exports, module) => {
  (function(global2, module2, define2) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var { b, c, d, a } = me;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0;k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define2 && define2.amd) {
      define2(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(exports, typeof module == "object" && module, typeof define == "function" && define);
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id,
  scrypt: () => Td,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga
});
function dw() {
  return Hq;
}
var pw, Xa, vw, bw, mw, gw, R0 = (t, e) => () => (t && (e = t(t = 0)), e), T = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Ja = (t, e) => {
  for (var r in e)
    Xa(t, r, { get: e[r], enumerable: true });
}, Ya = (t, e, r, o) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f of bw(e))
      !gw.call(t, f) && f !== r && Xa(t, f, { get: () => e[f], enumerable: !(o = vw(e, f)) || o.enumerable });
  return t;
}, ot = (t, e, r) => (Ya(t, e, "default"), r && Ya(r, e, "default")), rn = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t)), ur = (t) => Ya(Xa({}, "__esModule", { value: true }), t), Nd, Dd, Ut, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh, Ao, Bo, pn, _p, Ep, gh, qp, yh, Op, ko, Tt, Gr, No, Jt, pa, Rh, pr, Y_, Oi, Fi, Ui, k12, yn, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr, fu, ou, os, eb, cu, lb, bu, vf, S7, db, yi, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu, Au, Ub, Iu, Tu, ar, vs, ku, Yb, Qb, em, im, nm, yf, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji, Yu, Ym, Xm, As, tl, ol, rg, ag, hg, hl, pg, dl, kn, cl, bl, Ln, Ds, Lg, Dg, yl, Il, Yg, t2, i2, Ws, Ks, s2, ri, Nl, or, Oa, b2, y2, _2, Pl, Cr, Tf, Cl, N2, Fl, F2, Wl, Z2, V2, Q2, ty, e0, ny, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy, dd, r3, n3, o3, cd, d3, p3, v3, m3, Ha, bd, _3, A3, k3, N3, P3, _d, xd, w0, Ed, j3, Y3, X3, ow, qd, Xt, zq, Ga = "buffer", uw = (t) => crypto.getRandomValues(t), lw = () => crypto.randomUUID(), Hq, x0, Id, Td, cw, Wq;
var init_crypto = __esm(() => {
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  Nd = T((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr["-".charCodeAt(0)] = 62;
    lr["_".charCodeAt(0)] = 63;
    function Ld(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o = r === e ? 0 : 4 - r % 4;
      return [r, o];
    }
    function ww(t) {
      var e = Ld(t), r = e[0], o = e[1];
      return (r + o) * 3 / 4 - o;
    }
    function Mw(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e, r = Ld(t), o = r[0], f = r[1], p2 = new yw(Mw(t, o, f)), m = 0, y = f > 0 ? o - 4 : o, M;
      for (M = 0;M < y; M += 4)
        e = lr[t.charCodeAt(M)] << 18 | lr[t.charCodeAt(M + 1)] << 12 | lr[t.charCodeAt(M + 2)] << 6 | lr[t.charCodeAt(M + 3)], p2[m++] = e >> 16 & 255, p2[m++] = e >> 8 & 255, p2[m++] = e & 255;
      return f === 2 && (e = lr[t.charCodeAt(M)] << 2 | lr[t.charCodeAt(M + 1)] >> 4, p2[m++] = e & 255), f === 1 && (e = lr[t.charCodeAt(M)] << 10 | lr[t.charCodeAt(M + 1)] << 4 | lr[t.charCodeAt(M + 2)] >> 2, p2[m++] = e >> 8 & 255, p2[m++] = e & 255), p2;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e, r) {
      for (var o, f = [], p2 = e;p2 < r; p2 += 3)
        o = (t[p2] << 16 & 16711680) + (t[p2 + 1] << 8 & 65280) + (t[p2 + 2] & 255), f.push(xw(o));
      return f.join("");
    }
    function Ew(t) {
      for (var e, r = t.length, o = r % 3, f = [], p2 = 16383, m = 0, y = r - o;m < y; m += p2)
        f.push(Sw(t, m, m + p2 > y ? y : m + p2));
      return o === 1 ? (e = t[r - 1], f.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o === 2 && (e = (t[r - 2] << 8) + t[r - 1], f.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f.join("");
    }
  });
  Dd = T((q0) => {
    q0.read = function(t, e, r, o, f) {
      var p2, m, y = f * 8 - o - 1, M = (1 << y) - 1, x = M >> 1, S = -7, E2 = r ? f - 1 : 0, B = r ? -1 : 1, q = t[e + E2];
      for (E2 += B, p2 = q & (1 << -S) - 1, q >>= -S, S += y;S > 0; p2 = p2 * 256 + t[e + E2], E2 += B, S -= 8)
        ;
      for (m = p2 & (1 << -S) - 1, p2 >>= -S, S += o;S > 0; m = m * 256 + t[e + E2], E2 += B, S -= 8)
        ;
      if (p2 === 0)
        p2 = 1 - x;
      else {
        if (p2 === M)
          return m ? NaN : (q ? -1 : 1) * (1 / 0);
        m = m + Math.pow(2, o), p2 = p2 - x;
      }
      return (q ? -1 : 1) * m * Math.pow(2, p2 - o);
    };
    q0.write = function(t, e, r, o, f, p2) {
      var m, y, M, x = p2 * 8 - f - 1, S = (1 << x) - 1, E2 = S >> 1, B = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o ? 0 : p2 - 1, L = o ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y = isNaN(e) ? 1 : 0, m = S) : (m = Math.floor(Math.log(e) / Math.LN2), e * (M = Math.pow(2, -m)) < 1 && (m--, M *= 2), m + E2 >= 1 ? e += B / M : e += B * Math.pow(2, 1 - E2), e * M >= 2 && (m++, M /= 2), m + E2 >= S ? (y = 0, m = S) : m + E2 >= 1 ? (y = (e * M - 1) * Math.pow(2, f), m = m + E2) : (y = e * Math.pow(2, E2 - 1) * Math.pow(2, f), m = 0));f >= 8; t[r + q] = y & 255, q += L, y /= 256, f -= 8)
        ;
      for (m = m << f | y, x += f;x > 0; t[r + q] = m & 255, q += L, m /= 256, x -= 8)
        ;
      t[r + q - L] |= ge * 128;
    };
  });
  Ut = T((Xn) => {
    var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo = 2147483647;
    Xn.kMaxLength = eo;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li(t) {
      if (t > eo)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, me.prototype), e;
    }
    function me(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e, r);
    }
    me.poolSize = 8192;
    function Ud(t, e, r) {
      if (typeof t == "string")
        return Bw(t, e);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr2(t, ArrayBuffer) || t && Zr2(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr2(t, SharedArrayBuffer) || t && Zr2(t.buffer, SharedArrayBuffer)))
        return k02(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o = t.valueOf && t.valueOf();
      if (o != null && o !== t)
        return me.from(o, e, r);
      let f = Iw(t);
      if (f)
        return f;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e, r) {
      return Ud(t, e, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e, r) {
      return zd(t), t <= 0 ? li(t) : e !== undefined ? typeof r == "string" ? li(t).fill(e, r) : li(t).fill(e) : li(t);
    }
    me.alloc = function(t, e, r) {
      return Rw(t, e, r);
    };
    function N0(t) {
      return zd(t), li(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = Hd(t, e) | 0, o = li(r), f = o.write(t, e);
      return f !== r && (o = o.slice(0, f)), o;
    }
    function T0(t) {
      let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li(e);
      for (let o = 0;o < e; o += 1)
        r[o] = t[o] & 255;
      return r;
    }
    function qw(t) {
      if (Zr2(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return k02(e.buffer, e.byteOffset, e.byteLength);
      }
      return T0(t);
    }
    function k02(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o;
      return e === undefined && r === undefined ? o = new Uint8Array(t) : r === undefined ? o = new Uint8Array(t, e) : o = new Uint8Array(t, e, r), Object.setPrototypeOf(o, me.prototype), o;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e = D0(t.length) | 0, r = li(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== me.prototype;
    };
    me.compare = function(e, r) {
      if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr2(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o = e.length, f = r.length;
      for (let p2 = 0, m = Math.min(o, f);p2 < m; ++p2)
        if (e[p2] !== r[p2]) {
          o = e[p2], f = r[p2];
          break;
        }
      return o < f ? -1 : f < o ? 1 : 0;
    };
    me.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return me.alloc(0);
      let o;
      if (r === undefined)
        for (r = 0, o = 0;o < e.length; ++o)
          r += e[o].length;
      let f = me.allocUnsafe(r), p2 = 0;
      for (o = 0;o < e.length; ++o) {
        let m = e[o];
        if (Zr2(m, Uint8Array))
          p2 + m.length > f.length ? (me.isBuffer(m) || (m = me.from(m)), m.copy(f, p2)) : Uint8Array.prototype.set.call(f, m, p2);
        else if (me.isBuffer(m))
          m.copy(f, p2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p2 += m.length;
      }
      return f;
    };
    function Hd(t, e) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr2(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o = arguments.length > 2 && arguments[2] === true;
      if (!o && r === 0)
        return 0;
      let f = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f)
              return o ? -1 : L0(t).length;
            e = ("" + e).toLowerCase(), f = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e, r) {
      let o = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e, r);
          case "ascii":
            return Uw(this, e, r);
          case "latin1":
          case "binary":
            return zw(this, e, r);
          case "base64":
            return Ow(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e, r);
          default:
            if (o)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e, r) {
      let o = t[e];
      t[e] = t[r], t[r] = o;
    }
    me.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e) {
      if (!me.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : me.compare(this, e) === 0;
    };
    me.prototype.inspect = function() {
      let e = "", r = Xn.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e, r, o, f, p2) {
      if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o === undefined && (o = e ? e.length : 0), f === undefined && (f = 0), p2 === undefined && (p2 = this.length), r < 0 || o > e.length || f < 0 || p2 > this.length)
        throw new RangeError("out of range index");
      if (f >= p2 && r >= o)
        return 0;
      if (f >= p2)
        return -1;
      if (r >= o)
        return 1;
      if (r >>>= 0, o >>>= 0, f >>>= 0, p2 >>>= 0, this === e)
        return 0;
      let m = p2 - f, y = o - r, M = Math.min(m, y), x = this.slice(f, p2), S = e.slice(r, o);
      for (let E2 = 0;E2 < M; ++E2)
        if (x[E2] !== S[E2]) {
          m = x[E2], y = S[E2];
          break;
        }
      return m < y ? -1 : y < m ? 1 : 0;
    };
    function Wd(t, e, r, o, f) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = me.from(e, o)), me.isBuffer(e))
        return e.length === 0 ? -1 : Cd(t, e, r, o, f);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o, f);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e, r, o, f) {
      let p2 = 1, m = t.length, y = e.length;
      if (o !== undefined && (o = String(o).toLowerCase(), o === "ucs2" || o === "ucs-2" || o === "utf16le" || o === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p2 = 2, m /= 2, y /= 2, r /= 2;
      }
      function M(S, E2) {
        return p2 === 1 ? S[E2] : S.readUInt16BE(E2 * p2);
      }
      let x;
      if (f) {
        let S = -1;
        for (x = r;x < m; x++)
          if (M(t, x) === M(e, S === -1 ? 0 : x - S)) {
            if (S === -1 && (S = x), x - S + 1 === y)
              return S * p2;
          } else
            S !== -1 && (x -= x - S), S = -1;
      } else
        for (r + y > m && (r = m - y), x = r;x >= 0; x--) {
          let S = true;
          for (let E2 = 0;E2 < y; E2++)
            if (M(t, x + E2) !== M(e, E2)) {
              S = false;
              break;
            }
          if (S)
            return x;
        }
      return -1;
    }
    me.prototype.includes = function(e, r, o) {
      return this.indexOf(e, r, o) !== -1;
    };
    me.prototype.indexOf = function(e, r, o) {
      return Wd(this, e, r, o, true);
    };
    me.prototype.lastIndexOf = function(e, r, o) {
      return Wd(this, e, r, o, false);
    };
    function Lw(t, e, r, o) {
      r = Number(r) || 0;
      let f = t.length - r;
      o ? (o = Number(o), o > f && (o = f)) : o = f;
      let p2 = e.length;
      o > p2 / 2 && (o = p2 / 2);
      let m;
      for (m = 0;m < o; ++m) {
        let y = parseInt(e.substr(m * 2, 2), 16);
        if (C0(y))
          return m;
        t[r + m] = y;
      }
      return m;
    }
    function Nw(t, e, r, o) {
      return to(L0(e, t.length - r), t, r, o);
    }
    function Dw(t, e, r, o) {
      return to(Vw(e), t, r, o);
    }
    function Pw(t, e, r, o) {
      return to(Xd(e), t, r, o);
    }
    function Cw(t, e, r, o) {
      return to($w(e, t.length - r), t, r, o);
    }
    me.prototype.write = function(e, r, o, f) {
      if (r === undefined)
        f = "utf8", o = this.length, r = 0;
      else if (o === undefined && typeof r == "string")
        f = r, o = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o) ? (o = o >>> 0, f === undefined && (f = "utf8")) : (f = o, o = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p2 = this.length - r;
      if ((o === undefined || o > p2) && (o = p2), e.length > 0 && (o < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f || (f = "utf8");
      let m = false;
      for (;; )
        switch (f) {
          case "hex":
            return Lw(this, e, r, o);
          case "utf8":
          case "utf-8":
            return Nw(this, e, r, o);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e, r, o);
          case "base64":
            return Pw(this, e, r, o);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e, r, o);
          default:
            if (m)
              throw new TypeError("Unknown encoding: " + f);
            f = ("" + f).toLowerCase(), m = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e, r) {
      return e === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e, r));
    }
    function Kd(t, e, r) {
      r = Math.min(t.length, r);
      let o = [], f = e;
      for (;f < r; ) {
        let p2 = t[f], m = null, y = p2 > 239 ? 4 : p2 > 223 ? 3 : p2 > 191 ? 2 : 1;
        if (f + y <= r) {
          let M, x, S, E2;
          switch (y) {
            case 1:
              p2 < 128 && (m = p2);
              break;
            case 2:
              M = t[f + 1], (M & 192) === 128 && (E2 = (p2 & 31) << 6 | M & 63, E2 > 127 && (m = E2));
              break;
            case 3:
              M = t[f + 1], x = t[f + 2], (M & 192) === 128 && (x & 192) === 128 && (E2 = (p2 & 15) << 12 | (M & 63) << 6 | x & 63, E2 > 2047 && (E2 < 55296 || E2 > 57343) && (m = E2));
              break;
            case 4:
              M = t[f + 1], x = t[f + 2], S = t[f + 3], (M & 192) === 128 && (x & 192) === 128 && (S & 192) === 128 && (E2 = (p2 & 15) << 18 | (M & 63) << 12 | (x & 63) << 6 | S & 63, E2 > 65535 && E2 < 1114112 && (m = E2));
          }
        }
        m === null ? (m = 65533, y = 1) : m > 65535 && (m -= 65536, o.push(m >>> 10 & 1023 | 55296), m = 56320 | m & 1023), o.push(m), f += y;
      }
      return Fw(o);
    }
    var Od = 4096;
    function Fw(t) {
      let e = t.length;
      if (e <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o = 0;
      for (;o < e; )
        r += String.fromCharCode.apply(String, t.slice(o, o += Od));
      return r;
    }
    function Uw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e;f < r; ++f)
        o += String.fromCharCode(t[f] & 127);
      return o;
    }
    function zw(t, e, r) {
      let o = "";
      r = Math.min(t.length, r);
      for (let f = e;f < r; ++f)
        o += String.fromCharCode(t[f]);
      return o;
    }
    function Hw(t, e, r) {
      let o = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o) && (r = o);
      let f = "";
      for (let p2 = e;p2 < r; ++p2)
        f += Gw[t[p2]];
      return f;
    }
    function Ww(t, e, r) {
      let o = t.slice(e, r), f = "";
      for (let p2 = 0;p2 < o.length - 1; p2 += 2)
        f += String.fromCharCode(o[p2] + o[p2 + 1] * 256);
      return f;
    }
    me.prototype.slice = function(e, r) {
      let o = this.length;
      e = ~~e, r = r === undefined ? o : ~~r, e < 0 ? (e += o, e < 0 && (e = 0)) : e > o && (e = o), r < 0 ? (r += o, r < 0 && (r = 0)) : r > o && (r = o), r < e && (r = e);
      let f = this.subarray(e, r);
      return Object.setPrototypeOf(f, me.prototype), f;
    };
    function Dt(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e], p2 = 1, m = 0;
      for (;++m < r && (p2 *= 256); )
        f += this[e + m] * p2;
      return f;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e + --r], p2 = 1;
      for (;r > 0 && (p2 *= 256); )
        f += this[e + --r] * p2;
      return f;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    me.prototype.readBigUInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p2 = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o * 2 ** 24;
      return BigInt(f) + (BigInt(p2) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p2 = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o;
      return (BigInt(f) << BigInt(32)) + BigInt(p2);
    });
    me.prototype.readIntLE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = this[e], p2 = 1, m = 0;
      for (;++m < r && (p2 *= 256); )
        f += this[e + m] * p2;
      return p2 *= 128, f >= p2 && (f -= Math.pow(2, 8 * r)), f;
    };
    me.prototype.readIntBE = function(e, r, o) {
      e = e >>> 0, r = r >>> 0, o || Dt(e, r, this.length);
      let f = r, p2 = 1, m = this[e + --f];
      for (;f > 0 && (p2 *= 256); )
        m += this[e + --f] * p2;
      return p2 *= 128, m >= p2 && (m -= Math.pow(2, 8 * r)), m;
    };
    me.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Dt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    me.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e] | this[e + 1] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Dt(e, 2, this.length);
      let o = this[e + 1] | this[e] << 8;
      return o & 32768 ? o | 4294901760 : o;
    };
    me.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    me.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    me.prototype.readBigInt64LE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o << 24);
      return (BigInt(f) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o = this[e + 7];
      (r === undefined || o === undefined) && Vf(e, this.length - 8);
      let f = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o);
    });
    me.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 4, this.length), Gn.read(this, e, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Dt(e, 8, this.length), Gn.read(this, e, false, 52, 8);
    };
    function er(t, e, r, o, f, p2) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f || e < p2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y, 0);
      }
      let p2 = 1, m = 0;
      for (this[r] = e & 255;++m < o && (p2 *= 256); )
        this[r + m] = e / p2 & 255;
      return r + o;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, o = o >>> 0, !f) {
        let y = Math.pow(2, 8 * o) - 1;
        er(this, e, r, o, y, 0);
      }
      let p2 = o - 1, m = 1;
      for (this[r + p2] = e & 255;--p2 >= 0 && (m *= 256); )
        this[r + p2] = e / m & 255;
      return r + o;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function jd(t, e, r, o, f) {
      Yd(e, o, f, t, r, 7);
      let p2 = Number(e & BigInt(4294967295));
      t[r++] = p2, p2 = p2 >> 8, t[r++] = p2, p2 = p2 >> 8, t[r++] = p2, p2 = p2 >> 8, t[r++] = p2;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, m = m >> 8, t[r++] = m, r;
    }
    function Zd(t, e, r, o, f) {
      Yd(e, o, f, t, r, 7);
      let p2 = Number(e & BigInt(4294967295));
      t[r + 7] = p2, p2 = p2 >> 8, t[r + 6] = p2, p2 = p2 >> 8, t[r + 5] = p2, p2 = p2 >> 8, t[r + 4] = p2;
      let m = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m, m = m >> 8, t[r + 2] = m, m = m >> 8, t[r + 1] = m, m = m >> 8, t[r] = m, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M - 1, -M);
      }
      let p2 = 0, m = 1, y = 0;
      for (this[r] = e & 255;++p2 < o && (m *= 256); )
        e < 0 && y === 0 && this[r + p2 - 1] !== 0 && (y = 1), this[r + p2] = (e / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeIntBE = function(e, r, o, f) {
      if (e = +e, r = r >>> 0, !f) {
        let M = Math.pow(2, 8 * o - 1);
        er(this, e, r, o, M - 1, -M);
      }
      let p2 = o - 1, m = 1, y = 0;
      for (this[r + p2] = e & 255;--p2 >= 0 && (m *= 256); )
        e < 0 && y === 0 && this[r + p2 + 1] !== 0 && (y = 1), this[r + p2] = (e / m >> 0) - y & 255;
      return r + o;
    };
    me.prototype.writeInt8 = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e, r, o) {
      return e = +e, r = r >>> 0, o || er(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti(function(e, r = 0) {
      return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti(function(e, r = 0) {
      return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e, r, o, f, p2) {
      if (r + o > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e, r, o, f) {
      return e = +e, r = r >>> 0, f || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e, r, o) {
      return $d(this, e, r, true, o);
    };
    me.prototype.writeFloatBE = function(e, r, o) {
      return $d(this, e, r, false, o);
    };
    function Gd(t, e, r, o, f) {
      return e = +e, r = r >>> 0, f || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e, r, o) {
      return Gd(this, e, r, true, o);
    };
    me.prototype.writeDoubleBE = function(e, r, o) {
      return Gd(this, e, r, false, o);
    };
    me.prototype.copy = function(e, r, o, f) {
      if (!me.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o || (o = 0), !f && f !== 0 && (f = this.length), r >= e.length && (r = e.length), r || (r = 0), f > 0 && f < o && (f = o), f === o || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o < 0 || o >= this.length)
        throw new RangeError("Index out of range");
      if (f < 0)
        throw new RangeError("sourceEnd out of bounds");
      f > this.length && (f = this.length), e.length - r < f - o && (f = e.length - r + o);
      let p2 = f - o;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o, f) : Uint8Array.prototype.set.call(e, this.subarray(o, f), r), p2;
    };
    me.prototype.fill = function(e, r, o, f) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f = r, r = 0, o = this.length) : typeof o == "string" && (f = o, o = this.length), f !== undefined && typeof f != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f == "string" && !me.isEncoding(f))
          throw new TypeError("Unknown encoding: " + f);
        if (e.length === 1) {
          let m = e.charCodeAt(0);
          (f === "utf8" && m < 128 || f === "latin1") && (e = m);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o)
        throw new RangeError("Out of range index");
      if (o <= r)
        return this;
      r = r >>> 0, o = o === undefined ? this.length : o >>> 0, e || (e = 0);
      let p2;
      if (typeof e == "number")
        for (p2 = r;p2 < o; ++p2)
          this[p2] = e;
      else {
        let m = me.isBuffer(e) ? e : me.from(e, f), y = m.length;
        if (y === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p2 = 0;p2 < o - r; ++p2)
          this[p2 + r] = m[p2 % y];
      }
      return this;
    };
    var $n = {};
    function P0(t, e, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o = `The value of "${t}" is out of range.`, f = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f = Fd(String(r)) : typeof r == "bigint" && (f = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f = Fd(f)), f += "n"), o += ` It must be ${e}. Received ${f}`, o;
    }, RangeError);
    function Fd(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function Kw(t, e, r) {
      Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
    }
    function Yd(t, e, r, o, f, p2) {
      if (t > r || t < e) {
        let m = typeof e == "bigint" ? "n" : "", y;
        throw p2 > 3 ? e === 0 || e === BigInt(0) ? y = `>= 0${m} and < 2${m} ** ${(p2 + 1) * 8}${m}` : y = `>= -(2${m} ** ${(p2 + 1) * 8 - 1}${m}) and < 2 ** ${(p2 + 1) * 8 - 1}${m}` : y = `>= ${e}${m} and <= ${r}${m}`, new $n.ERR_OUT_OF_RANGE("value", y, t);
      }
      Kw(o, f, p2);
    }
    function Yn(t, e) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Vf(t, e, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e) {
      e = e || 1 / 0;
      let r, o = t.length, f = null, p2 = [];
      for (let m = 0;m < o; ++m) {
        if (r = t.charCodeAt(m), r > 55295 && r < 57344) {
          if (!f) {
            if (r > 56319) {
              (e -= 3) > -1 && p2.push(239, 191, 189);
              continue;
            } else if (m + 1 === o) {
              (e -= 3) > -1 && p2.push(239, 191, 189);
              continue;
            }
            f = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p2.push(239, 191, 189), f = r;
            continue;
          }
          r = (f - 55296 << 10 | r - 56320) + 65536;
        } else
          f && (e -= 3) > -1 && p2.push(239, 191, 189);
        if (f = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p2.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p2;
    }
    function Vw(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function $w(t, e) {
      let r, o, f, p2 = [];
      for (let m = 0;m < t.length && !((e -= 2) < 0); ++m)
        r = t.charCodeAt(m), o = r >> 8, f = r % 256, p2.push(f), p2.push(o);
      return p2;
    }
    function Xd(t) {
      return I0.toByteArray(Zw(t));
    }
    function to(t, e, r, o) {
      let f;
      for (f = 0;f < o && !(f + r >= e.length || f >= t.length); ++f)
        e[f + r] = t[f];
      return f;
    }
    function Zr2(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o = r * 16;
        for (let f = 0;f < 16; ++f)
          e[o + f] = t[r] + t[f];
      }
      return e;
    }();
    function Ti(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T((O0, Qd) => {
    var ro = Ut(), Vr = ro.Buffer;
    function Jd(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro : (Jd(ro, O0), O0.Buffer = an);
    function an(t, e, r) {
      return Vr(t, e, r);
    }
    an.prototype = Object.create(Vr.prototype);
    Jd(Vr, an);
    an.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    an.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o = Vr(t);
      return e !== undefined ? typeof r == "string" ? o.fill(e, r) : o.fill(e) : o.fill(0), o;
    };
    an.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro.SlowBuffer(t);
    };
  });
  on = T((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o = 0;o < t; o += F0)
            io.getRandomValues(r.slice(o, o + F0));
        else
          io.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = T((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o = function() {
        };
        o.prototype = r.prototype, e.prototype = new o, e.prototype.constructor = e;
      }
    };
  });
  ki = T((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o) {
      return Function.prototype.apply.call(e, r, o);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : no = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || rc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function ic(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o = 1;o < arguments.length; o++)
        r.push(arguments[o]);
      var f = e === "error", p2 = this._events;
      if (p2 !== undefined)
        f = f && p2.error === undefined;
      else if (!f)
        return false;
      if (f) {
        var m;
        if (r.length > 0 && (m = r[0]), m instanceof Error)
          throw m;
        var y = new Error("Unhandled error." + (m ? " (" + m.message + ")" : ""));
        throw y.context = m, y;
      }
      var M = p2[e];
      if (M === undefined)
        return false;
      if (typeof M == "function")
        ec(M, this, r);
      else
        for (var x = M.length, S = sc(M, x), o = 0;o < x; ++o)
          ec(S[o], this, r);
      return true;
    };
    function nc(t, e, r, o) {
      var f, p2, m;
      if (fo(r), p2 = t._events, p2 === undefined ? (p2 = t._events = Object.create(null), t._eventsCount = 0) : (p2.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p2 = t._events), m = p2[e]), m === undefined)
        m = p2[e] = r, ++t._eventsCount;
      else if (typeof m == "function" ? m = p2[e] = o ? [r, m] : [m, r] : o ? m.unshift(r) : m.push(r), f = ic(t), f > 0 && m.length > f && !m.warned) {
        m.warned = true;
        var y = new Error("Possible EventEmitter memory leak detected. " + m.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y.name = "MaxListenersExceededWarning", y.emitter = t, y.type = e, y.count = m.length, t6(y);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return nc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return nc(this, e, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e, r) {
      var o = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f = r6.bind(o);
      return f.listener = r, o.wrapFn = f, f;
    }
    Fe.prototype.once = function(e, r) {
      return fo(r), this.on(e, fc(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return fo(r), this.prependListener(e, fc(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o, f, p2, m, y;
      if (fo(r), f = this._events, f === undefined)
        return this;
      if (o = f[e], o === undefined)
        return this;
      if (o === r || o.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f[e], f.removeListener && this.emit("removeListener", e, o.listener || r));
      else if (typeof o != "function") {
        for (p2 = -1, m = o.length - 1;m >= 0; m--)
          if (o[m] === r || o[m].listener === r) {
            y = o[m].listener, p2 = m;
            break;
          }
        if (p2 < 0)
          return this;
        p2 === 0 ? o.shift() : i6(o, p2), o.length === 1 && (f[e] = o[0]), f.removeListener !== undefined && this.emit("removeListener", e, y || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o, f;
      if (o = this._events, o === undefined)
        return this;
      if (o.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o[e]), this;
      if (arguments.length === 0) {
        var p2 = Object.keys(o), m;
        for (f = 0;f < p2.length; ++f)
          m = p2[f], m !== "removeListener" && this.removeAllListeners(m);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f = r.length - 1;f >= 0; f--)
          this.removeListener(e, r[f]);
      return this;
    };
    function ac(t, e, r) {
      var o = t._events;
      if (o === undefined)
        return [];
      var f = o[e];
      return f === undefined ? [] : typeof f == "function" ? r ? [f.listener || f] : [f] : r ? n6(f) : sc(f, f.length);
    }
    Fe.prototype.listeners = function(e) {
      return ac(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return ac(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e) {
      for (var r = new Array(e), o = 0;o < e; ++o)
        r[o] = t[o];
      return r;
    }
    function i6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function n6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function f6(t, e) {
      return new Promise(function(r, o) {
        function f(m) {
          t.removeListener(e, p2), o(m);
        }
        function p2() {
          typeof t.removeListener == "function" && t.removeListener("error", f), r([].slice.call(arguments));
        }
        hc(t, e, p2, { once: true }), e !== "error" && a6(t, f, { once: true });
      });
    }
    function a6(t, e, r) {
      typeof t.on == "function" && hc(t, "error", e, r);
    }
    function hc(t, e, r, o) {
      if (typeof t.on == "function")
        o.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p2) {
          o.once && t.removeEventListener(e, f), r(p2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T(() => {
  });
  pc = T((tI, cc) => {
    function lc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function o6(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lc(Object(r), true).forEach(function(o) {
          s6(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function s6(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function h6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function u6(t, e, r) {
      return e && dc(t.prototype, e), r && dc(t, r), t;
    }
    var l6 = Ut(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e, r) {
      ao.prototype.copy.call(t, e, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o = ao.allocUnsafe(r >>> 0), f = this.head, p2 = 0;f; )
          p6(f.data, o, p2), p2 += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p2 = o.data;
        for (r -= p2.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p2 += m : p2 += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p2;
      } }, { key: "_getBuffer", value: function(r) {
        var o = ao.allocUnsafe(r), f = this.head, p2 = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p2, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p2;
        }
        return this.length -= p2, o;
      } }, { key: c6, value: function(r, o) {
        return K0(this, o6({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T((rI, bc) => {
    function v6(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p2) {
        !e && p2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p2)) : process.nextTick(vc, r, p2) : e ? (process.nextTick(oo, r), e(p2)) : process.nextTick(oo, r);
      }), this);
    }
    function vc(t, e) {
      j0(t, e), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e) {
      t.emit("error", e);
    }
    function m6(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T((iI, yc) => {
    function g6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gc = {};
    function dr2(t, e, r) {
      r || (r = Error);
      function o(p2, m, y) {
        return typeof e == "string" ? e : e(p2, m, y);
      }
      var f = function(p2) {
        g6(m, p2);
        function m(y, M, x) {
          return p2.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gc[t] = f;
    }
    function mc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function y6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function w6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function M6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr2("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr2("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && y6(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f;
      if (w6(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mc(e, "type"));
      else {
        var p2 = M6(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p2, " ").concat(o, " ").concat(mc(e, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    dr2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr2("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr2("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr2("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr2("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc.exports.codes = gc;
  });
  V0 = T((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function S6(t, e, r, o) {
      var f = x6(e, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p2 = o ? r : "highWaterMark";
          throw new _6(p2, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e);
          $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  J0 = T((aI, Rc) => {
    Rc.exports = ht;
    function xc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e, t);
      };
    }
    var Qn;
    ht.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut().Buffer, R6 = global.Uint8Array || function() {
    };
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li = sn().codes, k6 = Li.ERR_INVALID_ARG_TYPE, L6 = Li.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li.ERR_MULTIPLE_CALLBACK, D6 = Li.ERR_STREAM_CANNOT_PIPE, P6 = Li.ERR_STREAM_DESTROYED, C6 = Li.ERR_STREAM_NULL_VALUES, O6 = Li.ERR_STREAM_WRITE_AFTER_END, F6 = Li.ERR_UNKNOWN_ENCODING, ef = X0.errorOrDestroy;
    Ie()(ht, Sc);
    function U6() {
    }
    function Yf(t, e, r) {
      Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        V6(e, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var so2;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, { value: function(e) {
      return so2.call(this, e) ? true : this !== ht ? false : e && e._writableState instanceof Yf;
    } })) : so2 = function(e) {
      return e instanceof this;
    };
    function ht(t) {
      Qn = Qn || hn();
      var e = this instanceof Qn;
      if (!e && !so2.call(ht, this))
        return new ht(t);
      this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
    }
    ht.prototype.pipe = function() {
      ef(this, new D6);
    };
    function z6(t, e) {
      var r = new O6;
      ef(t, r), process.nextTick(e, r);
    }
    function H6(t, e, r, o) {
      var f;
      return r === null ? f = new C6 : typeof r != "string" && !e.objectMode && (f = new k6("chunk", ["string", "Buffer"], r)), f ? (ef(t, f), process.nextTick(o, f), false) : true;
    }
    ht.prototype.write = function(t, e, r) {
      var o = this._writableState, f = false, p2 = !o.objectMode && q6(t);
      return p2 && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p2 ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = U6), o.ending ? z6(this, r) : (p2 || H6(this, o, t, r)) && (o.pendingcb++, f = K6(this, o, p2, t, e, r)), f;
    };
    ht.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new F6(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
    }
    Object.defineProperty(ht.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e, r, o, f, p2) {
      if (!r) {
        var m = W6(e, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p2, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Y0(t, e, false, y, o, f, p2);
      return M;
    }
    function Y0(t, e, r, o, f, p2, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p2, e.onwrite), e.sync = false;
    }
    function j6(t, e, r, o, f) {
      --e.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef(t, o)) : (f(o), t._writableState.errorEmitted = true, ef(t, o), Gf(t, e));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new N6;
      if (Z6(r), e)
        j6(t, r, o, e, f);
      else {
        var p2 = Ac(r) || t.destroyed;
        !p2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o ? process.nextTick(_c, t, r, p2, f) : _c(t, r, p2, f);
      }
    }
    function _c(t, e, r, o) {
      r || $6(t, e), e.pendingcb--, o(), Gf(t, e);
    }
    function $6(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f = new Array(o), p2 = e.corkedRequestsFree;
        p2.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, Y0(t, e, true, e.length, f, "", p2.finish), e.pendingcb++, e.lastBufferedRequest = null, p2.next ? (e.corkedRequestsFree = p2.next, p2.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S } = r, E2 = e.objectMode ? 1 : M.length;
          if (Y0(t, e, false, E2, M, x, S), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht.prototype._write = function(t, e, r) {
      r(new L6("_write()"));
    };
    ht.prototype._writev = null;
    ht.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || X6(this, o, r), this;
    };
    Object.defineProperty(ht.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && ef(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
      });
    }
    function Y6(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e) {
      var r = Ac(e);
      if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e, r) {
      e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function J6(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e.pendingcb--, f(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht.prototype.destroy = X0.destroy;
    ht.prototype._undestroy = X0.undestroy;
    ht.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  hn = T((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    qc.exports = $r;
    var Bc = th(), eh = J0();
    Ie()($r, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r.prototype[lo] || ($r.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r(t) {
      if (!(this instanceof $r))
        return new $r(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  co = T((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function iM(t) {
      var e = rM(t);
      if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e = 4;
          break;
        case "utf8":
          this.fillLast = aM, e = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e, r) {
      var o = e.length - 1;
      if (o < r)
        return 0;
      var f = rh(e[o]);
      return f >= 0 ? (f > 0 && (t.lastNeed = f - 1), f) : --o < r || f === -2 ? 0 : (f = rh(e[o]), f >= 0 ? (f > 0 && (t.lastNeed = f - 2), f) : --o < r || f === -2 ? 0 : (f = rh(e[o]), f >= 0 ? (f > 0 && (f === 2 ? f = 0 : t.lastNeed = f - 3), f) : 0));
    }
    function fM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "\uFFFD";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "\uFFFD";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "\uFFFD";
      }
    }
    function aM(t) {
      var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e) {
      var r = nM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o), t.toString("utf8", e, o);
    }
    function sM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "\uFFFD" : e;
    }
    function hM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o = r.charCodeAt(r.length - 1);
          if (o >= 55296 && o <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function uM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function lM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function dM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn(co());
  });
  vo = T((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function bM() {
    }
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e, r) {
      if (typeof e == "function")
        return Lc(t, null, e);
      e || (e = {}), r = vM(r || bM);
      var o = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p2 = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S = function(L) {
        r.call(t, L);
      }, E2 = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new kc), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new kc), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return mM(t) ? (t.on("complete", y), t.on("abort", E2), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p2), t.on("close", p2)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S), t.on("close", E2), function() {
        t.removeListener("complete", y), t.removeListener("abort", E2), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p2), t.removeListener("close", p2), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S), t.removeListener("close", E2);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T((uI, Dc) => {
    var bo;
    function Ni(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var gM = vo(), Di = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi(t, e) {
      return { value: t, done: e };
    }
    function yM(t) {
      var e = t[Di];
      if (e !== null) {
        var r = t[dn].read();
        r !== null && (t[ln] = null, t[Di] = null, t[un] = null, e(Pi(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[mo]) {
            r(Pi(undefined, true));
            return;
          }
          e[nh](r, o);
        }, o);
      };
    }
    var _M = Object.getPrototypeOf(function() {
    }), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[ea] ? y(e[ea]) : m(Pi(undefined, true));
          });
        });
      var o = this[ln], f;
      if (o)
        f = new Promise(MM(o, this));
      else {
        var p2 = this[dn].read();
        if (p2 !== null)
          return Promise.resolve(Pi(p2, false));
        f = new Promise(this[nh]);
      }
      return this[ln] = f, f;
    } }, Ni(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni(bo, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[dn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Pi(undefined, true));
        });
      });
    }), bo), _M), SM = function(e) {
      var r, o = Object.create(xM, (r = {}, Ni(r, dn, { value: e, writable: true }), Ni(r, Di, { value: null, writable: true }), Ni(r, un, { value: null, writable: true }), Ni(r, ea, { value: null, writable: true }), Ni(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni(r, nh, { value: function(p2, m) {
        var y = o[dn].read();
        y ? (o[ln] = null, o[Di] = null, o[un] = null, p2(Pi(y, false))) : (o[Di] = p2, o[un] = m);
      }, writable: true }), r));
      return o[ln] = null, gM(e, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p2 = o[un];
          p2 !== null && (o[ln] = null, o[Di] = null, o[un] = null, p2(f)), o[ea] = f;
          return;
        }
        var m = o[Di];
        m !== null && (o[ln] = null, o[Di] = null, o[un] = null, m(Pi(undefined, true))), o[mo] = true;
      }), e.on("readable", wM.bind(null, o)), o;
    };
    Dc.exports = SM;
  });
  Oc = T((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T((cI, $c) => {
    $c.exports = Ce;
    var tf;
    Ce.ReadableState = Hc;
    var dI = ki().EventEmitter, zc = function(e, r) {
      return e.listeners(r).length;
    }, ra = W0(), go = Ut().Buffer, EM = global.Uint8Array || function() {
    };
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh = $f(), Ne;
    fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {
    };
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Hc(t, e, r) {
      tf = tf || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (tf = tf || hn(), !(this instanceof Ce))
        return new Ce(t);
      var e = this instanceof tf;
      this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce.prototype.destroy = dh.destroy;
    Ce.prototype._undestroy = dh.undestroy;
    Ce.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o = true), Wc(this, t, e, false, o);
    };
    Ce.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e, r, o, f) {
      Ne("readableAddChunk", e);
      var p2 = t._readableState;
      if (e === null)
        p2.reading = false, OM(t, p2);
      else {
        var m;
        if (f || (m = PM(p2, e)), m)
          ta(t, m);
        else if (p2.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p2.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o)
            p2.endEmitted ? ta(t, new NM) : hh(t, p2, e, true);
          else if (p2.ended)
            ta(t, new kM);
          else {
            if (p2.destroyed)
              return false;
            p2.reading = false, p2.decoder && !r ? (e = p2.decoder.write(e), p2.objectMode || e.length !== 0 ? hh(t, p2, e, false) : lh(t, p2)) : hh(t, p2, e, false);
          }
        else
          o || (p2.reading = false, lh(t, p2));
      }
      return !p2.ended && (p2.length < p2.highWaterMark || p2.length === 0);
    }
    function hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo(t)), lh(t, e);
    }
    function PM(t, e) {
      var r;
      return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur(Jf)).StringDecoder);
      var e = new rf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh(this) : wo(this), null;
      if (t = Uc(t, e), t === 0 && e.ended)
        return e.length === 0 && uh(this), null;
      var o = e.needReadable;
      Ne("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Ne("length less than watermark", o)), e.ended || e.reading ? (o = false, Ne("reading or ended", o)) : o && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc(r, e)));
      var f;
      return t > 0 ? f = Zc(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh(this)), f !== null && this.emit("data", f), f;
    };
    function OM(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? wo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
      }
    }
    function wo(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
    }
    function lh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
    }
    function FM(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, Ne("pipe count=%d opts=%j", o.pipesCount, e);
      var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p2 = f ? y : ge;
      o.endEmitted ? process.nextTick(p2) : r.once("end", p2), t.on("unpipe", m);
      function m(_e, N2) {
        Ne("onunpipe"), _e === r && N2 && N2.hasUnpiped === false && (N2.hasUnpiped = true, S());
      }
      function y() {
        Ne("onend"), t.end();
      }
      var M = UM(r);
      t.on("drain", M);
      var x = false;
      function S() {
        Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E2), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E2);
      function E2(_e) {
        Ne("ondata");
        var N2 = t.write(_e);
        Ne("dest.write", N2), N2 === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Vc(o.pipes, t) !== -1) && !x && (Ne("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        Ne("onerror", _e), ge(), t.removeListener("error", B), zc(t, "error") === 0 && ta(t, _e);
      }
      DM(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        Ne("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p2 = 0;p2 < f; p2++)
          o[p2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Vc(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e) {
      var r = ra.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Ne("on readable", o.length, o.reading), o.length ? wo(this) : o.reading || process.nextTick(zM, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e) {
      var r = ra.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
    };
    function jc(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
    }
    function WM(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (Ne("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p2 = 0;p2 < sh.length; p2++)
        t.on(sh[p2], this.emit.bind(this, sh[p2]));
      return this._read = function(m) {
        Ne("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce._fromList = Zc;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function uh(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
    }
    function KM(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e) {
      return oh === undefined && (oh = Oc()), oh(Ce, t, e);
    });
    function Vc(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  ph = T((pI, Yc) => {
    Yc.exports = di;
    var Mo = sn().codes, jM = Mo.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo.ERR_MULTIPLE_CALLBACK, VM = Mo.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di, _o);
    function GM(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function di(t) {
      if (!(this instanceof di))
        return new di(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Gc(t, e, r);
      }) : Gc(this, null, null);
    }
    di.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
    };
    di.prototype._transform = function(t, e, r) {
      r(new jM("_transform()"));
    };
    di.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    di.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    di.prototype._destroy = function(t, e) {
      _o.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Gc(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  np = T((bI, ip) => {
    var vh;
    function XM(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e, r, o) {
      o = XM(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p2 = false;
      return function(m) {
        if (!f && !p2) {
          if (p2 = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e) {
      return t.pipe(e);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = i4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new JM("streams");
      var f, p2 = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return t4(m, M, x, function(S) {
          f || (f = S), S && p2.forEach(tp), !M && (p2.forEach(tp), o(f));
        });
      });
      return e.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T((cr, fp) => {
    cr = fp.exports = th();
    cr.Stream = cr;
    cr.Readable = cr;
    cr.Writable = J0();
    cr.Duplex = hn();
    cr.Transform = ph();
    cr.PassThrough = Qc();
    cr.finished = vo();
    cr.pipeline = np();
  });
  bh = T((mI, sp) => {
    var xo = Te().Buffer, op2 = ap().Transform, f4 = Ie();
    function a4(t, e) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function Ci(t) {
      op2.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op2);
    Ci.prototype._transform = function(t, e, r) {
      var o = null;
      try {
        this.update(t, e);
      } catch (f) {
        o = f;
      }
      r(o);
    };
    Ci.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Ci.prototype.update = function(t, e) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e));
      for (var r = this._block, o = 0;this._blockOffset + t.length - o >= this._blockSize; ) {
        for (var f = this._blockOffset;f < this._blockSize; )
          r[f++] = t[o++];
        this._update(), this._blockOffset = 0;
      }
      for (;o < t.length; )
        r[this._blockOffset++] = t[o++];
      for (var p2 = 0, m = t.length * 8;m > 0; ++p2)
        this._length[p2] += m, m = this._length[p2] / 4294967296 | 0, m > 0 && (this._length[p2] -= 4294967296 * m);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T((gI, up) => {
    var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o = this._b, f = this._c, p2 = this._d;
      r = jt(r, o, f, p2, t[0], 3614090360, 7), p2 = jt(p2, r, o, f, t[1], 3905402710, 12), f = jt(f, p2, r, o, t[2], 606105819, 17), o = jt(o, f, p2, r, t[3], 3250441966, 22), r = jt(r, o, f, p2, t[4], 4118548399, 7), p2 = jt(p2, r, o, f, t[5], 1200080426, 12), f = jt(f, p2, r, o, t[6], 2821735955, 17), o = jt(o, f, p2, r, t[7], 4249261313, 22), r = jt(r, o, f, p2, t[8], 1770035416, 7), p2 = jt(p2, r, o, f, t[9], 2336552879, 12), f = jt(f, p2, r, o, t[10], 4294925233, 17), o = jt(o, f, p2, r, t[11], 2304563134, 22), r = jt(r, o, f, p2, t[12], 1804603682, 7), p2 = jt(p2, r, o, f, t[13], 4254626195, 12), f = jt(f, p2, r, o, t[14], 2792965006, 17), o = jt(o, f, p2, r, t[15], 1236535329, 22), r = Zt(r, o, f, p2, t[1], 4129170786, 5), p2 = Zt(p2, r, o, f, t[6], 3225465664, 9), f = Zt(f, p2, r, o, t[11], 643717713, 14), o = Zt(o, f, p2, r, t[0], 3921069994, 20), r = Zt(r, o, f, p2, t[5], 3593408605, 5), p2 = Zt(p2, r, o, f, t[10], 38016083, 9), f = Zt(f, p2, r, o, t[15], 3634488961, 14), o = Zt(o, f, p2, r, t[4], 3889429448, 20), r = Zt(r, o, f, p2, t[9], 568446438, 5), p2 = Zt(p2, r, o, f, t[14], 3275163606, 9), f = Zt(f, p2, r, o, t[3], 4107603335, 14), o = Zt(o, f, p2, r, t[8], 1163531501, 20), r = Zt(r, o, f, p2, t[13], 2850285829, 5), p2 = Zt(p2, r, o, f, t[2], 4243563512, 9), f = Zt(f, p2, r, o, t[7], 1735328473, 14), o = Zt(o, f, p2, r, t[12], 2368359562, 20), r = Vt(r, o, f, p2, t[5], 4294588738, 4), p2 = Vt(p2, r, o, f, t[8], 2272392833, 11), f = Vt(f, p2, r, o, t[11], 1839030562, 16), o = Vt(o, f, p2, r, t[14], 4259657740, 23), r = Vt(r, o, f, p2, t[1], 2763975236, 4), p2 = Vt(p2, r, o, f, t[4], 1272893353, 11), f = Vt(f, p2, r, o, t[7], 4139469664, 16), o = Vt(o, f, p2, r, t[10], 3200236656, 23), r = Vt(r, o, f, p2, t[13], 681279174, 4), p2 = Vt(p2, r, o, f, t[0], 3936430074, 11), f = Vt(f, p2, r, o, t[3], 3572445317, 16), o = Vt(o, f, p2, r, t[6], 76029189, 23), r = Vt(r, o, f, p2, t[9], 3654602809, 4), p2 = Vt(p2, r, o, f, t[12], 3873151461, 11), f = Vt(f, p2, r, o, t[15], 530742520, 16), o = Vt(o, f, p2, r, t[2], 3299628645, 23), r = $t(r, o, f, p2, t[0], 4096336452, 6), p2 = $t(p2, r, o, f, t[7], 1126891415, 10), f = $t(f, p2, r, o, t[14], 2878612391, 15), o = $t(o, f, p2, r, t[5], 4237533241, 21), r = $t(r, o, f, p2, t[12], 1700485571, 6), p2 = $t(p2, r, o, f, t[3], 2399980690, 10), f = $t(f, p2, r, o, t[10], 4293915773, 15), o = $t(o, f, p2, r, t[1], 2240044497, 21), r = $t(r, o, f, p2, t[8], 1873313359, 6), p2 = $t(p2, r, o, f, t[15], 4264355552, 10), f = $t(f, p2, r, o, t[6], 2734768916, 15), o = $t(o, f, p2, r, t[13], 1309151649, 21), r = $t(r, o, f, p2, t[4], 4149444226, 6), p2 = $t(p2, r, o, f, t[11], 3174756917, 10), f = $t(f, p2, r, o, t[2], 718787259, 15), o = $t(o, f, p2, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o | 0, this._c = this._c + f | 0, this._d = this._d + p2 | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt(t, e, r, o, f, p2, m) {
      return Eo(t + (e & r | ~e & o) + f + p2 | 0, m) + e | 0;
    }
    function Zt(t, e, r, o, f, p2, m) {
      return Eo(t + (e & o | r & ~o) + f + p2 | 0, m) + e | 0;
    }
    function Vt(t, e, r, o, f, p2, m) {
      return Eo(t + (e ^ r ^ o) + f + p2 | 0, m) + e | 0;
    }
    function $t(t, e, r, o, f, p2, m) {
      return Eo(t + (r ^ (e | ~o)) + f + p2 | 0, m) + e | 0;
    }
    up.exports = So;
  });
  Bo = T((yI, mp) => {
    var mh = Ut().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o = this._b | 0, f = this._c | 0, p2 = this._d | 0, m = this._e | 0, y = this._a | 0, M = this._b | 0, x = this._c | 0, S = this._d | 0, E2 = this._e | 0, B = 0;B < 80; B += 1) {
        var q, L;
        B < 16 ? (q = lp(r, o, f, p2, m, t[na[B]], sa[0], aa[B]), L = vp(y, M, x, S, E2, t[fa[B]], ha[0], oa[B])) : B < 32 ? (q = dp(r, o, f, p2, m, t[na[B]], sa[1], aa[B]), L = pp(y, M, x, S, E2, t[fa[B]], ha[1], oa[B])) : B < 48 ? (q = cp(r, o, f, p2, m, t[na[B]], sa[2], aa[B]), L = cp(y, M, x, S, E2, t[fa[B]], ha[2], oa[B])) : B < 64 ? (q = pp(r, o, f, p2, m, t[na[B]], sa[3], aa[B]), L = dp(y, M, x, S, E2, t[fa[B]], ha[3], oa[B])) : (q = vp(r, o, f, p2, m, t[na[B]], sa[4], aa[B]), L = lp(y, M, x, S, E2, t[fa[B]], ha[4], oa[B])), r = m, m = p2, p2 = cn(f, 10), f = o, o = q, y = E2, E2 = S, S = cn(x, 10), x = M, M = L;
      }
      var ge = this._b + f + S | 0;
      this._b = this._c + p2 + E2 | 0, this._c = this._d + m + y | 0, this._d = this._e + r + M | 0, this._e = this._a + o + x | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn(t, e) {
      return t << e | t >>> 32 - e;
    }
    function lp(t, e, r, o, f, p2, m, y) {
      return cn(t + (e ^ r ^ o) + p2 + m | 0, y) + f | 0;
    }
    function dp(t, e, r, o, f, p2, m, y) {
      return cn(t + (e & r | ~e & o) + p2 + m | 0, y) + f | 0;
    }
    function cp(t, e, r, o, f, p2, m, y) {
      return cn(t + ((e | ~r) ^ o) + p2 + m | 0, y) + f | 0;
    }
    function pp(t, e, r, o, f, p2, m, y) {
      return cn(t + (e & o | r & ~o) + p2 + m | 0, y) + f | 0;
    }
    function vp(t, e, r, o, f, p2, m, y) {
      return cn(t + (e ^ (r | ~o)) + p2 + m | 0, y) + f | 0;
    }
    mp.exports = Ro;
  });
  pn = T((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e) {
      this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
      for (var r = this._block, o = this._blockSize, f = t.length, p2 = this._len, m = 0;m < f; ) {
        for (var y = p2 % o, M = Math.min(f - m, o - y), x = 0;x < M; x++)
          r[y + x] = t[m + x];
        p2 += M, m += M, p2 % o === 0 && this._update(r);
      }
      return this._len += f, this;
    };
    qo.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o = (r & 4294967295) >>> 0, f = (r - o) / 4294967296;
        this._block.writeUInt32BE(f, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
      }
      this._update(this._block);
      var p2 = this._hash();
      return t ? p2.toString(t) : p2;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T((MI, Mp) => {
    var d4 = Ie(), wp = pn(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b4(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    ua.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p2 = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16];
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S = b4(r) + g4(x, o, f, p2) + m + e[M] + p4[x] | 0;
        m = p2, p2 = f, f = m4(o), o = r, r = S;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p2 + this._d | 0, this._e = m + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T((_I, Sp) => {
    var y4 = Ie(), xp = pn(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y4(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x4(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E4(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e, r, o) {
      return t === 0 ? e & r | ~e & o : t === 2 ? e & r | e & o | r & o : e ^ r ^ o;
    }
    la.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p2 = this._d | 0, m = this._e | 0, y = 0;y < 16; ++y)
        e[y] = t.readInt32BE(y * 4);
      for (;y < 80; ++y)
        e[y] = x4(e[y - 3] ^ e[y - 8] ^ e[y - 14] ^ e[y - 16]);
      for (var M = 0;M < 80; ++M) {
        var x = ~~(M / 20), S = S4(r) + A4(x, o, f, p2) + m + e[M] + M4[x] | 0;
        m = p2, p2 = f, f = E4(o), o = r, r = S;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p2 + this._d | 0, this._e = m + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T((xI, Rp) => {
    var R4 = Ie(), Ap = pn(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
    function da() {
      this.init(), this._w = I4, Ap.call(this, 64, 56);
    }
    R4(da, Ap);
    da.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function k4(t, e, r) {
      return t & e | r & (t | e);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N4(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P4(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o = this._b | 0, f = this._c | 0, p2 = this._d | 0, m = this._e | 0, y = this._f | 0, M = this._g | 0, x = this._h | 0, S = 0;S < 16; ++S)
        e[S] = t.readInt32BE(S * 4);
      for (;S < 64; ++S)
        e[S] = P4(e[S - 2]) + e[S - 7] + D4(e[S - 15]) + e[S - 16] | 0;
      for (var E2 = 0;E2 < 64; ++E2) {
        var B = x + N4(m) + T4(m, y, M) + q4[E2] + e[E2] | 0, q = L4(r) + k4(r, o, f) | 0;
        x = M, M = y, y = m, m = p2 + B | 0, p2 = f, f = o, o = r, r = B + q | 0;
      }
      this._a = r + this._a | 0, this._b = o + this._b | 0, this._c = f + this._c | 0, this._d = p2 + this._d | 0, this._e = m + this._e | 0, this._f = y + this._f | 0, this._g = M + this._g | 0, this._h = x + this._h | 0;
    };
    da.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da;
  });
  qp = T((SI, Bp) => {
    var C4 = Ie(), O4 = gh(), F4 = pn(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp.exports = Io;
  });
  yh = T((EI, Pp) => {
    var H4 = Ie(), Dp = pn(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
    function ca() {
      this.init(), this._w = K4, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function kp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Lp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Np(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function j4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function Z4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function V4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Pt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o = this._bh | 0, f = this._ch | 0, p2 = this._dh | 0, m = this._eh | 0, y = this._fh | 0, M = this._gh | 0, x = this._hh | 0, S = this._al | 0, E2 = this._bl | 0, B = this._cl | 0, q = this._dl | 0, L = this._el | 0, ge = this._fl | 0, _e = this._gl | 0, N2 = this._hl | 0, we = 0;we < 32; we += 2)
        e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye = e[we - 30], xe = e[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
        ye = e[we - 2 * 2], xe = e[we - 2 * 2 + 1];
        var Ae2 = V4(ye, xe), P = $4(xe, ye), Se2 = e[we - 7 * 2], v = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a = e[we - 16 * 2 + 1], h = Ee + v | 0, s = Re + Se2 + Pt(h, Ee) | 0;
        h = h + P | 0, s = s + Ae2 + Pt(h, P) | 0, h = h + a | 0, s = s + i + Pt(h, a) | 0, e[we] = s, e[we + 1] = h;
      }
      for (var u = 0;u < 160; u += 2) {
        s = e[u], h = e[u + 1];
        var c = kp(r, o, f), b = kp(S, E2, B), l = Lp(r, S), n = Lp(S, r), d = Np(m, L), w = Np(L, m), g = Ip[u], _ = Ip[u + 1], A = Tp(m, y, M), R = Tp(L, ge, _e), I = N2 + w | 0, Me = x + d + Pt(I, N2) | 0;
        I = I + R | 0, Me = Me + A + Pt(I, R) | 0, I = I + _ | 0, Me = Me + g + Pt(I, _) | 0, I = I + h | 0, Me = Me + s + Pt(I, h) | 0;
        var k = n + b | 0, D = l + c + Pt(k, n) | 0;
        x = M, N2 = _e, M = y, _e = ge, y = m, ge = L, L = q + I | 0, m = p2 + Me + Pt(L, q) | 0, p2 = f, q = B, f = o, B = E2, o = r, E2 = S, S = I + k | 0, r = Me + D + Pt(S, I) | 0;
      }
      this._al = this._al + S | 0, this._bl = this._bl + E2 | 0, this._cl = this._cl + B | 0, this._dl = this._dl + q | 0, this._el = this._el + L | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e | 0, this._hl = this._hl + N2 | 0, this._ah = this._ah + r + Pt(this._al, S) | 0, this._bh = this._bh + o + Pt(this._bl, E2) | 0, this._ch = this._ch + f + Pt(this._cl, B) | 0, this._dh = this._dh + p2 + Pt(this._dl, q) | 0, this._eh = this._eh + m + Pt(this._el, L) | 0, this._fh = this._fh + y + Pt(this._fl, ge) | 0, this._gh = this._gh + M + Pt(this._gl, _e) | 0, this._hh = this._hh + x + Pt(this._hl, N2) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn(), J4 = Te().Buffer, Q4 = new Array(160);
    function To() {
      this.init(), this._w = Q4, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e(r, o, f) {
        t.writeInt32BE(r, f), t.writeInt32BE(o, f + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T((ci, Fp) => {
    var ci = Fp.exports = function(e) {
      e = e.toLowerCase();
      var r = ci[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    ci.sha = _p();
    ci.sha1 = Ep();
    ci.sha224 = qp();
    ci.sha256 = gh();
    ci.sha384 = Op();
    ci.sha512 = yh();
  });
  Tt = T((RI, Up) => {
    Up.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr = T((BI, Mh) => {
    var e_ = Ut(), t_ = Object.getPrototypeOf(async function() {
    }).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
      return e instanceof zp;
    } : function(e) {
      return false;
    }, wh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o = 0;o < e.length; o++)
          r += `    ${e[o].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o, f) => {
        t = o, e = f;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o, ...f) => o ? r(o) : e(...f));
      });
    }, debuglog() {
      return function() {
      };
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o]) {
        let f = e.shift();
        return o === "f" ? f.toFixed(6) : o === "j" ? JSON.stringify(f) : o === "s" && typeof f == "object" ? `${f.constructor !== Object ? f.constructor.name : ""} {}`.trim() : f.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e);
    }
    function Wp(t) {
      let e = "", r = t.length, o = t[0] === "-" ? 1 : 0;
      for (;r >= o + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function l_(t, e, r) {
      if (typeof e == "function")
        return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o = (e.match(/%[dfijoOs]/g) || []).length;
      return vn(o === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o}).`), r.length === 0 ? e : n_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o extends r {
        constructor(...p2) {
          super(l_(t, e, p2));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o.prototype.code = t, o.prototype[o_] = true, Po[t] = o;
    }
    function Kp(t) {
      let e = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function d_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new a_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var _h = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o = "The ";
      t.endsWith(" argument") ? o += `${t} ` : o += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o += "must be ";
      let f = [], p2 = [], m = [];
      for (let M of e)
        vn(typeof M == "string", "All expected entries have to be of type string"), s_.includes(M) ? f.push(M.toLowerCase()) : h_.test(M) ? p2.push(M) : (vn(M !== "object", 'The value "object" should be written as "Object"'), m.push(M));
      if (p2.length > 0) {
        let M = f.indexOf("object");
        M !== -1 && (f.splice(f, M, 1), p2.push("Object"));
      }
      if (f.length > 0) {
        switch (f.length) {
          case 1:
            o += `of type ${f[0]}`;
            break;
          case 2:
            o += `one of type ${f[0]} or ${f[1]}`;
            break;
          default: {
            let M = f.pop();
            o += `one of type ${f.join(", ")}, or ${M}`;
          }
        }
        (p2.length > 0 || m.length > 0) && (o += " or ");
      }
      if (p2.length > 0) {
        switch (p2.length) {
          case 1:
            o += `an instance of ${p2[0]}`;
            break;
          case 2:
            o += `an instance of ${p2[0]} or ${p2[1]}`;
            break;
          default: {
            let M = p2.pop();
            o += `an instance of ${p2.join(", ")}, or ${M}`;
          }
        }
        m.length > 0 && (o += " or ");
      }
      switch (m.length) {
        case 0:
          break;
        case 1:
          m[0].toLowerCase() !== m[0] && (o += "an "), o += `${m[0]}`;
          break;
        case 2:
          o += `one of ${m[0]} or ${m[1]}`;
          break;
        default: {
          let M = m.pop();
          o += `one of ${m.join(", ")}, or ${M}`;
        }
      }
      if (r == null)
        o += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y;
        (y = r.constructor) !== null && y !== undefined && y.name ? o += `. Received an instance of ${r.constructor.name}` : o += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M = Do(r, { colors: false });
        M.length > 25 && (M = `${M.slice(0, 25)}...`), o += `. Received type ${typeof r} (${M})`;
      }
      return o;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o = Do(e);
      return o.length > 128 && (o = o.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o;
      let f = r != null && (o = r.constructor) !== null && o !== undefined && o.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o) => `"${o}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o = t.pop();
            e += `The ${t.join(", ")}, and ${o} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      vn(e, 'Missing "range" argument');
      let o;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = Wp(String(r)) : typeof r == "bigint" ? (o = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o = Wp(o)), o += "n") : o = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
  });
  pa = T((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt(), { hideStackFrames: Ir, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr().types, Vp = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e), t;
    }
    var k_ = Ir((t, e, r = b_, o = v_) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), L_ = Ir((t, e, r = -2147483648, o = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o)
        throw new bn(e, `>= ${r} && <= ${o}`, t);
    }), Xp = Ir((t, e, r = false) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      let o = r ? 1 : 0, f = 4294967295;
      if (t < o || t > f)
        throw new bn(e, `>= ${o} && <= ${f}`, t);
    });
    function Jp(t, e) {
      if (typeof t != "string")
        throw new tr(e, "string", t);
    }
    function N_(t, e, r = undefined, o) {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (r != null && t < r || o != null && t > o || (r != null || o != null) && p_(t))
        throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o != null ? " && " : ""}${o != null ? `<= ${o}` : ""}`, t);
    }
    var D_ = Ir((t, e, r) => {
      if (!Gp(r, t)) {
        let o = Yp(c_(r, (p2) => typeof p2 == "string" ? `'${p2}'` : w_(p2)), ", "), f = "must be one of: " + o;
        throw new Co(e, t, f);
      }
    });
    function P_(t, e) {
      if (typeof t != "boolean")
        throw new tr(e, "boolean", t);
    }
    function xh(t, e, r) {
      return t == null || !g_(t, e) ? r : t[e];
    }
    var C_ = Ir((t, e, r = null) => {
      let o = xh(r, "allowArray", false), f = xh(r, "allowFunction", false);
      if (!xh(r, "nullable", false) && t === null || !o && $p(t) || typeof t != "object" && (!f || typeof t != "function"))
        throw new tr(e, "Object", t);
    }), O_ = Ir((t, e, r = 0) => {
      if (!$p(t))
        throw new tr(e, "Array", t);
      if (t.length < r) {
        let o = `must be longer than ${r}`;
        throw new Co(e, t, o);
      }
    });
    function F_(t, e = "signal") {
      if (Jp(t, e), Vp[t] === undefined)
        throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir((t, e = "buffer") => {
      if (!A_(t))
        throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e) {
      let r = S_(e), o = t.length;
      if (r === "hex" && o % 2 !== 0)
        throw new Co("encoding", e, `is invalid for data of length ${o}`);
    }
    function H_(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e, t, r);
      return t | 0;
    }
    var W_ = Ir((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e, "AbortSignal", t);
    }), K_ = Ir((t, e) => {
      if (typeof t != "function")
        throw new tr(e, "Function", t);
    }), j_ = Ir((t, e) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e, "Function", t);
    }), Z_ = Ir((t, e) => {
      if (t !== undefined)
        throw new tr(e, "undefined", t);
    });
    function V_(t, e, r) {
      if (!Gp(r, t))
        throw new tr(e, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T((kI, i1) => {
    var dt2 = i1.exports = {}, Yr, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
      } catch {
        Yr = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Eh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi = mn.concat(pi) : Oo = -1, pi.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e = pi.length;e; ) {
          for (mn = pi, pi = [];++Oo < e; )
            mn && mn[Oo].run();
          Oo = -1, e = pi.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt2.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      pi.push(new r1(t, e)), pi.length === 1 && !nf && e1(t1);
    };
    function r1(t, e) {
      this.fun = t, this.array = e;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt2.title = "browser";
    dt2.browser = true;
    dt2.env = {};
    dt2.argv = [];
    dt2.version = "";
    dt2.versions = {};
    function vi() {
    }
    dt2.on = vi;
    dt2.addListener = vi;
    dt2.once = vi;
    dt2.off = vi;
    dt2.removeListener = vi;
    dt2.removeAllListeners = vi;
    dt2.emit = vi;
    dt2.prependListener = vi;
    dt2.prependOnceListener = vi;
    dt2.listeners = function(t) {
      return [];
    };
    dt2.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt2.cwd = function() {
      return "/";
    };
    dt2.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt2.umask = function() {
      return 0;
    };
  });
  pr = {};
  Ja(pr, { default: () => Y_ });
  Oi = R0(() => {
    ot(pr, rn(Rh()));
    Y_ = rn(Rh());
  });
  Fi = T((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e) {
      return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !!(t.destroyed || t[a1] || o != null && o.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function Q_(t, e) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function u1(t, e) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e) {
      return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function i8(t) {
      var e, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o = e || r;
      return !o && p1(t) || !!(o && o.autoDestroy && o.emitClose && o.closed === false);
    }
    function o8(t) {
      var e;
      return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e, r, o, f, p2, m, y, M, x, S;
      return !!(t && ((e = (r = (o = (f = (p2 = (m = t[o1]) !== null && m !== undefined ? m : t.readableErrored) !== null && p2 !== undefined ? p2 : t.writableErrored) !== null && f !== undefined ? f : (y = t._readableState) === null || y === undefined ? undefined : y.errorEmitted) !== null && o !== undefined ? o : (M = t._writableState) === null || M === undefined ? undefined : M.errorEmitted) !== null && r !== undefined ? r : (x = t._readableState) === null || x === undefined ? undefined : x.errored) !== null && e !== undefined ? e : (S = t._writableState) === null || S === undefined ? undefined : S.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T((DI, Ih) => {
    var ff = (Oi(), ur(pr)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {
    };
    function S1(t, e, r) {
      var o, f;
      arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
      let p2 = (o = e.readable) !== null && o !== undefined ? o : qh(t), m = (f = e.writable) !== null && f !== undefined ? f : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y, _readableState: M } = t, x = () => {
        t.writable || B();
      }, S = w8(t) && qh(t) === p2 && _1(t) === m, E2 = x1(t, false), B = () => {
        E2 = true, t.destroyed && (S = false), !(S && (!t.readable || p2)) && (!p2 || q) && r.call(t);
      }, q = w1(t, false), L = () => {
        q = true, t.destroyed && (S = false), !(S && (!t.writable || m)) && (!m || E2) && r.call(t);
      }, ge = (xe) => {
        r.call(t, xe);
      }, _e = b8(t), N2 = () => {
        _e = true;
        let xe = g8(t) || m8(t);
        if (xe && typeof xe != "boolean")
          return r.call(t, xe);
        if (p2 && !q && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m && !E2 && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B);
      };
      M8(t) ? (t.on("complete", B), S || t.on("abort", N2), t.req ? we() : t.on("request", we)) : m && !y && (t.on("end", x), t.on("close", x)), !S && typeof t.aborted == "boolean" && t.on("aborted", N2), t.on("end", L), t.on("finish", B), e.error !== false && t.on("error", ge), t.on("close", N2), _e ? ff.nextTick(N2) : y != null && y.errorEmitted || M != null && M.errorEmitted ? S || ff.nextTick(N2) : (!p2 && (!S || y1(t)) && (E2 || M1(t) === false) || !m && (!S || M1(t)) && (q || y1(t) === false) || M && t.req && t.aborted) && ff.nextTick(N2);
      let ye = () => {
        r = _8, t.removeListener("aborted", N2), t.removeListener("complete", B), t.removeListener("abort", N2), t.removeListener("request", we), t.req && t.req.removeListener("finish", B), t.removeListener("end", x), t.removeListener("close", x), t.removeListener("finish", B), t.removeListener("end", L), t.removeListener("error", ge), t.removeListener("close", N2);
      };
      if (e.signal && !_e) {
        let xe = () => {
          let Re = r;
          ye(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          ff.nextTick(xe);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
          }), e.signal.addEventListener("abort", xe);
        }
      }
      return ye;
    }
    function x8(t, e) {
      return new v8((r, o) => {
        S1(t, e, (f) => {
          f ? o(f) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k12 = T((PI, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f, p2;
        let m = new B1, y = this, M = [], x = m.signal, S = { signal: x }, E2 = () => m.abort();
        e != null && (f = e.signal) !== null && f !== undefined && f.aborted && E2(), e == null || (p2 = e.signal) === null || p2 === undefined || p2.addEventListener("abort", E2);
        let B, q, L = false;
        function ge() {
          L = true;
        }
        async function _e() {
          try {
            for await (let ye of y) {
              var N2;
              if (L)
                return;
              if (x.aborted)
                throw new Jr;
              try {
                ye = t(ye, S);
              } catch (xe) {
                ye = A1(xe);
              }
              ye !== Wo && (typeof ((N2 = ye) === null || N2 === undefined ? undefined : N2.catch) == "function" && ye.catch(ge), M.push(ye), B && (B(), B = null), !L && M.length && M.length >= r && await new E1((xe) => {
                q = xe;
              }));
            }
            M.push(R1);
          } catch (ye) {
            let xe = A1(ye);
            L8(xe, undefined, ge), M.push(xe);
          } finally {
            var we;
            L = true, B && (B(), B = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E2);
          }
        }
        _e();
        try {
          for (;; ) {
            for (;M.length > 0; ) {
              let N2 = await M[0];
              if (N2 === R1)
                return;
              if (x.aborted)
                throw new Jr;
              N2 !== Wo && (yield N2), M.shift(), q && (q(), q = null);
            }
            await new E1((N2) => {
              B = N2;
            });
          }
        } finally {
          m.abort(), L = true, q && (q(), q = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f of this) {
          var o;
          if (t != null && (o = t.signal) !== null && o !== undefined && o.aborted)
            throw new Jr({ cause: t.signal.reason });
          yield [r++, f];
        }
      }.call(this);
    }
    async function I1(t, e = undefined) {
      for await (let r of kh.call(this, t, e))
        return true;
      return false;
    }
    async function D8(t, e = undefined) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e);
    }
    async function P8(t, e) {
      for await (let r of kh.call(this, t, e))
        return r;
    }
    async function C8(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f), Wo;
      }
      for await (let o of Ko.call(this, r, e))
        ;
    }
    function kh(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o, f) {
        return await t(o, f) ? o : Wo;
      }
      return Ko.call(this, r, e);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e, r) {
      var o;
      if (typeof t != "function")
        throw new va("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f = arguments.length > 1;
      if (r != null && (o = r.signal) !== null && o !== undefined && o.aborted) {
        let x = new Jr(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {
        }), await B8(this.destroy(x)), x;
      }
      let p2 = new B1, m = p2.signal;
      if (r != null && r.signal) {
        let x = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p2.abort(), x);
      }
      let y = false;
      try {
        for await (let x of this) {
          var M;
          if (y = true, r != null && (M = r.signal) !== null && M !== undefined && M.aborted)
            throw new Jr;
          f ? e = await t(e, x, { signal: m }) : (e = x, f = true);
        }
        if (!y && !f)
          throw new Th;
      } finally {
        p2.abort();
      }
      return e;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e = [];
      for await (let o of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr(undefined, { cause: t.signal.reason });
        q8(e, o);
      }
      return e;
    }
    function U8(t, e) {
      let r = Ko.call(this, t, e);
      return async function* () {
        for await (let f of r)
          yield* f;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p2 of this) {
          var f;
          if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          t-- <= 0 && (yield p2);
        }
      }.call(this);
    }
    function H8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o;
        if (e != null && (o = e.signal) !== null && o !== undefined && o.aborted)
          throw new Jr;
        for await (let p2 of this) {
          var f;
          if (e != null && (f = e.signal) !== null && f !== undefined && f.aborted)
            throw new Jr;
          if (t-- > 0)
            yield p2;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn = T((CI, U1) => {
    var zi = (Oi(), ur(pr)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e) {
      let r = this._readableState, o = this._writableState, f = o || r;
      return o && o.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o, r), o && (o.destroyed = true), r && (r.destroyed = true), f.constructed ? L1(this, t, e) : this.once(P1, function(p2) {
        L1(this, W8(p2, t), e);
      }), this);
    }
    function L1(t, e, r) {
      let o = false;
      function f(p2) {
        if (o)
          return;
        o = true;
        let { _readableState: m, _writableState: y } = t;
        C1(p2, y, m), y && (y.closed = true), m && (m.closed = true), typeof r == "function" && r(p2), p2 ? zi.nextTick(X8, t, p2) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e || null, f);
      } catch (p2) {
        f(p2);
      }
    }
    function X8(t, e) {
      Dh(t, e), O1(t);
    }
    function O1(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
    }
    function Dh(t, e) {
      let { _readableState: r, _writableState: o } = t;
      o && o.errorEmitted || r && r.errorEmitted || (o && (o.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function J8() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Ph(t, e, r) {
      let { _readableState: o, _writableState: f } = t;
      if (f && f.destroyed || o && o.destroyed)
        return this;
      o && o.autoDestroy || f && f.autoDestroy ? t.destroy(e) : e && (e.stack, f && !f.errored && (f.errored = e), o && !o.errored && (o.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
    }
    function Q8(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o } = t;
      r && (r.constructed = false), o && (o.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e = false;
      function r(o) {
        if (e) {
          Ph(t, o ?? new K8);
          return;
        }
        e = true;
        let { _readableState: f, _writableState: p2 } = t, m = p2 || f;
        f && (f.constructed = true), p2 && (p2.constructed = true), m.destroyed ? t.emit(P1, o) : o ? Ph(t, o, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o) {
        r(o);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e) {
      t.emit("error", e), zi.nextTick(F1, t);
    }
    function i5(t, e) {
      !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e) {
      let r = this;
      function o(S) {
        t.writable && t.write(S) === false && r.pause && r.pause();
      }
      r.on("data", o);
      function f() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f), !t._isStdio && (!e || e.end !== false) && (r.on("end", m), r.on("close", y));
      let p2 = false;
      function m() {
        p2 || (p2 = true, t.end());
      }
      function y() {
        p2 || (p2 = true, typeof t.destroy == "function" && t.destroy());
      }
      function M(S) {
        x(), jo.listenerCount(this, "error") === 0 && this.emit("error", S);
      }
      Ch(r, "error", M), Ch(t, "error", M);
      function x() {
        r.removeListener("data", o), t.removeListener("drain", f), r.removeListener("end", m), r.removeListener("close", y), r.removeListener("error", M), t.removeListener("error", M), r.removeListener("end", x), r.removeListener("close", x), t.removeListener("close", x);
      }
      return r.on("end", x), r.on("close", x), t.on("close", x), t.emit("pipe", r), t;
    };
    function Ch(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e, r) {
      if (s5(e, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = () => {
        e.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  Z1 = T((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt(), { Buffer: Oh } = Ut(), { inspect: d5 } = Gr();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o = "" + r.data;
        for (;(r = r.next) !== null; )
          o += e + r.data;
        return o;
      }
      concat(e) {
        if (this.length === 0)
          return Oh.alloc(0);
        let r = Oh.allocUnsafe(e >>> 0), o = this.head, f = 0;
        for (;o; )
          Yo(r, o.data, f), f += o.data.length, o = o.next;
        return r;
      }
      consume(e, r) {
        let o = this.head.data;
        if (e < o.length) {
          let f = o.slice(0, e);
          return this.head.data = o.slice(e), f;
        }
        return e === o.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o = this.head, f = 0;
        do {
          let p2 = o.data;
          if (e > p2.length)
            r += p2, e -= p2.length;
          else {
            e === p2.length ? (r += p2, ++f, o.next ? this.head = o.next : this.head = this.tail = null) : (r += K1(p2, 0, e), this.head = o, o.data = K1(p2, e));
            break;
          }
          ++f;
        } while ((o = o.next) !== null);
        return this.length -= f, r;
      }
      _getBuffer(e) {
        let r = Oh.allocUnsafe(e), o = e, f = this.head, p2 = 0;
        do {
          let m = f.data;
          if (e > m.length)
            Yo(r, m, o - e), e -= m.length;
          else {
            e === m.length ? (Yo(r, m, o - e), ++p2, f.next ? this.head = f.next : this.head = this.tail = null) : (Yo(r, new l5(m.buffer, m.byteOffset, e), o - e), this.head = f, f.data = m.slice(e));
            break;
          }
          ++p2;
        } while ((f = f.next) !== null);
        return this.length -= p2, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b5(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e, r, o) {
      let f = b5(e, o, r);
      if (f != null) {
        if (!p5(f) || f < 0) {
          let p2 = o ? `options.${r}` : "options.highWaterMark";
          throw new v5(p2, f);
        }
        return c5(f);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T((WI, J1) => {
    var G1 = (Oi(), ur(pr)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt(), { Buffer: y5 } = Ut(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e, r) {
      let o;
      if (typeof e == "string" || e instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f;
      if (e && e[Y1])
        f = true, o = e[Y1]();
      else if (e && e[X1])
        f = false, o = e[X1]();
      else
        throw new w5("iterable", ["Iterable"], e);
      let p2 = new t({ objectMode: true, highWaterMark: 1, ...r }), m = false;
      p2._read = function() {
        m || (m = true, M());
      }, p2._destroy = function(x, S) {
        g5(y(x), () => G1.nextTick(S, x), (E2) => G1.nextTick(S, E2 || x));
      };
      async function y(x) {
        let S = x != null, E2 = typeof o.throw == "function";
        if (S && E2) {
          let { value: B, done: q } = await o.throw(x);
          if (await B, q)
            return;
        }
        if (typeof o.return == "function") {
          let { value: B } = await o.return();
          await B;
        }
      }
      async function M() {
        for (;; ) {
          try {
            let { value: x, done: S } = f ? await o.next() : o.next();
            if (S)
              p2.push(null);
            else {
              let E2 = x && typeof x.then == "function" ? await x : x;
              if (E2 === null)
                throw m = false, new M5;
              if (p2.push(E2))
                continue;
              m = false;
            }
          } catch (x) {
            p2.destroy(x);
          }
          break;
        }
      }
      return p2;
    }
    J1.exports = _5;
  });
  ba = T((KI, lv) => {
    var Tr = (Oi(), ur(pr)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E5, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe2 = Gr().debuglog("stream", (t) => {
      Pe2 = t;
    }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi.prototype);
    rv(Le, Hi);
    var zh = () => {
    }, { errorOrDestroy: sf } = hf;
    function jh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof Qr();
      this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N5(t.signal, this)), Hi.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return nv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return nv(this, t, e, true);
    };
    function nv(t, e, r, o) {
      Pe2("readableAddChunk", e);
      let f = t._readableState, p2;
      if (f.objectMode || (typeof e == "string" ? (r = r || f.defaultEncoding, f.encoding !== r && (o && f.encoding ? e = Uh.from(e, r).toString(f.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi._isUint8Array(e) ? (e = Hi._uint8ArrayToBuffer(e), r = "") : e != null && (p2 = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p2)
        sf(t, p2);
      else if (e === null)
        f.reading = false, $5(t, f);
      else if (f.objectMode || e && e.length > 0)
        if (o)
          if (f.endEmitted)
            sf(t, new W5);
          else {
            if (f.destroyed || f.errored)
              return false;
            Hh(t, f, e, true);
          }
        else if (f.ended)
          sf(t, new H5);
        else {
          if (f.destroyed || f.errored)
            return false;
          f.reading = false, f.decoder && !r ? (e = f.decoder.write(e), f.objectMode || e.length !== 0 ? Hh(t, f, e, false) : Jo(t, f)) : Hh(t, f, e, false);
        }
      else
        o || (f.reading = false, Jo(t, f));
      return !f.ended && (f.length < f.highWaterMark || f.length === 0);
    }
    function Hh(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo(t)), Jo(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new iv(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o = "";
      for (let f of r)
        o += e.write(f);
      return r.clear(), o !== "" && r.push(o), this._readableState.length = o.length, this;
    };
    var Z5 = 1073741824;
    function V5(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E5(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe2("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = V5(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe2("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo(this), null;
      if (t = ev(t, e), t === 0 && e.ended)
        return e.length === 0 && Wh(this), null;
      let o = e.needReadable;
      if (Pe2("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, Pe2("length less than watermark", o)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o = false, Pe2("reading, ended or constructing", o);
      else if (o) {
        Pe2("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p2) {
          sf(this, p2);
        }
        e.sync = false, e.reading || (t = ev(r, e));
      }
      let f;
      return t > 0 ? f = hv(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f)), f;
    };
    function $5(t, e) {
      if (Pe2("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Qo(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
      }
    }
    function Qo(t) {
      let e = t._readableState;
      Pe2("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe2("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e = t._readableState;
      Pe2("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
    }
    function Jo(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
    }
    function G5(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (Pe2("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o = this._readableState;
      o.pipes.length === 1 && (o.multiAwaitDrain || (o.multiAwaitDrain = true, o.awaitDrainWriters = new q5(o.awaitDrainWriters ? [o.awaitDrainWriters] : []))), o.pipes.push(t), Pe2("pipe count=%d opts=%j", o.pipes.length, e);
      let p2 = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y : _e;
      o.endEmitted ? Tr.nextTick(p2) : r.once("end", p2), t.on("unpipe", m);
      function m(N2, we) {
        Pe2("onunpipe"), N2 === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S());
      }
      function y() {
        Pe2("onend"), t.end();
      }
      let M, x = false;
      function S() {
        Pe2("cleanup"), t.removeListener("close", L), t.removeListener("finish", ge), M && t.removeListener("drain", M), t.removeListener("error", q), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", _e), r.removeListener("data", B), x = true, M && o.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M();
      }
      function E2() {
        x || (o.pipes.length === 1 && o.pipes[0] === t ? (Pe2("false write response, pause", 0), o.awaitDrainWriters = t, o.multiAwaitDrain = false) : o.pipes.length > 1 && o.pipes.includes(t) && (Pe2("false write response, pause", o.awaitDrainWriters.size), o.awaitDrainWriters.add(t)), r.pause()), M || (M = Y5(r, t), t.on("drain", M));
      }
      r.on("data", B);
      function B(N2) {
        Pe2("ondata");
        let we = t.write(N2);
        Pe2("dest.write", we), we === false && E2();
      }
      function q(N2) {
        if (Pe2("onerror", N2), _e(), t.removeListener("error", q), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N2) : t.emit("error", N2);
        }
      }
      L5(t, "error", q);
      function L() {
        t.removeListener("finish", ge), _e();
      }
      t.once("close", L);
      function ge() {
        Pe2("onfinish"), t.removeListener("close", L), _e();
      }
      t.once("finish", ge);
      function _e() {
        Pe2("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o.flowing && E2() : o.flowing || (Pe2("pipe resume"), r.resume()), t;
    };
    function Y5(t, e) {
      return function() {
        let o = t._readableState;
        o.awaitDrainWriters === e ? (Pe2("pipeOnDrain", 1), o.awaitDrainWriters = null) : o.multiAwaitDrain && (Pe2("pipeOnDrain", o.awaitDrainWriters.size), o.awaitDrainWriters.delete(e)), (!o.awaitDrainWriters || o.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f = e.pipes;
        e.pipes = [], this.pause();
        for (let p2 = 0;p2 < f.length; p2++)
          f[p2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o = x5(e.pipes, t);
      return o === -1 ? this : (e.pipes.splice(o, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Hi.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, Pe2("on readable", o.length, o.reading), o.length ? Qo(this) : o.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Hi.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Hi.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
    };
    function av(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function X5(t) {
      Pe2("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe2("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
    }
    function Q5(t, e) {
      Pe2("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e = t._readableState;
      for (Pe2("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o) => {
        !this.push(o) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o) => {
        sf(this, o);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = R5(t);
      for (let o = 1;o < r.length; o++) {
        let f = r[o];
        this[f] === undefined && typeof t[f] == "function" && (this[f] = t[f].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e);
      return r.stream = t, r;
    }
    async function* ex(t, e) {
      let r = zh;
      function o(m) {
        this === t ? (r(), r = zh) : r = m;
      }
      t.on("readable", o);
      let f, p2 = D5(t, { writable: false }, (m) => {
        f = m ? Q1(f, m) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m = t.destroyed ? null : t.read();
          if (m !== null)
            yield m;
          else {
            if (f)
              throw f;
            if (f === null)
              return;
            await new B5(o);
          }
        }
      } catch (m) {
        throw f = Q1(f, m), f;
      } finally {
        (f || e?.destroyOnReturn !== false) && (f === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o), p2());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wh(t) {
      let e = t._readableState;
      Pe2("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
    }
    function tx(t, e) {
      if (Pe2("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(rx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return j5(Le, t, e);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e) {
      return uv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return uv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o;
      return new Le({ objectMode: (r = (o = t.readableObjectMode) !== null && o !== undefined ? o : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f, p2) {
        hf.destroyer(t, f), p2(f);
      } }).wrap(t);
    };
  });
  Jh = T((jI, xv) => {
    var Mn = (Oi(), ur(pr)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt();
    xv.exports = st2;
    st2.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st2.prototype, ma.prototype);
    mv(st2, ma);
    function $h() {
    }
    var lf = ax("kOnFinished");
    function ya(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st2(t) {
      let e = this instanceof Qr();
      if (!e && !vv(st2, this))
        return new st2(t);
      this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st2, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st2 ? false : t && t._writableState instanceof ya;
    } });
    st2.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e, r, o) {
      let f = t._writableState;
      if (typeof r == "function")
        o = r, r = f.defaultEncoding;
      else {
        if (!r)
          r = f.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o != "function" && (o = $h);
      }
      if (e === null)
        throw new bx;
      if (!f.objectMode)
        if (typeof e == "string")
          f.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
        else if (e instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e))
          e = ma._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p2;
      return f.ending ? p2 = new mx : f.destroyed && (p2 = new ga("write")), p2 ? (Mn.nextTick(o, p2), uf(t, p2, true), p2) : (f.pendingcb++, gx(t, f, e, r, o));
    }
    st2.prototype.write = function(t, e, r) {
      return wv(this, t, e, r) === true;
    };
    st2.prototype.cork = function() {
      this._writableState.corked++;
    };
    st2.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st2.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
        throw new yv(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function gx(t, e, r, o, f) {
      let p2 = e.objectMode ? 1 : r.length;
      e.length += p2;
      let m = e.length < e.highWaterMark;
      return m || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o, callback: f }), e.allBuffers && o !== "buffer" && (e.allBuffers = false), e.allNoop && f !== $h && (e.allNoop = false)) : (e.writelen = p2, e.writecb = f, e.writing = true, e.sync = true, t._write(r, o, e.onwrite), e.sync = false), m && !e.errored && !e.destroyed;
    }
    function dv(t, e, r, o, f, p2, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p2, e.onwrite), e.sync = false;
    }
    function cv(t, e, r, o) {
      --e.pendingcb, o(r), Gh(e), uf(t, r);
    }
    function yx(t, e) {
      let r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o ? Mn.nextTick(cv, t, r, e, f) : cv(t, r, e, f)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f));
    }
    function wx({ stream: t, state: e, count: r, cb: o }) {
      return e.afterWriteTickInfo = null, Mv(t, e, r, o);
    }
    function Mv(t, e, r, o) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o();
      e.destroyed && Gh(e), Xh(t, e);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f = t.bufferedIndex;f < t.buffered.length; ++f) {
        var e;
        let { chunk: p2, callback: m } = t.buffered[f], y = t.objectMode ? 1 : p2.length;
        t.length -= y, m((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f = 0;f < r.length; f++) {
        var o;
        r[f]((o = t.errored) !== null && o !== undefined ? o : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o, objectMode: f } = e, p2 = r.length - o;
      if (!p2)
        return;
      let m = o;
      if (e.bufferProcessing = true, p2 > 1 && t._writev) {
        e.pendingcb -= p2 - 1;
        let y = e.allNoop ? $h : (x) => {
          for (let S = m;S < r.length; ++S)
            r[S].callback(x);
        }, M = e.allNoop && m === 0 ? r : pv(r, m);
        M.allBuffers = e.allBuffers, dv(t, e, true, e.length, M, "", y), rs(e);
      } else {
        do {
          let { chunk: y, encoding: M, callback: x } = r[m];
          r[m++] = null;
          let S = f ? 1 : y.length;
          dv(t, e, false, S, y, M, x);
        } while (m < r.length && !e.writing);
        m === r.length ? rs(e) : m > 256 ? (r.splice(0, m), e.bufferedIndex = 0) : e.bufferedIndex = m;
      }
      e.bufferProcessing = false;
    }
    st2.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new cx("_write()");
    };
    st2.prototype._writev = null;
    st2.prototype.end = function(t, e, r) {
      let o = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f;
      if (t != null) {
        let p2 = wv(this, t, e);
        p2 instanceof ix && (f = p2);
      }
      return o.corked && (o.corked = 1, this.uncork()), f || (!o.errored && !o.ending ? (o.ending = true, Xh(this, o, true), o.ended = true) : o.finished ? f = new vx("end") : o.destroyed && (f = new ga("end"))), typeof r == "function" && (f || o.finished ? Mn.nextTick(r, f) : o[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e) {
      let r = false;
      function o(f) {
        if (r) {
          uf(t, f ?? gv());
          return;
        }
        if (r = true, e.pendingcb--, f) {
          let p2 = e[lf].splice(0);
          for (let m = 0;m < p2.length; m++)
            p2[m](f);
          uf(t, f, e.sync);
        } else
          ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o);
      } catch (f) {
        o(f);
      }
      e.sync = false;
    }
    function _x(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e, r) {
      ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o, f) => {
        ts(f) ? Vh(o, f) : f.pendingcb--;
      }, t, e)) : ts(e) && (e.pendingcb++, Vh(t, e))));
    }
    function Vh(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[lf].splice(0);
      for (let o = 0;o < r.length; o++)
        r[o]();
      if (t.emit("finish"), e.autoDestroy) {
        let o = t._readableState;
        (!o || o.autoDestroy && (o.endEmitted || o.readable === false)) && t.destroy();
      }
    }
    nx(st2.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st2.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
    };
    st2.prototype._undestroy = is.undestroy;
    st2.prototype._destroy = function(t, e) {
      e(t);
    };
    st2.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st2.fromWeb = function(t, e) {
      return _v().newStreamWritableFromWritableStream(t, e);
    };
    st2.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T((ZI, Nv) => {
    var Qh = (Oi(), ur(pr)), Sx = Ut(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr(), Tx = ba(), { createDeferredPromise: qv } = Gr(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
      return e instanceof Tv;
    } : function(e) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt(), _n = class extends Ix {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e, r) {
      if (Bx(e))
        return e;
      if (Ev(e))
        return ns({ readable: e });
      if (Av(e))
        return ns({ writable: e });
      if (Rx(e))
        return ns({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f, write: p2, final: m, destroy: y } = Nx(e);
        if (Sv(f))
          return Iv(_n, f, { objectMode: true, write: p2, final: m, destroy: y });
        let M = f?.then;
        if (typeof M == "function") {
          let x, S = kv(M, f, (E2) => {
            if (E2 != null)
              throw new Bv("nully", "body", E2);
          }, (E2) => {
            df(x, E2);
          });
          return x = new _n({ objectMode: true, readable: false, write: p2, final(E2) {
            m(async () => {
              try {
                await S, Qh.nextTick(E2, null);
              } catch (B) {
                Qh.nextTick(E2, B);
              }
            });
          }, destroy: y });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f);
      }
      if (kx(e))
        return t(e.arrayBuffer());
      if (Sv(e))
        return Iv(_n, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p2 = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return ns({ readable: f, writable: p2 });
      }
      let o = e?.then;
      if (typeof o == "function") {
        let f;
        return kv(o, e, (p2) => {
          p2 != null && f.push(p2), f.push(null);
        }, (p2) => {
          df(f, p2);
        }), f = new _n({ objectMode: true, writable: false, read() {
        } });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Nx(t) {
      let { promise: e, resolve: r } = qv(), o = new Lx, f = o.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m = e;
          e = null;
          let { chunk: y, done: M, cb: x } = await m;
          if (Qh.nextTick(x), M)
            return;
          if (f.aborted)
            throw new Lv(undefined, { cause: f.reason });
          ({ promise: e, resolve: r } = qv()), yield y;
        }
      }(), { signal: f }), write(m, y, M) {
        let x = r;
        r = null, x({ chunk: m, done: false, cb: M });
      }, final(m) {
        let y = r;
        r = null, y({ done: true, cb: m });
      }, destroy(m, y) {
        o.abort(), y(m);
      } };
    }
    function ns(t) {
      let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o = !!Ex(e), f = !!Ax(r), p2, m, y, M, x;
      function S(E2) {
        let B = M;
        M = null, B ? B(E2) : E2 ? x.destroy(E2) : !o && !f && x.destroy();
      }
      return x = new _n({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o, writable: f }), f && (Rv(r, (E2) => {
        f = false, E2 && df(e, E2), S(E2);
      }), x._write = function(E2, B, q) {
        r.write(E2, B) ? q() : p2 = q;
      }, x._final = function(E2) {
        r.end(), m = E2;
      }, r.on("drain", function() {
        if (p2) {
          let E2 = p2;
          p2 = null, E2();
        }
      }), r.on("finish", function() {
        if (m) {
          let E2 = m;
          m = null, E2();
        }
      })), o && (Rv(e, (E2) => {
        o = false, E2 && df(e, E2), S(E2);
      }), e.on("readable", function() {
        if (y) {
          let E2 = y;
          y = null, E2();
        }
      }), e.on("end", function() {
        x.push(null);
      }), x._read = function() {
        for (;; ) {
          let E2 = e.read();
          if (E2 === null) {
            y = x._read;
            return;
          }
          if (!x.push(E2))
            return;
        }
      }), x._destroy = function(E2, B) {
        !E2 && M !== null && (E2 = new Lv), y = null, p2 = null, m = null, M === null ? B(E2) : (M = B, df(r, E2), df(e, E2));
      }, x;
    }
  });
  Qr = T((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt();
    Ov.exports = kr;
    var ru = ba(), vr = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = vr.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi(vr.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi(vr.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi(vr.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi(vr.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi(vr.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi(vr.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi(vr.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi(vr.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi(vr.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu = T(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt();
    Uv.exports = mi;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr(), { getHighWaterMark: Fx } = Xo();
    Fv(mi.prototype, nu.prototype);
    Fv(mi, nu);
    var wa = Cx("kCallback");
    function mi(t) {
      if (!(this instanceof mi))
        return new mi(t);
      let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu && iu.call(this);
    }
    mi.prototype._final = iu;
    mi.prototype._transform = function(t, e, r) {
      throw new Ox("_transform()");
    };
    mi.prototype._write = function(t, e, r) {
      let o = this._readableState, f = this._writableState, p2 = o.length;
      this._transform(t, e, (m, y) => {
        if (m) {
          r(m);
          return;
        }
        y != null && this.push(y), f.ended || p2 === o.length || o.length < o.highWaterMark ? r() : this[wa] = r;
      });
    };
    mi.prototype._read = function() {
      if (this[wa]) {
        let t = this[wa];
        this[wa] = null, t();
      }
    };
  });
  ou = T((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt();
    Hv.exports = cf;
    var au = fu();
    zv(cf.prototype, au.prototype);
    zv(cf, au);
    function cf(t) {
      if (!(this instanceof cf))
        return new cf(t);
      au.call(this, t);
    }
    cf.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  os = T((YI, Gv) => {
    var fs = (Oi(), ur(pr)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt(), as = Ui(), { once: Kx } = Gr(), jx = yn(), Wv = Qr(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu, lu;
    function jv(t, e, r) {
      let o = false;
      t.on("close", () => {
        o = true;
      });
      let f = as(t, { readable: e, writable: r }, (p2) => {
        o = !p2;
      });
      return { destroy: (p2) => {
        o || (o = true, jx.destroyer(t, p2 || new $x("pipe")));
      }, cleanup: f };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu || (lu = ba()), yield* lu.prototype[Wx].call(t);
    }
    async function Zv(t, e, r, { end: o }) {
      let f, p2 = null, m = (x) => {
        if (x && (f = x), p2) {
          let S = p2;
          p2 = null, S();
        }
      }, y = () => new Hx((x, S) => {
        f ? S(f) : p2 = () => {
          f ? S(f) : x();
        };
      });
      e.on("drain", m);
      let M = as(e, { readable: false }, m);
      try {
        e.writableNeedDrain && await y();
        for await (let x of t)
          e.write(x) || await y();
        o && e.end(), await y(), r();
      } catch (x) {
        r(f !== x ? Zx(f, x) : x);
      } finally {
        M(), e.off("drain", m);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o = new Qx, f = o.signal, p2 = r?.signal, m = [];
      Jx(p2, "options.signal");
      function y() {
        q(new Yx);
      }
      p2?.addEventListener("abort", y);
      let M, x, S = [], E2 = 0;
      function B(N2) {
        q(N2, --E2 === 0);
      }
      function q(N2, we) {
        if (N2 && (!M || M.code === "ERR_STREAM_PREMATURE_CLOSE") && (M = N2), !(!M && !we)) {
          for (;S.length; )
            S.shift()(M);
          p2?.removeEventListener("abort", y), o.abort(), we && (M || m.forEach((ye) => ye()), fs.nextTick(e, M, x));
        }
      }
      let L;
      for (let N2 = 0;N2 < t.length; N2++) {
        let we = t[N2], ye = N2 < t.length - 1, xe = N2 > 0, Re = ye || r?.end !== false, Ee = N2 === t.length - 1;
        if (Kv(we)) {
          let Ae2 = function(P) {
            P && P.name !== "AbortError" && P.code !== "ERR_STREAM_PREMATURE_CLOSE" && B(P);
          };
          var _e = Ae2;
          if (Re) {
            let { destroy: P, cleanup: Se2 } = jv(we, ye, xe);
            S.push(P), hu(we) && Ee && m.push(Se2);
          }
          we.on("error", Ae2), hu(we) && Ee && m.push(() => {
            we.removeListener("error", Ae2);
          });
        }
        if (N2 === 0)
          if (typeof we == "function") {
            if (L = we({ signal: f }), !pf(L))
              throw new su("Iterable, AsyncIterable or Stream", "source", L);
          } else
            pf(we) || du(we) ? L = we : L = Wv.from(we);
        else if (typeof we == "function")
          if (L = t7(L), L = we(L, { signal: f }), ye) {
            if (!pf(L, true))
              throw new su("AsyncIterable", `transform[${N2 - 1}]`, L);
          } else {
            var ge;
            uu || (uu = ou());
            let Ae2 = new uu({ objectMode: true }), P = (ge = L) === null || ge === undefined ? undefined : ge.then;
            if (typeof P == "function")
              E2++, P.call(L, (i) => {
                x = i, i != null && Ae2.write(i), Re && Ae2.end(), fs.nextTick(B);
              }, (i) => {
                Ae2.destroy(i), fs.nextTick(B, i);
              });
            else if (pf(L, true))
              E2++, Zv(L, Ae2, B, { end: Re });
            else
              throw new su("AsyncIterable or Promise", "destination", L);
            L = Ae2;
            let { destroy: Se2, cleanup: v } = jv(L, false, true);
            S.push(Se2), Ee && m.push(v);
          }
        else if (Kv(we)) {
          if (du(L)) {
            E2 += 2;
            let Ae2 = n7(L, we, B, { end: Re });
            hu(we) && Ee && m.push(Ae2);
          } else if (pf(L))
            E2++, Zv(L, we, B, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L);
          L = we;
        } else
          L = Wv.from(we);
      }
      return (f != null && f.aborted || p2 != null && p2.aborted) && fs.nextTick(y), L;
    }
    function n7(t, e, r, { end: o }) {
      let f = false;
      return e.on("close", () => {
        f || r(new Gx);
      }), t.pipe(e, { end: o }), o ? t.once("end", () => {
        f = true, e.end();
      }) : r(), as(t, { readable: true, writable: false }, (p2) => {
        let m = t._readableState;
        p2 && p2.code === "ERR_STREAM_PREMATURE_CLOSE" && m && m.ended && !m.errored && !m.errorEmitted ? t.once("end", r).once("error", r) : r(p2);
      }), as(e, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e) {
      if (e.length === 0)
        throw new h7("streams");
      if (e.length === 1)
        return ss.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
        let q = e.length - 1;
        e[q] = ss.from(e[q]);
      }
      for (let q = 0;q < e.length; ++q)
        if (!!o7(e[q])) {
          if (q < e.length - 1 && !Yv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be readable");
          if (q > 0 && !Xv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be writable");
        }
      let o, f, p2, m, y;
      function M(q) {
        let L = m;
        m = null, L ? L(q) : q ? y.destroy(q) : !B && !E2 && y.destroy();
      }
      let x = e[0], S = f7(e, M), E2 = !!Xv(x), B = !!Yv(S);
      return y = new ss({ writableObjectMode: !!(x != null && x.writableObjectMode), readableObjectMode: !!(S != null && S.writableObjectMode), writable: E2, readable: B }), E2 && (y._write = function(q, L, ge) {
        x.write(q, L) ? ge() : o = ge;
      }, y._final = function(q) {
        x.end(), f = q;
      }, x.on("drain", function() {
        if (o) {
          let q = o;
          o = null, q();
        }
      }), S.on("finish", function() {
        if (f) {
          let q = f;
          f = null, q();
        }
      })), B && (S.on("readable", function() {
        if (p2) {
          let q = p2;
          p2 = null, q();
        }
      }), S.on("end", function() {
        y.push(null);
      }), y._read = function() {
        for (;; ) {
          let q = S.read();
          if (q === null) {
            p2 = y._read;
            return;
          }
          if (!y.push(q))
            return;
        }
      }), y._destroy = function(q, L) {
        !q && m !== null && (q = new s7), p2 = null, o = null, f = null, m === null ? L(q) : (m = L, a7(S, q));
      }, y;
    };
  });
  cu = T((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e, r) => {
        let o, f, p2 = t[t.length - 1];
        if (p2 && typeof p2 == "object" && !c7(p2) && !d7(p2)) {
          let m = u7(t);
          o = m.signal, f = m.end;
        }
        p7(t, (m, y) => {
          m ? r(m) : e(y);
        }, { signal: o, end: f });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T((QI, ub) => {
    var { Buffer: m7 } = Ut(), { ObjectDefineProperty: gi, ObjectKeys: nb, ReflectApply: fb } = Tt(), { promisify: { custom: ab } } = Gr(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k12(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu(), vu = Fi(), ct2 = ub.exports = Vo().Stream;
    ct2.isDisturbed = vu.isDisturbed;
    ct2.isErrored = vu.isErrored;
    ct2.isReadable = vu.isReadable;
    ct2.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o) {
        if (new.target)
          throw ob();
        return ct2.Readable.from(fb(e, this, o));
      };
      M7 = r;
      let e = rb[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct2.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f) {
        if (new.target)
          throw ob();
        return fb(e, this, f);
      };
      M7 = r;
      let e = ib[t];
      gi(r, "name", { __proto__: null, value: e.name }), gi(r, "length", { __proto__: null, value: e.length }), gi(ct2.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct2.Writable = Jh();
    ct2.Duplex = Qr();
    ct2.Transform = fu();
    ct2.PassThrough = ou();
    ct2.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct2.addAbortSignal = w7;
    ct2.finished = hb;
    ct2.destroy = y7;
    ct2.compose = g7;
    gi(ct2, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct2.Stream = ct2;
    ct2._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct2._uint8ArrayToBuffer = function(e) {
      return m7.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  bu = T((eT, pt2) => {
    var Lt = lb(), _7 = cu(), x7 = Lt.Readable.destroy;
    pt2.exports = Lt.Readable;
    pt2.exports._uint8ArrayToBuffer = Lt._uint8ArrayToBuffer;
    pt2.exports._isUint8Array = Lt._isUint8Array;
    pt2.exports.isDisturbed = Lt.isDisturbed;
    pt2.exports.isErrored = Lt.isErrored;
    pt2.exports.isReadable = Lt.isReadable;
    pt2.exports.Readable = Lt.Readable;
    pt2.exports.Writable = Lt.Writable;
    pt2.exports.Duplex = Lt.Duplex;
    pt2.exports.Transform = Lt.Transform;
    pt2.exports.PassThrough = Lt.PassThrough;
    pt2.exports.addAbortSignal = Lt.addAbortSignal;
    pt2.exports.finished = Lt.finished;
    pt2.exports.destroy = Lt.destroy;
    pt2.exports.destroy = x7;
    pt2.exports.pipeline = Lt.pipeline;
    pt2.exports.compose = Lt.compose;
    Object.defineProperty(Lt, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt2.exports.Stream = Lt.Stream;
    pt2.exports.default = pt2.exports;
  });
  vf = {};
  Ja(vf, { default: () => S7 });
  db = R0(() => {
    ot(vf, rn(bu()));
    S7 = rn(bu());
  });
  yi = T((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = cb.from(t, e));
      var o = this._update(t);
      return this.hashMode ? this : (r && (o = this._toString(o, r)), o);
    };
    Lr.prototype.setAutoPadding = function() {
    };
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f) {
        o = f;
      } finally {
        r(o);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || cb.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o = this._decoder.write(t);
      return r && (o += this._decoder.end()), o;
    };
    vb.exports = Lr;
  });
  bf = T((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
    };
  });
  wb = T((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi(), k7 = xn.alloc(128), mf = 64;
    function us(t, e) {
      gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf ? e = t(e) : e.length < mf && (e = xn.concat([e, k7], mf));
      for (var r = this._ipad = xn.allocUnsafe(mf), o = this._opad = xn.allocUnsafe(mf), f = 0;f < mf; f++)
        r[f] = e[f] ^ 54, o[f] = e[f] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e) {
      _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o = t === "rmd160" ? new gu : yu(t);
        e = o.update(e).digest();
      } else
        e.length < r && (e = Ma.concat([e, C7], r));
      for (var f = this._ipad = Ma.allocUnsafe(r), p2 = this._opad = Ma.allocUnsafe(r), m = 0;m < r; m++)
        f[m] = e[m] ^ 54, p2[m] = e[m] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    xb.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
    };
  });
  Mu = T((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > F7 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  xu = T((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu = T((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e, r) {
      var o = j7(t), f = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f ? e = o(e) : e.length < f && (e = Sn.concat([e, K7], f));
      for (var p2 = Sn.allocUnsafe(f + ds[t]), m = Sn.allocUnsafe(f + ds[t]), y = 0;y < f; y++)
        p2[y] = e[y] ^ 54, m[y] = e[y] ^ 92;
      var M = Sn.allocUnsafe(f + r + 4);
      p2.copy(M, 0, 0, f), this.ipad1 = M, this.ipad2 = p2, this.opad = m, this.alg = t, this.blocksize = f, this.hash = o, this.size = ds[t];
    }
    kb.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e(o) {
        return H7(t).update(o).digest();
      }
      function r(o) {
        return new z7().update(o).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
    }
    function Z7(t, e, r, o, f) {
      W7(r, o), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f = f || "sha1";
      var p2 = new kb(f, t, e.length), m = Sn.allocUnsafe(o), y = Sn.allocUnsafe(e.length + 4);
      e.copy(y, 0, 0, e.length);
      for (var M = 0, x = ds[f], S = Math.ceil(o / x), E2 = 1;E2 <= S; E2++) {
        y.writeUInt32BE(E2, e.length);
        for (var B = p2.run(y, p2.ipad1), q = B, L = 1;L < r; L++) {
          q = p2.run(q, p2.ipad2);
          for (var ge = 0;ge < x; ge++)
            B[ge] ^= q[ge];
        }
        B.copy(m, M), M += x;
      }
      return m;
    }
    Lb.exports = Z7;
  });
  Ub = T((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e, e;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e, r, o, f) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p2) {
        return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f } }, p2, o << 3);
      }).then(function(p2) {
        return Cb.from(p2);
      });
    }
    function Y7(t, e) {
      t.then(function(r) {
        Bu()(function() {
          e(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e(r);
        });
      });
    }
    Fb.exports = function(t, e, r, o, f, p2) {
      typeof f == "function" && (p2 = f, f = undefined), f = f || "sha1";
      var m = $7[f.toLowerCase()];
      if (!m || typeof global.Promise != "function") {
        Bu()(function() {
          var y;
          try {
            y = Db(t, e, r, o, f);
          } catch (M) {
            return p2(M);
          }
          p2(null, y);
        });
        return;
      }
      if (V7(r, o), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p2 != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m).then(function(y) {
        return y ? Ob(t, e, r, o, m) : Db(t, e, r, o, f);
      }), p2);
    };
  });
  Iu = T((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T((br2) => {
    br2.readUInt32BE = function(e, r) {
      var o = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o >>> 0;
    };
    br2.writeUInt32BE = function(e, r, o) {
      e[0 + o] = r >>> 24, e[1 + o] = r >>> 16 & 255, e[2 + o] = r >>> 8 & 255, e[3 + o] = r & 255;
    };
    br2.ip = function(e, r, o, f) {
      for (var p2 = 0, m = 0, y = 6;y >= 0; y -= 2) {
        for (var M = 0;M <= 24; M += 8)
          p2 <<= 1, p2 |= r >>> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p2 <<= 1, p2 |= e >>> M + y & 1;
      }
      for (var y = 6;y >= 0; y -= 2) {
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= r >>> M + y & 1;
        for (var M = 1;M <= 25; M += 8)
          m <<= 1, m |= e >>> M + y & 1;
      }
      o[f + 0] = p2 >>> 0, o[f + 1] = m >>> 0;
    };
    br2.rip = function(e, r, o, f) {
      for (var p2 = 0, m = 0, y = 0;y < 4; y++)
        for (var M = 24;M >= 0; M -= 8)
          p2 <<= 1, p2 |= r >>> M + y & 1, p2 <<= 1, p2 |= e >>> M + y & 1;
      for (var y = 4;y < 8; y++)
        for (var M = 24;M >= 0; M -= 8)
          m <<= 1, m |= r >>> M + y & 1, m <<= 1, m |= e >>> M + y & 1;
      o[f + 0] = p2 >>> 0, o[f + 1] = m >>> 0;
    };
    br2.pc1 = function(e, r, o, f) {
      for (var p2 = 0, m = 0, y = 7;y >= 5; y--) {
        for (var M = 0;M <= 24; M += 8)
          p2 <<= 1, p2 |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          p2 <<= 1, p2 |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        p2 <<= 1, p2 |= r >> M + y & 1;
      for (var y = 1;y <= 3; y++) {
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= r >> M + y & 1;
        for (var M = 0;M <= 24; M += 8)
          m <<= 1, m |= e >> M + y & 1;
      }
      for (var M = 0;M <= 24; M += 8)
        m <<= 1, m |= e >> M + y & 1;
      o[f + 0] = p2 >>> 0, o[f + 1] = m >>> 0;
    };
    br2.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br2.pc2 = function(e, r, o, f) {
      for (var p2 = 0, m = 0, y = ps.length >>> 1, M = 0;M < y; M++)
        p2 <<= 1, p2 |= e >>> ps[M] & 1;
      for (var M = y;M < ps.length; M++)
        m <<= 1, m |= r >>> ps[M] & 1;
      o[f + 0] = p2 >>> 0, o[f + 1] = m >>> 0;
    };
    br2.expand = function(e, r, o) {
      var f = 0, p2 = 0;
      f = (e & 1) << 5 | e >>> 27;
      for (var m = 23;m >= 15; m -= 4)
        f <<= 6, f |= e >>> m & 63;
      for (var m = 11;m >= 3; m -= 4)
        p2 |= e >>> m & 63, p2 <<= 6;
      p2 |= (e & 31) << 1 | e >>> 31, r[o + 0] = f >>> 0, r[o + 1] = p2 >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br2.substitute = function(e, r) {
      for (var o = 0, f = 0;f < 4; f++) {
        var p2 = e >>> 18 - f * 6 & 63, m = zb[f * 64 + p2];
        o <<= 4, o |= m;
      }
      for (var f = 0;f < 4; f++) {
        var p2 = r >>> 18 - f * 6 & 63, m = zb[4 * 64 + f * 64 + p2];
        o <<= 4, o |= m;
      }
      return o >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br2.permute = function(e) {
      for (var r = 0, o = 0;o < Hb.length; o++)
        r <<= 1, r |= e >>> Hb[o] & 1;
      return r >>> 0;
    };
    br2.padSplit = function(e, r, o) {
      for (var f = e.toString(2);f.length < r; )
        f = "0" + f;
      for (var p2 = [], m = 0;m < r; m += o)
        p2.push(f.slice(m, m + o));
      return p2.join(" ");
    };
  });
  ar = T((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    Wb.equal = function(e, r, o) {
      if (e != r)
        throw new Error(o || "Assertion failed: " + e + " != " + r);
    };
  });
  vs = T((mT, jb) => {
    var X7 = ar();
    function mr(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr;
    mr.prototype._init = function() {
    };
    mr.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    mr.prototype._buffer = function(e, r) {
      for (var o = Math.min(this.buffer.length - this.bufferOff, e.length - r), f = 0;f < o; f++)
        this.buffer[this.bufferOff + f] = e[r + f];
      return this.bufferOff += o, o;
    };
    mr.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    mr.prototype._updateEncrypt = function(e) {
      var r = 0, o = 0, f = (this.bufferOff + e.length) / this.blockSize | 0, p2 = new Array(f * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o += this._flushBuffer(p2, o)));
      for (var m = e.length - (e.length - r) % this.blockSize;r < m; r += this.blockSize)
        this._update(e, r, p2, o), o += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p2;
    };
    mr.prototype._updateDecrypt = function(e) {
      for (var r = 0, o = 0, f = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p2 = new Array(f * this.blockSize);f > 0; f--)
        r += this._buffer(e, r), o += this._flushBuffer(p2, o);
      return r += this._buffer(e, r), p2;
    };
    mr.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o;
      return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), r ? r.concat(o) : o;
    };
    mr.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    mr.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    mr.prototype._unpad = function(e) {
      return e;
    };
    mr.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  ku = T((gT, $b) => {
    var Zb = ar(), J7 = Ie(), Nt = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e = new Q7;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e) {
      return new ei(e);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o = Nt.readUInt32BE(r, 0), f = Nt.readUInt32BE(r, 4);
      Nt.pc1(o, f, e.tmp, 0), o = e.tmp[0], f = e.tmp[1];
      for (var p2 = 0;p2 < e.keys.length; p2 += 2) {
        var m = e9[p2 >>> 1];
        o = Nt.r28shl(o, m), f = Nt.r28shl(f, m), Nt.pc2(o, f, e.keys, p2);
      }
    };
    ei.prototype._update = function(e, r, o, f) {
      var p2 = this._desState, m = Nt.readUInt32BE(e, r), y = Nt.readUInt32BE(e, r + 4);
      Nt.ip(m, y, p2.tmp, 0), m = p2.tmp[0], y = p2.tmp[1], this.type === "encrypt" ? this._encrypt(p2, m, y, p2.tmp, 0) : this._decrypt(p2, m, y, p2.tmp, 0), m = p2.tmp[0], y = p2.tmp[1], Nt.writeUInt32BE(o, m, f), Nt.writeUInt32BE(o, y, f + 4);
    };
    ei.prototype._pad = function(e, r) {
      for (var o = e.length - r, f = r;f < e.length; f++)
        e[f] = o;
      return true;
    };
    ei.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], o = e.length - r;o < e.length; o++)
        Zb.equal(e[o], r);
      return e.slice(0, e.length - r);
    };
    ei.prototype._encrypt = function(e, r, o, f, p2) {
      for (var m = r, y = o, M = 0;M < e.keys.length; M += 2) {
        var x = e.keys[M], S = e.keys[M + 1];
        Nt.expand(y, e.tmp, 0), x ^= e.tmp[0], S ^= e.tmp[1];
        var E2 = Nt.substitute(x, S), B = Nt.permute(E2), q = y;
        y = (m ^ B) >>> 0, m = q;
      }
      Nt.rip(y, m, f, p2);
    };
    ei.prototype._decrypt = function(e, r, o, f, p2) {
      for (var m = o, y = r, M = e.keys.length - 2;M >= 0; M -= 2) {
        var x = e.keys[M], S = e.keys[M + 1];
        Nt.expand(m, e.tmp, 0), x ^= e.tmp[0], S ^= e.tmp[1];
        var E2 = Nt.substitute(x, S), B = Nt.permute(E2), q = m;
        m = (y ^ B) >>> 0, y = q;
      }
      Nt.rip(m, y, f, p2);
    };
  });
  Yb = T((Gb) => {
    var t9 = ar(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function n9(t) {
      function e(p2) {
        t.call(this, p2), this._cbcInit();
      }
      r9(e, t);
      for (var r = Object.keys(bs), o = 0;o < r.length; o++) {
        var f = r[o];
        e.prototype[f] = bs[f];
      }
      return e.create = function(m) {
        return new e(m);
      }, e;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e = new i9(this.options.iv);
      this._cbcState = e;
    };
    bs._update = function(e, r, o, f) {
      var p2 = this._cbcState, m = this.constructor.super_.prototype, y = p2.iv;
      if (this.type === "encrypt") {
        for (var M = 0;M < this.blockSize; M++)
          y[M] ^= e[r + M];
        m._update.call(this, y, 0, o, f);
        for (var M = 0;M < this.blockSize; M++)
          y[M] = o[f + M];
      } else {
        m._update.call(this, e, r, o, f);
        for (var M = 0;M < this.blockSize; M++)
          o[f + M] ^= y[M];
        for (var M = 0;M < this.blockSize; M++)
          y[M] = e[r + M];
      }
    };
  });
  Qb = T((wT, Jb) => {
    var f9 = ar(), a9 = Ie(), Xb = vs(), Wi = ku();
    function o9(t, e) {
      f9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o = e.slice(8, 16), f = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi.create({ type: "encrypt", key: r }), Wi.create({ type: "decrypt", key: o }), Wi.create({ type: "encrypt", key: f })] : this.ciphers = [Wi.create({ type: "decrypt", key: f }), Wi.create({ type: "encrypt", key: o }), Wi.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e = new o9(this.type, this.options.key);
      this._edeState = e;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e) {
      return new An(e);
    };
    An.prototype._update = function(e, r, o, f) {
      var p2 = this._edeState;
      p2.ciphers[0]._update(e, r, o, f), p2.ciphers[1]._update(o, f, o, f), p2.ciphers[2]._update(o, f, o, f);
    };
    An.prototype._pad = Wi.prototype._pad;
    An.prototype._unpad = Wi.prototype._unpad;
  });
  em = T((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T((_T, rm) => {
    var tm = yi(), wi = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi.CBC.instantiate(wi.EDE), "des-ede3": wi.EDE, "des-ede-cbc": wi.CBC.instantiate(wi.EDE), "des-ede": wi.EDE, "des-cbc": wi.CBC.instantiate(wi.DES), "des-ecb": wi.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e = t.mode.toLowerCase(), r = Sa[e], o;
      t.decrypt ? o = "decrypt" : o = "encrypt";
      var f = t.key;
      Rn.isBuffer(f) || (f = Rn.from(f)), (e === "des-ede" || e === "des-ede-cbc") && (f = Rn.concat([f, f.slice(0, 8)]));
      var p2 = t.iv;
      Rn.isBuffer(p2) || (p2 = Rn.from(p2)), this._des = r.create({ key: f, iv: p2, type: o });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T((Lu) => {
    Lu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Lu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  yf = T((ST, fm) => {
    fm.exports = function(e, r) {
      for (var o = Math.min(e.length, r.length), f = new Buffer(o), p2 = 0;p2 < o; ++p2)
        f[p2] = e[p2] ^ r[p2];
      return f;
    };
  });
  om = T((Nu) => {
    var am = yf();
    Nu.encrypt = function(t, e) {
      var r = am(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o = t._cipher.decryptBlock(e);
      return am(o, r);
    };
  });
  um = T((hm) => {
    var Ea = Te().Buffer, h9 = yf();
    function sm(t, e, r) {
      var o = e.length, f = h9(e, t._cache);
      return t._cache = t._cache.slice(o), t._prev = Ea.concat([t._prev, r ? e : f]), f;
    }
    hm.encrypt = function(t, e, r) {
      for (var o = Ea.allocUnsafe(0), f;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
          f = t._cache.length, o = Ea.concat([o, sm(t, e.slice(0, f), r)]), e = e.slice(f);
        else {
          o = Ea.concat([o, sm(t, e, r)]);
          break;
        }
      return o;
    };
  });
  dm = T((lm) => {
    var Du = Te().Buffer;
    function u9(t, e, r) {
      var o = t._cipher.encryptBlock(t._prev), f = o[0] ^ e;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f])]), f;
    }
    lm.encrypt = function(t, e, r) {
      for (var o = e.length, f = Du.allocUnsafe(o), p2 = -1;++p2 < o; )
        f[p2] = u9(t, e[p2], r);
      return f;
    };
  });
  pm = T((cm) => {
    var gs = Te().Buffer;
    function l9(t, e, r) {
      for (var o, f = -1, p2 = 8, m = 0, y, M;++f < p2; )
        o = t._cipher.encryptBlock(t._prev), y = e & 1 << 7 - f ? 128 : 0, M = o[0] ^ y, m += (M & 128) >> f % 8, t._prev = d9(t._prev, r ? y : M);
      return m;
    }
    function d9(t, e) {
      var r = t.length, o = -1, f = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e])]);++o < r; )
        f[o] = t[o] << 1 | t[o + 1] >> 7;
      return f;
    }
    cm.encrypt = function(t, e, r) {
      for (var o = e.length, f = gs.allocUnsafe(o), p2 = -1;++p2 < o; )
        f[p2] = l9(t, e[p2], r);
      return f;
    };
  });
  bm = T((vm) => {
    var c9 = yf();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), c9(e, r);
    };
  });
  Pu = T((IT, mm) => {
    function v9(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T((ym) => {
    var b9 = yf(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e;
    }
    var Cu = 16;
    ym.encrypt = function(t, e) {
      var r = Math.ceil(e.length / Cu), o = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f = 0;f < r; f++) {
        var p2 = g9(t), m = o + f * Cu;
        t._cache.writeUInt32BE(p2[0], m + 0), t._cache.writeUInt32BE(p2[1], m + 4), t._cache.writeUInt32BE(p2[2], m + 8), t._cache.writeUInt32BE(p2[3], m + 12);
      }
      var y = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), b9(e, y);
    };
  });
  Fu = T((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o = 0;o < e; o++)
        r[o] = t.readUInt32BE(o * 4);
      return r;
    }
    function zu(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Mm(t, e, r, o, f) {
      for (var p2 = r[0], m = r[1], y = r[2], M = r[3], x = t[0] ^ e[0], S = t[1] ^ e[1], E2 = t[2] ^ e[2], B = t[3] ^ e[3], q, L, ge, _e, N2 = 4, we = 1;we < f; we++)
        q = p2[x >>> 24] ^ m[S >>> 16 & 255] ^ y[E2 >>> 8 & 255] ^ M[B & 255] ^ e[N2++], L = p2[S >>> 24] ^ m[E2 >>> 16 & 255] ^ y[B >>> 8 & 255] ^ M[x & 255] ^ e[N2++], ge = p2[E2 >>> 24] ^ m[B >>> 16 & 255] ^ y[x >>> 8 & 255] ^ M[S & 255] ^ e[N2++], _e = p2[B >>> 24] ^ m[x >>> 16 & 255] ^ y[S >>> 8 & 255] ^ M[E2 & 255] ^ e[N2++], x = q, S = L, E2 = ge, B = _e;
      return q = (o[x >>> 24] << 24 | o[S >>> 16 & 255] << 16 | o[E2 >>> 8 & 255] << 8 | o[B & 255]) ^ e[N2++], L = (o[S >>> 24] << 24 | o[E2 >>> 16 & 255] << 16 | o[B >>> 8 & 255] << 8 | o[x & 255]) ^ e[N2++], ge = (o[E2 >>> 24] << 24 | o[B >>> 16 & 255] << 16 | o[x >>> 8 & 255] << 8 | o[S & 255]) ^ e[N2++], _e = (o[B >>> 24] << 24 | o[x >>> 16 & 255] << 16 | o[S >>> 8 & 255] << 8 | o[E2 & 255]) ^ e[N2++], q = q >>> 0, L = L >>> 0, ge = ge >>> 0, _e = _e >>> 0, [q, L, ge, _e];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o = [], f = [[], [], [], []], p2 = [[], [], [], []], m = 0, y = 0, M = 0;M < 256; ++M) {
        var x = y ^ y << 1 ^ y << 2 ^ y << 3 ^ y << 4;
        x = x >>> 8 ^ x & 255 ^ 99, r[m] = x, o[x] = m;
        var S = t[m], E2 = t[S], B = t[E2], q = t[x] * 257 ^ x * 16843008;
        f[0][m] = q << 24 | q >>> 8, f[1][m] = q << 16 | q >>> 16, f[2][m] = q << 8 | q >>> 24, f[3][m] = q, q = B * 16843009 ^ E2 * 65537 ^ S * 257 ^ m * 16843008, p2[0][x] = q << 24 | q >>> 8, p2[1][x] = q << 16 | q >>> 16, p2[2][x] = q << 8 | q >>> 24, p2[3][x] = q, m === 0 ? m = y = 1 : (m = S ^ t[t[t[B ^ S]]], y ^= t[t[y]]);
      }
      return { SBOX: r, INV_SBOX: o, SUB_MIX: f, INV_SUB_MIX: p2 };
    }();
    function gr2(t) {
      this._key = Hu(t), this._reset();
    }
    gr2.blockSize = 4 * 4;
    gr2.keySize = 256 / 8;
    gr2.prototype.blockSize = gr2.blockSize;
    gr2.prototype.keySize = gr2.keySize;
    gr2.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o = (r + 1) * 4, f = [], p2 = 0;p2 < e; p2++)
        f[p2] = t[p2];
      for (p2 = e;p2 < o; p2++) {
        var m = f[p2 - 1];
        p2 % e === 0 ? (m = m << 8 | m >>> 24, m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255], m ^= M9[p2 / e | 0] << 24) : e > 6 && p2 % e === 4 && (m = kt.SBOX[m >>> 24] << 24 | kt.SBOX[m >>> 16 & 255] << 16 | kt.SBOX[m >>> 8 & 255] << 8 | kt.SBOX[m & 255]), f[p2] = f[p2 - e] ^ m;
      }
      for (var y = [], M = 0;M < o; M++) {
        var x = o - M, S = f[x - (M % 4 ? 0 : 4)];
        M < 4 || x <= 4 ? y[M] = S : y[M] = kt.INV_SUB_MIX[0][kt.SBOX[S >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S & 255]];
      }
      this._nRounds = r, this._keySchedule = f, this._invKeySchedule = y;
    };
    gr2.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    gr2.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    gr2.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Mm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o = Ms.allocUnsafe(16);
      return o.writeUInt32BE(r[0], 0), o.writeUInt32BE(r[3], 4), o.writeUInt32BE(r[2], 8), o.writeUInt32BE(r[1], 12), o;
    };
    gr2.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr2;
  });
  Em = T((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e = wf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e = [0, 0, 0, 0], r, o, f, p2 = -1;++p2 < 128; ) {
        for (o = (this.state[~~(p2 / 8)] & 1 << 7 - p2 % 8) !== 0, o && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    Ra.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T((PT, Bm) => {
    var S9 = Aa(), rr = Te().Buffer, Am = yi(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
    function B9(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o = Math.min(t.length, e.length), f = 0;f < o; ++f)
        r += t[f] ^ e[f];
      return r;
    }
    function q9(t, e, r) {
      if (e.length === 12)
        return t._finID = rr.concat([e, rr.from([0, 0, 0, 1])]), rr.concat([e, rr.from([0, 0, 0, 2])]);
      var o = new Rm(r), f = e.length, p2 = f % 16;
      o.update(e), p2 && (p2 = 16 - p2, o.update(rr.alloc(p2, 0))), o.update(rr.alloc(8, 0));
      var m = f * 8, y = rr.alloc(8);
      y.writeUIntBE(m, 0, 8), o.update(y), t._finID = o.state;
      var M = rr.from(t._finID);
      return R9(M), M;
    }
    function Bn(t, e, r, o) {
      Am.call(this);
      var f = rr.alloc(4, 0);
      this._cipher = new S9.AES(e);
      var p2 = this._cipher.encryptBlock(f);
      this._ghash = new Rm(p2), r = q9(this, r, p2), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn, Am);
    Bn.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Bn.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Bm.exports = Bn;
  });
  ju = T((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi(), T9 = Ie();
    function _s(t, e, r, o) {
      qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T((OT, Tm) => {
    var qn = Te().Buffer, k9 = Ao();
    function L9(t, e, r, o) {
      if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e && (qn.isBuffer(e) || (e = qn.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f = r / 8, p2 = qn.alloc(f), m = qn.alloc(o || 0), y = qn.alloc(0);f > 0 || o > 0; ) {
        var M = new k9;
        M.update(y), M.update(t), e && M.update(e), y = M.digest();
        var x = 0;
        if (f > 0) {
          var S = p2.length - f;
          x = Math.min(f, y.length), y.copy(p2, S, 0, x), f -= x;
        }
        if (x < y.length && o > 0) {
          var E2 = m.length - o, B = Math.min(o, y.length - x);
          y.copy(m, E2, x, x + B), o -= B;
        }
      }
      return y.fill(0), { key: p2, iv: m };
    }
    Tm.exports = L9;
  });
  Dm = T((Zu) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o.push(r);
      return Mi.concat(o);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Mi.concat([this.cache, e]);
    };
    function Nm(t, e, r) {
      var o = km[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Mi.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Mi.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o.type === "stream" ? new D9(o.module, e, r) : o.type === "auth" ? new N9(o.module, e, r) : new qa(o.module, e, r);
    }
    function U9(t, e) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = C9(e, false, r.key, r.iv);
      return Nm(t, o.key, o.iv);
    }
    Zu.createCipheriv = Nm;
    Zu.createCipher = U9;
  });
  Fm = T((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia(t, e, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia, Cm);
    Ia.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o.push(r);
      return Mf.concat(o);
    };
    Ia.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function Om(t, e, r) {
      var o = Pm[t.toLowerCase()];
      if (!o)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o.mode !== "GCM" && r.length !== o.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Mf.from(e)), e.length !== o.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o.type === "stream" ? new H9(o.module, e, r, true) : o.type === "auth" ? new z9(o.module, e, r, true) : new Ia(o.module, e, r);
    }
    function V9(t, e) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o = K9(e, false, r.key, r.iv);
      return Om(t, o.key, o.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T((_i) => {
    _i["des-ecb"] = { key: 8, iv: 0 };
    _i["des-cbc"] = _i.des = { key: 8, iv: 8 };
    _i["des-ede3-cbc"] = _i.des3 = { key: 24, iv: 8 };
    _i["des-ede3"] = { key: 24, iv: 0 };
    _i["des-ede-cbc"] = { key: 16, iv: 8 };
    _i["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T((Dr) => {
    var Wm = im(), $u = Es(), Ki = ws(), xi = Hm(), Km = Ba();
    function Y9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e, false, r, o);
      return jm(t, f.key, f.iv);
    }
    function X9(t, e) {
      t = t.toLowerCase();
      var r, o;
      if (Ki[t])
        r = Ki[t].key, o = Ki[t].iv;
      else if (xi[t])
        r = xi[t].key * 8, o = xi[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f = Km(e, false, r, o);
      return Zm(t, f.key, f.iv);
    }
    function jm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createCipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e, r) {
      if (t = t.toLowerCase(), Ki[t])
        return $u.createDecipheriv(t, e, r);
      if (xi[t])
        return new Wm({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi).concat($u.getCiphers());
    }
    Dr.createCipher = Dr.Cipher = Y9;
    Dr.createCipheriv = Dr.Cipheriv = jm;
    Dr.createDecipher = Dr.Decipher = X9;
    Dr.createDecipheriv = Dr.Decipheriv = Zm;
    Dr.listCiphers = Dr.getCiphers = J9;
  });
  ji = T(() => {
  });
  Yu = T(($m, Gu) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E2[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt2 = s[3] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = s[4] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = s[6] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = s[7] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = s[8] | 0, V2 = yt2 & 8191, $ = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = u[5] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re2) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re2) | 0;
        var qe2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re2) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re2) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F2, X), n = Math.imul(F2, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re2) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d = Math.imul(H2, J), l = l + Math.imul(F2, Q) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re2) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re2) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d = d + Math.imul(H2, ee) | 0, l = l + Math.imul(F2, te) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re2) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d = d + Math.imul(H2, re2) | 0, l = l + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V2, X), n = Math.imul(V2, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re2) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d = d + Math.imul(H2, ne) | 0, l = l + Math.imul(F2, fe) | 0, n = n + Math.imul(F2, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce2) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce2) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d = Math.imul(Y2, J), l = l + Math.imul(V2, Q) | 0, n = n + Math.imul(V2, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re2) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re2) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d = d + Math.imul(H2, ae) | 0, l = l + Math.imul(F2, oe) | 0, n = n + Math.imul(F2, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce2) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce2) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d = Math.imul(Y2, ee), l = l + Math.imul(V2, te) | 0, n = n + Math.imul(V2, re2) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re2) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d = d + Math.imul(H2, se) | 0, l = l + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce2) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d = Math.imul(Y2, re2), l = l + Math.imul(V2, ie) | 0, n = n + Math.imul(V2, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d = d + Math.imul(H2, ue) | 0, l = l + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce2) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce2) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d = Math.imul(Y2, ne), l = l + Math.imul(V2, fe) | 0, n = n + Math.imul(V2, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d = d + Math.imul(H2, de) | 0, l = l + Math.imul(F2, ce2) | 0, n = n + Math.imul(F2, pe) | 0, n = n + Math.imul(U, ce2) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d = Math.imul(Y2, ae), l = l + Math.imul(V2, oe) | 0, n = n + Math.imul(V2, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d = d + Math.imul(H2, pe) | 0, l = l + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d = Math.imul(Y2, se), l = l + Math.imul(V2, he) | 0, n = n + Math.imul(V2, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce2) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d = d + Math.imul(H2, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d = Math.imul(Y2, ue), l = l + Math.imul(V2, le) | 0, n = n + Math.imul(V2, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce2) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce2) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d = Math.imul(Y2, de), l = l + Math.imul(V2, ce2) | 0, n = n + Math.imul(V2, pe) | 0, n = n + Math.imul($, ce2) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d = Math.imul(Y2, pe), l = l + Math.imul(V2, ve) | 0, n = n + Math.imul(V2, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d = Math.imul(Y2, be);
        var rt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt2, c[18] = rt2, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N2;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N2(v, i) {
        this.x = v, this.y = i;
      }
      N2.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N2.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N2.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N2.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N2.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N2.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N2.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N2.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N2.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N2.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se2(i);
      };
      function Se2(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se2, P), Se2.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se2.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se2.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Gu > "u" || Gu, $m);
  });
  Ym = T((Gm, Xu) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E2[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt2 = s[3] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = s[4] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = s[6] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = s[7] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = s[8] | 0, V2 = yt2 & 8191, $ = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = u[5] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re2) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re2) | 0;
        var qe2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re2) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re2) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F2, X), n = Math.imul(F2, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re2) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d = Math.imul(H2, J), l = l + Math.imul(F2, Q) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re2) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re2) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d = d + Math.imul(H2, ee) | 0, l = l + Math.imul(F2, te) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re2) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d = d + Math.imul(H2, re2) | 0, l = l + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V2, X), n = Math.imul(V2, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re2) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d = d + Math.imul(H2, ne) | 0, l = l + Math.imul(F2, fe) | 0, n = n + Math.imul(F2, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce2) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce2) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d = Math.imul(Y2, J), l = l + Math.imul(V2, Q) | 0, n = n + Math.imul(V2, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re2) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re2) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d = d + Math.imul(H2, ae) | 0, l = l + Math.imul(F2, oe) | 0, n = n + Math.imul(F2, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce2) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce2) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d = Math.imul(Y2, ee), l = l + Math.imul(V2, te) | 0, n = n + Math.imul(V2, re2) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re2) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d = d + Math.imul(H2, se) | 0, l = l + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce2) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d = Math.imul(Y2, re2), l = l + Math.imul(V2, ie) | 0, n = n + Math.imul(V2, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d = d + Math.imul(H2, ue) | 0, l = l + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce2) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce2) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d = Math.imul(Y2, ne), l = l + Math.imul(V2, fe) | 0, n = n + Math.imul(V2, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d = d + Math.imul(H2, de) | 0, l = l + Math.imul(F2, ce2) | 0, n = n + Math.imul(F2, pe) | 0, n = n + Math.imul(U, ce2) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d = Math.imul(Y2, ae), l = l + Math.imul(V2, oe) | 0, n = n + Math.imul(V2, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d = d + Math.imul(H2, pe) | 0, l = l + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d = Math.imul(Y2, se), l = l + Math.imul(V2, he) | 0, n = n + Math.imul(V2, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce2) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d = d + Math.imul(H2, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d = Math.imul(Y2, ue), l = l + Math.imul(V2, le) | 0, n = n + Math.imul(V2, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce2) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce2) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d = Math.imul(Y2, de), l = l + Math.imul(V2, ce2) | 0, n = n + Math.imul(V2, pe) | 0, n = n + Math.imul($, ce2) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d = Math.imul(Y2, pe), l = l + Math.imul(V2, ve) | 0, n = n + Math.imul(V2, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d = Math.imul(Y2, be);
        var rt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt2, c[18] = rt2, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N2;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N2(v, i) {
        this.x = v, this.y = i;
      }
      N2.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N2.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N2.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N2.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N2.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N2.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N2.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N2.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N2.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N2.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se2(i);
      };
      function Se2(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se2, P), Se2.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se2.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se2.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T(() => {
  });
  As = T(($T, el) => {
    var Ju;
    el.exports = function(e) {
      return Ju || (Ju = new Zi(null)), Ju.generate(e);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e) {
      return this._rand(e);
    };
    Zi.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o = 0;o < r.length; o++)
        r[o] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e) {
          return Qu.randomBytes(e);
        };
      } catch {
      }
    var Qu;
  });
  tl = T((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn;
    Tn.create = function(e) {
      return new Tn(e);
    };
    Tn.prototype._randbelow = function(e) {
      var r = e.bitLength(), o = Math.ceil(r / 8);
      do
        var f = new In(this.rand.generate(o));
      while (f.cmp(e) >= 0);
      return f;
    };
    Tn.prototype._randrange = function(e, r) {
      var o = r.sub(e);
      return e.add(this._randbelow(o));
    };
    Tn.prototype.test = function(e, r, o) {
      var f = e.bitLength(), p2 = In.mont(e), m = new In(1).toRed(p2);
      r || (r = Math.max(1, f / 48 | 0));
      for (var y = e.subn(1), M = 0;!y.testn(M); M++)
        ;
      for (var x = e.shrn(M), S = y.toRed(p2), E2 = true;r > 0; r--) {
        var B = this._randrange(new In(2), y);
        o && o(B);
        var q = B.toRed(p2).redPow(x);
        if (!(q.cmp(m) === 0 || q.cmp(S) === 0)) {
          for (var L = 1;L < M; L++) {
            if (q = q.redSqr(), q.cmp(m) === 0)
              return false;
            if (q.cmp(S) === 0)
              break;
          }
          if (L === M)
            return false;
        }
      }
      return E2;
    };
    Tn.prototype.getDivisor = function(e, r) {
      var o = e.bitLength(), f = In.mont(e), p2 = new In(1).toRed(f);
      r || (r = Math.max(1, o / 48 | 0));
      for (var m = e.subn(1), y = 0;!m.testn(y); y++)
        ;
      for (var M = e.shrn(y), x = m.toRed(f);r > 0; r--) {
        var S = this._randrange(new In(2), m), E2 = e.gcd(S);
        if (E2.cmpn(1) !== 0)
          return E2;
        var B = S.toRed(f).redPow(M);
        if (!(B.cmp(p2) === 0 || B.cmp(x) === 0)) {
          for (var q = 1;q < y; q++) {
            if (B = B.redSqr(), B.cmp(p2) === 0)
              return B.fromRed().subn(1).gcd(e);
            if (B.cmp(x) === 0)
              break;
          }
          if (q === y)
            return B = B.redSqr(), B.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  ol = T((ek, tg) => {
    var eS = on();
    tg.exports = al;
    al.simpleSieve = nl;
    al.fermatTest = fl;
    var Ht = Yu(), tS = new Ht(24), rS = tl(), Qm = new rS, iS = new Ht(1), il = new Ht(2), nS = new Ht(5), YT = new Ht(16), XT = new Ht(8), fS = new Ht(10), aS = new Ht(3), JT = new Ht(7), oS = new Ht(11), eg = new Ht(4), QT = new Ht(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o = 3;o < t; o += 2) {
        for (var f = Math.ceil(Math.sqrt(o)), p2 = 0;p2 < r && e[p2] <= f && o % e[p2] !== 0; p2++)
          ;
        r !== p2 && e[p2] <= f || (e[r++] = o);
      }
      return rl = e, e;
    }
    function nl(t) {
      for (var e = sS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function fl(t) {
      var e = Ht.mont(t);
      return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht([140, 123]) : new Ht([140, 39]);
      e = new Ht(e);
      for (var r, o;; ) {
        for (r = new Ht(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
          if (!e.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o = r.shrn(1), nl(o) && nl(r) && fl(o) && fl(r) && Qm.test(o) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T((rk, fg) => {
    var yr = Yu(), uS = tl(), ig = new uS, lS = new yr(24), dS = new yr(11), cS = new yr(10), pS = new yr(3), vS = new yr(7), ng = ol(), bS = on();
    fg.exports = Si;
    function mS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr(t), this;
    }
    function gS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr(t), this;
    }
    var Rs = {};
    function yS(t, e) {
      var r = e.toString("hex"), o = [r, t.toString(16)].join("_");
      if (o in Rs)
        return Rs[o];
      var f = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f += 1, r === "02" || r === "05" ? f += 8 : f += 4, Rs[o] = f, f;
      ig.test(t.shrn(1)) || (f += 2);
      var p2;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f += 8);
          break;
        case "05":
          p2 = t.mod(cS), p2.cmp(pS) && p2.cmp(vS) && (f += 8);
          break;
        default:
          f += 4;
      }
      return Rs[o] = f, f;
    }
    function Si(t, e, r) {
      this.setGenerator(e), this.__prime = new yr(t), this._prime = yr.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si.prototype.computeSecret = function(t) {
      t = new yr(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o = this.getPrime();
      if (r.length < o.length) {
        var f = new Buffer(o.length - r.length);
        f.fill(0), r = Buffer.concat([f, r]);
      }
      return r;
    };
    Si.prototype.getPublicKey = function(e) {
      return Bs(this._pub, e);
    };
    Si.prototype.getPrivateKey = function(e) {
      return Bs(this._priv, e);
    };
    Si.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr(t), this;
    };
    function Bs(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  hg = T((_f) => {
    var wS = ol(), og = rg(), sl = ag();
    function MS(t) {
      var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl(e, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e, r, o) {
      return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o = o || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl = T((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T((fk, cg) => {
    function lg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(t);
        e && (o = o.filter(function(f) {
          return Object.getOwnPropertyDescriptor(t, f).enumerable;
        })), r.push.apply(r, o);
      }
      return r;
    }
    function xS(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lg(Object(r), true).forEach(function(o) {
          SS(t, o, r[o]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o) {
          Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(r, o));
        });
      }
      return t;
    }
    function SS(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function ES(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o = e[r];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(t, o.key, o);
      }
    }
    function AS(t, e, r) {
      return e && dg(t.prototype, e), r && dg(t, r), t;
    }
    var RS = Ut(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e, r) {
      qs.prototype.copy.call(t, e, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o = { data: r, next: null };
        this.length > 0 ? this.tail.next = o : this.head = o, this.tail = o, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o = { data: r, next: this.head };
        this.length === 0 && (this.tail = o), this.head = o, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o = this.head, f = "" + o.data;o = o.next; )
          f += r + o.data;
        return f;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o = qs.allocUnsafe(r >>> 0), f = this.head, p2 = 0;f; )
          IS(f.data, o, p2), p2 += f.data.length, f = f.next;
        return o;
      } }, { key: "consume", value: function(r, o) {
        var f;
        return r < this.head.data.length ? (f = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f = this.shift() : f = o ? this._getString(r) : this._getBuffer(r), f;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o = this.head, f = 1, p2 = o.data;
        for (r -= p2.length;o = o.next; ) {
          var m = o.data, y = r > m.length ? m.length : r;
          if (y === m.length ? p2 += m : p2 += m.slice(0, r), r -= y, r === 0) {
            y === m.length ? (++f, o.next ? this.head = o.next : this.head = this.tail = null) : (this.head = o, o.data = m.slice(y));
            break;
          }
          ++f;
        }
        return this.length -= f, p2;
      } }, { key: "_getBuffer", value: function(r) {
        var o = qs.allocUnsafe(r), f = this.head, p2 = 1;
        for (f.data.copy(o), r -= f.data.length;f = f.next; ) {
          var m = f.data, y = r > m.length ? m.length : r;
          if (m.copy(o, o.length - r, 0, y), r -= y, r === 0) {
            y === m.length ? (++p2, f.next ? this.head = f.next : this.head = this.tail = null) : (this.head = f, f.data = m.slice(y));
            break;
          }
          ++p2;
        }
        return this.length -= p2, o;
      } }, { key: qS, value: function(r, o) {
        return ul(this, xS({}, o, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl = T((ak, bg) => {
    function TS(t, e) {
      var r = this, o = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
      return o || f ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p2) {
        !e && p2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p2)) : process.nextTick(vg, r, p2) : e ? (process.nextTick(Is, r), e(p2)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e) {
      ll(t, e), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e) {
      t.emit("error", e);
    }
    function LS(t, e) {
      var { _readableState: r, _writableState: o } = t;
      r && r.autoDestroy || o && o.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T((ok, yg) => {
    function NS(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gg = {};
    function wr(t, e, r) {
      r || (r = Error);
      function o(p2, m, y) {
        return typeof e == "string" ? e : e(p2, m, y);
      }
      var f = function(p2) {
        NS(m, p2);
        function m(y, M, x) {
          return p2.call(this, o(y, M, x)) || this;
        }
        return m;
      }(r);
      f.prototype.name = r.name, f.prototype.code = t, gg[t] = f;
    }
    function mg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o) {
          return String(o);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function DS(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function PS(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function CS(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o;
      typeof e == "string" && DS(e, "not ") ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be";
      var f;
      if (PS(t, " argument"))
        f = "The ".concat(t, " ").concat(o, " ").concat(mg(e, "type"));
      else {
        var p2 = CS(t, ".") ? "property" : "argument";
        f = 'The "'.concat(t, '" ').concat(p2, " ").concat(o, " ").concat(mg(e, "type"));
      }
      return f += ". Received type ".concat(typeof r), f;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl = T((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function US(t, e, r, o) {
      var f = FS(e, o, r);
      if (f != null) {
        if (!(isFinite(f) && Math.floor(f) === f) || f < 0) {
          var p2 = o ? r : "highWaterMark";
          throw new OS(p2, f);
        }
        return Math.floor(f);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T((hk, Ag) => {
    Ag.exports = ut;
    function _g(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e, t);
      };
    }
    var xf;
    ut.WritableState = ka;
    var zS = { deprecate: G0() }, xg = hl(), ks = Ut().Buffer, HS = global.Uint8Array || function() {
    };
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl(), jS = cl(), ZS = jS.getHighWaterMark, Vi = kn().codes, VS = Vi.ERR_INVALID_ARG_TYPE, $S = Vi.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi.ERR_MULTIPLE_CALLBACK, YS = Vi.ERR_STREAM_CANNOT_PIPE, XS = Vi.ERR_STREAM_DESTROYED, JS = Vi.ERR_STREAM_NULL_VALUES, QS = Vi.ERR_STREAM_WRITE_AFTER_END, eE = Vi.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
    Ie()(ut, xg);
    function tE() {
    }
    function ka(t, e, r) {
      xf = xf || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o = t.decodeStrings === false;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f) {
        sE(e, f);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {
      }
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut, Symbol.hasInstance, { value: function(e) {
      return Ts.call(this, e) ? true : this !== ut ? false : e && e._writableState instanceof ka;
    } })) : Ts = function(e) {
      return e instanceof this;
    };
    function ut(t) {
      xf = xf || Ln();
      var e = this instanceof xf;
      if (!e && !Ts.call(ut, this))
        return new ut(t);
      this._writableState = new ka(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut.prototype.pipe = function() {
      Sf(this, new YS);
    };
    function rE(t, e) {
      var r = new QS;
      Sf(t, r), process.nextTick(e, r);
    }
    function iE(t, e, r, o) {
      var f;
      return r === null ? f = new JS : typeof r != "string" && !e.objectMode && (f = new VS("chunk", ["string", "Buffer"], r)), f ? (Sf(t, f), process.nextTick(o, f), false) : true;
    }
    ut.prototype.write = function(t, e, r) {
      var o = this._writableState, f = false, p2 = !o.objectMode && KS(t);
      return p2 && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p2 ? e = "buffer" : e || (e = o.defaultEncoding), typeof r != "function" && (r = tE), o.ending ? rE(this, r) : (p2 || iE(this, o, t, r)) && (o.pendingcb++, f = fE(this, o, p2, t, e, r)), f;
    };
    ut.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new eE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
    }
    Object.defineProperty(ut.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e, r, o, f, p2) {
      if (!r) {
        var m = nE(e, o, f);
        o !== m && (r = true, f = "buffer", o = m);
      }
      var y = e.objectMode ? 1 : o.length;
      e.length += y;
      var M = e.length < e.highWaterMark;
      if (M || (e.needDrain = true), e.writing || e.corked) {
        var x = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o, encoding: f, isBuf: r, callback: p2, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        pl(t, e, false, y, o, f, p2);
      return M;
    }
    function pl(t, e, r, o, f, p2, m) {
      e.writelen = o, e.writecb = m, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f, e.onwrite) : t._write(f, p2, e.onwrite), e.sync = false;
    }
    function aE(t, e, r, o, f) {
      --e.pendingcb, r ? (process.nextTick(f, o), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf(t, o)) : (f(o), t._writableState.errorEmitted = true, Sf(t, o), Ta(t, e));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e) {
      var r = t._writableState, o = r.sync, f = r.writecb;
      if (typeof f != "function")
        throw new GS;
      if (oE(r), e)
        aE(t, r, o, e, f);
      else {
        var p2 = Eg(r) || t.destroyed;
        !p2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o ? process.nextTick(Mg, t, r, p2, f) : Mg(t, r, p2, f);
      }
    }
    function Mg(t, e, r, o) {
      r || hE(t, e), e.pendingcb--, o(), Ta(t, e);
    }
    function hE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o = e.bufferedRequestCount, f = new Array(o), p2 = e.corkedRequestsFree;
        p2.entry = r;
        for (var m = 0, y = true;r; )
          f[m] = r, r.isBuf || (y = false), r = r.next, m += 1;
        f.allBuffers = y, pl(t, e, true, e.length, f, "", p2.finish), e.pendingcb++, e.lastBufferedRequest = null, p2.next ? (e.corkedRequestsFree = p2.next, p2.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M, encoding: x, callback: S } = r, E2 = e.objectMode ? 1 : M.length;
          if (pl(t, e, false, E2, M, x, S), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut.prototype._write = function(t, e, r) {
      r(new $S("_write()"));
    };
    ut.prototype._writev = null;
    ut.prototype.end = function(t, e, r) {
      var o = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o.corked && (o.corked = 1, this.uncork()), o.ending || dE(this, o, r), this;
    };
    Object.defineProperty(ut.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Sf(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
      });
    }
    function lE(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e) {
      var r = Eg(e);
      if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o = t._readableState;
        (!o || o.autoDestroy && o.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e, r) {
      e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function cE(t, e, r) {
      var o = t.entry;
      for (t.entry = null;o; ) {
        var f = o.callback;
        e.pendingcb--, f(r), o = o.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut.prototype.destroy = vl.destroy;
    ut.prototype._undestroy = vl.undestroy;
    ut.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  Ln = T((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    Bg.exports = ti;
    var Rg = yl(), gl = bl();
    Ie()(ti, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti.prototype[Ns] || (ti.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti(t) {
      if (!(this instanceof ti))
        return new ti(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Ds = T((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o = new Array(r), f = 0;f < r; f++)
            o[f] = arguments[f];
          t.apply(this, o);
        }
      };
    }
    function gE() {
    }
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e, r) {
      if (typeof e == "function")
        return Ig(t, null, e);
      e || (e = {}), r = mE(r || gE);
      var o = e.readable || e.readable !== false && t.readable, f = e.writable || e.writable !== false && t.writable, p2 = function() {
        t.writable || y();
      }, m = t._writableState && t._writableState.finished, y = function() {
        f = false, m = true, o || r.call(t);
      }, M = t._readableState && t._readableState.endEmitted, x = function() {
        o = false, M = true, f || r.call(t);
      }, S = function(L) {
        r.call(t, L);
      }, E2 = function() {
        var L;
        if (o && !M)
          return (!t._readableState || !t._readableState.ended) && (L = new qg), r.call(t, L);
        if (f && !m)
          return (!t._writableState || !t._writableState.ended) && (L = new qg), r.call(t, L);
      }, B = function() {
        t.req.on("finish", y);
      };
      return yE(t) ? (t.on("complete", y), t.on("abort", E2), t.req ? B() : t.on("request", B)) : f && !t._writableState && (t.on("end", p2), t.on("close", p2)), t.on("end", x), t.on("finish", y), e.error !== false && t.on("error", S), t.on("close", E2), function() {
        t.removeListener("complete", y), t.removeListener("abort", E2), t.removeListener("request", B), t.req && t.req.removeListener("finish", y), t.removeListener("end", p2), t.removeListener("close", p2), t.removeListener("finish", y), t.removeListener("end", x), t.removeListener("error", S), t.removeListener("close", E2);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T((dk, kg) => {
    var Ps;
    function $i(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var wE = Ds(), Gi = Symbol("lastResolve"), Nn = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi(t, e) {
      return { value: t, done: e };
    }
    function ME(t) {
      var e = t[Gi];
      if (e !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn] = null, t[Gi] = null, t[Nn] = null, e(Yi(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e) {
      return function(r, o) {
        t.then(function() {
          if (e[Cs]) {
            r(Yi(undefined, true));
            return;
          }
          e[wl](r, o);
        }, o);
      };
    }
    var SE = Object.getPrototypeOf(function() {
    }), EE = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m, y) {
          process.nextTick(function() {
            e[La] ? y(e[La]) : m(Yi(undefined, true));
          });
        });
      var o = this[Dn], f;
      if (o)
        f = new Promise(xE(o, this));
      else {
        var p2 = this[Pn].read();
        if (p2 !== null)
          return Promise.resolve(Yi(p2, false));
        f = new Promise(this[wl]);
      }
      return this[Dn] = f, f;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e = this;
      return new Promise(function(r, o) {
        e[Pn].destroy(null, function(f) {
          if (f) {
            o(f);
            return;
          }
          r(Yi(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e) {
      var r, o = Object.create(EE, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi, { value: null, writable: true }), $i(r, Nn, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p2, m) {
        var y = o[Pn].read();
        y ? (o[Dn] = null, o[Gi] = null, o[Nn] = null, p2(Yi(y, false))) : (o[Gi] = p2, o[Nn] = m);
      }, writable: true }), r));
      return o[Dn] = null, wE(e, function(f) {
        if (f && f.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p2 = o[Nn];
          p2 !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, p2(f)), o[La] = f;
          return;
        }
        var m = o[Gi];
        m !== null && (o[Dn] = null, o[Gi] = null, o[Nn] = null, m(Yi(undefined, true))), o[Cs] = true;
      }), e.on("readable", _E.bind(null, o)), o;
    };
    kg.exports = AE;
  });
  Dg = T((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl = T((vk, jg) => {
    jg.exports = Oe;
    var Ef;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e, r) {
      return e.listeners(r).length;
    }, Da = hl(), Os = Ut().Buffer, RE = global.Uint8Array || function() {
    };
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {
    };
    var IE = pg(), Bl = dl(), TE = cl(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
    Ie()(Oe, Da);
    var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Fg(t, e, r) {
      Ef = Ef || Ln(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef = Ef || Ln(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Ef;
      this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o;
      return r.objectMode ? o = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o = true), Ug(this, t, e, false, o);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e, r, o, f) {
      De("readableAddChunk", e);
      var p2 = t._readableState;
      if (e === null)
        p2.reading = false, UE(t, p2);
      else {
        var m;
        if (f || (m = OE(p2, e)), m)
          Na(t, m);
        else if (p2.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p2.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o)
            p2.endEmitted ? Na(t, new PE) : El(t, p2, e, true);
          else if (p2.ended)
            Na(t, new NE);
          else {
            if (p2.destroyed)
              return false;
            p2.reading = false, p2.decoder && !r ? (e = p2.decoder.write(e), p2.objectMode || e.length !== 0 ? El(t, p2, e, false) : Rl(t, p2)) : El(t, p2, e, false);
          }
        else
          o || (p2.reading = false, Rl(t, p2));
      }
      return !p2.ended && (p2.length < p2.highWaterMark || p2.length === 0);
    }
    function El(t, e, r, o) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us(t)), Rl(t, e);
    }
    function OE(t, e) {
      var r;
      return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af || (Af = (Qf(), ur(Jf)).StringDecoder);
      var e = new Af(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o = "";r !== null; )
        o += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o !== "" && this._readableState.buffer.push(o), this._readableState.length = o.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us(this), null;
      if (t = Cg(t, e), t === 0 && e.ended)
        return e.length === 0 && Al(this), null;
      var o = e.needReadable;
      De("need readable", o), (e.length === 0 || e.length - t < e.highWaterMark) && (o = true, De("length less than watermark", o)), e.ended || e.reading ? (o = false, De("reading or ended", o)) : o && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
      var f;
      return t > 0 ? f = Wg(t, e) : f = null, f === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f !== null && this.emit("data", f), f;
    };
    function UE(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Us(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
      }
    }
    function Us(t) {
      var e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
    }
    function Rl(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
    }
    function zE(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o = this._readableState;
      switch (o.pipesCount) {
        case 0:
          o.pipes = t;
          break;
        case 1:
          o.pipes = [o.pipes, t];
          break;
        default:
          o.pipes.push(t);
          break;
      }
      o.pipesCount += 1, De("pipe count=%d opts=%j", o.pipesCount, e);
      var f = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p2 = f ? y : ge;
      o.endEmitted ? process.nextTick(p2) : r.once("end", p2), t.on("unpipe", m);
      function m(_e, N2) {
        De("onunpipe"), _e === r && N2 && N2.hasUnpiped === false && (N2.hasUnpiped = true, S());
      }
      function y() {
        De("onend"), t.end();
      }
      var M = HE(r);
      t.on("drain", M);
      var x = false;
      function S() {
        De("cleanup"), t.removeListener("close", q), t.removeListener("finish", L), t.removeListener("drain", M), t.removeListener("error", B), t.removeListener("unpipe", m), r.removeListener("end", y), r.removeListener("end", ge), r.removeListener("data", E2), x = true, o.awaitDrain && (!t._writableState || t._writableState.needDrain) && M();
      }
      r.on("data", E2);
      function E2(_e) {
        De("ondata");
        var N2 = t.write(_e);
        De("dest.write", N2), N2 === false && ((o.pipesCount === 1 && o.pipes === t || o.pipesCount > 1 && Kg(o.pipes, t) !== -1) && !x && (De("false write response, pause", o.awaitDrain), o.awaitDrain++), r.pause());
      }
      function B(_e) {
        De("onerror", _e), ge(), t.removeListener("error", B), Og(t, "error") === 0 && Na(t, _e);
      }
      CE(t, "error", B);
      function q() {
        t.removeListener("finish", L), ge();
      }
      t.once("close", q);
      function L() {
        De("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o, pipesCount: f } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p2 = 0;p2 < f; p2++)
          o[p2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m = Kg(e.pipes, t);
      return m === -1 ? this : (e.pipes.splice(m, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Da.prototype.on.call(this, t, e), o = this._readableState;
      return t === "data" ? (o.readableListening = this.listenerCount("readable") > 0, o.flowing !== false && this.resume()) : t === "readable" && !o.endEmitted && !o.readableListening && (o.readableListening = o.needReadable = true, o.flowing = false, o.emittedReadable = false, De("on readable", o.length, o.reading), o.length ? Us(this) : o.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Da.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
    };
    function Hg(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
    }
    function jE(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m = r.decoder.end();
          m && m.length && e.push(m);
        }
        e.push(null);
      }), t.on("data", function(m) {
        if (De("wrapped data"), r.decoder && (m = r.decoder.write(m)), !(r.objectMode && m == null) && !(!r.objectMode && (!m || !m.length))) {
          var y = e.push(m);
          y || (o = true, t.pause());
        }
      });
      for (var f in t)
        this[f] === undefined && typeof t[f] == "function" && (this[f] = function(y) {
          return function() {
            return t[y].apply(t, arguments);
          };
        }(f));
      for (var p2 = 0;p2 < Sl.length; p2++)
        t.on(Sl[p2], this.emit.bind(this, Sl[p2]));
      return this._read = function(m) {
        De("wrapped _read", m), o && (o = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Al(t) {
      var e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
    }
    function ZE(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e);
    });
    function Kg(t, e) {
      for (var r = 0, o = t.length;r < o; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Il = T((bk, Vg) => {
    Vg.exports = Ei;
    var zs = kn().codes, VE = zs.ERR_METHOD_NOT_IMPLEMENTED, $E = zs.ERR_MULTIPLE_CALLBACK, GE = zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs.ERR_TRANSFORM_WITH_LENGTH_0, Hs = Ln();
    Ie()(Ei, Hs);
    function XE(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o = r.writecb;
      if (o === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o(t);
      var f = this._readableState;
      f.reading = false, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
    function Ei(t) {
      if (!(this instanceof Ei))
        return new Ei(t);
      Hs.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Zg(t, e, r);
      }) : Zg(this, null, null);
    }
    Ei.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Hs.prototype.push.call(this, t, e);
    };
    Ei.prototype._transform = function(t, e, r) {
      r(new VE("_transform()"));
    };
    Ei.prototype._write = function(t, e, r) {
      var o = this._transformState;
      if (o.writecb = r, o.writechunk = t, o.writeencoding = e, !o.transforming) {
        var f = this._readableState;
        (o.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
      }
    };
    Ei.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    Ei.prototype._destroy = function(t, e) {
      Hs.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Zg(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  t2 = T((gk, e2) => {
    var Tl;
    function QE(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e, r, o) {
      o = QE(o);
      var f = false;
      t.on("close", function() {
        f = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m) {
        if (m)
          return o(m);
        f = true, o();
      });
      var p2 = false;
      return function(m) {
        if (!f && !p2) {
          if (p2 = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o(m || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e) {
      return t.pipe(e);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o = fA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new eA("streams");
      var f, p2 = e.map(function(m, y) {
        var M = y < e.length - 1, x = y > 0;
        return iA(m, M, x, function(S) {
          f || (f = S), S && p2.forEach(Jg), !M && (p2.forEach(Jg), o(f));
        });
      });
      return e.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T((Mr, r2) => {
    Mr = r2.exports = yl();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws = T((n2, kl) => {
    (function(t, e) {
      function r(h, s) {
        if (!h)
          throw new Error(s || "Assertion failed");
      }
      function o(h, s) {
        h.super_ = s;
        var u = function() {
        };
        u.prototype = s.prototype, h.prototype = new u, h.prototype.constructor = h;
      }
      function f(h, s, u) {
        if (f.isBN(h))
          return h;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h !== null && ((s === "le" || s === "be") && (u = s, s = 10), this._init(h || 0, s || 10, u || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(s) {
        return s instanceof f ? true : s !== null && typeof s == "object" && s.constructor.wordSize === f.wordSize && Array.isArray(s.words);
      }, f.max = function(s, u) {
        return s.cmp(u) > 0 ? s : u;
      }, f.min = function(s, u) {
        return s.cmp(u) < 0 ? s : u;
      }, f.prototype._init = function(s, u, c) {
        if (typeof s == "number")
          return this._initNumber(s, u, c);
        if (typeof s == "object")
          return this._initArray(s, u, c);
        u === "hex" && (u = 16), r(u === (u | 0) && u >= 2 && u <= 36), s = s.toString().replace(/\s+/g, "");
        var b = 0;
        s[0] === "-" && (b++, this.negative = 1), b < s.length && (u === 16 ? this._parseHex(s, b, c) : (this._parseBase(s, u, b), c === "le" && this._initArray(this.toArray(), u, c)));
      }, f.prototype._initNumber = function(s, u, c) {
        s < 0 && (this.negative = 1, s = -s), s < 67108864 ? (this.words = [s & 67108863], this.length = 1) : s < 4503599627370496 ? (this.words = [s & 67108863, s / 67108864 & 67108863], this.length = 2) : (r(s < 9007199254740992), this.words = [s & 67108863, s / 67108864 & 67108863, 1], this.length = 3), c === "le" && this._initArray(this.toArray(), u, c);
      }, f.prototype._initArray = function(s, u, c) {
        if (r(typeof s.length == "number"), s.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s.length / 3), this.words = new Array(this.length);
        for (var b = 0;b < this.length; b++)
          this.words[b] = 0;
        var l, n, d = 0;
        if (c === "be")
          for (b = s.length - 1, l = 0;b >= 0; b -= 3)
            n = s[b] | s[b - 1] << 8 | s[b - 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        else if (c === "le")
          for (b = 0, l = 0;b < s.length; b += 3)
            n = s[b] | s[b + 1] << 8 | s[b + 2] << 16, this.words[l] |= n << d & 67108863, this.words[l + 1] = n >>> 26 - d & 67108863, d += 24, d >= 26 && (d -= 26, l++);
        return this._strip();
      };
      function m(h, s) {
        var u = h.charCodeAt(s);
        if (u >= 48 && u <= 57)
          return u - 48;
        if (u >= 65 && u <= 70)
          return u - 55;
        if (u >= 97 && u <= 102)
          return u - 87;
        r(false, "Invalid character in " + h);
      }
      function y(h, s, u) {
        var c = m(h, u);
        return u - 1 >= s && (c |= m(h, u - 1) << 4), c;
      }
      f.prototype._parseHex = function(s, u, c) {
        this.length = Math.ceil((s.length - u) / 6), this.words = new Array(this.length);
        for (var b = 0;b < this.length; b++)
          this.words[b] = 0;
        var l = 0, n = 0, d;
        if (c === "be")
          for (b = s.length - 1;b >= u; b -= 2)
            d = y(s, u, b) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        else {
          var w = s.length - u;
          for (b = w % 2 === 0 ? u + 1 : u;b < s.length; b += 2)
            d = y(s, u, b) << l, this.words[n] |= d & 67108863, l >= 18 ? (l -= 18, n += 1, this.words[n] |= d >>> 26) : l += 8;
        }
        this._strip();
      };
      function M(h, s, u, c) {
        for (var b = 0, l = 0, n = Math.min(h.length, u), d = s;d < n; d++) {
          var w = h.charCodeAt(d) - 48;
          b *= c, w >= 49 ? l = w - 49 + 10 : w >= 17 ? l = w - 17 + 10 : l = w, r(w >= 0 && l < c, "Invalid character"), b += l;
        }
        return b;
      }
      f.prototype._parseBase = function(s, u, c) {
        this.words = [0], this.length = 1;
        for (var b = 0, l = 1;l <= 67108863; l *= u)
          b++;
        b--, l = l / u | 0;
        for (var n = s.length - c, d = n % b, w = Math.min(n, n - d) + c, g = 0, _ = c;_ < w; _ += b)
          g = M(s, _, _ + b, u), this.imuln(l), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        if (d !== 0) {
          var A = 1;
          for (g = M(s, _, s.length, u), _ = 0;_ < d; _++)
            A *= u;
          this.imuln(A), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        }
        this._strip();
      }, f.prototype.copy = function(s) {
        s.words = new Array(this.length);
        for (var u = 0;u < this.length; u++)
          s.words[u] = this.words[u];
        s.length = this.length, s.negative = this.negative, s.red = this.red;
      };
      function x(h, s) {
        h.words = s.words, h.length = s.length, h.negative = s.negative, h.red = s.red;
      }
      if (f.prototype._move = function(s) {
        x(s, this);
      }, f.prototype.clone = function() {
        var s = new f(null);
        return this.copy(s), s;
      }, f.prototype._expand = function(s) {
        for (;this.length < s; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f.prototype[Symbol.for("nodejs.util.inspect.custom")] = S;
        } catch {
          f.prototype.inspect = S;
        }
      else
        f.prototype.inspect = S;
      function S() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(s, u) {
        s = s || 10, u = u | 0 || 1;
        var c;
        if (s === 16 || s === "hex") {
          c = "";
          for (var b = 0, l = 0, n = 0;n < this.length; n++) {
            var d = this.words[n], w = ((d << b | l) & 16777215).toString(16);
            l = d >>> 24 - b & 16777215, b += 2, b >= 26 && (b -= 26, n--), l !== 0 || n !== this.length - 1 ? c = E2[6 - w.length] + w + c : c = w + c;
          }
          for (l !== 0 && (c = l.toString(16) + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        if (s === (s | 0) && s >= 2 && s <= 36) {
          var g = B[s], _ = q[s];
          c = "";
          var A = this.clone();
          for (A.negative = 0;!A.isZero(); ) {
            var R = A.modrn(_).toString(s);
            A = A.idivn(_), A.isZero() ? c = R + c : c = E2[g - R.length] + R + c;
          }
          for (this.isZero() && (c = "0" + c);c.length % u !== 0; )
            c = "0" + c;
          return this.negative !== 0 && (c = "-" + c), c;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var s = this.words[0];
        return this.length === 2 ? s += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s : s;
      }, f.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p2 && (f.prototype.toBuffer = function(s, u) {
        return this.toArrayLike(p2, s, u);
      }), f.prototype.toArray = function(s, u) {
        return this.toArrayLike(Array, s, u);
      };
      var L = function(s, u) {
        return s.allocUnsafe ? s.allocUnsafe(u) : new s(u);
      };
      f.prototype.toArrayLike = function(s, u, c) {
        this._strip();
        var b = this.byteLength(), l = c || Math.max(1, b);
        r(b <= l, "byte array longer than desired length"), r(l > 0, "Requested array length <= 0");
        var n = L(s, l), d = u === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d](n, b), n;
      }, f.prototype._toArrayLikeLE = function(s, u) {
        for (var c = 0, b = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b;
          s[c++] = d & 255, c < s.length && (s[c++] = d >> 8 & 255), c < s.length && (s[c++] = d >> 16 & 255), n === 6 ? (c < s.length && (s[c++] = d >> 24 & 255), b = 0, n = 0) : (b = d >>> 24, n += 2);
        }
        if (c < s.length)
          for (s[c++] = b;c < s.length; )
            s[c++] = 0;
      }, f.prototype._toArrayLikeBE = function(s, u) {
        for (var c = s.length - 1, b = 0, l = 0, n = 0;l < this.length; l++) {
          var d = this.words[l] << n | b;
          s[c--] = d & 255, c >= 0 && (s[c--] = d >> 8 & 255), c >= 0 && (s[c--] = d >> 16 & 255), n === 6 ? (c >= 0 && (s[c--] = d >> 24 & 255), b = 0, n = 0) : (b = d >>> 24, n += 2);
        }
        if (c >= 0)
          for (s[c--] = b;c >= 0; )
            s[c--] = 0;
      }, Math.clz32 ? f.prototype._countBits = function(s) {
        return 32 - Math.clz32(s);
      } : f.prototype._countBits = function(s) {
        var u = s, c = 0;
        return u >= 4096 && (c += 13, u >>>= 13), u >= 64 && (c += 7, u >>>= 7), u >= 8 && (c += 4, u >>>= 4), u >= 2 && (c += 2, u >>>= 2), c + u;
      }, f.prototype._zeroBits = function(s) {
        if (s === 0)
          return 26;
        var u = s, c = 0;
        return (u & 8191) === 0 && (c += 13, u >>>= 13), (u & 127) === 0 && (c += 7, u >>>= 7), (u & 15) === 0 && (c += 4, u >>>= 4), (u & 3) === 0 && (c += 2, u >>>= 2), (u & 1) === 0 && c++, c;
      }, f.prototype.bitLength = function() {
        var s = this.words[this.length - 1], u = this._countBits(s);
        return (this.length - 1) * 26 + u;
      };
      function ge(h) {
        for (var s = new Array(h.bitLength()), u = 0;u < s.length; u++) {
          var c = u / 26 | 0, b = u % 26;
          s[u] = h.words[c] >>> b & 1;
        }
        return s;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s = 0, u = 0;u < this.length; u++) {
          var c = this._zeroBits(this.words[u]);
          if (s += c, c !== 26)
            break;
        }
        return s;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(s) {
        return this.negative !== 0 ? this.abs().inotn(s).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(s) {
        return this.testn(s - 1) ? this.notn(s).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(s) {
        for (;this.length < s.length; )
          this.words[this.length++] = 0;
        for (var u = 0;u < s.length; u++)
          this.words[u] = this.words[u] | s.words[u];
        return this._strip();
      }, f.prototype.ior = function(s) {
        return r((this.negative | s.negative) === 0), this.iuor(s);
      }, f.prototype.or = function(s) {
        return this.length > s.length ? this.clone().ior(s) : s.clone().ior(this);
      }, f.prototype.uor = function(s) {
        return this.length > s.length ? this.clone().iuor(s) : s.clone().iuor(this);
      }, f.prototype.iuand = function(s) {
        var u;
        this.length > s.length ? u = s : u = this;
        for (var c = 0;c < u.length; c++)
          this.words[c] = this.words[c] & s.words[c];
        return this.length = u.length, this._strip();
      }, f.prototype.iand = function(s) {
        return r((this.negative | s.negative) === 0), this.iuand(s);
      }, f.prototype.and = function(s) {
        return this.length > s.length ? this.clone().iand(s) : s.clone().iand(this);
      }, f.prototype.uand = function(s) {
        return this.length > s.length ? this.clone().iuand(s) : s.clone().iuand(this);
      }, f.prototype.iuxor = function(s) {
        var u, c;
        this.length > s.length ? (u = this, c = s) : (u = s, c = this);
        for (var b = 0;b < c.length; b++)
          this.words[b] = u.words[b] ^ c.words[b];
        if (this !== u)
          for (;b < u.length; b++)
            this.words[b] = u.words[b];
        return this.length = u.length, this._strip();
      }, f.prototype.ixor = function(s) {
        return r((this.negative | s.negative) === 0), this.iuxor(s);
      }, f.prototype.xor = function(s) {
        return this.length > s.length ? this.clone().ixor(s) : s.clone().ixor(this);
      }, f.prototype.uxor = function(s) {
        return this.length > s.length ? this.clone().iuxor(s) : s.clone().iuxor(this);
      }, f.prototype.inotn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = Math.ceil(s / 26) | 0, c = s % 26;
        this._expand(u), c > 0 && u--;
        for (var b = 0;b < u; b++)
          this.words[b] = ~this.words[b] & 67108863;
        return c > 0 && (this.words[b] = ~this.words[b] & 67108863 >> 26 - c), this._strip();
      }, f.prototype.notn = function(s) {
        return this.clone().inotn(s);
      }, f.prototype.setn = function(s, u) {
        r(typeof s == "number" && s >= 0);
        var c = s / 26 | 0, b = s % 26;
        return this._expand(c + 1), u ? this.words[c] = this.words[c] | 1 << b : this.words[c] = this.words[c] & ~(1 << b), this._strip();
      }, f.prototype.iadd = function(s) {
        var u;
        if (this.negative !== 0 && s.negative === 0)
          return this.negative = 0, u = this.isub(s), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s.negative !== 0)
          return s.negative = 0, u = this.isub(s), s.negative = 1, u._normSign();
        var c, b;
        this.length > s.length ? (c = this, b = s) : (c = s, b = this);
        for (var l = 0, n = 0;n < b.length; n++)
          u = (c.words[n] | 0) + (b.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        for (;l !== 0 && n < c.length; n++)
          u = (c.words[n] | 0) + l, this.words[n] = u & 67108863, l = u >>> 26;
        if (this.length = c.length, l !== 0)
          this.words[this.length] = l, this.length++;
        else if (c !== this)
          for (;n < c.length; n++)
            this.words[n] = c.words[n];
        return this;
      }, f.prototype.add = function(s) {
        var u;
        return s.negative !== 0 && this.negative === 0 ? (s.negative = 0, u = this.sub(s), s.negative ^= 1, u) : s.negative === 0 && this.negative !== 0 ? (this.negative = 0, u = s.sub(this), this.negative = 1, u) : this.length > s.length ? this.clone().iadd(s) : s.clone().iadd(this);
      }, f.prototype.isub = function(s) {
        if (s.negative !== 0) {
          s.negative = 0;
          var u = this.iadd(s);
          return s.negative = 1, u._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s), this.negative = 1, this._normSign();
        var c = this.cmp(s);
        if (c === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b, l;
        c > 0 ? (b = this, l = s) : (b = s, l = this);
        for (var n = 0, d = 0;d < l.length; d++)
          u = (b.words[d] | 0) - (l.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        for (;n !== 0 && d < b.length; d++)
          u = (b.words[d] | 0) + n, n = u >> 26, this.words[d] = u & 67108863;
        if (n === 0 && d < b.length && b !== this)
          for (;d < b.length; d++)
            this.words[d] = b.words[d];
        return this.length = Math.max(this.length, d), b !== this && (this.negative = 1), this._strip();
      }, f.prototype.sub = function(s) {
        return this.clone().isub(s);
      };
      function _e(h, s, u) {
        u.negative = s.negative ^ h.negative;
        var c = h.length + s.length | 0;
        u.length = c, c = c - 1 | 0;
        var b = h.words[0] | 0, l = s.words[0] | 0, n = b * l, d = n & 67108863, w = n / 67108864 | 0;
        u.words[0] = d;
        for (var g = 1;g < c; g++) {
          for (var _ = w >>> 26, A = w & 67108863, R = Math.min(g, s.length - 1), I = Math.max(0, g - h.length + 1);I <= R; I++) {
            var Me = g - I | 0;
            b = h.words[Me] | 0, l = s.words[I] | 0, n = b * l + A, _ += n / 67108864 | 0, A = n & 67108863;
          }
          u.words[g] = A | 0, w = _ | 0;
        }
        return w !== 0 ? u.words[g] = w | 0 : u.length--, u._strip();
      }
      var N2 = function(s, u, c) {
        var b = s.words, l = u.words, n = c.words, d = 0, w, g, _, A = b[0] | 0, R = A & 8191, I = A >>> 13, Me = b[1] | 0, k = Me & 8191, D = Me >>> 13, nt2 = b[2] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = b[3] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = b[4] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = b[5] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = b[6] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = b[7] | 0, V2 = yt2 & 8191, $ = yt2 >>> 13, wt = b[8] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = b[9] | 0, X = Mt & 8191, J = Mt >>> 13, _t = l[0] | 0, Q = _t & 8191, ee = _t >>> 13, xt = l[1] | 0, te = xt & 8191, re2 = xt >>> 13, St = l[2] | 0, ie = St & 8191, ne = St >>> 13, Et = l[3] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = l[4] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = l[5] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = l[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt = l[7] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = l[8] | 0, ve = It & 8191, be = It >>> 13, ft = l[9] | 0, Be = ft & 8191, qe2 = ft >>> 13;
        c.negative = s.negative ^ u.negative, c.length = 19, w = Math.imul(R, Q), g = Math.imul(R, ee), g = g + Math.imul(I, Q) | 0, _ = Math.imul(I, ee);
        var ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w = Math.imul(k, Q), g = Math.imul(k, ee), g = g + Math.imul(D, Q) | 0, _ = Math.imul(D, ee), w = w + Math.imul(R, te) | 0, g = g + Math.imul(R, re2) | 0, g = g + Math.imul(I, te) | 0, _ = _ + Math.imul(I, re2) | 0;
        var He = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, w = Math.imul(C, Q), g = Math.imul(C, ee), g = g + Math.imul(O, Q) | 0, _ = Math.imul(O, ee), w = w + Math.imul(k, te) | 0, g = g + Math.imul(k, re2) | 0, g = g + Math.imul(D, te) | 0, _ = _ + Math.imul(D, re2) | 0, w = w + Math.imul(R, ie) | 0, g = g + Math.imul(R, ne) | 0, g = g + Math.imul(I, ie) | 0, _ = _ + Math.imul(I, ne) | 0;
        var We = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, w = Math.imul(F2, Q), g = Math.imul(F2, ee), g = g + Math.imul(U, Q) | 0, _ = Math.imul(U, ee), w = w + Math.imul(C, te) | 0, g = g + Math.imul(C, re2) | 0, g = g + Math.imul(O, te) | 0, _ = _ + Math.imul(O, re2) | 0, w = w + Math.imul(k, ie) | 0, g = g + Math.imul(k, ne) | 0, g = g + Math.imul(D, ie) | 0, _ = _ + Math.imul(D, ne) | 0, w = w + Math.imul(R, fe) | 0, g = g + Math.imul(R, ae) | 0, g = g + Math.imul(I, fe) | 0, _ = _ + Math.imul(I, ae) | 0;
        var Ke = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, w = Math.imul(z, Q), g = Math.imul(z, ee), g = g + Math.imul(H2, Q) | 0, _ = Math.imul(H2, ee), w = w + Math.imul(F2, te) | 0, g = g + Math.imul(F2, re2) | 0, g = g + Math.imul(U, te) | 0, _ = _ + Math.imul(U, re2) | 0, w = w + Math.imul(C, ie) | 0, g = g + Math.imul(C, ne) | 0, g = g + Math.imul(O, ie) | 0, _ = _ + Math.imul(O, ne) | 0, w = w + Math.imul(k, fe) | 0, g = g + Math.imul(k, ae) | 0, g = g + Math.imul(D, fe) | 0, _ = _ + Math.imul(D, ae) | 0, w = w + Math.imul(R, oe) | 0, g = g + Math.imul(R, se) | 0, g = g + Math.imul(I, oe) | 0, _ = _ + Math.imul(I, se) | 0;
        var je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w = Math.imul(W, Q), g = Math.imul(W, ee), g = g + Math.imul(K, Q) | 0, _ = Math.imul(K, ee), w = w + Math.imul(z, te) | 0, g = g + Math.imul(z, re2) | 0, g = g + Math.imul(H2, te) | 0, _ = _ + Math.imul(H2, re2) | 0, w = w + Math.imul(F2, ie) | 0, g = g + Math.imul(F2, ne) | 0, g = g + Math.imul(U, ie) | 0, _ = _ + Math.imul(U, ne) | 0, w = w + Math.imul(C, fe) | 0, g = g + Math.imul(C, ae) | 0, g = g + Math.imul(O, fe) | 0, _ = _ + Math.imul(O, ae) | 0, w = w + Math.imul(k, oe) | 0, g = g + Math.imul(k, se) | 0, g = g + Math.imul(D, oe) | 0, _ = _ + Math.imul(D, se) | 0, w = w + Math.imul(R, he) | 0, g = g + Math.imul(R, ue) | 0, g = g + Math.imul(I, he) | 0, _ = _ + Math.imul(I, ue) | 0;
        var Ze = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, w = Math.imul(j, Q), g = Math.imul(j, ee), g = g + Math.imul(Z, Q) | 0, _ = Math.imul(Z, ee), w = w + Math.imul(W, te) | 0, g = g + Math.imul(W, re2) | 0, g = g + Math.imul(K, te) | 0, _ = _ + Math.imul(K, re2) | 0, w = w + Math.imul(z, ie) | 0, g = g + Math.imul(z, ne) | 0, g = g + Math.imul(H2, ie) | 0, _ = _ + Math.imul(H2, ne) | 0, w = w + Math.imul(F2, fe) | 0, g = g + Math.imul(F2, ae) | 0, g = g + Math.imul(U, fe) | 0, _ = _ + Math.imul(U, ae) | 0, w = w + Math.imul(C, oe) | 0, g = g + Math.imul(C, se) | 0, g = g + Math.imul(O, oe) | 0, _ = _ + Math.imul(O, se) | 0, w = w + Math.imul(k, he) | 0, g = g + Math.imul(k, ue) | 0, g = g + Math.imul(D, he) | 0, _ = _ + Math.imul(D, ue) | 0, w = w + Math.imul(R, le) | 0, g = g + Math.imul(R, de) | 0, g = g + Math.imul(I, le) | 0, _ = _ + Math.imul(I, de) | 0;
        var Ve = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w = Math.imul(V2, Q), g = Math.imul(V2, ee), g = g + Math.imul($, Q) | 0, _ = Math.imul($, ee), w = w + Math.imul(j, te) | 0, g = g + Math.imul(j, re2) | 0, g = g + Math.imul(Z, te) | 0, _ = _ + Math.imul(Z, re2) | 0, w = w + Math.imul(W, ie) | 0, g = g + Math.imul(W, ne) | 0, g = g + Math.imul(K, ie) | 0, _ = _ + Math.imul(K, ne) | 0, w = w + Math.imul(z, fe) | 0, g = g + Math.imul(z, ae) | 0, g = g + Math.imul(H2, fe) | 0, _ = _ + Math.imul(H2, ae) | 0, w = w + Math.imul(F2, oe) | 0, g = g + Math.imul(F2, se) | 0, g = g + Math.imul(U, oe) | 0, _ = _ + Math.imul(U, se) | 0, w = w + Math.imul(C, he) | 0, g = g + Math.imul(C, ue) | 0, g = g + Math.imul(O, he) | 0, _ = _ + Math.imul(O, ue) | 0, w = w + Math.imul(k, le) | 0, g = g + Math.imul(k, de) | 0, g = g + Math.imul(D, le) | 0, _ = _ + Math.imul(D, de) | 0, w = w + Math.imul(R, ce2) | 0, g = g + Math.imul(R, pe) | 0, g = g + Math.imul(I, ce2) | 0, _ = _ + Math.imul(I, pe) | 0;
        var $e = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, w = Math.imul(G, Q), g = Math.imul(G, ee), g = g + Math.imul(Y2, Q) | 0, _ = Math.imul(Y2, ee), w = w + Math.imul(V2, te) | 0, g = g + Math.imul(V2, re2) | 0, g = g + Math.imul($, te) | 0, _ = _ + Math.imul($, re2) | 0, w = w + Math.imul(j, ie) | 0, g = g + Math.imul(j, ne) | 0, g = g + Math.imul(Z, ie) | 0, _ = _ + Math.imul(Z, ne) | 0, w = w + Math.imul(W, fe) | 0, g = g + Math.imul(W, ae) | 0, g = g + Math.imul(K, fe) | 0, _ = _ + Math.imul(K, ae) | 0, w = w + Math.imul(z, oe) | 0, g = g + Math.imul(z, se) | 0, g = g + Math.imul(H2, oe) | 0, _ = _ + Math.imul(H2, se) | 0, w = w + Math.imul(F2, he) | 0, g = g + Math.imul(F2, ue) | 0, g = g + Math.imul(U, he) | 0, _ = _ + Math.imul(U, ue) | 0, w = w + Math.imul(C, le) | 0, g = g + Math.imul(C, de) | 0, g = g + Math.imul(O, le) | 0, _ = _ + Math.imul(O, de) | 0, w = w + Math.imul(k, ce2) | 0, g = g + Math.imul(k, pe) | 0, g = g + Math.imul(D, ce2) | 0, _ = _ + Math.imul(D, pe) | 0, w = w + Math.imul(R, ve) | 0, g = g + Math.imul(R, be) | 0, g = g + Math.imul(I, ve) | 0, _ = _ + Math.imul(I, be) | 0;
        var Ge = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w = Math.imul(X, Q), g = Math.imul(X, ee), g = g + Math.imul(J, Q) | 0, _ = Math.imul(J, ee), w = w + Math.imul(G, te) | 0, g = g + Math.imul(G, re2) | 0, g = g + Math.imul(Y2, te) | 0, _ = _ + Math.imul(Y2, re2) | 0, w = w + Math.imul(V2, ie) | 0, g = g + Math.imul(V2, ne) | 0, g = g + Math.imul($, ie) | 0, _ = _ + Math.imul($, ne) | 0, w = w + Math.imul(j, fe) | 0, g = g + Math.imul(j, ae) | 0, g = g + Math.imul(Z, fe) | 0, _ = _ + Math.imul(Z, ae) | 0, w = w + Math.imul(W, oe) | 0, g = g + Math.imul(W, se) | 0, g = g + Math.imul(K, oe) | 0, _ = _ + Math.imul(K, se) | 0, w = w + Math.imul(z, he) | 0, g = g + Math.imul(z, ue) | 0, g = g + Math.imul(H2, he) | 0, _ = _ + Math.imul(H2, ue) | 0, w = w + Math.imul(F2, le) | 0, g = g + Math.imul(F2, de) | 0, g = g + Math.imul(U, le) | 0, _ = _ + Math.imul(U, de) | 0, w = w + Math.imul(C, ce2) | 0, g = g + Math.imul(C, pe) | 0, g = g + Math.imul(O, ce2) | 0, _ = _ + Math.imul(O, pe) | 0, w = w + Math.imul(k, ve) | 0, g = g + Math.imul(k, be) | 0, g = g + Math.imul(D, ve) | 0, _ = _ + Math.imul(D, be) | 0, w = w + Math.imul(R, Be) | 0, g = g + Math.imul(R, qe2) | 0, g = g + Math.imul(I, Be) | 0, _ = _ + Math.imul(I, qe2) | 0;
        var Ye = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w = Math.imul(X, te), g = Math.imul(X, re2), g = g + Math.imul(J, te) | 0, _ = Math.imul(J, re2), w = w + Math.imul(G, ie) | 0, g = g + Math.imul(G, ne) | 0, g = g + Math.imul(Y2, ie) | 0, _ = _ + Math.imul(Y2, ne) | 0, w = w + Math.imul(V2, fe) | 0, g = g + Math.imul(V2, ae) | 0, g = g + Math.imul($, fe) | 0, _ = _ + Math.imul($, ae) | 0, w = w + Math.imul(j, oe) | 0, g = g + Math.imul(j, se) | 0, g = g + Math.imul(Z, oe) | 0, _ = _ + Math.imul(Z, se) | 0, w = w + Math.imul(W, he) | 0, g = g + Math.imul(W, ue) | 0, g = g + Math.imul(K, he) | 0, _ = _ + Math.imul(K, ue) | 0, w = w + Math.imul(z, le) | 0, g = g + Math.imul(z, de) | 0, g = g + Math.imul(H2, le) | 0, _ = _ + Math.imul(H2, de) | 0, w = w + Math.imul(F2, ce2) | 0, g = g + Math.imul(F2, pe) | 0, g = g + Math.imul(U, ce2) | 0, _ = _ + Math.imul(U, pe) | 0, w = w + Math.imul(C, ve) | 0, g = g + Math.imul(C, be) | 0, g = g + Math.imul(O, ve) | 0, _ = _ + Math.imul(O, be) | 0, w = w + Math.imul(k, Be) | 0, g = g + Math.imul(k, qe2) | 0, g = g + Math.imul(D, Be) | 0, _ = _ + Math.imul(D, qe2) | 0;
        var Xe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w = Math.imul(X, ie), g = Math.imul(X, ne), g = g + Math.imul(J, ie) | 0, _ = Math.imul(J, ne), w = w + Math.imul(G, fe) | 0, g = g + Math.imul(G, ae) | 0, g = g + Math.imul(Y2, fe) | 0, _ = _ + Math.imul(Y2, ae) | 0, w = w + Math.imul(V2, oe) | 0, g = g + Math.imul(V2, se) | 0, g = g + Math.imul($, oe) | 0, _ = _ + Math.imul($, se) | 0, w = w + Math.imul(j, he) | 0, g = g + Math.imul(j, ue) | 0, g = g + Math.imul(Z, he) | 0, _ = _ + Math.imul(Z, ue) | 0, w = w + Math.imul(W, le) | 0, g = g + Math.imul(W, de) | 0, g = g + Math.imul(K, le) | 0, _ = _ + Math.imul(K, de) | 0, w = w + Math.imul(z, ce2) | 0, g = g + Math.imul(z, pe) | 0, g = g + Math.imul(H2, ce2) | 0, _ = _ + Math.imul(H2, pe) | 0, w = w + Math.imul(F2, ve) | 0, g = g + Math.imul(F2, be) | 0, g = g + Math.imul(U, ve) | 0, _ = _ + Math.imul(U, be) | 0, w = w + Math.imul(C, Be) | 0, g = g + Math.imul(C, qe2) | 0, g = g + Math.imul(O, Be) | 0, _ = _ + Math.imul(O, qe2) | 0;
        var Je = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w = Math.imul(X, fe), g = Math.imul(X, ae), g = g + Math.imul(J, fe) | 0, _ = Math.imul(J, ae), w = w + Math.imul(G, oe) | 0, g = g + Math.imul(G, se) | 0, g = g + Math.imul(Y2, oe) | 0, _ = _ + Math.imul(Y2, se) | 0, w = w + Math.imul(V2, he) | 0, g = g + Math.imul(V2, ue) | 0, g = g + Math.imul($, he) | 0, _ = _ + Math.imul($, ue) | 0, w = w + Math.imul(j, le) | 0, g = g + Math.imul(j, de) | 0, g = g + Math.imul(Z, le) | 0, _ = _ + Math.imul(Z, de) | 0, w = w + Math.imul(W, ce2) | 0, g = g + Math.imul(W, pe) | 0, g = g + Math.imul(K, ce2) | 0, _ = _ + Math.imul(K, pe) | 0, w = w + Math.imul(z, ve) | 0, g = g + Math.imul(z, be) | 0, g = g + Math.imul(H2, ve) | 0, _ = _ + Math.imul(H2, be) | 0, w = w + Math.imul(F2, Be) | 0, g = g + Math.imul(F2, qe2) | 0, g = g + Math.imul(U, Be) | 0, _ = _ + Math.imul(U, qe2) | 0;
        var Qe = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, w = Math.imul(X, oe), g = Math.imul(X, se), g = g + Math.imul(J, oe) | 0, _ = Math.imul(J, se), w = w + Math.imul(G, he) | 0, g = g + Math.imul(G, ue) | 0, g = g + Math.imul(Y2, he) | 0, _ = _ + Math.imul(Y2, ue) | 0, w = w + Math.imul(V2, le) | 0, g = g + Math.imul(V2, de) | 0, g = g + Math.imul($, le) | 0, _ = _ + Math.imul($, de) | 0, w = w + Math.imul(j, ce2) | 0, g = g + Math.imul(j, pe) | 0, g = g + Math.imul(Z, ce2) | 0, _ = _ + Math.imul(Z, pe) | 0, w = w + Math.imul(W, ve) | 0, g = g + Math.imul(W, be) | 0, g = g + Math.imul(K, ve) | 0, _ = _ + Math.imul(K, be) | 0, w = w + Math.imul(z, Be) | 0, g = g + Math.imul(z, qe2) | 0, g = g + Math.imul(H2, Be) | 0, _ = _ + Math.imul(H2, qe2) | 0;
        var et = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, w = Math.imul(X, he), g = Math.imul(X, ue), g = g + Math.imul(J, he) | 0, _ = Math.imul(J, ue), w = w + Math.imul(G, le) | 0, g = g + Math.imul(G, de) | 0, g = g + Math.imul(Y2, le) | 0, _ = _ + Math.imul(Y2, de) | 0, w = w + Math.imul(V2, ce2) | 0, g = g + Math.imul(V2, pe) | 0, g = g + Math.imul($, ce2) | 0, _ = _ + Math.imul($, pe) | 0, w = w + Math.imul(j, ve) | 0, g = g + Math.imul(j, be) | 0, g = g + Math.imul(Z, ve) | 0, _ = _ + Math.imul(Z, be) | 0, w = w + Math.imul(W, Be) | 0, g = g + Math.imul(W, qe2) | 0, g = g + Math.imul(K, Be) | 0, _ = _ + Math.imul(K, qe2) | 0;
        var tt2 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, w = Math.imul(X, le), g = Math.imul(X, de), g = g + Math.imul(J, le) | 0, _ = Math.imul(J, de), w = w + Math.imul(G, ce2) | 0, g = g + Math.imul(G, pe) | 0, g = g + Math.imul(Y2, ce2) | 0, _ = _ + Math.imul(Y2, pe) | 0, w = w + Math.imul(V2, ve) | 0, g = g + Math.imul(V2, be) | 0, g = g + Math.imul($, ve) | 0, _ = _ + Math.imul($, be) | 0, w = w + Math.imul(j, Be) | 0, g = g + Math.imul(j, qe2) | 0, g = g + Math.imul(Z, Be) | 0, _ = _ + Math.imul(Z, qe2) | 0;
        var rt2 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, w = Math.imul(X, ce2), g = Math.imul(X, pe), g = g + Math.imul(J, ce2) | 0, _ = Math.imul(J, pe), w = w + Math.imul(G, ve) | 0, g = g + Math.imul(G, be) | 0, g = g + Math.imul(Y2, ve) | 0, _ = _ + Math.imul(Y2, be) | 0, w = w + Math.imul(V2, Be) | 0, g = g + Math.imul(V2, qe2) | 0, g = g + Math.imul($, Be) | 0, _ = _ + Math.imul($, qe2) | 0;
        var S0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w = Math.imul(X, ve), g = Math.imul(X, be), g = g + Math.imul(J, ve) | 0, _ = Math.imul(J, be), w = w + Math.imul(G, Be) | 0, g = g + Math.imul(G, qe2) | 0, g = g + Math.imul(Y2, Be) | 0, _ = _ + Math.imul(Y2, qe2) | 0;
        var E0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        d = (_ + (g >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w = Math.imul(X, Be), g = Math.imul(X, qe2), g = g + Math.imul(J, Be) | 0, _ = Math.imul(J, qe2);
        var A0 = (d + w | 0) + ((g & 8191) << 13) | 0;
        return d = (_ + (g >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He, n[2] = We, n[3] = Ke, n[4] = je, n[5] = Ze, n[6] = Ve, n[7] = $e, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe, n[13] = et, n[14] = tt2, n[15] = rt2, n[16] = S0, n[17] = E0, n[18] = A0, d !== 0 && (n[19] = d, c.length++), c;
      };
      Math.imul || (N2 = _e);
      function we(h, s, u) {
        u.negative = s.negative ^ h.negative, u.length = h.length + s.length;
        for (var c = 0, b = 0, l = 0;l < u.length - 1; l++) {
          var n = b;
          b = 0;
          for (var d = c & 67108863, w = Math.min(l, s.length - 1), g = Math.max(0, l - h.length + 1);g <= w; g++) {
            var _ = l - g, A = h.words[_] | 0, R = s.words[g] | 0, I = A * R, Me = I & 67108863;
            n = n + (I / 67108864 | 0) | 0, Me = Me + d | 0, d = Me & 67108863, n = n + (Me >>> 26) | 0, b += n >>> 26, n &= 67108863;
          }
          u.words[l] = d, c = n, n = b;
        }
        return c !== 0 ? u.words[l] = c : u.length--, u._strip();
      }
      function ye(h, s, u) {
        return we(h, s, u);
      }
      f.prototype.mulTo = function(s, u) {
        var c, b = this.length + s.length;
        return this.length === 10 && s.length === 10 ? c = N2(this, s, u) : b < 63 ? c = _e(this, s, u) : b < 1024 ? c = we(this, s, u) : c = ye(this, s, u), c;
      };
      function xe(h, s) {
        this.x = h, this.y = s;
      }
      xe.prototype.makeRBT = function(s) {
        for (var u = new Array(s), c = f.prototype._countBits(s) - 1, b = 0;b < s; b++)
          u[b] = this.revBin(b, c, s);
        return u;
      }, xe.prototype.revBin = function(s, u, c) {
        if (s === 0 || s === c - 1)
          return s;
        for (var b = 0, l = 0;l < u; l++)
          b |= (s & 1) << u - l - 1, s >>= 1;
        return b;
      }, xe.prototype.permute = function(s, u, c, b, l, n) {
        for (var d = 0;d < n; d++)
          b[d] = u[s[d]], l[d] = c[s[d]];
      }, xe.prototype.transform = function(s, u, c, b, l, n) {
        this.permute(n, s, u, c, b, l);
        for (var d = 1;d < l; d <<= 1)
          for (var w = d << 1, g = Math.cos(2 * Math.PI / w), _ = Math.sin(2 * Math.PI / w), A = 0;A < l; A += w)
            for (var R = g, I = _, Me = 0;Me < d; Me++) {
              var k = c[A + Me], D = b[A + Me], nt2 = c[A + Me + d], C = b[A + Me + d], O = R * nt2 - I * C;
              C = R * C + I * nt2, nt2 = O, c[A + Me] = k + nt2, b[A + Me] = D + C, c[A + Me + d] = k - nt2, b[A + Me + d] = D - C, Me !== w && (O = g * R - _ * I, I = g * I + _ * R, R = O);
            }
      }, xe.prototype.guessLen13b = function(s, u) {
        var c = Math.max(u, s) | 1, b = c & 1, l = 0;
        for (c = c / 2 | 0;c; c = c >>> 1)
          l++;
        return 1 << l + 1 + b;
      }, xe.prototype.conjugate = function(s, u, c) {
        if (!(c <= 1))
          for (var b = 0;b < c / 2; b++) {
            var l = s[b];
            s[b] = s[c - b - 1], s[c - b - 1] = l, l = u[b], u[b] = -u[c - b - 1], u[c - b - 1] = -l;
          }
      }, xe.prototype.normalize13b = function(s, u) {
        for (var c = 0, b = 0;b < u / 2; b++) {
          var l = Math.round(s[2 * b + 1] / u) * 8192 + Math.round(s[2 * b] / u) + c;
          s[b] = l & 67108863, l < 67108864 ? c = 0 : c = l / 67108864 | 0;
        }
        return s;
      }, xe.prototype.convert13b = function(s, u, c, b) {
        for (var l = 0, n = 0;n < u; n++)
          l = l + (s[n] | 0), c[2 * n] = l & 8191, l = l >>> 13, c[2 * n + 1] = l & 8191, l = l >>> 13;
        for (n = 2 * u;n < b; ++n)
          c[n] = 0;
        r(l === 0), r((l & -8192) === 0);
      }, xe.prototype.stub = function(s) {
        for (var u = new Array(s), c = 0;c < s; c++)
          u[c] = 0;
        return u;
      }, xe.prototype.mulp = function(s, u, c) {
        var b = 2 * this.guessLen13b(s.length, u.length), l = this.makeRBT(b), n = this.stub(b), d = new Array(b), w = new Array(b), g = new Array(b), _ = new Array(b), A = new Array(b), R = new Array(b), I = c.words;
        I.length = b, this.convert13b(s.words, s.length, d, b), this.convert13b(u.words, u.length, _, b), this.transform(d, n, w, g, b, l), this.transform(_, n, A, R, b, l);
        for (var Me = 0;Me < b; Me++) {
          var k = w[Me] * A[Me] - g[Me] * R[Me];
          g[Me] = w[Me] * R[Me] + g[Me] * A[Me], w[Me] = k;
        }
        return this.conjugate(w, g, b), this.transform(w, g, I, n, b, l), this.conjugate(I, n, b), this.normalize13b(I, b), c.negative = s.negative ^ u.negative, c.length = s.length + u.length, c._strip();
      }, f.prototype.mul = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), this.mulTo(s, u);
      }, f.prototype.mulf = function(s) {
        var u = new f(null);
        return u.words = new Array(this.length + s.length), ye(this, s, u);
      }, f.prototype.imul = function(s) {
        return this.clone().mulTo(s, this);
      }, f.prototype.imuln = function(s) {
        var u = s < 0;
        u && (s = -s), r(typeof s == "number"), r(s < 67108864);
        for (var c = 0, b = 0;b < this.length; b++) {
          var l = (this.words[b] | 0) * s, n = (l & 67108863) + (c & 67108863);
          c >>= 26, c += l / 67108864 | 0, c += n >>> 26, this.words[b] = n & 67108863;
        }
        return c !== 0 && (this.words[b] = c, this.length++), u ? this.ineg() : this;
      }, f.prototype.muln = function(s) {
        return this.clone().imuln(s);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(s) {
        var u = ge(s);
        if (u.length === 0)
          return new f(1);
        for (var c = this, b = 0;b < u.length && u[b] === 0; b++, c = c.sqr())
          ;
        if (++b < u.length)
          for (var l = c.sqr();b < u.length; b++, l = l.sqr())
            u[b] !== 0 && (c = c.mul(l));
        return c;
      }, f.prototype.iushln = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b = 67108863 >>> 26 - u << 26 - u, l;
        if (u !== 0) {
          var n = 0;
          for (l = 0;l < this.length; l++) {
            var d = this.words[l] & b, w = (this.words[l] | 0) - d << u;
            this.words[l] = w | n, n = d >>> 26 - u;
          }
          n && (this.words[l] = n, this.length++);
        }
        if (c !== 0) {
          for (l = this.length - 1;l >= 0; l--)
            this.words[l + c] = this.words[l];
          for (l = 0;l < c; l++)
            this.words[l] = 0;
          this.length += c;
        }
        return this._strip();
      }, f.prototype.ishln = function(s) {
        return r(this.negative === 0), this.iushln(s);
      }, f.prototype.iushrn = function(s, u, c) {
        r(typeof s == "number" && s >= 0);
        var b;
        u ? b = (u - u % 26) / 26 : b = 0;
        var l = s % 26, n = Math.min((s - l) / 26, this.length), d = 67108863 ^ 67108863 >>> l << l, w = c;
        if (b -= n, b = Math.max(0, b), w) {
          for (var g = 0;g < n; g++)
            w.words[g] = this.words[g];
          w.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g = 0;g < this.length; g++)
              this.words[g] = this.words[g + n];
          else
            this.words[0] = 0, this.length = 1;
        var _ = 0;
        for (g = this.length - 1;g >= 0 && (_ !== 0 || g >= b); g--) {
          var A = this.words[g] | 0;
          this.words[g] = _ << 26 - l | A >>> l, _ = A & d;
        }
        return w && _ !== 0 && (w.words[w.length++] = _), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f.prototype.ishrn = function(s, u, c) {
        return r(this.negative === 0), this.iushrn(s, u, c);
      }, f.prototype.shln = function(s) {
        return this.clone().ishln(s);
      }, f.prototype.ushln = function(s) {
        return this.clone().iushln(s);
      }, f.prototype.shrn = function(s) {
        return this.clone().ishrn(s);
      }, f.prototype.ushrn = function(s) {
        return this.clone().iushrn(s);
      }, f.prototype.testn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26, b = 1 << u;
        if (this.length <= c)
          return false;
        var l = this.words[c];
        return !!(l & b);
      }, f.prototype.imaskn = function(s) {
        r(typeof s == "number" && s >= 0);
        var u = s % 26, c = (s - u) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
          return this;
        if (u !== 0 && c++, this.length = Math.min(c, this.length), u !== 0) {
          var b = 67108863 ^ 67108863 >>> u << u;
          this.words[this.length - 1] &= b;
        }
        return this._strip();
      }, f.prototype.maskn = function(s) {
        return this.clone().imaskn(s);
      }, f.prototype.iaddn = function(s) {
        return r(typeof s == "number"), r(s < 67108864), s < 0 ? this.isubn(-s) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s ? (this.words[0] = s - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s), this.negative = 1, this) : this._iaddn(s);
      }, f.prototype._iaddn = function(s) {
        this.words[0] += s;
        for (var u = 0;u < this.length && this.words[u] >= 67108864; u++)
          this.words[u] -= 67108864, u === this.length - 1 ? this.words[u + 1] = 1 : this.words[u + 1]++;
        return this.length = Math.max(this.length, u + 1), this;
      }, f.prototype.isubn = function(s) {
        if (r(typeof s == "number"), r(s < 67108864), s < 0)
          return this.iaddn(-s);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s), this.negative = 1, this;
        if (this.words[0] -= s, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u = 0;u < this.length && this.words[u] < 0; u++)
            this.words[u] += 67108864, this.words[u + 1] -= 1;
        return this._strip();
      }, f.prototype.addn = function(s) {
        return this.clone().iaddn(s);
      }, f.prototype.subn = function(s) {
        return this.clone().isubn(s);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(s, u, c) {
        var b = s.length + c, l;
        this._expand(b);
        var n, d = 0;
        for (l = 0;l < s.length; l++) {
          n = (this.words[l + c] | 0) + d;
          var w = (s.words[l] | 0) * u;
          n -= w & 67108863, d = (n >> 26) - (w / 67108864 | 0), this.words[l + c] = n & 67108863;
        }
        for (;l < this.length - c; l++)
          n = (this.words[l + c] | 0) + d, d = n >> 26, this.words[l + c] = n & 67108863;
        if (d === 0)
          return this._strip();
        for (r(d === -1), d = 0, l = 0;l < this.length; l++)
          n = -(this.words[l] | 0) + d, d = n >> 26, this.words[l] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f.prototype._wordDiv = function(s, u) {
        var c = this.length - s.length, b = this.clone(), l = s, n = l.words[l.length - 1] | 0, d = this._countBits(n);
        c = 26 - d, c !== 0 && (l = l.ushln(c), b.iushln(c), n = l.words[l.length - 1] | 0);
        var w = b.length - l.length, g;
        if (u !== "mod") {
          g = new f(null), g.length = w + 1, g.words = new Array(g.length);
          for (var _ = 0;_ < g.length; _++)
            g.words[_] = 0;
        }
        var A = b.clone()._ishlnsubmul(l, 1, w);
        A.negative === 0 && (b = A, g && (g.words[w] = 1));
        for (var R = w - 1;R >= 0; R--) {
          var I = (b.words[l.length + R] | 0) * 67108864 + (b.words[l.length + R - 1] | 0);
          for (I = Math.min(I / n | 0, 67108863), b._ishlnsubmul(l, I, R);b.negative !== 0; )
            I--, b.negative = 0, b._ishlnsubmul(l, 1, R), b.isZero() || (b.negative ^= 1);
          g && (g.words[R] = I);
        }
        return g && g._strip(), b._strip(), u !== "div" && c !== 0 && b.iushrn(c), { div: g || null, mod: b };
      }, f.prototype.divmod = function(s, u, c) {
        if (r(!s.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var b, l, n;
        return this.negative !== 0 && s.negative === 0 ? (n = this.neg().divmod(s, u), u !== "mod" && (b = n.div.neg()), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.iadd(s)), { div: b, mod: l }) : this.negative === 0 && s.negative !== 0 ? (n = this.divmod(s.neg(), u), u !== "mod" && (b = n.div.neg()), { div: b, mod: n.mod }) : (this.negative & s.negative) !== 0 ? (n = this.neg().divmod(s.neg(), u), u !== "div" && (l = n.mod.neg(), c && l.negative !== 0 && l.isub(s)), { div: n.div, mod: l }) : s.length > this.length || this.cmp(s) < 0 ? { div: new f(0), mod: this } : s.length === 1 ? u === "div" ? { div: this.divn(s.words[0]), mod: null } : u === "mod" ? { div: null, mod: new f(this.modrn(s.words[0])) } : { div: this.divn(s.words[0]), mod: new f(this.modrn(s.words[0])) } : this._wordDiv(s, u);
      }, f.prototype.div = function(s) {
        return this.divmod(s, "div", false).div;
      }, f.prototype.mod = function(s) {
        return this.divmod(s, "mod", false).mod;
      }, f.prototype.umod = function(s) {
        return this.divmod(s, "mod", true).mod;
      }, f.prototype.divRound = function(s) {
        var u = this.divmod(s);
        if (u.mod.isZero())
          return u.div;
        var c = u.div.negative !== 0 ? u.mod.isub(s) : u.mod, b = s.ushrn(1), l = s.andln(1), n = c.cmp(b);
        return n < 0 || l === 1 && n === 0 ? u.div : u.div.negative !== 0 ? u.div.isubn(1) : u.div.iaddn(1);
      }, f.prototype.modrn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = (1 << 26) % s, b = 0, l = this.length - 1;l >= 0; l--)
          b = (c * b + (this.words[l] | 0)) % s;
        return u ? -b : b;
      }, f.prototype.modn = function(s) {
        return this.modrn(s);
      }, f.prototype.idivn = function(s) {
        var u = s < 0;
        u && (s = -s), r(s <= 67108863);
        for (var c = 0, b = this.length - 1;b >= 0; b--) {
          var l = (this.words[b] | 0) + c * 67108864;
          this.words[b] = l / s | 0, c = l % s;
        }
        return this._strip(), u ? this.ineg() : this;
      }, f.prototype.divn = function(s) {
        return this.clone().idivn(s);
      }, f.prototype.egcd = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b = new f(1), l = new f(0), n = new f(0), d = new f(1), w = 0;u.isEven() && c.isEven(); )
          u.iushrn(1), c.iushrn(1), ++w;
        for (var g = c.clone(), _ = u.clone();!u.isZero(); ) {
          for (var A = 0, R = 1;(u.words[0] & R) === 0 && A < 26; ++A, R <<= 1)
            ;
          if (A > 0)
            for (u.iushrn(A);A-- > 0; )
              (b.isOdd() || l.isOdd()) && (b.iadd(g), l.isub(_)), b.iushrn(1), l.iushrn(1);
          for (var I = 0, Me = 1;(c.words[0] & Me) === 0 && I < 26; ++I, Me <<= 1)
            ;
          if (I > 0)
            for (c.iushrn(I);I-- > 0; )
              (n.isOdd() || d.isOdd()) && (n.iadd(g), d.isub(_)), n.iushrn(1), d.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b.isub(n), l.isub(d)) : (c.isub(u), n.isub(b), d.isub(l));
        }
        return { a: n, b: d, gcd: c.iushln(w) };
      }, f.prototype._invmp = function(s) {
        r(s.negative === 0), r(!s.isZero());
        var u = this, c = s.clone();
        u.negative !== 0 ? u = u.umod(s) : u = u.clone();
        for (var b = new f(1), l = new f(0), n = c.clone();u.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
          for (var d = 0, w = 1;(u.words[0] & w) === 0 && d < 26; ++d, w <<= 1)
            ;
          if (d > 0)
            for (u.iushrn(d);d-- > 0; )
              b.isOdd() && b.iadd(n), b.iushrn(1);
          for (var g = 0, _ = 1;(c.words[0] & _) === 0 && g < 26; ++g, _ <<= 1)
            ;
          if (g > 0)
            for (c.iushrn(g);g-- > 0; )
              l.isOdd() && l.iadd(n), l.iushrn(1);
          u.cmp(c) >= 0 ? (u.isub(c), b.isub(l)) : (c.isub(u), l.isub(b));
        }
        var A;
        return u.cmpn(1) === 0 ? A = b : A = l, A.cmpn(0) < 0 && A.iadd(s), A;
      }, f.prototype.gcd = function(s) {
        if (this.isZero())
          return s.abs();
        if (s.isZero())
          return this.abs();
        var u = this.clone(), c = s.clone();
        u.negative = 0, c.negative = 0;
        for (var b = 0;u.isEven() && c.isEven(); b++)
          u.iushrn(1), c.iushrn(1);
        do {
          for (;u.isEven(); )
            u.iushrn(1);
          for (;c.isEven(); )
            c.iushrn(1);
          var l = u.cmp(c);
          if (l < 0) {
            var n = u;
            u = c, c = n;
          } else if (l === 0 || c.cmpn(1) === 0)
            break;
          u.isub(c);
        } while (true);
        return c.iushln(b);
      }, f.prototype.invm = function(s) {
        return this.egcd(s).a.umod(s);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(s) {
        return this.words[0] & s;
      }, f.prototype.bincn = function(s) {
        r(typeof s == "number");
        var u = s % 26, c = (s - u) / 26, b = 1 << u;
        if (this.length <= c)
          return this._expand(c + 1), this.words[c] |= b, this;
        for (var l = b, n = c;l !== 0 && n < this.length; n++) {
          var d = this.words[n] | 0;
          d += l, l = d >>> 26, d &= 67108863, this.words[n] = d;
        }
        return l !== 0 && (this.words[n] = l, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(s) {
        var u = s < 0;
        if (this.negative !== 0 && !u)
          return -1;
        if (this.negative === 0 && u)
          return 1;
        this._strip();
        var c;
        if (this.length > 1)
          c = 1;
        else {
          u && (s = -s), r(s <= 67108863, "Number is too big");
          var b = this.words[0] | 0;
          c = b === s ? 0 : b < s ? -1 : 1;
        }
        return this.negative !== 0 ? -c | 0 : c;
      }, f.prototype.cmp = function(s) {
        if (this.negative !== 0 && s.negative === 0)
          return -1;
        if (this.negative === 0 && s.negative !== 0)
          return 1;
        var u = this.ucmp(s);
        return this.negative !== 0 ? -u | 0 : u;
      }, f.prototype.ucmp = function(s) {
        if (this.length > s.length)
          return 1;
        if (this.length < s.length)
          return -1;
        for (var u = 0, c = this.length - 1;c >= 0; c--) {
          var b = this.words[c] | 0, l = s.words[c] | 0;
          if (b !== l) {
            b < l ? u = -1 : b > l && (u = 1);
            break;
          }
        }
        return u;
      }, f.prototype.gtn = function(s) {
        return this.cmpn(s) === 1;
      }, f.prototype.gt = function(s) {
        return this.cmp(s) === 1;
      }, f.prototype.gten = function(s) {
        return this.cmpn(s) >= 0;
      }, f.prototype.gte = function(s) {
        return this.cmp(s) >= 0;
      }, f.prototype.ltn = function(s) {
        return this.cmpn(s) === -1;
      }, f.prototype.lt = function(s) {
        return this.cmp(s) === -1;
      }, f.prototype.lten = function(s) {
        return this.cmpn(s) <= 0;
      }, f.prototype.lte = function(s) {
        return this.cmp(s) <= 0;
      }, f.prototype.eqn = function(s) {
        return this.cmpn(s) === 0;
      }, f.prototype.eq = function(s) {
        return this.cmp(s) === 0;
      }, f.red = function(s) {
        return new i(s);
      }, f.prototype.toRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s.convertTo(this)._forceRed(s);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(s) {
        return this.red = s, this;
      }, f.prototype.forceRed = function(s) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s);
      }, f.prototype.redAdd = function(s) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s);
      }, f.prototype.redIAdd = function(s) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s);
      }, f.prototype.redSub = function(s) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s);
      }, f.prototype.redISub = function(s) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s);
      }, f.prototype.redShl = function(s) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s);
      }, f.prototype.redMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.mul(this, s);
      }, f.prototype.redIMul = function(s) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s), this.red.imul(this, s);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(s) {
        return r(this.red && !s.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h, s) {
        this.name = h, this.p = new f(s, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s = new f(null);
        return s.words = new Array(Math.ceil(this.n / 13)), s;
      }, Ee.prototype.ireduce = function(s) {
        var u = s, c;
        do
          this.split(u, this.tmp), u = this.imulK(u), u = u.iadd(this.tmp), c = u.bitLength();
        while (c > this.n);
        var b = c < this.n ? -1 : u.ucmp(this.p);
        return b === 0 ? (u.words[0] = 0, u.length = 1) : b > 0 ? u.isub(this.p) : u.strip !== undefined ? u.strip() : u._strip(), u;
      }, Ee.prototype.split = function(s, u) {
        s.iushrn(this.n, 0, u);
      }, Ee.prototype.imulK = function(s) {
        return s.imul(this.k);
      };
      function Ae2() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(Ae2, Ee), Ae2.prototype.split = function(s, u) {
        for (var c = 4194303, b = Math.min(s.length, 9), l = 0;l < b; l++)
          u.words[l] = s.words[l];
        if (u.length = b, s.length <= 9) {
          s.words[0] = 0, s.length = 1;
          return;
        }
        var n = s.words[9];
        for (u.words[u.length++] = n & c, l = 10;l < s.length; l++) {
          var d = s.words[l] | 0;
          s.words[l - 10] = (d & c) << 4 | n >>> 22, n = d;
        }
        n >>>= 22, s.words[l - 10] = n, n === 0 && s.length > 10 ? s.length -= 10 : s.length -= 9;
      }, Ae2.prototype.imulK = function(s) {
        s.words[s.length] = 0, s.words[s.length + 1] = 0, s.length += 2;
        for (var u = 0, c = 0;c < s.length; c++) {
          var b = s.words[c] | 0;
          u += b * 977, s.words[c] = u & 67108863, u = b * 64 + (u / 67108864 | 0);
        }
        return s.words[s.length - 1] === 0 && (s.length--, s.words[s.length - 1] === 0 && s.length--), s;
      };
      function P() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(P, Ee);
      function Se2() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Se2, Ee);
      function v() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(v, Ee), v.prototype.imulK = function(s) {
        for (var u = 0, c = 0;c < s.length; c++) {
          var b = (s.words[c] | 0) * 19 + u, l = b & 67108863;
          b >>>= 26, s.words[c] = l, u = b;
        }
        return u !== 0 && (s.words[s.length++] = u), s;
      }, f._prime = function(s) {
        if (Re[s])
          return Re[s];
        var u;
        if (s === "k256")
          u = new Ae2;
        else if (s === "p224")
          u = new P;
        else if (s === "p192")
          u = new Se2;
        else if (s === "p25519")
          u = new v;
        else
          throw new Error("Unknown prime " + s);
        return Re[s] = u, u;
      };
      function i(h) {
        if (typeof h == "string") {
          var s = f._prime(h);
          this.m = s.p, this.prime = s;
        } else
          r(h.gtn(1), "modulus must be greater than 1"), this.m = h, this.prime = null;
      }
      i.prototype._verify1 = function(s) {
        r(s.negative === 0, "red works only with positives"), r(s.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s, u) {
        r((s.negative | u.negative) === 0, "red works only with positives"), r(s.red && s.red === u.red, "red works only with red numbers");
      }, i.prototype.imod = function(s) {
        return this.prime ? this.prime.ireduce(s)._forceRed(this) : (x(s, s.umod(this.m)._forceRed(this)), s);
      }, i.prototype.neg = function(s) {
        return s.isZero() ? s.clone() : this.m.sub(s)._forceRed(this);
      }, i.prototype.add = function(s, u) {
        this._verify2(s, u);
        var c = s.add(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
      }, i.prototype.iadd = function(s, u) {
        this._verify2(s, u);
        var c = s.iadd(u);
        return c.cmp(this.m) >= 0 && c.isub(this.m), c;
      }, i.prototype.sub = function(s, u) {
        this._verify2(s, u);
        var c = s.sub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
      }, i.prototype.isub = function(s, u) {
        this._verify2(s, u);
        var c = s.isub(u);
        return c.cmpn(0) < 0 && c.iadd(this.m), c;
      }, i.prototype.shl = function(s, u) {
        return this._verify1(s), this.imod(s.ushln(u));
      }, i.prototype.imul = function(s, u) {
        return this._verify2(s, u), this.imod(s.imul(u));
      }, i.prototype.mul = function(s, u) {
        return this._verify2(s, u), this.imod(s.mul(u));
      }, i.prototype.isqr = function(s) {
        return this.imul(s, s.clone());
      }, i.prototype.sqr = function(s) {
        return this.mul(s, s);
      }, i.prototype.sqrt = function(s) {
        if (s.isZero())
          return s.clone();
        var u = this.m.andln(3);
        if (r(u % 2 === 1), u === 3) {
          var c = this.m.add(new f(1)).iushrn(2);
          return this.pow(s, c);
        }
        for (var b = this.m.subn(1), l = 0;!b.isZero() && b.andln(1) === 0; )
          l++, b.iushrn(1);
        r(!b.isZero());
        var n = new f(1).toRed(this), d = n.redNeg(), w = this.m.subn(1).iushrn(1), g = this.m.bitLength();
        for (g = new f(2 * g * g).toRed(this);this.pow(g, w).cmp(d) !== 0; )
          g.redIAdd(d);
        for (var _ = this.pow(g, b), A = this.pow(s, b.addn(1).iushrn(1)), R = this.pow(s, b), I = l;R.cmp(n) !== 0; ) {
          for (var Me = R, k = 0;Me.cmp(n) !== 0; k++)
            Me = Me.redSqr();
          r(k < I);
          var D = this.pow(_, new f(1).iushln(I - k - 1));
          A = A.redMul(D), _ = D.redSqr(), R = R.redMul(_), I = k;
        }
        return A;
      }, i.prototype.invm = function(s) {
        var u = s._invmp(this.m);
        return u.negative !== 0 ? (u.negative = 0, this.imod(u).redNeg()) : this.imod(u);
      }, i.prototype.pow = function(s, u) {
        if (u.isZero())
          return new f(1).toRed(this);
        if (u.cmpn(1) === 0)
          return s.clone();
        var c = 4, b = new Array(1 << c);
        b[0] = new f(1).toRed(this), b[1] = s;
        for (var l = 2;l < b.length; l++)
          b[l] = this.mul(b[l - 1], s);
        var n = b[0], d = 0, w = 0, g = u.bitLength() % 26;
        for (g === 0 && (g = 26), l = u.length - 1;l >= 0; l--) {
          for (var _ = u.words[l], A = g - 1;A >= 0; A--) {
            var R = _ >> A & 1;
            if (n !== b[0] && (n = this.sqr(n)), R === 0 && d === 0) {
              w = 0;
              continue;
            }
            d <<= 1, d |= R, w++, !(w !== c && (l !== 0 || A !== 0)) && (n = this.mul(n, b[d]), w = 0, d = 0);
          }
          g = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s) {
        var u = s.umod(this.m);
        return u === s ? u.clone() : u;
      }, i.prototype.convertFrom = function(s) {
        var u = s.clone();
        return u.red = null, u;
      }, f.mont = function(s) {
        return new a(s);
      };
      function a(h) {
        i.call(this, h), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(a, i), a.prototype.convertTo = function(s) {
        return this.imod(s.ushln(this.shift));
      }, a.prototype.convertFrom = function(s) {
        var u = this.imod(s.mul(this.rinv));
        return u.red = null, u;
      }, a.prototype.imul = function(s, u) {
        if (s.isZero() || u.isZero())
          return s.words[0] = 0, s.length = 1, s;
        var c = s.imul(u), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.mul = function(s, u) {
        if (s.isZero() || u.isZero())
          return new f(0)._forceRed(this);
        var c = s.mul(u), b = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l = c.isub(b).iushrn(this.shift), n = l;
        return l.cmp(this.m) >= 0 ? n = l.isub(this.m) : l.cmpn(0) < 0 && (n = l.iadd(this.m)), n._forceRed(this);
      }, a.prototype.invm = function(s) {
        var u = this.imod(s._invmp(this.m).mul(this.r2));
        return u._forceRed(this);
      };
    })(typeof kl > "u" || kl, n2);
  });
  Ks = T((yk, o2) => {
    var Rf = Ws(), oA = on();
    function sA(t) {
      var e = f2(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function f2(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a2(t, e) {
      var r = sA(e), o = e.modulus.byteLength(), f = new Rf(t).mul(r.blinder).umod(e.modulus), p2 = f.toRed(Rf.mont(e.prime1)), m = f.toRed(Rf.mont(e.prime2)), y = e.coefficient, M = e.prime1, x = e.prime2, S = p2.redPow(e.exponent1).fromRed(), E2 = m.redPow(e.exponent2).fromRed(), B = S.isub(E2).imul(y).umod(M).imul(x);
      return E2.iadd(B).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o);
    }
    a2.getr = f2;
    o2.exports = a2;
  });
  s2 = T((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri = T((h2, Ll) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E2[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt2 = s[3] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = s[4] | 0, F2 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = s[6] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = s[7] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = s[8] | 0, V2 = yt2 & 8191, $ = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = u[5] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re2) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re2) | 0;
        var qe2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re2) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re2) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F2, X), n = Math.imul(F2, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re2) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d = Math.imul(H2, J), l = l + Math.imul(F2, Q) | 0, n = n + Math.imul(F2, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re2) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re2) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d = d + Math.imul(H2, ee) | 0, l = l + Math.imul(F2, te) | 0, n = n + Math.imul(F2, re2) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re2) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d = d + Math.imul(H2, re2) | 0, l = l + Math.imul(F2, ie) | 0, n = n + Math.imul(F2, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V2, X), n = Math.imul(V2, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re2) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d = d + Math.imul(H2, ne) | 0, l = l + Math.imul(F2, fe) | 0, n = n + Math.imul(F2, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce2) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce2) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d = Math.imul(Y2, J), l = l + Math.imul(V2, Q) | 0, n = n + Math.imul(V2, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re2) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re2) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d = d + Math.imul(H2, ae) | 0, l = l + Math.imul(F2, oe) | 0, n = n + Math.imul(F2, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce2) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce2) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d = Math.imul(Y2, ee), l = l + Math.imul(V2, te) | 0, n = n + Math.imul(V2, re2) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re2) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d = d + Math.imul(H2, se) | 0, l = l + Math.imul(F2, he) | 0, n = n + Math.imul(F2, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce2) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d = Math.imul(Y2, re2), l = l + Math.imul(V2, ie) | 0, n = n + Math.imul(V2, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d = d + Math.imul(H2, ue) | 0, l = l + Math.imul(F2, le) | 0, n = n + Math.imul(F2, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce2) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce2) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d = Math.imul(Y2, ne), l = l + Math.imul(V2, fe) | 0, n = n + Math.imul(V2, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d = d + Math.imul(H2, de) | 0, l = l + Math.imul(F2, ce2) | 0, n = n + Math.imul(F2, pe) | 0, n = n + Math.imul(U, ce2) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d = Math.imul(Y2, ae), l = l + Math.imul(V2, oe) | 0, n = n + Math.imul(V2, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d = d + Math.imul(H2, pe) | 0, l = l + Math.imul(F2, ve) | 0, n = n + Math.imul(F2, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d = Math.imul(Y2, se), l = l + Math.imul(V2, he) | 0, n = n + Math.imul(V2, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce2) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d = d + Math.imul(H2, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d = Math.imul(Y2, ue), l = l + Math.imul(V2, le) | 0, n = n + Math.imul(V2, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce2) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce2) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d = Math.imul(Y2, de), l = l + Math.imul(V2, ce2) | 0, n = n + Math.imul(V2, pe) | 0, n = n + Math.imul($, ce2) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d = Math.imul(Y2, pe), l = l + Math.imul(V2, ve) | 0, n = n + Math.imul(V2, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d = Math.imul(Y2, be);
        var rt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt2, c[18] = rt2, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N2;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N2(v, i) {
        this.x = v, this.y = i;
      }
      N2.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N2.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N2.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N2.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N2.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N2.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N2.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N2.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N2.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N2.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se2(i);
      };
      function Se2(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se2, P), Se2.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se2.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se2.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h2);
  });
  Nl = T((d2) => {
    var js = d2;
    function uA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o = 0;o < t.length; o++)
          r[o] = t[o] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o = 0;o < t.length; o += 2)
          r.push(parseInt(t[o] + t[o + 1], 16));
      } else
        for (var o = 0;o < t.length; o++) {
          var f = t.charCodeAt(o), p2 = f >> 8, m = f & 255;
          p2 ? r.push(p2, m) : r.push(m);
        }
      return r;
    }
    js.toArray = uA;
    function u2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js.zero2 = u2;
    function l2(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += u2(t[r].toString(16));
      return e;
    }
    js.toHex = l2;
    js.encode = function(e, r) {
      return r === "hex" ? l2(e) : e;
    };
  });
  or = T((c2) => {
    var Pr = c2, lA = ri(), dA = ar(), Zs = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs.toArray;
    Pr.zero2 = Zs.zero2;
    Pr.toHex = Zs.toHex;
    Pr.encode = Zs.encode;
    function cA(t, e, r) {
      var o = new Array(Math.max(t.bitLength(), r) + 1);
      o.fill(0);
      for (var f = 1 << e + 1, p2 = t.clone(), m = 0;m < o.length; m++) {
        var y, M = p2.andln(f - 1);
        p2.isOdd() ? (M > (f >> 1) - 1 ? y = (f >> 1) - M : y = M, p2.isubn(y)) : y = 0, o[m] = y, p2.iushrn(1);
      }
      return o;
    }
    Pr.getNAF = cA;
    function pA(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o = 0, f = 0, p2;t.cmpn(-o) > 0 || e.cmpn(-f) > 0; ) {
        var m = t.andln(3) + o & 3, y = e.andln(3) + f & 3;
        m === 3 && (m = -1), y === 3 && (y = -1);
        var M;
        (m & 1) === 0 ? M = 0 : (p2 = t.andln(7) + o & 7, (p2 === 3 || p2 === 5) && y === 2 ? M = -m : M = m), r[0].push(M);
        var x;
        (y & 1) === 0 ? x = 0 : (p2 = e.andln(7) + f & 7, (p2 === 3 || p2 === 5) && m === 2 ? x = -y : x = y), r[1].push(x), 2 * o === M + 1 && (o = 1 - o), 2 * f === x + 1 && (f = 1 - f), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e, r) {
      var o = "_" + e;
      t.prototype[e] = function() {
        return this[o] !== undefined ? this[o] : this[o] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T((xk, p2) => {
    var Cn = ri(), Ca = or(), Vs = Ca.getNAF, gA = Ca.getJSF, $s = Ca.assert;
    function Xi(t, e) {
      this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p2.exports = Xi;
    Xi.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi.prototype._fixedNafMul = function(e, r) {
      $s(e.precomputed);
      var o = e._getDoubles(), f = Vs(r, 1, this._bitLength), p3 = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
      p3 /= 3;
      var m = [], y, M;
      for (y = 0;y < f.length; y += o.step) {
        M = 0;
        for (var x = y + o.step - 1;x >= y; x--)
          M = (M << 1) + f[x];
        m.push(M);
      }
      for (var S = this.jpoint(null, null, null), E2 = this.jpoint(null, null, null), B = p3;B > 0; B--) {
        for (y = 0;y < m.length; y++)
          M = m[y], M === B ? E2 = E2.mixedAdd(o.points[y]) : M === -B && (E2 = E2.mixedAdd(o.points[y].neg()));
        S = S.add(E2);
      }
      return S.toP();
    };
    Xi.prototype._wnafMul = function(e, r) {
      var o = 4, f = e._getNAFPoints(o);
      o = f.wnd;
      for (var p3 = f.points, m = Vs(r, o, this._bitLength), y = this.jpoint(null, null, null), M = m.length - 1;M >= 0; M--) {
        for (var x = 0;M >= 0 && m[M] === 0; M--)
          x++;
        if (M >= 0 && x++, y = y.dblp(x), M < 0)
          break;
        var S = m[M];
        $s(S !== 0), e.type === "affine" ? S > 0 ? y = y.mixedAdd(p3[S - 1 >> 1]) : y = y.mixedAdd(p3[-S - 1 >> 1].neg()) : S > 0 ? y = y.add(p3[S - 1 >> 1]) : y = y.add(p3[-S - 1 >> 1].neg());
      }
      return e.type === "affine" ? y.toP() : y;
    };
    Xi.prototype._wnafMulAdd = function(e, r, o, f, p3) {
      var m = this._wnafT1, y = this._wnafT2, M = this._wnafT3, x = 0, S, E2, B;
      for (S = 0;S < f; S++) {
        B = r[S];
        var q = B._getNAFPoints(e);
        m[S] = q.wnd, y[S] = q.points;
      }
      for (S = f - 1;S >= 1; S -= 2) {
        var L = S - 1, ge = S;
        if (m[L] !== 1 || m[ge] !== 1) {
          M[L] = Vs(o[L], m[L], this._bitLength), M[ge] = Vs(o[ge], m[ge], this._bitLength), x = Math.max(M[L].length, x), x = Math.max(M[ge].length, x);
          continue;
        }
        var _e = [r[L], null, null, r[ge]];
        r[L].y.cmp(r[ge].y) === 0 ? (_e[1] = r[L].add(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg())) : r[L].y.cmp(r[ge].y.redNeg()) === 0 ? (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].add(r[ge].neg())) : (_e[1] = r[L].toJ().mixedAdd(r[ge]), _e[2] = r[L].toJ().mixedAdd(r[ge].neg()));
        var N2 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o[L], o[ge]);
        for (x = Math.max(we[0].length, x), M[L] = new Array(x), M[ge] = new Array(x), E2 = 0;E2 < x; E2++) {
          var ye = we[0][E2] | 0, xe = we[1][E2] | 0;
          M[L][E2] = N2[(ye + 1) * 3 + (xe + 1)], M[ge][E2] = 0, y[L] = _e;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S = x;S >= 0; S--) {
        for (var Ae2 = 0;S >= 0; ) {
          var P = true;
          for (E2 = 0;E2 < f; E2++)
            Ee[E2] = M[E2][S] | 0, Ee[E2] !== 0 && (P = false);
          if (!P)
            break;
          Ae2++, S--;
        }
        if (S >= 0 && Ae2++, Re = Re.dblp(Ae2), S < 0)
          break;
        for (E2 = 0;E2 < f; E2++) {
          var Se2 = Ee[E2];
          Se2 !== 0 && (Se2 > 0 ? B = y[E2][Se2 - 1 >> 1] : Se2 < 0 && (B = y[E2][-Se2 - 1 >> 1].neg()), B.type === "affine" ? Re = Re.mixedAdd(B) : Re = Re.add(B));
        }
      }
      for (S = 0;S < f; S++)
        y[S] = null;
      return p3 ? Re : Re.toP();
    };
    function _r(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Xi.BasePoint = _r;
    _r.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi.prototype.decodePoint = function(e, r) {
      e = Ca.toArray(e, r);
      var o = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
        e[0] === 6 ? $s(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s(e[e.length - 1] % 2 === 1);
        var f = this.point(e.slice(1, 1 + o), e.slice(1 + o, 1 + 2 * o));
        return f;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
        return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
      throw new Error("Unknown point format");
    };
    _r.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    _r.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", r));
    };
    _r.prototype.encode = function(e, r) {
      return Ca.encode(this._encode(r), e);
    };
    _r.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    _r.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o = [this], f = this, p3 = 0;p3 < r; p3 += e) {
        for (var m = 0;m < e; m++)
          f = f.dbl();
        o.push(f);
      }
      return { step: e, points: o };
    };
    _r.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o = (1 << e) - 1, f = o === 1 ? null : this.dbl(), p3 = 1;p3 < o; p3++)
        r[p3] = r[p3 - 1].add(f);
      return { wnd: e, points: r };
    };
    _r.prototype._getBeta = function() {
      return null;
    };
    _r.prototype.dblp = function(e) {
      for (var r = this, o = 0;o < e; o++)
        r = r.dbl();
      return r;
    };
  });
  b2 = T((Sk, v2) => {
    var yA = or(), lt2 = ri(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr(t) {
      Bf.call(this, "short", t), this.a = new lt2(t.a, 16).toRed(this.red), this.b = new lt2(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr, Bf);
    v2.exports = xr;
    xr.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o;
        if (e.beta)
          r = new lt2(e.beta, 16).toRed(this.red);
        else {
          var f = this._getEndoRoots(this.p);
          r = f[0].cmp(f[1]) < 0 ? f[0] : f[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o = new lt2(e.lambda, 16);
        else {
          var p2 = this._getEndoRoots(this.n);
          this.g.mul(p2[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o = p2[0] : (o = p2[1], wA(this.g.mul(o).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m;
        return e.basis ? m = e.basis.map(function(y) {
          return { a: new lt2(y.a, 16), b: new lt2(y.b, 16) };
        }) : m = this._getEndoBasis(o), { beta: r, lambda: o, basis: m };
      }
    };
    xr.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt2.mont(e), o = new lt2(2).toRed(r).redInvm(), f = o.redNeg(), p2 = new lt2(3).toRed(r).redNeg().redSqrt().redMul(o), m = f.redAdd(p2).fromRed(), y = f.redSub(p2).fromRed();
      return [m, y];
    };
    xr.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, f = this.n.clone(), p2 = new lt2(1), m = new lt2(0), y = new lt2(0), M = new lt2(1), x, S, E2, B, q, L, ge, _e = 0, N2, we;o.cmpn(0) !== 0; ) {
        var ye = f.div(o);
        N2 = f.sub(ye.mul(o)), we = y.sub(ye.mul(p2));
        var xe = M.sub(ye.mul(m));
        if (!E2 && N2.cmp(r) < 0)
          x = ge.neg(), S = p2, E2 = N2.neg(), B = we;
        else if (E2 && ++_e === 2)
          break;
        ge = N2, f = o, o = N2, y = p2, p2 = we, M = m, m = xe;
      }
      q = N2.neg(), L = we;
      var Re = E2.sqr().add(B.sqr()), Ee = q.sqr().add(L.sqr());
      return Ee.cmp(Re) >= 0 && (q = x, L = S), E2.negative && (E2 = E2.neg(), B = B.neg()), q.negative && (q = q.neg(), L = L.neg()), [{ a: E2, b: B }, { a: q, b: L }];
    };
    xr.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o = r[0], f = r[1], p2 = f.b.mul(e).divRound(this.n), m = o.b.neg().mul(e).divRound(this.n), y = p2.mul(o.a), M = m.mul(f.a), x = p2.mul(o.b), S = m.mul(f.b), E2 = e.sub(y).sub(M), B = x.add(S).neg();
      return { k1: E2, k2: B };
    };
    xr.prototype.pointFromX = function(e, r) {
      e = new lt2(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f = o.redSqrt();
      if (f.redSqr().redSub(o).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p2 = f.fromRed().isOdd();
      return (r && !p2 || !r && p2) && (f = f.redNeg()), this.point(e, f);
    };
    xr.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o } = e, f = this.a.redMul(r), p2 = r.redSqr().redMul(r).redIAdd(f).redIAdd(this.b);
      return o.redSqr().redISub(p2).cmpn(0) === 0;
    };
    xr.prototype._endoWnafMulAdd = function(e, r, o) {
      for (var f = this._endoWnafT1, p2 = this._endoWnafT2, m = 0;m < e.length; m++) {
        var y = this._endoSplit(r[m]), M = e[m], x = M._getBeta();
        y.k1.negative && (y.k1.ineg(), M = M.neg(true)), y.k2.negative && (y.k2.ineg(), x = x.neg(true)), f[m * 2] = M, f[m * 2 + 1] = x, p2[m * 2] = y.k1, p2[m * 2 + 1] = y.k2;
      }
      for (var S = this._wnafMulAdd(1, f, p2, m * 2, o), E2 = 0;E2 < m * 2; E2++)
        f[E2] = null, p2[E2] = null;
      return S;
    };
    function Ct(t, e, r, o) {
      Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt2(e, 16), this.y = new lt2(r, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr.prototype.point = function(e, r, o) {
      return new Ct(this, e, r, o);
    };
    xr.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o = this.curve, f = function(p2) {
            return o.point(p2.x.redMul(o.endo.beta), p2.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o) {
      typeof r == "string" && (r = JSON.parse(r));
      var f = e.point(r[0], r[1], o);
      if (!r[2])
        return f;
      function p2(y) {
        return e.point(y[0], y[1], o);
      }
      var m = r[2];
      return f.precomputed = { beta: null, doubles: m.doubles && { step: m.doubles.step, points: [f].concat(m.doubles.points.map(p2)) }, naf: m.naf && { wnd: m.naf.wnd, points: [f].concat(m.naf.points.map(p2)) } }, f;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o = r.redSqr().redISub(this.x).redISub(e.x), f = r.redMul(this.x.redSub(o)).redISub(this.y);
      return this.curve.point(o, f);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o = this.x.redSqr(), f = e.redInvm(), p2 = o.redAdd(o).redIAdd(o).redIAdd(r).redMul(f), m = p2.redSqr().redISub(this.x.redAdd(this.x)), y = p2.redMul(this.x.redSub(m)).redISub(this.y);
      return this.curve.point(m, y);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt2(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o) {
      var f = [this, r], p2 = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p2) : this.curve._wnafMulAdd(1, f, p2, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o) {
      var f = [this, r], p2 = [e, o];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f, p2, true) : this.curve._wnafMulAdd(1, f, p2, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o = this.precomputed, f = function(p2) {
          return p2.neg();
        };
        r.precomputed = { naf: o.naf && { wnd: o.naf.wnd, points: o.naf.points.map(f) }, doubles: o.doubles && { step: o.doubles.step, points: o.doubles.points.map(f) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt(t, e, r, o) {
      Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt2(0)) : (this.x = new lt2(e, 16), this.y = new lt2(r, 16), this.z = new lt2(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt, Bf.BasePoint);
    xr.prototype.jpoint = function(e, r, o) {
      return new Wt(this, e, r, o);
    };
    Wt.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o = this.x.redMul(r), f = this.y.redMul(r).redMul(e);
      return this.curve.point(o, f);
    };
    Wt.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o = this.z.redSqr(), f = this.x.redMul(r), p2 = e.x.redMul(o), m = this.y.redMul(r.redMul(e.z)), y = e.y.redMul(o.redMul(this.z)), M = f.redSub(p2), x = m.redSub(y);
      if (M.cmpn(0) === 0)
        return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S = M.redSqr(), E2 = S.redMul(M), B = f.redMul(S), q = x.redSqr().redIAdd(E2).redISub(B).redISub(B), L = x.redMul(B.redISub(q)).redISub(m.redMul(E2)), ge = this.z.redMul(e.z).redMul(M);
      return this.curve.jpoint(q, L, ge);
    };
    Wt.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o = this.x, f = e.x.redMul(r), p2 = this.y, m = e.y.redMul(r).redMul(this.z), y = o.redSub(f), M = p2.redSub(m);
      if (y.cmpn(0) === 0)
        return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x = y.redSqr(), S = x.redMul(y), E2 = o.redMul(x), B = M.redSqr().redIAdd(S).redISub(E2).redISub(E2), q = M.redMul(E2.redISub(B)).redISub(p2.redMul(S)), L = this.z.redMul(y);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o = this;
        for (r = 0;r < e; r++)
          o = o.dbl();
        return o;
      }
      var f = this.curve.a, p2 = this.curve.tinv, m = this.x, y = this.y, M = this.z, x = M.redSqr().redSqr(), S = y.redAdd(y);
      for (r = 0;r < e; r++) {
        var E2 = m.redSqr(), B = S.redSqr(), q = B.redSqr(), L = E2.redAdd(E2).redIAdd(E2).redIAdd(f.redMul(x)), ge = m.redMul(B), _e = L.redSqr().redISub(ge.redAdd(ge)), N2 = ge.redISub(_e), we = L.redMul(N2);
        we = we.redIAdd(we).redISub(q);
        var ye = S.redMul(M);
        r + 1 < e && (x = x.redMul(q)), m = _e, M = ye, S = we;
      }
      return this.curve.jpoint(m, S.redMul(p2), M);
    };
    Wt.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt.prototype._zeroDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p2 = this.y.redSqr(), m = p2.redSqr(), y = this.x.redAdd(p2).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f), x = M.redSqr().redISub(y).redISub(y), S = m.redIAdd(m);
        S = S.redIAdd(S), S = S.redIAdd(S), e = x, r = M.redMul(y.redISub(x)).redISub(S), o = this.y.redAdd(this.y);
      } else {
        var E2 = this.x.redSqr(), B = this.y.redSqr(), q = B.redSqr(), L = this.x.redAdd(B).redSqr().redISub(E2).redISub(q);
        L = L.redIAdd(L);
        var ge = E2.redAdd(E2).redIAdd(E2), _e = ge.redSqr(), N2 = q.redIAdd(q);
        N2 = N2.redIAdd(N2), N2 = N2.redIAdd(N2), e = _e.redISub(L).redISub(L), r = ge.redMul(L.redISub(e)).redISub(N2), o = this.y.redMul(this.z), o = o.redIAdd(o);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._threeDbl = function() {
      var e, r, o;
      if (this.zOne) {
        var f = this.x.redSqr(), p2 = this.y.redSqr(), m = p2.redSqr(), y = this.x.redAdd(p2).redSqr().redISub(f).redISub(m);
        y = y.redIAdd(y);
        var M = f.redAdd(f).redIAdd(f).redIAdd(this.curve.a), x = M.redSqr().redISub(y).redISub(y);
        e = x;
        var S = m.redIAdd(m);
        S = S.redIAdd(S), S = S.redIAdd(S), r = M.redMul(y.redISub(x)).redISub(S), o = this.y.redAdd(this.y);
      } else {
        var E2 = this.z.redSqr(), B = this.y.redSqr(), q = this.x.redMul(B), L = this.x.redSub(E2).redMul(this.x.redAdd(E2));
        L = L.redAdd(L).redIAdd(L);
        var ge = q.redIAdd(q);
        ge = ge.redIAdd(ge);
        var _e = ge.redAdd(ge);
        e = L.redSqr().redISub(_e), o = this.y.redAdd(this.z).redSqr().redISub(B).redISub(E2);
        var N2 = B.redSqr();
        N2 = N2.redIAdd(N2), N2 = N2.redIAdd(N2), N2 = N2.redIAdd(N2), r = L.redMul(ge.redISub(e)).redISub(N2);
      }
      return this.curve.jpoint(e, r, o);
    };
    Wt.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o = this.y, f = this.z, p2 = f.redSqr().redSqr(), m = r.redSqr(), y = o.redSqr(), M = m.redAdd(m).redIAdd(m).redIAdd(e.redMul(p2)), x = r.redAdd(r);
      x = x.redIAdd(x);
      var S = x.redMul(y), E2 = M.redSqr().redISub(S.redAdd(S)), B = S.redISub(E2), q = y.redSqr();
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = M.redMul(B).redISub(q), ge = o.redAdd(o).redMul(f);
      return this.curve.jpoint(E2, L, ge);
    };
    Wt.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr(), f = r.redSqr(), p2 = e.redAdd(e).redIAdd(e), m = p2.redSqr(), y = this.x.redAdd(r).redSqr().redISub(e).redISub(f);
      y = y.redIAdd(y), y = y.redAdd(y).redIAdd(y), y = y.redISub(m);
      var M = y.redSqr(), x = f.redIAdd(f);
      x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x);
      var S = p2.redIAdd(y).redSqr().redISub(m).redISub(M).redISub(x), E2 = r.redMul(S);
      E2 = E2.redIAdd(E2), E2 = E2.redIAdd(E2);
      var B = this.x.redMul(M).redISub(E2);
      B = B.redIAdd(B), B = B.redIAdd(B);
      var q = this.y.redMul(S.redMul(x.redISub(S)).redISub(y.redMul(M)));
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L = this.z.redAdd(y).redSqr().redISub(o).redISub(M);
      return this.curve.jpoint(B, q, L);
    };
    Wt.prototype.mul = function(e, r) {
      return e = new lt2(e, r), this.curve._wnafMul(this, e);
    };
    Wt.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o = e.z.redSqr();
      if (this.x.redMul(o).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f = r.redMul(this.z), p2 = o.redMul(e.z);
      return this.y.redMul(p2).redISub(e.y.redMul(f)).cmpn(0) === 0;
    };
    Wt.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o) === 0)
        return true;
      for (var f = e.clone(), p2 = this.curve.redN.redMul(r);; ) {
        if (f.iadd(this.curve.n), f.cmp(this.curve.p) >= 0)
          return false;
        if (o.redIAdd(p2), this.x.cmp(o) === 0)
          return true;
      }
    };
    Wt.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y2 = T((Ek, g2) => {
    var qf = ri(), m2 = Ie(), Gs = Oa(), MA = or();
    function If(t) {
      Gs.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m2(If, Gs);
    g2.exports = If;
    If.prototype.validate = function(e) {
      var r = e.normalize().x, o = r.redSqr(), f = o.redMul(r).redAdd(o.redMul(this.a)).redAdd(r), p2 = f.redSqrt();
      return p2.redSqr().cmp(f) === 0;
    };
    function Ot(t, e, r) {
      Gs.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m2(Ot, Gs.BasePoint);
    If.prototype.decodePoint = function(e, r) {
      return this.point(MA.toArray(e, r), 1);
    };
    If.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    If.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {
    };
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o = this.x.redSub(this.z), f = o.redSqr(), p2 = r.redSub(f), m = r.redMul(f), y = p2.redMul(f.redAdd(this.curve.a24.redMul(p2)));
      return this.curve.point(m, y);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o = this.x.redAdd(this.z), f = this.x.redSub(this.z), p2 = e.x.redAdd(e.z), m = e.x.redSub(e.z), y = m.redMul(o), M = p2.redMul(f), x = r.z.redMul(y.redAdd(M).redSqr()), S = r.x.redMul(y.redISub(M).redSqr());
      return this.curve.point(x, S);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o = this, f = this.curve.point(null, null), p2 = this, m = [];r.cmpn(0) !== 0; r.iushrn(1))
        m.push(r.andln(1));
      for (var y = m.length - 1;y >= 0; y--)
        m[y] === 0 ? (o = o.diffAdd(f, p2), f = f.dbl()) : (f = o.diffAdd(f, p2), o = o.dbl());
      return f;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _2 = T((Ak, M2) => {
    var _A = or(), Ai = ri(), w2 = Ie(), Ys = Oa(), xA = _A.assert;
    function ii(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys.call(this, "edwards", t), this.a = new Ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w2(ii, Ys);
    M2.exports = ii;
    ii.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ii.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ii.prototype.jpoint = function(e, r, o, f) {
      return this.point(e, r, o, f);
    };
    ii.prototype.pointFromX = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f = this.c2.redSub(this.a.redMul(o)), p2 = this.one.redSub(this.c2.redMul(this.d).redMul(o)), m = f.redMul(p2.redInvm()), y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M = y.fromRed().isOdd();
      return (r && !M || !r && M) && (y = y.redNeg()), this.point(e, y);
    };
    ii.prototype.pointFromY = function(e, r) {
      e = new Ai(e, 16), e.red || (e = e.toRed(this.red));
      var o = e.redSqr(), f = o.redSub(this.c2), p2 = o.redMul(this.d).redMul(this.c2).redSub(this.a), m = f.redMul(p2.redInvm());
      if (m.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y = m.redSqrt();
      if (y.redSqr().redSub(m).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y.fromRed().isOdd() !== r && (y = y.redNeg()), this.point(y, e);
    };
    ii.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o = e.y.redSqr(), f = r.redMul(this.a).redAdd(o), p2 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o)));
      return f.cmp(p2) === 0;
    };
    function at(t, e, r, o, f) {
      Ys.BasePoint.call(this, t, "projective"), e === null && r === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai(e, 16), this.y = new Ai(r, 16), this.z = o ? new Ai(o, 16) : this.curve.one, this.t = f && new Ai(f, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w2(at, Ys.BasePoint);
    ii.prototype.pointFromJSON = function(e) {
      return at.fromJSON(this, e);
    };
    ii.prototype.point = function(e, r, o, f) {
      return new at(this, e, r, o, f);
    };
    at.fromJSON = function(e, r) {
      return new at(e, r[0], r[1], r[2]);
    };
    at.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o = this.z.redSqr();
      o = o.redIAdd(o);
      var f = this.curve._mulA(e), p2 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m = f.redAdd(r), y = m.redSub(o), M = f.redSub(r), x = p2.redMul(y), S = m.redMul(M), E2 = p2.redMul(M), B = y.redMul(m);
      return this.curve.point(x, S, B, E2);
    };
    at.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o = this.y.redSqr(), f, p2, m, y, M, x;
      if (this.curve.twisted) {
        y = this.curve._mulA(r);
        var S = y.redAdd(o);
        this.zOne ? (f = e.redSub(r).redSub(o).redMul(S.redSub(this.curve.two)), p2 = S.redMul(y.redSub(o)), m = S.redSqr().redSub(S).redSub(S)) : (M = this.z.redSqr(), x = S.redSub(M).redISub(M), f = e.redSub(r).redISub(o).redMul(x), p2 = S.redMul(y.redSub(o)), m = S.redMul(x));
      } else
        y = r.redAdd(o), M = this.curve._mulC(this.z).redSqr(), x = y.redSub(M).redSub(M), f = this.curve._mulC(e.redISub(y)).redMul(x), p2 = this.curve._mulC(y).redMul(r.redISub(o)), m = y.redMul(x);
      return this.curve.point(f, p2, m);
    };
    at.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f = this.t.redMul(this.curve.dd).redMul(e.t), p2 = this.z.redMul(e.z.redAdd(e.z)), m = o.redSub(r), y = p2.redSub(f), M = p2.redAdd(f), x = o.redAdd(r), S = m.redMul(y), E2 = M.redMul(x), B = m.redMul(x), q = y.redMul(M);
      return this.curve.point(S, E2, q, B);
    };
    at.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o = r.redSqr(), f = this.x.redMul(e.x), p2 = this.y.redMul(e.y), m = this.curve.d.redMul(f).redMul(p2), y = o.redSub(m), M = o.redAdd(m), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f).redISub(p2), S = r.redMul(y).redMul(x), E2, B;
      return this.curve.twisted ? (E2 = r.redMul(M).redMul(p2.redSub(this.curve._mulA(f))), B = y.redMul(M)) : (E2 = r.redMul(M).redMul(p2.redSub(f)), B = this.curve._mulC(y).redMul(M)), this.curve.point(S, E2, B);
    };
    at.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at.prototype.mulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, false);
    };
    at.prototype.jmulAdd = function(e, r, o) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o], 2, true);
    };
    at.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o = e.clone(), f = this.curve.redN.redMul(this.z);; ) {
        if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f), this.x.cmp(r) === 0)
          return true;
      }
    };
    at.prototype.toP = at.prototype.normalize;
    at.prototype.mixedAdd = at.prototype.add;
  });
  Pl = T((x2) => {
    var Xs = x2;
    Xs.base = Oa();
    Xs.short = b2();
    Xs.mont = y2();
    Xs.edwards = _2();
  });
  Cr = T((it) => {
    var SA = ar(), EA = Ie();
    it.inherits = EA;
    function AA(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function RA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f = 0;f < t.length; f += 2)
              r.push(parseInt(t[f] + t[f + 1], 16));
        } else
          for (var o = 0, f = 0;f < t.length; f++) {
            var p2 = t.charCodeAt(f);
            p2 < 128 ? r[o++] = p2 : p2 < 2048 ? (r[o++] = p2 >> 6 | 192, r[o++] = p2 & 63 | 128) : AA(t, f) ? (p2 = 65536 + ((p2 & 1023) << 10) + (t.charCodeAt(++f) & 1023), r[o++] = p2 >> 18 | 240, r[o++] = p2 >> 12 & 63 | 128, r[o++] = p2 >> 6 & 63 | 128, r[o++] = p2 & 63 | 128) : (r[o++] = p2 >> 12 | 224, r[o++] = p2 >> 6 & 63 | 128, r[o++] = p2 & 63 | 128);
          }
      else
        for (f = 0;f < t.length; f++)
          r[f] = t[f] | 0;
      return r;
    }
    it.toArray = RA;
    function BA(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += E2(t[r].toString(16));
      return e;
    }
    it.toHex = BA;
    function S2(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it.htonl = S2;
    function qA(t, e) {
      for (var r = "", o = 0;o < t.length; o++) {
        var f = t[o];
        e === "little" && (f = S2(f)), r += A2(f.toString(16));
      }
      return r;
    }
    it.toHex32 = qA;
    function E2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it.zero2 = E2;
    function A2(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it.zero8 = A2;
    function IA(t, e, r, o) {
      var f = r - e;
      SA(f % 4 === 0);
      for (var p2 = new Array(f / 4), m = 0, y = e;m < p2.length; m++, y += 4) {
        var M;
        o === "big" ? M = t[y] << 24 | t[y + 1] << 16 | t[y + 2] << 8 | t[y + 3] : M = t[y + 3] << 24 | t[y + 2] << 16 | t[y + 1] << 8 | t[y], p2[m] = M >>> 0;
      }
      return p2;
    }
    it.join32 = IA;
    function TA(t, e) {
      for (var r = new Array(t.length * 4), o = 0, f = 0;o < t.length; o++, f += 4) {
        var p2 = t[o];
        e === "big" ? (r[f] = p2 >>> 24, r[f + 1] = p2 >>> 16 & 255, r[f + 2] = p2 >>> 8 & 255, r[f + 3] = p2 & 255) : (r[f + 3] = p2 >>> 24, r[f + 2] = p2 >>> 16 & 255, r[f + 1] = p2 >>> 8 & 255, r[f] = p2 & 255);
      }
      return r;
    }
    it.split32 = TA;
    function kA(t, e) {
      return t >>> e | t << 32 - e;
    }
    it.rotr32 = kA;
    function LA(t, e) {
      return t << e | t >>> 32 - e;
    }
    it.rotl32 = LA;
    function NA(t, e) {
      return t + e >>> 0;
    }
    it.sum32 = NA;
    function DA(t, e, r) {
      return t + e + r >>> 0;
    }
    it.sum32_3 = DA;
    function PA(t, e, r, o) {
      return t + e + r + o >>> 0;
    }
    it.sum32_4 = PA;
    function CA(t, e, r, o, f) {
      return t + e + r + o + f >>> 0;
    }
    it.sum32_5 = CA;
    function OA(t, e, r, o) {
      var f = t[e], p2 = t[e + 1], m = o + p2 >>> 0, y = (m < o ? 1 : 0) + r + f;
      t[e] = y >>> 0, t[e + 1] = m;
    }
    it.sum64 = OA;
    function FA(t, e, r, o) {
      var f = e + o >>> 0, p2 = (f < e ? 1 : 0) + t + r;
      return p2 >>> 0;
    }
    it.sum64_hi = FA;
    function UA(t, e, r, o) {
      var f = e + o;
      return f >>> 0;
    }
    it.sum64_lo = UA;
    function zA(t, e, r, o, f, p2, m, y) {
      var M = 0, x = e;
      x = x + o >>> 0, M += x < e ? 1 : 0, x = x + p2 >>> 0, M += x < p2 ? 1 : 0, x = x + y >>> 0, M += x < y ? 1 : 0;
      var S = t + r + f + m + M;
      return S >>> 0;
    }
    it.sum64_4_hi = zA;
    function HA(t, e, r, o, f, p2, m, y) {
      var M = e + o + p2 + y;
      return M >>> 0;
    }
    it.sum64_4_lo = HA;
    function WA(t, e, r, o, f, p2, m, y, M, x) {
      var S = 0, E3 = e;
      E3 = E3 + o >>> 0, S += E3 < e ? 1 : 0, E3 = E3 + p2 >>> 0, S += E3 < p2 ? 1 : 0, E3 = E3 + y >>> 0, S += E3 < y ? 1 : 0, E3 = E3 + x >>> 0, S += E3 < x ? 1 : 0;
      var B = t + r + f + m + M + S;
      return B >>> 0;
    }
    it.sum64_5_hi = WA;
    function KA(t, e, r, o, f, p2, m, y, M, x) {
      var S = e + o + p2 + y + x;
      return S >>> 0;
    }
    it.sum64_5_lo = KA;
    function jA(t, e, r) {
      var o = e << 32 - r | t >>> r;
      return o >>> 0;
    }
    it.rotr64_hi = jA;
    function ZA(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.rotr64_lo = ZA;
    function VA(t, e, r) {
      return t >>> r;
    }
    it.shr64_hi = VA;
    function $A(t, e, r) {
      var o = t << 32 - r | e >>> r;
      return o >>> 0;
    }
    it.shr64_lo = $A;
  });
  Tf = T((B2) => {
    var R2 = Cr(), GA = ar();
    function Js() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B2.BlockHash = Js;
    Js.prototype.update = function(e, r) {
      if (e = R2.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o = e.length % this._delta8;
        this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = R2.join32(e, 0, e.length - o, this.endian);
        for (var f = 0;f < e.length; f += this._delta32)
          this._update(e, f, f + this._delta32);
      }
      return this;
    };
    Js.prototype.digest = function(e) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e);
    };
    Js.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o = r - (e + this.padLength) % r, f = new Array(o + this.padLength);
      f[0] = 128;
      for (var p2 = 1;p2 < o; p2++)
        f[p2] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m = 8;m < this.padLength; m++)
          f[p2++] = 0;
        f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, f[p2++] = e >>> 24 & 255, f[p2++] = e >>> 16 & 255, f[p2++] = e >>> 8 & 255, f[p2++] = e & 255;
      } else
        for (f[p2++] = e & 255, f[p2++] = e >>> 8 & 255, f[p2++] = e >>> 16 & 255, f[p2++] = e >>> 24 & 255, f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, f[p2++] = 0, m = 8;m < this.padLength; m++)
          f[p2++] = 0;
      return f;
    };
  });
  Cl = T((Ri) => {
    var YA = Cr(), ni = YA.rotr32;
    function XA(t, e, r, o) {
      if (t === 0)
        return q2(e, r, o);
      if (t === 1 || t === 3)
        return T2(e, r, o);
      if (t === 2)
        return I2(e, r, o);
    }
    Ri.ft_1 = XA;
    function q2(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ri.ch32 = q2;
    function I2(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ri.maj32 = I2;
    function T2(t, e, r) {
      return t ^ e ^ r;
    }
    Ri.p32 = T2;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri.g1_256 = tR;
  });
  N2 = T((Tk, L2) => {
    var kf = Cr(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k22 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi() {
      if (!(this instanceof fi))
        return new fi;
      k22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi, k22);
    L2.exports = fi;
    fi.blockSize = 512;
    fi.outSize = 160;
    fi.hmacStrength = 80;
    fi.padLength = 64;
    fi.prototype._update = function(e, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e[r + f];
      for (;f < o.length; f++)
        o[f] = Ol(o[f - 3] ^ o[f - 8] ^ o[f - 14] ^ o[f - 16], 1);
      var p2 = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4];
      for (f = 0;f < o.length; f++) {
        var S = ~~(f / 20), E2 = nR(Ol(p2, 5), fR(S, m, y, M), x, o[f], aR[S]);
        x = M, M = y, y = Ol(m, 30), m = p2, p2 = E2;
      }
      this.h[0] = Fa(this.h[0], p2), this.h[1] = Fa(this.h[1], m), this.h[2] = Fa(this.h[2], y), this.h[3] = Fa(this.h[3], M), this.h[4] = Fa(this.h[4], x);
    };
    fi.prototype._digest = function(e) {
      return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T((kk, P2) => {
    var Lf = Cr(), oR = Tf(), Nf = Cl(), sR = ar(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai() {
      if (!(this instanceof ai))
        return new ai;
      D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai, D2);
    P2.exports = ai;
    ai.blockSize = 512;
    ai.outSize = 256;
    ai.hmacStrength = 192;
    ai.padLength = 64;
    ai.prototype._update = function(e, r) {
      for (var o = this.W, f = 0;f < 16; f++)
        o[f] = e[r + f];
      for (;f < o.length; f++)
        o[f] = hR(bR(o[f - 2]), o[f - 7], vR(o[f - 15]), o[f - 16]);
      var p2 = this.h[0], m = this.h[1], y = this.h[2], M = this.h[3], x = this.h[4], S = this.h[5], E2 = this.h[6], B = this.h[7];
      for (sR(this.k.length === o.length), f = 0;f < o.length; f++) {
        var q = uR(B, pR(x), lR(x, S, E2), this.k[f], o[f]), L = Or(cR(p2), dR(p2, m, y));
        B = E2, E2 = S, S = x, x = Or(M, q), M = y, y = m, m = p2, p2 = Or(q, L);
      }
      this.h[0] = Or(this.h[0], p2), this.h[1] = Or(this.h[1], m), this.h[2] = Or(this.h[2], y), this.h[3] = Or(this.h[3], M), this.h[4] = Or(this.h[4], x), this.h[5] = Or(this.h[5], S), this.h[6] = Or(this.h[6], E2), this.h[7] = Or(this.h[7], B);
    };
    ai.prototype._digest = function(e) {
      return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F2 = T((Lk, O2) => {
    var Ul = Cr(), C2 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C2.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C2);
    O2.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e) {
      return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T((Nk, W2) => {
    var ir = Cr(), gR = Tf(), yR = ar(), oi = ir.rotr64_hi, si = ir.rotr64_lo, U2 = ir.shr64_hi, z2 = ir.shr64_lo, Ji = ir.sum64, zl = ir.sum64_hi, Hl = ir.sum64_lo, wR = ir.sum64_4_hi, MR = ir.sum64_4_lo, _R = ir.sum64_5_hi, xR = ir.sum64_5_lo, H2 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr2() {
      if (!(this instanceof Fr2))
        return new Fr2;
      H2.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir.inherits(Fr2, H2);
    W2.exports = Fr2;
    Fr2.blockSize = 1024;
    Fr2.outSize = 512;
    Fr2.hmacStrength = 192;
    Fr2.padLength = 128;
    Fr2.prototype._prepareBlock = function(e, r) {
      for (var o = this.W, f = 0;f < 32; f++)
        o[f] = e[r + f];
      for (;f < o.length; f += 2) {
        var p2 = DR(o[f - 4], o[f - 3]), m = PR(o[f - 4], o[f - 3]), y = o[f - 14], M = o[f - 13], x = LR(o[f - 30], o[f - 29]), S = NR(o[f - 30], o[f - 29]), E2 = o[f - 32], B = o[f - 31];
        o[f] = wR(p2, m, y, M, x, S, E2, B), o[f + 1] = MR(p2, m, y, M, x, S, E2, B);
      }
    };
    Fr2.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o = this.W, f = this.h[0], p2 = this.h[1], m = this.h[2], y = this.h[3], M = this.h[4], x = this.h[5], S = this.h[6], E2 = this.h[7], B = this.h[8], q = this.h[9], L = this.h[10], ge = this.h[11], _e = this.h[12], N3 = this.h[13], we = this.h[14], ye = this.h[15];
      yR(this.k.length === o.length);
      for (var xe = 0;xe < o.length; xe += 2) {
        var Re = we, Ee = ye, Ae2 = TR(B, q), P = kR(B, q), Se2 = ER(B, q, L, ge, _e, N3), v = AR(B, q, L, ge, _e, N3), i = this.k[xe], a = this.k[xe + 1], h = o[xe], s = o[xe + 1], u = _R(Re, Ee, Ae2, P, Se2, v, i, a, h, s), c = xR(Re, Ee, Ae2, P, Se2, v, i, a, h, s);
        Re = qR(f, p2), Ee = IR(f, p2), Ae2 = RR(f, p2, m, y, M, x), P = BR(f, p2, m, y, M, x);
        var b = zl(Re, Ee, Ae2, P), l = Hl(Re, Ee, Ae2, P);
        we = _e, ye = N3, _e = L, N3 = ge, L = B, ge = q, B = zl(S, E2, u, c), q = Hl(E2, E2, u, c), S = M, E2 = x, M = m, x = y, m = f, y = p2, f = zl(u, c, b, l), p2 = Hl(u, c, b, l);
      }
      Ji(this.h, 0, f, p2), Ji(this.h, 2, m, y), Ji(this.h, 4, M, x), Ji(this.h, 6, S, E2), Ji(this.h, 8, B, q), Ji(this.h, 10, L, ge), Ji(this.h, 12, _e, N3), Ji(this.h, 14, we, ye);
    };
    Fr2.prototype._digest = function(e) {
      return e === "hex" ? ir.toHex32(this.h, "big") : ir.split32(this.h, "big");
    };
    function ER(t, e, r, o, f) {
      var p2 = t & r ^ ~t & f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function AR(t, e, r, o, f, p2) {
      var m = e & o ^ ~e & p2;
      return m < 0 && (m += 4294967296), m;
    }
    function RR(t, e, r, o, f) {
      var p2 = t & r ^ t & f ^ r & f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function BR(t, e, r, o, f, p2) {
      var m = e & o ^ e & p2 ^ o & p2;
      return m < 0 && (m += 4294967296), m;
    }
    function qR(t, e) {
      var r = oi(t, e, 28), o = oi(e, t, 2), f = oi(e, t, 7), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function IR(t, e) {
      var r = si(t, e, 28), o = si(e, t, 2), f = si(e, t, 7), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function TR(t, e) {
      var r = oi(t, e, 14), o = oi(t, e, 18), f = oi(e, t, 9), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function kR(t, e) {
      var r = si(t, e, 14), o = si(t, e, 18), f = si(e, t, 9), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function LR(t, e) {
      var r = oi(t, e, 1), o = oi(t, e, 8), f = U2(t, e, 7), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function NR(t, e) {
      var r = si(t, e, 1), o = si(t, e, 8), f = z2(t, e, 7), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function DR(t, e) {
      var r = oi(t, e, 19), o = oi(e, t, 29), f = U2(t, e, 6), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
    function PR(t, e) {
      var r = si(t, e, 19), o = si(e, t, 29), f = z2(t, e, 6), p2 = r ^ o ^ f;
      return p2 < 0 && (p2 += 4294967296), p2;
    }
  });
  Z2 = T((Dk, j2) => {
    var Kl = Cr(), K2 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K2.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K2);
    j2.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e) {
      return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V2 = T((Df) => {
    Df.sha1 = N2();
    Df.sha224 = F2();
    Df.sha256 = Fl();
    Df.sha384 = Z2();
    Df.sha512 = Wl();
  });
  Q2 = T((J2) => {
    var On = Cr(), CR = Tf(), Qs = On.rotl32, $2 = On.sum32, Ua = On.sum32_3, G2 = On.sum32_4, X2 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On.inherits(hi, X2);
    J2.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o = this.h[0], f = this.h[1], p2 = this.h[2], m = this.h[3], y = this.h[4], M = o, x = f, S = p2, E2 = m, B = y, q = 0;q < 80; q++) {
        var L = $2(Qs(G2(o, Y2(q, f, p2, m), e[UR[q] + r], OR(q)), HR[q]), y);
        o = y, y = m, m = Qs(p2, 10), p2 = f, f = L, L = $2(Qs(G2(M, Y2(79 - q, x, S, E2), e[zR[q] + r], FR(q)), WR[q]), B), M = B, B = E2, E2 = Qs(S, 10), S = x, x = L;
      }
      L = Ua(this.h[1], p2, E2), this.h[1] = Ua(this.h[2], m, B), this.h[2] = Ua(this.h[3], y, M), this.h[3] = Ua(this.h[4], o, x), this.h[4] = Ua(this.h[0], f, S), this.h[0] = L;
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? On.toHex32(this.h, "little") : On.split32(this.h, "little");
    };
    function Y2(t, e, r, o) {
      return t <= 15 ? e ^ r ^ o : t <= 31 ? e & r | ~e & o : t <= 47 ? (e | ~r) ^ o : t <= 63 ? e & o | r & ~o : e ^ (r | ~o);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T((Ok, ey) => {
    var KR = Cr(), jR = ar();
    function Pf(t, e, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Pf.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Pf.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  e0 = T((ry) => {
    var Kt = ry;
    Kt.utils = Cr();
    Kt.common = Tf();
    Kt.sha = V2();
    Kt.ripemd = Q2();
    Kt.hmac = ty();
    Kt.sha1 = Kt.sha.sha1;
    Kt.sha256 = Kt.sha.sha256;
    Kt.sha224 = Kt.sha.sha224;
    Kt.sha384 = Kt.sha.sha384;
    Kt.sha512 = Kt.sha.sha512;
    Kt.ripemd160 = Kt.ripemd.ripemd160;
  });
  ny = T((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T((oy) => {
    var Zl = oy, Qi = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T((Hk, hy) => {
    var VR = e0(), Fn = Nl(), sy = ar();
    function tn(t) {
      if (!(this instanceof tn))
        return new tn(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Fn.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn.toArray(t.nonce, t.nonceEnc || "hex"), o = Fn.toArray(t.pers, t.persEnc || "hex");
      sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o);
    }
    hy.exports = tn;
    tn.prototype._init = function(e, r, o) {
      var f = e.concat(r).concat(o);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p2 = 0;p2 < this.V.length; p2++)
        this.K[p2] = 0, this.V[p2] = 1;
      this._update(f), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn.prototype.reseed = function(e, r, o, f) {
      typeof r != "string" && (f = o, o = r, r = null), e = Fn.toArray(e, r), o = Fn.toArray(o, f), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o || [])), this._reseed = 1;
    };
    tn.prototype.generate = function(e, r, o, f) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f = o, o = r, r = null), o && (o = Fn.toArray(o, f || "hex"), this._update(o));
      for (var p2 = [];p2.length < e; )
        this.V = this._hmac().update(this.V).digest(), p2 = p2.concat(this.V);
      var m = p2.slice(0, e);
      return this._update(o), this._reseed++, Fn.encode(m, r);
    };
  });
  dy = T((Wk, ly) => {
    var $R = ri(), GR = or(), $l = GR.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o });
    };
    Gt.fromPrivate = function(e, r, o) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o) {
      return this.ec.sign(e, this, r, o);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T((Kk, py) => {
    var r0 = ri(), Xl = or(), YR = Xl.assert;
    function i0(t, e) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o = r & 15;
      if (o === 0 || o > 4)
        return false;
      for (var f = 0, p2 = 0, m = e.place;p2 < o; p2++, m++)
        f <<= 8, f |= t[m], f >>>= 0;
      return f <= 127 ? false : (e.place = m, f);
    }
    function cy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    i0.prototype._importDER = function(e, r) {
      e = Xl.toArray(e, r);
      var o = new XR;
      if (e[o.place++] !== 48)
        return false;
      var f = Gl(e, o);
      if (f === false || f + o.place !== e.length || e[o.place++] !== 2)
        return false;
      var p2 = Gl(e, o);
      if (p2 === false)
        return false;
      var m = e.slice(o.place, p2 + o.place);
      if (o.place += p2, e[o.place++] !== 2)
        return false;
      var y = Gl(e, o);
      if (y === false || e.length !== y + o.place)
        return false;
      var M = e.slice(o.place, y + o.place);
      if (m[0] === 0)
        if (m[1] & 128)
          m = m.slice(1);
        else
          return false;
      if (M[0] === 0)
        if (M[1] & 128)
          M = M.slice(1);
        else
          return false;
      return this.r = new r0(m), this.s = new r0(M), this.recoveryParam = null, true;
    };
    function Yl(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    i0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o[0] & 128 && (o = [0].concat(o)), r = cy(r), o = cy(o);!o[0] && !(o[1] & 128); )
        o = o.slice(1);
      var f = [2];
      Yl(f, r.length), f = f.concat(r), f.push(2), Yl(f, o.length);
      var p2 = f.concat(o), m = [48];
      return Yl(m, p2.length), m = m.concat(p2), Xl.encode(m, e);
    };
  });
  yy = T((jk, gy) => {
    var Un = ri(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e) {
      return new Ql(this, e);
    };
    Sr.prototype.keyFromPrivate = function(e, r) {
      return Ql.fromPrivate(this, e, r);
    };
    Sr.prototype.keyFromPublic = function(e, r) {
      return Ql.fromPublic(this, e, r);
    };
    Sr.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o = this.n.byteLength(), f = this.n.sub(new Un(2));; ) {
        var p2 = new Un(r.generate(o));
        if (!(p2.cmp(f) > 0))
          return p2.iaddn(1), this.keyFromPrivate(p2);
      }
    };
    Sr.prototype._truncateToN = function(e, r) {
      var o = e.byteLength() * 8 - this.n.bitLength();
      return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Sr.prototype.sign = function(e, r, o, f) {
      typeof o == "object" && (f = o, o = null), f || (f = {}), r = this.keyFromPrivate(r, o), e = this._truncateToN(new Un(e, 16));
      for (var p2 = this.n.byteLength(), m = r.getPrivate().toArray("be", p2), y = e.toArray("be", p2), M = new by({ hash: this.hash, entropy: m, nonce: y, pers: f.pers, persEnc: f.persEnc || "utf8" }), x = this.n.sub(new Un(1)), S = 0;; S++) {
        var E2 = f.k ? f.k(S) : new Un(M.generate(this.n.byteLength()));
        if (E2 = this._truncateToN(E2, true), !(E2.cmpn(1) <= 0 || E2.cmp(x) >= 0)) {
          var B = this.g.mul(E2);
          if (!B.isInfinity()) {
            var q = B.getX(), L = q.umod(this.n);
            if (L.cmpn(0) !== 0) {
              var ge = E2.invm(this.n).mul(L.mul(r.getPrivate()).iadd(e));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e = (B.getY().isOdd() ? 1 : 0) | (q.cmp(L) !== 0 ? 2 : 0);
                return f.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e ^= 1), new n0({ r: L, s: ge, recoveryParam: _e });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e, r, o, f) {
      e = this._truncateToN(new Un(e, 16)), o = this.keyFromPublic(o, f), r = new n0(r, "hex");
      var { r: p2, s: m } = r;
      if (p2.cmpn(1) < 0 || p2.cmp(this.n) >= 0 || m.cmpn(1) < 0 || m.cmp(this.n) >= 0)
        return false;
      var y = m.invm(this.n), M = y.mul(e).umod(this.n), x = y.mul(p2).umod(this.n), S;
      return this.curve._maxwellTrick ? (S = this.g.jmulAdd(M, o.getPublic(), x), S.isInfinity() ? false : S.eqXToP(p2)) : (S = this.g.mulAdd(M, o.getPublic(), x), S.isInfinity() ? false : S.getX().umod(this.n).cmp(p2) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e, r, o) {
      my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o);
      var f = this.n, p2 = new Un(t), m = e.r, y = e.s, M = r & 1, x = r >> 1;
      if (m.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x)
        throw new Error("Unable to find sencond key candinate");
      x ? m = this.curve.pointFromX(m.add(this.curve.n), M) : m = this.curve.pointFromX(m, M);
      var S = e.r.invm(f), E2 = f.sub(p2).mul(S).umod(f), B = y.mul(S).umod(f);
      return this.g.mulAdd(E2, m, B);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e, r, o) {
      if (e = new n0(e, o), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f = 0;f < 4; f++) {
        var p2;
        try {
          p2 = this.recoverPubKey(t, e, f);
        } catch {
          continue;
        }
        if (p2.eq(r))
          return f;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf = za.cachedProperty;
    function Ft(t, e) {
      this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
    }
    Ft.fromPublic = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { pub: r });
    };
    Ft.fromSecret = function(e, r) {
      return r instanceof Ft ? r : new Ft(e, { secret: r });
    };
    Ft.prototype.secret = function() {
      return this._secret;
    };
    Cf(Ft, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf(Ft, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf(Ft, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o = e.encodingLength - 1, f = r.slice(0, e.encodingLength);
      return f[0] &= 248, f[o] &= 127, f[o] |= 64, f;
    });
    Cf(Ft, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf(Ft, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf(Ft, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft.prototype.sign = function(e) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft.prototype.getSecret = function(e) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
    };
    Ft.prototype.getPublic = function(e) {
      return za.encode(this.pubBytes(), e);
    };
    _y.exports = Ft;
  });
  Ey = T((Vk, Sy) => {
    var eB = ri(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn(t, e) {
      this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    a0(zn, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn;
  });
  Iy = T(($k, qy) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = Ry(e);
      var o = this.keyFromSecret(r), f = this.hashInt(o.messagePrefix(), e), p2 = this.g.mul(f), m = this.encodePoint(p2), y = this.hashInt(m, o.pubBytes(), e).mul(o.priv()), M = f.add(y).umod(this.curve.n);
      return this.makeSignature({ R: p2, S: M, Rencoded: m });
    };
    nr.prototype.verify = function(e, r, o) {
      e = Ry(e), r = this.makeSignature(r);
      var f = this.keyFromPublic(o), p2 = this.hashInt(r.Rencoded(), f.pubBytes(), e), m = this.g.mul(r.S()), y = r.R().add(f.pub().mul(p2));
      return y.eq(m);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return Of.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return By.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return By.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Ay ? e : new Ay(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = Of.parseBytes(e);
      var r = e.length - 1, o = e.slice(0, r).concat(e[r] & -129), f = (e[r] & 128) !== 0, p2 = Of.intFromLE(o);
      return this.curve.pointFromY(p2, f);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return Of.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  o0 = T((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T((ky, ed) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E2[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt2 = s[3] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = s[4] | 0, F3 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = s[6] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = s[7] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = s[8] | 0, V3 = yt2 & 8191, $ = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = u[5] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re2) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re2) | 0;
        var qe2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re2) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re2) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F3, X), n = Math.imul(F3, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re2) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d = Math.imul(H2, J), l = l + Math.imul(F3, Q) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re2) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re2) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d = d + Math.imul(H2, ee) | 0, l = l + Math.imul(F3, te) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re2) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d = d + Math.imul(H2, re2) | 0, l = l + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V3, X), n = Math.imul(V3, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re2) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d = d + Math.imul(H2, ne) | 0, l = l + Math.imul(F3, fe) | 0, n = n + Math.imul(F3, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce2) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce2) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d = Math.imul(Y2, J), l = l + Math.imul(V3, Q) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re2) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re2) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d = d + Math.imul(H2, ae) | 0, l = l + Math.imul(F3, oe) | 0, n = n + Math.imul(F3, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce2) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce2) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d = Math.imul(Y2, ee), l = l + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re2) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re2) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d = d + Math.imul(H2, se) | 0, l = l + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce2) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d = Math.imul(Y2, re2), l = l + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d = d + Math.imul(H2, ue) | 0, l = l + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce2) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce2) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d = Math.imul(Y2, ne), l = l + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d = d + Math.imul(H2, de) | 0, l = l + Math.imul(F3, ce2) | 0, n = n + Math.imul(F3, pe) | 0, n = n + Math.imul(U, ce2) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d = Math.imul(Y2, ae), l = l + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d = d + Math.imul(H2, pe) | 0, l = l + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d = Math.imul(Y2, se), l = l + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce2) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d = d + Math.imul(H2, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d = Math.imul(Y2, ue), l = l + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce2) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce2) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d = Math.imul(Y2, de), l = l + Math.imul(V3, ce2) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($, ce2) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d = Math.imul(Y2, pe), l = l + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d = Math.imul(Y2, be);
        var rt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt2, c[18] = rt2, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N3;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N3(v, i) {
        this.x = v, this.y = i;
      }
      N3.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N3.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N3.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N3.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N3.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N3.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N3.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N3.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N3.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N3.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se2(i);
      };
      function Se2(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se2, P), Se2.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se2.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se2.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T((Yk, Ly) => {
    var s0 = Ut(), Ff = s0.Buffer, Er = {}, Ar;
    for (Ar in s0)
      !s0.hasOwnProperty(Ar) || Ar === "SlowBuffer" || Ar === "Buffer" || (Er[Ar] = s0[Ar]);
    var Uf = Er.Buffer = {};
    for (Ar in Ff)
      !Ff.hasOwnProperty(Ar) || Ar === "allocUnsafe" || Ar === "allocUnsafeSlow" || (Uf[Ar] = Ff[Ar]);
    Er.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o = Ff(t);
      return !e || e.length === 0 ? o.fill(0) : typeof r == "string" ? o.fill(e, r) : o.fill(e), o;
    });
    if (!Er.kStringMaxLength)
      try {
        Er.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {
      }
    Er.constants || (Er.constants = { MAX_LENGTH: Er.kMaxLength }, Er.kStringMaxLength && (Er.constants.MAX_STRING_LENGTH = Er.kStringMaxLength));
    Ly.exports = Er;
  });
  u0 = T((Ny) => {
    var aB = Ie();
    function Rr2(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr2;
    Rr2.prototype.isError = function(e) {
      return e instanceof zf;
    };
    Rr2.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Rr2.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Rr2.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Rr2.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Rr2.prototype.leaveKey = function(e, r, o) {
      let f = this._reporterState;
      this.exitKey(e), f.obj !== null && (f.obj[r] = o);
    };
    Rr2.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr2.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Rr2.prototype.leaveObject = function(e) {
      let r = this._reporterState, o = r.obj;
      return r.obj = e, o;
    };
    Rr2.prototype.error = function(e) {
      let r, o = this._reporterState, f = e instanceof zf;
      if (f ? r = e : r = new zf(o.path.map(function(p2) {
        return "[" + JSON.stringify(p2) + "]";
      }).join(""), e.message || e, e.stack), !o.options.partial)
        throw r;
      return f || o.errors.push(r), r;
    };
    Rr2.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function zf(t, e) {
      this.path = t, this.rethrow(e);
    }
    aB(zf, Error);
    zf.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br2(t, e) {
      if (l0.call(this, e), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br2, l0);
    rd.DecoderBuffer = Br2;
    Br2.isDecoderBuffer = function(e) {
      return e instanceof Br2 ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    Br2.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br2.prototype.restore = function(e) {
      let r = new Br2(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
    };
    Br2.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br2.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    Br2.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o = new Br2(this.base);
      return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e, this.offset += e, o;
    };
    Br2.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Wf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e) {
      return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Wf.prototype.join = function(e, r) {
      return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
        o.join(e, r), r += o.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  d0 = T((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt = ar(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o = {};
      this._baseState = o, o.name = r, o.enc = t, o.parent = e || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = false, o.any = false, o.obj = false, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      cB.forEach(function(f) {
        r[f] = e[f];
      });
      let o = new this.constructor(r.parent);
      return o._baseState = r, o;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f = new this.constructor(this);
          return e.children.push(f), f[r].apply(f, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      Qt(r.parent === null), e.call(this), r.children = r.children.filter(function(o) {
        return o._baseState.parent === this;
      }, this), Qt.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o = e.filter(function(f) {
        return f instanceof this.constructor;
      }, this);
      e = e.filter(function(f) {
        return !(f instanceof this.constructor);
      }, this), o.length !== 0 && (Qt(r.children === null), r.children = o, o.forEach(function(f) {
        f._baseState.parent = this;
      }, this)), e.length !== 0 && (Qt(r.args === null), r.args = e, r.reverseArgs = e.map(function(f) {
        if (typeof f != "object" || f.constructor !== Object)
          return f;
        let p2 = {};
        return Object.keys(f).forEach(function(m) {
          m == (m | 0) && (m |= 0);
          let y = f[m];
          p2[y] = m;
        }), p2;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o = Array.prototype.slice.call(arguments);
        return Qt(r.tag === null), r.tag = t, this._useArgs(o), this;
      };
    });
    Ue.prototype.use = function(e) {
      Qt(e);
      let r = this._baseState;
      return Qt(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return Qt(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return Qt(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return Qt(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return Qt(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o) {
        return e[o];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return Qt(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o = this._baseState;
      if (o.parent === null)
        return e.wrapResult(o.children[0]._decode(e, r));
      let f = o.default, p2 = true, m = null;
      if (o.key !== null && (m = e.enterKey(o.key)), o.optional) {
        let M = null;
        if (o.explicit !== null ? M = o.explicit : o.implicit !== null ? M = o.implicit : o.tag !== null && (M = o.tag), M === null && !o.any) {
          let x = e.save();
          try {
            o.choice === null ? this._decodeGeneric(o.tag, e, r) : this._decodeChoice(e, r), p2 = true;
          } catch {
            p2 = false;
          }
          e.restore(x);
        } else if (p2 = this._peekTag(e, M, o.any), e.isError(p2))
          return p2;
      }
      let y;
      if (o.obj && p2 && (y = e.enterObject()), p2) {
        if (o.explicit !== null) {
          let x = this._decodeTag(e, o.explicit);
          if (e.isError(x))
            return x;
          e = x;
        }
        let M = e.offset;
        if (o.use === null && o.choice === null) {
          let x;
          o.any && (x = e.save());
          let S = this._decodeTag(e, o.implicit !== null ? o.implicit : o.tag, o.any);
          if (e.isError(S))
            return S;
          o.any ? f = e.raw(x) : e = S;
        }
        if (r && r.track && o.tag !== null && r.track(e.path(), M, e.length, "tagged"), r && r.track && o.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o.any || (o.choice === null ? f = this._decodeGeneric(o.tag, e, r) : f = this._decodeChoice(e, r)), e.isError(f))
          return f;
        if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(S) {
          S._decode(e, r);
        }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
          let x = new uB(f);
          f = this._getUse(o.contains, e._reporterState.obj)._decode(x, r);
        }
      }
      return o.obj && p2 && (f = e.leaveObject(y)), o.key !== null && (f !== null || p2 === true) ? e.leaveKey(m, o.key, f) : m !== null && e.exitKey(m), f;
    };
    Ue.prototype._decodeGeneric = function(e, r, o) {
      let f = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f.args[0], o) : /str$/.test(e) ? this._decodeStr(r, e, o) : e === "objid" && f.args ? this._decodeObjid(r, f.args[0], f.args[1], o) : e === "objid" ? this._decodeObjid(r, null, null, o) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o) : e === "null_" ? this._decodeNull(r, o) : e === "bool" ? this._decodeBool(r, o) : e === "objDesc" ? this._decodeStr(r, e, o) : e === "int" || e === "enum" ? this._decodeInt(r, f.args && f.args[0], o) : f.use !== null ? this._getUse(f.use, r._reporterState.obj)._decode(r, o) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o = this._baseState;
      return o.useDecoder = this._use(e, r), Qt(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o = this._baseState, f = null, p2 = false;
      return Object.keys(o.choice).some(function(m) {
        let y = e.save(), M = o.choice[m];
        try {
          let x = M._decode(e, r);
          if (e.isError(x))
            return false;
          f = { type: m, value: x }, p2 = true;
        } catch {
          return e.restore(y), false;
        }
        return true;
      }, this), p2 ? f : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new hB(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o) {
      let f = this._baseState;
      if (f.default !== null && f.default === e)
        return;
      let p2 = this._encodeValue(e, r, o);
      if (p2 !== undefined && !this._skipDefault(p2, r, o))
        return p2;
    };
    Ue.prototype._encodeValue = function(e, r, o) {
      let f = this._baseState;
      if (f.parent === null)
        return f.children[0]._encode(e, r || new sB);
      let p2 = null;
      if (this.reporter = r, f.optional && e === undefined)
        if (f.default !== null)
          e = f.default;
        else
          return;
      let m = null, y = false;
      if (f.any)
        p2 = this._createEncoderBuffer(e);
      else if (f.choice)
        p2 = this._encodeChoice(e, r);
      else if (f.contains)
        m = this._getUse(f.contains, o)._encode(e, r), y = true;
      else if (f.children)
        m = f.children.map(function(M) {
          if (M._baseState.tag === "null_")
            return M._encode(null, r, e);
          if (M._baseState.key === null)
            return r.error("Child should have a key");
          let x = r.enterKey(M._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S = M._encode(e[M._baseState.key], r, e);
          return r.leaveKey(x), S;
        }, this).filter(function(M) {
          return M;
        }), m = this._createEncoderBuffer(m);
      else if (f.tag === "seqof" || f.tag === "setof") {
        if (!(f.args && f.args.length === 1))
          return r.error("Too many args for : " + f.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M = this.clone();
        M._baseState.implicit = null, m = this._createEncoderBuffer(e.map(function(x) {
          let S = this._baseState;
          return this._getUse(S.args[0], e)._encode(x, r);
        }, M));
      } else
        f.use !== null ? p2 = this._getUse(f.use, o)._encode(e, r) : (m = this._encodePrimitive(f.tag, e), y = true);
      if (!f.any && f.choice === null) {
        let M = f.implicit !== null ? f.implicit : f.tag, x = f.implicit === null ? "universal" : "context";
        M === null ? f.use === null && r.error("Tag could be omitted only for .use()") : f.use === null && (p2 = this._encodeComposite(M, y, x, m));
      }
      return f.explicit !== null && (p2 = this._encodeComposite(f.explicit, false, "context", p2)), p2;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o = this._baseState, f = o.choice[e.type];
      return f || Qt(false, e.type + " not found in " + JSON.stringify(Object.keys(o.choice))), f._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o.args)
        return this._encodeObjid(r, o.reverseArgs[0], o.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o.args && o.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  c0 = T((Wn) => {
    function Cy(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o = t[r];
        e[o] = r;
      }), e;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T((tL, Uy) => {
    var pB = Ie(), Ii = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur2, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur2(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur2, Oy);
    Ur2.prototype._encodeComposite = function(e, r, o, f) {
      let p2 = vB(e, r, o, this.reporter);
      if (f.length < 128) {
        let M = Ii.alloc(2);
        return M[0] = p2, M[1] = f.length, this._createEncoderBuffer([M, f]);
      }
      let m = 1;
      for (let M = f.length;M >= 256; M >>= 8)
        m++;
      let y = Ii.alloc(1 + 1 + m);
      y[0] = p2, y[1] = 128 | m;
      for (let M = 1 + m, x = f.length;x > 0; M--, x >>= 8)
        y[M] = x & 255;
      return this._createEncoderBuffer([y, f]);
    };
    Ur2.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o = Ii.alloc(e.length * 2);
        for (let f = 0;f < e.length; f++)
          o.writeUInt16BE(e.charCodeAt(f), f * 2);
        return this._createEncoderBuffer(o);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur2.prototype._encodeObjid = function(e, r, o) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y = 0;y < e.length; y++)
          e[y] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f = 0;
      for (let y = 0;y < e.length; y++) {
        let M = e[y];
        for (f++;M >= 128; M >>= 7)
          f++;
      }
      let p2 = Ii.alloc(f), m = p2.length - 1;
      for (let y = e.length - 1;y >= 0; y--) {
        let M = e[y];
        for (p2[m--] = M & 127;(M >>= 7) > 0; )
          p2[m--] = 128 | M & 127;
      }
      return this._createEncoderBuffer(p2);
    };
    function qr(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur2.prototype._encodeTime = function(e, r) {
      let o, f = new Date(e);
      return r === "gentime" ? o = [qr(f.getUTCFullYear()), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o = [qr(f.getUTCFullYear() % 100), qr(f.getUTCMonth() + 1), qr(f.getUTCDate()), qr(f.getUTCHours()), qr(f.getUTCMinutes()), qr(f.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o, "octstr");
    };
    Ur2.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur2.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ii.isBuffer(e)) {
        let p2 = e.toArray();
        !e.sign && p2[0] & 128 && p2.unshift(0), e = Ii.from(p2);
      }
      if (Ii.isBuffer(e)) {
        let p2 = e.length;
        e.length === 0 && p2++;
        let m = Ii.alloc(p2);
        return e.copy(m), e.length === 0 && (m[0] = 0), this._createEncoderBuffer(m);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o = 1;
      for (let p2 = e;p2 >= 256; p2 >>= 8)
        o++;
      let f = new Array(o);
      for (let p2 = f.length - 1;p2 >= 0; p2--)
        f[p2] = e & 255, e >>= 8;
      return f[0] & 128 && f.unshift(0), this._createEncoderBuffer(Ii.from(f));
    };
    Ur2.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur2.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur2.prototype._skipDefault = function(e, r, o) {
      let f = this._baseState, p2;
      if (f.default === null)
        return false;
      let m = e.join();
      if (f.defaultBuffer === undefined && (f.defaultBuffer = this._encodeValue(f.default, r, o).join()), m.length !== f.defaultBuffer.length)
        return false;
      for (p2 = 0;p2 < m.length; p2++)
        if (m[p2] !== f.defaultBuffer[p2])
          return false;
      return true;
    };
    function vB(t, e, r, o) {
      let f;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f = t;
      else
        return o.error("Unknown tag: " + t);
      return f >= 31 ? o.error("Multi-octet tag encoding unsupported") : (e || (f |= 32), f |= id.tagClassByName[r || "universal"] << 6, f);
    }
  });
  Hy = T((rL, zy) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy.exports = ad;
    ad.prototype.encode = function(e, r) {
      let f = fd.prototype.encode.call(this, e).toString("base64"), p2 = ["-----BEGIN " + r.label + "-----"];
      for (let m = 0;m < f.length; m += 64)
        p2.push(f.slice(m, m + 64));
      return p2.push("-----END " + r.label + "-----"), p2.join(`
`);
    };
  });
  od = T((Ky) => {
    var Wy = Ky;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T((nL, Yy) => {
    var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy.exports = $y;
    $y.prototype.decode = function(e, r) {
      return jy.isDecoderBuffer(e) || (e = new jy(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      Vy.call(this, "der", t);
    }
    mB(sr, Vy);
    sr.prototype._peekTag = function(e, r, o) {
      if (e.isEmpty())
        return false;
      let f = e.save(), p2 = sd(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p2) ? p2 : (e.restore(f), p2.tag === r || p2.tagStr === r || p2.tagStr + "of" === r || o);
    };
    sr.prototype._decodeTag = function(e, r, o) {
      let f = sd(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f))
        return f;
      let p2 = Gy(e, f.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p2))
        return p2;
      if (!o && f.tag !== r && f.tagStr !== r && f.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f.primitive || p2 !== null)
        return e.skip(p2, 'Failed to match body of: "' + r + '"');
      let m = e.save(), y = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y) ? y : (p2 = e.offset - m.offset, e.restore(m), e.skip(p2, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o = sd(e, r);
        if (e.isError(o))
          return o;
        let f = Gy(e, o.primitive, r);
        if (e.isError(f))
          return f;
        let p2;
        if (o.primitive || f !== null ? p2 = e.skip(f) : p2 = this._skipUntilEnd(e, r), e.isError(p2))
          return p2;
        if (o.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o, f) {
      let p2 = [];
      for (;!e.isEmpty(); ) {
        let m = this._peekTag(e, "end");
        if (e.isError(m))
          return m;
        let y = o.decode(e, "der", f);
        if (e.isError(y) && m)
          break;
        p2.push(y);
      }
      return p2;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o = e.readUInt8();
        return e.isError(o) ? o : { unused: o, data: e.raw() };
      } else if (r === "bmpstr") {
        let o = e.raw();
        if (o.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f = "";
        for (let p2 = 0;p2 < o.length / 2; p2++)
          f += String.fromCharCode(o.readUInt16BE(p2 * 2));
        return f;
      } else if (r === "numstr") {
        let o = e.raw().toString("ascii");
        return this._isNumstr(o) ? o : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o = e.raw().toString("ascii");
          return this._isPrintstr(o) ? o : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o) {
      let f, p2 = [], m = 0, y = 0;
      for (;!e.isEmpty(); )
        y = e.readUInt8(), m <<= 7, m |= y & 127, (y & 128) === 0 && (p2.push(m), m = 0);
      y & 128 && p2.push(m);
      let M = p2[0] / 40 | 0, x = p2[0] % 40;
      if (o ? f = p2 : f = [M, x].concat(p2.slice(1)), r) {
        let S = r[f.join(" ")];
        S === undefined && (S = r[f.join(".")]), S !== undefined && (f = S);
      }
      return f;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o = e.raw().toString(), f, p2, m, y, M, x;
      if (r === "gentime")
        f = o.slice(0, 4) | 0, p2 = o.slice(4, 6) | 0, m = o.slice(6, 8) | 0, y = o.slice(8, 10) | 0, M = o.slice(10, 12) | 0, x = o.slice(12, 14) | 0;
      else if (r === "utctime")
        f = o.slice(0, 2) | 0, p2 = o.slice(2, 4) | 0, m = o.slice(4, 6) | 0, y = o.slice(6, 8) | 0, M = o.slice(8, 10) | 0, x = o.slice(10, 12) | 0, f < 70 ? f = 2000 + f : f = 1900 + f;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f, p2 - 1, m, y, M, x, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o = e.raw(), f = new gB(o);
      return r && (f = r[f.toString(10)] || f), f;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function sd(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o = Zy.tagClass[r >> 6], f = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m = r;
        for (r = 0;(m & 128) === 128; ) {
          if (m = t.readUInt8(e), t.isError(m))
            return m;
          r <<= 7, r |= m & 127;
        }
      } else
        r &= 31;
      let p2 = Zy.tag[r];
      return { cls: o, primitive: f, tag: r, tagStr: p2 };
    }
    function Gy(t, e, r) {
      let o = t.readUInt8(r);
      if (t.isError(o))
        return o;
      if (!e && o === 128)
        return null;
      if ((o & 128) === 0)
        return o;
      let f = o & 127;
      if (f > 4)
        return t.error("length octect is too long");
      o = 0;
      for (let p2 = 0;p2 < f; p2++) {
        o <<= 8;
        let m = t.readUInt8(r);
        if (t.isError(m))
          return m;
        o |= m;
      }
      return o;
    }
  });
  Jy = T((fL, Xy) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy.exports = ld;
    ld.prototype.decode = function(e, r) {
      let o = e.toString().split(/[\r\n]+/g), f = r.label.toUpperCase(), p2 = /^-----(BEGIN|END) ([^-]+)-----$/, m = -1, y = -1;
      for (let S = 0;S < o.length; S++) {
        let E2 = o[S].match(p2);
        if (E2 !== null && E2[2] === f)
          if (m === -1) {
            if (E2[1] !== "BEGIN")
              break;
            m = S;
          } else {
            if (E2[1] !== "END")
              break;
            y = S;
            break;
          }
      }
      if (m === -1 || y === -1)
        throw new Error("PEM section not found for: " + f);
      let M = o.slice(m + 1, y).join("");
      M.replace(/[^a-z0-9+/=]+/gi, "");
      let x = wB.from(M, "base64");
      return ud.prototype.decode.call(this, x, r);
    };
  });
  dd = T((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy();
  });
  r3 = T((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e, r) {
      return new jf(e, r);
    };
    function jf(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e) {
      let r = this.name;
      function o(f) {
        this._initNamed(f, r);
      }
      return xB(o, e), o.prototype._initNamed = function(p2, m) {
        e.call(this, p2, m);
      }, new o(this);
    };
    jf.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
    };
    jf.prototype.decode = function(e, r, o) {
      return this._getDecoder(r).decode(e, o);
    };
    jf.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
    };
    jf.prototype.encode = function(e, r, o) {
      return this._getEncoder(r).encode(e, o);
    };
  });
  n3 = T((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T((a3) => {
    var f3 = a3;
    f3._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        let f = e[o];
        r[f] = o;
      }), r;
    };
    f3.der = c0();
  });
  cd = T((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d3 = T((lL, l3) => {
    var zr = cd(), h3 = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
    }), IB = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T((Wr) => {
    var Hr = cd();
    Wr.certificate = d3();
    var LB = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v3 = T((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m3 = T((pL, b3) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b3.exports = function(t, e) {
      var r = t.toString(), o = r.match(HB), f;
      if (o) {
        var m = "aes" + o[1], y = v0.from(o[2], "hex"), M = v0.from(o[3].replace(/[\r\n]/g, ""), "base64"), x = jB(e, y.slice(0, 8), parseInt(o[1], 10)).key, S = [], E2 = ZB.createDecipheriv(m, x, y);
        S.push(E2.update(M)), S.push(E2.final()), f = v0.concat(S);
      } else {
        var p2 = r.match(KB);
        f = v0.from(p2[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B = r.match(WB)[1];
      return { tag: B, data: f };
    };
  });
  Ha = T((vL, y3) => {
    var fr = p3(), VB = v3(), $B = m3(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y3.exports = g3;
    function g3(t) {
      var e;
      typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e), o = r.tag, f = r.data, p2, m;
      switch (o) {
        case "CERTIFICATE":
          m = fr.certificate.decode(f, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m || (m = fr.PublicKey.decode(f, "der")), p2 = m.algorithm.algorithm.join("."), p2) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m.subjectPrivateKey = m.subjectPublicKey, { type: "ec", data: m };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.pub_key = fr.DSAparam.decode(m.subjectPublicKey.data, "der"), { type: "dsa", data: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p2);
          }
        case "ENCRYPTED PRIVATE KEY":
          f = fr.EncryptedPrivateKey.decode(f, "der"), f = XB(f, e);
        case "PRIVATE KEY":
          switch (m = fr.PrivateKey.decode(f, "der"), p2 = m.algorithm.algorithm.join("."), p2) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m.algorithm.params.priv_key = fr.DSAparam.decode(m.subjectPrivateKey, "der"), { type: "dsa", params: m.algorithm.params };
            default:
              throw new Error("unknown key id " + p2);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f, "der") };
        case "EC PRIVATE KEY":
          return f = fr.ECPrivateKey.decode(f, "der"), { curve: f.parameters.value, privateKey: f.privateKey };
        default:
          throw new Error("unknown key type " + o);
      }
    }
    g3.signature = fr.signature;
    function XB(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f = VB[t.algorithm.decrypt.cipher.algo.join(".")], p2 = t.algorithm.decrypt.cipher.iv, m = t.subjectPrivateKey, y = parseInt(f.split("-")[1], 10) / 8, M = YB.pbkdf2Sync(e, r, o, y, "sha1"), x = GB.createDecipheriv(f, M, p2), S = [];
      return S.push(x.update(m)), S.push(x.final()), vd.concat(S);
    }
  });
  bd = T((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _3 = T((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks(), eq = o0().ec, b0 = Ws(), tq = Ha(), rq = bd();
    function iq(t, e, r, o, f) {
      var p2 = tq(e);
      if (p2.curve) {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p2);
      } else if (p2.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p2, r);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f, t]);
      for (var m = p2.modulus.byteLength(), y = [0, 1];t.length + y.length + 1 < m; )
        y.push(255);
      y.push(0);
      for (var M = -1;++M < t.length; )
        y.push(t[M]);
      var x = QB(y, p2);
      return x;
    }
    function nq(t, e) {
      var r = rq[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o = new eq(r), f = o.keyFromPrivate(e.privateKey), p2 = f.sign(t);
      return Yt.from(p2.toDER());
    }
    function fq(t, e, r) {
      for (var o = e.params.priv_key, f = e.params.p, p2 = e.params.q, m = e.params.g, y = new b0(0), M, x = md(t, p2).mod(p2), S = false, E2 = w3(o, p2, t, r);S === false; )
        M = M3(p2, E2, r), y = sq(m, M, f, p2), S = M.invm(p2).imul(x.add(o.mul(y))).mod(p2), S.cmpn(0) === 0 && (S = false, y = new b0(0));
      return aq(y, S);
    }
    function aq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o = [48, r, 2, t.length];
      return o = o.concat(t, [2, e.length], e), Yt.from(o);
    }
    function w3(t, e, r, o) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f, t]);
      }
      var p2 = r.length, m = oq(r, e), y = Yt.alloc(p2);
      y.fill(1);
      var M = Yt.alloc(p2);
      return M = Kn(o, M).update(y).update(Yt.from([0])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), M = Kn(o, M).update(y).update(Yt.from([1])).update(t).update(m).digest(), y = Kn(o, M).update(y).digest(), { k: M, v: y };
    }
    function md(t, e) {
      var r = new b0(t), o = (t.length << 3) - e.bitLength();
      return o > 0 && r.ishrn(o), r;
    }
    function oq(t, e) {
      t = md(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o, r]);
      }
      return r;
    }
    function M3(t, e, r) {
      var o, f;
      do {
        for (o = Yt.alloc(0);o.length * 8 < t.bitLength(); )
          e.v = Kn(r, e.k).update(e.v).digest(), o = Yt.concat([o, e.v]);
        f = md(o, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
      } while (f.cmp(t) !== -1);
      return f;
    }
    function sq(t, e, r, o) {
      return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M3;
  });
  A3 = T((gL, E3) => {
    var gd = Te().Buffer, Wa = Ws(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e, r, o, f) {
      var p2 = S3(r);
      if (p2.type === "ec") {
        if (o !== "ecdsa" && o !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e, p2);
      } else if (p2.type === "dsa") {
        if (o !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e, p2);
      } else if (o !== "rsa" && o !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = gd.concat([f, e]);
      for (var m = p2.modulus.byteLength(), y = [1], M = 0;e.length + y.length + 2 < m; )
        y.push(255), M++;
      y.push(0);
      for (var x = -1;++x < e.length; )
        y.push(e[x]);
      y = gd.from(y);
      var S = Wa.mont(p2.modulus);
      t = new Wa(t).toRed(S), t = t.redPow(new Wa(p2.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E2 = M < 8 ? 1 : 0;
      for (m = Math.min(t.length, y.length), t.length !== y.length && (E2 = 1), x = -1;++x < m; )
        E2 |= t[x] ^ y[x];
      return E2 === 0;
    }
    function dq(t, e, r) {
      var o = uq[r.data.algorithm.curve.join(".")];
      if (!o)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f = new hq(o), p2 = r.data.subjectPrivateKey.data;
      return f.verify(e, t, p2);
    }
    function cq(t, e, r) {
      var o = r.data.p, f = r.data.q, p2 = r.data.g, m = r.data.pub_key, y = S3.signature.decode(t, "der"), M = y.s, x = y.r;
      x3(M, f), x3(x, f);
      var S = Wa.mont(o), E2 = M.invm(f), B = p2.toRed(S).redPow(new Wa(e).mul(E2).mod(f)).fromRed().mul(m.toRed(S).redPow(x.mul(E2).mod(f)).fromRed()).mod(o).mod(f);
      return B.cmp(x) === 0;
    }
    function x3(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    E3.exports = lq;
  });
  k3 = T((yL, T3) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I3 = Ie(), pq = _3(), vq = A3(), jn = Mu();
    Object.keys(jn).forEach(function(t) {
      jn[t].id = g0.from(jn[t].id, "hex"), jn[t.toLowerCase()] = jn[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(Ka, y0.Writable);
    Ka.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    Ka.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    Ka.prototype.sign = function(e, r) {
      this.end();
      var o = this._hash.digest(), f = pq(o, e, this._hashType, this._signType, this._tag);
      return r ? f.toString(r) : f;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e = jn[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I3(ja, y0.Writable);
    ja.prototype._write = function(e, r, o) {
      this._hash.update(e), o();
    };
    ja.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    ja.prototype.verify = function(e, r, o) {
      typeof r == "string" && (r = g0.from(r, o)), this.end();
      var f = this._hash.digest();
      return vq(r, f, e, this._signType, this._tag);
    };
    function R3(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
  });
  N3 = T((L3, yd) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E2[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt2 = s[3] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = s[4] | 0, F3 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = s[6] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = s[7] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = s[8] | 0, V3 = yt2 & 8191, $ = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = u[5] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re2) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re2) | 0;
        var qe2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re2) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re2) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F3, X), n = Math.imul(F3, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re2) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d = Math.imul(H2, J), l = l + Math.imul(F3, Q) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re2) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re2) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d = d + Math.imul(H2, ee) | 0, l = l + Math.imul(F3, te) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re2) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d = d + Math.imul(H2, re2) | 0, l = l + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V3, X), n = Math.imul(V3, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re2) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d = d + Math.imul(H2, ne) | 0, l = l + Math.imul(F3, fe) | 0, n = n + Math.imul(F3, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce2) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce2) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d = Math.imul(Y2, J), l = l + Math.imul(V3, Q) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re2) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re2) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d = d + Math.imul(H2, ae) | 0, l = l + Math.imul(F3, oe) | 0, n = n + Math.imul(F3, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce2) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce2) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d = Math.imul(Y2, ee), l = l + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re2) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re2) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d = d + Math.imul(H2, se) | 0, l = l + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce2) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d = Math.imul(Y2, re2), l = l + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d = d + Math.imul(H2, ue) | 0, l = l + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce2) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce2) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d = Math.imul(Y2, ne), l = l + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d = d + Math.imul(H2, de) | 0, l = l + Math.imul(F3, ce2) | 0, n = n + Math.imul(F3, pe) | 0, n = n + Math.imul(U, ce2) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d = Math.imul(Y2, ae), l = l + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d = d + Math.imul(H2, pe) | 0, l = l + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d = Math.imul(Y2, se), l = l + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce2) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d = d + Math.imul(H2, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d = Math.imul(Y2, ue), l = l + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce2) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce2) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d = Math.imul(Y2, de), l = l + Math.imul(V3, ce2) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($, ce2) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d = Math.imul(Y2, pe), l = l + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d = Math.imul(Y2, be);
        var rt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt2, c[18] = rt2, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N4;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N4(v, i) {
        this.x = v, this.y = i;
      }
      N4.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N4.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N4.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N4.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N4.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N4.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N4.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N4.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N4.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N4.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se2(i);
      };
      function Se2(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se2, P), Se2.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se2.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se2.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof yd > "u" || yd, L3);
  });
  P3 = T((wL, D3) => {
    var bq = o0(), mq = N3();
    D3.exports = function(e) {
      return new Zn(e);
    };
    var hr = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr.p224 = hr.secp224r1;
    hr.p256 = hr.secp256r1 = hr.prime256v1;
    hr.p192 = hr.secp192r1 = hr.prime192v1;
    hr.p384 = hr.secp384r1;
    hr.p521 = hr.secp521r1;
    function Zn(t) {
      this.curveType = hr[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Zn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o = this.curve.keyFromPublic(t).getPublic(), f = o.mul(this.keys.getPrivate()).getX();
      return wd(f, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o = new Buffer(t);
      if (r && o.length < r) {
        var f = new Buffer(r - o.length);
        f.fill(0), o = Buffer.concat([f, o]);
      }
      return e ? o.toString(e) : o;
    }
  });
  _d = T((ML, C3) => {
    var gq = bf(), Md = Te().Buffer;
    C3.exports = function(t, e) {
      for (var r = Md.alloc(0), o = 0, f;r.length < e; )
        f = yq(o++), r = Md.concat([r, gq("sha1").update(t).update(f).digest()]);
      return r.slice(0, e);
    };
    function yq(t) {
      var e = Md.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  xd = T((_L, O3) => {
    O3.exports = function(e, r) {
      for (var o = e.length, f = -1;++f < o; )
        e[f] ^= r[f];
      return e;
    };
  });
  w0 = T((F3, Sd) => {
    (function(t, e) {
      function r(v, i) {
        if (!v)
          throw new Error(i || "Assertion failed");
      }
      function o(v, i) {
        v.super_ = i;
        var a = function() {
        };
        a.prototype = i.prototype, v.prototype = new a, v.prototype.constructor = v;
      }
      function f(v, i, a) {
        if (f.isBN(v))
          return v;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v !== null && ((i === "le" || i === "be") && (a = i, i = 10), this._init(v || 0, i || 10, a || "be"));
      }
      typeof t == "object" ? t.exports = f : e.BN = f, f.BN = f, f.wordSize = 26;
      var p2;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p2 = window.Buffer : p2 = ji().Buffer;
      } catch {
      }
      f.isBN = function(i) {
        return i instanceof f ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f.wordSize && Array.isArray(i.words);
      }, f.max = function(i, a) {
        return i.cmp(a) > 0 ? i : a;
      }, f.min = function(i, a) {
        return i.cmp(a) < 0 ? i : a;
      }, f.prototype._init = function(i, a, h) {
        if (typeof i == "number")
          return this._initNumber(i, a, h);
        if (typeof i == "object")
          return this._initArray(i, a, h);
        a === "hex" && (a = 16), r(a === (a | 0) && a >= 2 && a <= 36), i = i.toString().replace(/\s+/g, "");
        var s = 0;
        i[0] === "-" && (s++, this.negative = 1), s < i.length && (a === 16 ? this._parseHex(i, s, h) : (this._parseBase(i, a, s), h === "le" && this._initArray(this.toArray(), a, h)));
      }, f.prototype._initNumber = function(i, a, h) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h === "le" && this._initArray(this.toArray(), a, h);
      }, f.prototype._initArray = function(i, a, h) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u, c, b = 0;
        if (h === "be")
          for (s = i.length - 1, u = 0;s >= 0; s -= 3)
            c = i[s] | i[s - 1] << 8 | i[s - 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        else if (h === "le")
          for (s = 0, u = 0;s < i.length; s += 3)
            c = i[s] | i[s + 1] << 8 | i[s + 2] << 16, this.words[u] |= c << b & 67108863, this.words[u + 1] = c >>> 26 - b & 67108863, b += 24, b >= 26 && (b -= 26, u++);
        return this.strip();
      };
      function m(v, i) {
        var a = v.charCodeAt(i);
        return a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : a - 48 & 15;
      }
      function y(v, i, a) {
        var h = m(v, a);
        return a - 1 >= i && (h |= m(v, a - 1) << 4), h;
      }
      f.prototype._parseHex = function(i, a, h) {
        this.length = Math.ceil((i.length - a) / 6), this.words = new Array(this.length);
        for (var s = 0;s < this.length; s++)
          this.words[s] = 0;
        var u = 0, c = 0, b;
        if (h === "be")
          for (s = i.length - 1;s >= a; s -= 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        else {
          var l = i.length - a;
          for (s = l % 2 === 0 ? a + 1 : a;s < i.length; s += 2)
            b = y(i, a, s) << u, this.words[c] |= b & 67108863, u >= 18 ? (u -= 18, c += 1, this.words[c] |= b >>> 26) : u += 8;
        }
        this.strip();
      };
      function M(v, i, a, h) {
        for (var s = 0, u = Math.min(v.length, a), c = i;c < u; c++) {
          var b = v.charCodeAt(c) - 48;
          s *= h, b >= 49 ? s += b - 49 + 10 : b >= 17 ? s += b - 17 + 10 : s += b;
        }
        return s;
      }
      f.prototype._parseBase = function(i, a, h) {
        this.words = [0], this.length = 1;
        for (var s = 0, u = 1;u <= 67108863; u *= a)
          s++;
        s--, u = u / a | 0;
        for (var c = i.length - h, b = c % s, l = Math.min(c, c - b) + h, n = 0, d = h;d < l; d += s)
          n = M(i, d, d + s, a), this.imuln(u), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b !== 0) {
          var w = 1;
          for (n = M(i, d, i.length, a), d = 0;d < b; d++)
            w *= a;
          this.imuln(w), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a = 0;a < this.length; a++)
          i.words[a] = this.words[a];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f.prototype.clone = function() {
        var i = new f(null);
        return this.copy(i), i;
      }, f.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f.prototype.toString = function(i, a) {
        i = i || 10, a = a | 0 || 1;
        var h;
        if (i === 16 || i === "hex") {
          h = "";
          for (var s = 0, u = 0, c = 0;c < this.length; c++) {
            var b = this.words[c], l = ((b << s | u) & 16777215).toString(16);
            u = b >>> 24 - s & 16777215, u !== 0 || c !== this.length - 1 ? h = x[6 - l.length] + l + h : h = l + h, s += 2, s >= 26 && (s -= 26, c--);
          }
          for (u !== 0 && (h = u.toString(16) + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S[i], d = E2[i];
          h = "";
          var w = this.clone();
          for (w.negative = 0;!w.isZero(); ) {
            var g = w.modn(d).toString(i);
            w = w.idivn(d), w.isZero() ? h = g + h : h = x[n - g.length] + g + h;
          }
          for (this.isZero() && (h = "0" + h);h.length % a !== 0; )
            h = "0" + h;
          return this.negative !== 0 && (h = "-" + h), h;
        }
        r(false, "Base should be between 2 and 36");
      }, f.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f.prototype.toJSON = function() {
        return this.toString(16);
      }, f.prototype.toBuffer = function(i, a) {
        return r(typeof p2 < "u"), this.toArrayLike(p2, i, a);
      }, f.prototype.toArray = function(i, a) {
        return this.toArrayLike(Array, i, a);
      }, f.prototype.toArrayLike = function(i, a, h) {
        var s = this.byteLength(), u = h || Math.max(1, s);
        r(s <= u, "byte array longer than desired length"), r(u > 0, "Requested array length <= 0"), this.strip();
        var c = a === "le", b = new i(u), l, n, d = this.clone();
        if (c) {
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[n] = l;
          for (;n < u; n++)
            b[n] = 0;
        } else {
          for (n = 0;n < u - s; n++)
            b[n] = 0;
          for (n = 0;!d.isZero(); n++)
            l = d.andln(255), d.iushrn(8), b[u - n - 1] = l;
        }
        return b;
      }, Math.clz32 ? f.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f.prototype._countBits = function(i) {
        var a = i, h = 0;
        return a >= 4096 && (h += 13, a >>>= 13), a >= 64 && (h += 7, a >>>= 7), a >= 8 && (h += 4, a >>>= 4), a >= 2 && (h += 2, a >>>= 2), h + a;
      }, f.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a = i, h = 0;
        return (a & 8191) === 0 && (h += 13, a >>>= 13), (a & 127) === 0 && (h += 7, a >>>= 7), (a & 15) === 0 && (h += 4, a >>>= 4), (a & 3) === 0 && (h += 2, a >>>= 2), (a & 1) === 0 && h++, h;
      }, f.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a = this._countBits(i);
        return (this.length - 1) * 26 + a;
      };
      function B(v) {
        for (var i = new Array(v.bitLength()), a = 0;a < i.length; a++) {
          var h = a / 26 | 0, s = a % 26;
          i[a] = (v.words[h] & 1 << s) >>> s;
        }
        return i;
      }
      f.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a = 0;a < this.length; a++) {
          var h = this._zeroBits(this.words[a]);
          if (i += h, h !== 26)
            break;
        }
        return i;
      }, f.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f.prototype.neg = function() {
        return this.clone().ineg();
      }, f.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a = 0;a < i.length; a++)
          this.words[a] = this.words[a] | i.words[a];
        return this.strip();
      }, f.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f.prototype.iuand = function(i) {
        var a;
        this.length > i.length ? a = i : a = this;
        for (var h = 0;h < a.length; h++)
          this.words[h] = this.words[h] & i.words[h];
        return this.length = a.length, this.strip();
      }, f.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f.prototype.iuxor = function(i) {
        var a, h;
        this.length > i.length ? (a = this, h = i) : (a = i, h = this);
        for (var s = 0;s < h.length; s++)
          this.words[s] = a.words[s] ^ h.words[s];
        if (this !== a)
          for (;s < a.length; s++)
            this.words[s] = a.words[s];
        return this.length = a.length, this.strip();
      }, f.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = Math.ceil(i / 26) | 0, h = i % 26;
        this._expand(a), h > 0 && a--;
        for (var s = 0;s < a; s++)
          this.words[s] = ~this.words[s] & 67108863;
        return h > 0 && (this.words[s] = ~this.words[s] & 67108863 >> 26 - h), this.strip();
      }, f.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f.prototype.setn = function(i, a) {
        r(typeof i == "number" && i >= 0);
        var h = i / 26 | 0, s = i % 26;
        return this._expand(h + 1), a ? this.words[h] = this.words[h] | 1 << s : this.words[h] = this.words[h] & ~(1 << s), this.strip();
      }, f.prototype.iadd = function(i) {
        var a;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a = this.isub(i), i.negative = 1, a._normSign();
        var h, s;
        this.length > i.length ? (h = this, s = i) : (h = i, s = this);
        for (var u = 0, c = 0;c < s.length; c++)
          a = (h.words[c] | 0) + (s.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        for (;u !== 0 && c < h.length; c++)
          a = (h.words[c] | 0) + u, this.words[c] = a & 67108863, u = a >>> 26;
        if (this.length = h.length, u !== 0)
          this.words[this.length] = u, this.length++;
        else if (h !== this)
          for (;c < h.length; c++)
            this.words[c] = h.words[c];
        return this;
      }, f.prototype.add = function(i) {
        var a;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a = this.sub(i), i.negative ^= 1, a) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a = i.sub(this), this.negative = 1, a) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a = this.iadd(i);
          return i.negative = 1, a._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h = this.cmp(i);
        if (h === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s, u;
        h > 0 ? (s = this, u = i) : (s = i, u = this);
        for (var c = 0, b = 0;b < u.length; b++)
          a = (s.words[b] | 0) - (u.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        for (;c !== 0 && b < s.length; b++)
          a = (s.words[b] | 0) + c, c = a >> 26, this.words[b] = a & 67108863;
        if (c === 0 && b < s.length && s !== this)
          for (;b < s.length; b++)
            this.words[b] = s.words[b];
        return this.length = Math.max(this.length, b), s !== this && (this.negative = 1), this.strip();
      }, f.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v, i, a) {
        a.negative = i.negative ^ v.negative;
        var h = v.length + i.length | 0;
        a.length = h, h = h - 1 | 0;
        var s = v.words[0] | 0, u = i.words[0] | 0, c = s * u, b = c & 67108863, l = c / 67108864 | 0;
        a.words[0] = b;
        for (var n = 1;n < h; n++) {
          for (var d = l >>> 26, w = l & 67108863, g = Math.min(n, i.length - 1), _ = Math.max(0, n - v.length + 1);_ <= g; _++) {
            var A = n - _ | 0;
            s = v.words[A] | 0, u = i.words[_] | 0, c = s * u + w, d += c / 67108864 | 0, w = c & 67108863;
          }
          a.words[n] = w | 0, l = d | 0;
        }
        return l !== 0 ? a.words[n] = l | 0 : a.length--, a.strip();
      }
      var L = function(i, a, h) {
        var s = i.words, u = a.words, c = h.words, b = 0, l, n, d, w = s[0] | 0, g = w & 8191, _ = w >>> 13, A = s[1] | 0, R = A & 8191, I = A >>> 13, Me = s[2] | 0, k = Me & 8191, D = Me >>> 13, nt2 = s[3] | 0, C = nt2 & 8191, O = nt2 >>> 13, vt = s[4] | 0, F4 = vt & 8191, U = vt >>> 13, bt2 = s[5] | 0, z = bt2 & 8191, H2 = bt2 >>> 13, mt2 = s[6] | 0, W = mt2 & 8191, K = mt2 >>> 13, gt2 = s[7] | 0, j = gt2 & 8191, Z = gt2 >>> 13, yt2 = s[8] | 0, V3 = yt2 & 8191, $ = yt2 >>> 13, wt = s[9] | 0, G = wt & 8191, Y2 = wt >>> 13, Mt = u[0] | 0, X = Mt & 8191, J = Mt >>> 13, _t = u[1] | 0, Q = _t & 8191, ee = _t >>> 13, xt = u[2] | 0, te = xt & 8191, re2 = xt >>> 13, St = u[3] | 0, ie = St & 8191, ne = St >>> 13, Et = u[4] | 0, fe = Et & 8191, ae = Et >>> 13, At2 = u[5] | 0, oe = At2 & 8191, se = At2 >>> 13, Rt = u[6] | 0, he = Rt & 8191, ue = Rt >>> 13, Bt = u[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt = u[8] | 0, ce2 = qt & 8191, pe = qt >>> 13, It = u[9] | 0, ve = It & 8191, be = It >>> 13;
        h.negative = i.negative ^ a.negative, h.length = 19, l = Math.imul(g, X), n = Math.imul(g, J), n = n + Math.imul(_, X) | 0, d = Math.imul(_, J);
        var ft = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l = Math.imul(R, X), n = Math.imul(R, J), n = n + Math.imul(I, X) | 0, d = Math.imul(I, J), l = l + Math.imul(g, Q) | 0, n = n + Math.imul(g, ee) | 0, n = n + Math.imul(_, Q) | 0, d = d + Math.imul(_, ee) | 0;
        var Be = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l = Math.imul(k, X), n = Math.imul(k, J), n = n + Math.imul(D, X) | 0, d = Math.imul(D, J), l = l + Math.imul(R, Q) | 0, n = n + Math.imul(R, ee) | 0, n = n + Math.imul(I, Q) | 0, d = d + Math.imul(I, ee) | 0, l = l + Math.imul(g, te) | 0, n = n + Math.imul(g, re2) | 0, n = n + Math.imul(_, te) | 0, d = d + Math.imul(_, re2) | 0;
        var qe2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l = Math.imul(C, X), n = Math.imul(C, J), n = n + Math.imul(O, X) | 0, d = Math.imul(O, J), l = l + Math.imul(k, Q) | 0, n = n + Math.imul(k, ee) | 0, n = n + Math.imul(D, Q) | 0, d = d + Math.imul(D, ee) | 0, l = l + Math.imul(R, te) | 0, n = n + Math.imul(R, re2) | 0, n = n + Math.imul(I, te) | 0, d = d + Math.imul(I, re2) | 0, l = l + Math.imul(g, ie) | 0, n = n + Math.imul(g, ne) | 0, n = n + Math.imul(_, ie) | 0, d = d + Math.imul(_, ne) | 0;
        var ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l = Math.imul(F4, X), n = Math.imul(F4, J), n = n + Math.imul(U, X) | 0, d = Math.imul(U, J), l = l + Math.imul(C, Q) | 0, n = n + Math.imul(C, ee) | 0, n = n + Math.imul(O, Q) | 0, d = d + Math.imul(O, ee) | 0, l = l + Math.imul(k, te) | 0, n = n + Math.imul(k, re2) | 0, n = n + Math.imul(D, te) | 0, d = d + Math.imul(D, re2) | 0, l = l + Math.imul(R, ie) | 0, n = n + Math.imul(R, ne) | 0, n = n + Math.imul(I, ie) | 0, d = d + Math.imul(I, ne) | 0, l = l + Math.imul(g, fe) | 0, n = n + Math.imul(g, ae) | 0, n = n + Math.imul(_, fe) | 0, d = d + Math.imul(_, ae) | 0;
        var He = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (He >>> 26) | 0, He &= 67108863, l = Math.imul(z, X), n = Math.imul(z, J), n = n + Math.imul(H2, X) | 0, d = Math.imul(H2, J), l = l + Math.imul(F4, Q) | 0, n = n + Math.imul(F4, ee) | 0, n = n + Math.imul(U, Q) | 0, d = d + Math.imul(U, ee) | 0, l = l + Math.imul(C, te) | 0, n = n + Math.imul(C, re2) | 0, n = n + Math.imul(O, te) | 0, d = d + Math.imul(O, re2) | 0, l = l + Math.imul(k, ie) | 0, n = n + Math.imul(k, ne) | 0, n = n + Math.imul(D, ie) | 0, d = d + Math.imul(D, ne) | 0, l = l + Math.imul(R, fe) | 0, n = n + Math.imul(R, ae) | 0, n = n + Math.imul(I, fe) | 0, d = d + Math.imul(I, ae) | 0, l = l + Math.imul(g, oe) | 0, n = n + Math.imul(g, se) | 0, n = n + Math.imul(_, oe) | 0, d = d + Math.imul(_, se) | 0;
        var We = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (We >>> 26) | 0, We &= 67108863, l = Math.imul(W, X), n = Math.imul(W, J), n = n + Math.imul(K, X) | 0, d = Math.imul(K, J), l = l + Math.imul(z, Q) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H2, Q) | 0, d = d + Math.imul(H2, ee) | 0, l = l + Math.imul(F4, te) | 0, n = n + Math.imul(F4, re2) | 0, n = n + Math.imul(U, te) | 0, d = d + Math.imul(U, re2) | 0, l = l + Math.imul(C, ie) | 0, n = n + Math.imul(C, ne) | 0, n = n + Math.imul(O, ie) | 0, d = d + Math.imul(O, ne) | 0, l = l + Math.imul(k, fe) | 0, n = n + Math.imul(k, ae) | 0, n = n + Math.imul(D, fe) | 0, d = d + Math.imul(D, ae) | 0, l = l + Math.imul(R, oe) | 0, n = n + Math.imul(R, se) | 0, n = n + Math.imul(I, oe) | 0, d = d + Math.imul(I, se) | 0, l = l + Math.imul(g, he) | 0, n = n + Math.imul(g, ue) | 0, n = n + Math.imul(_, he) | 0, d = d + Math.imul(_, ue) | 0;
        var Ke = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ke >>> 26) | 0, Ke &= 67108863, l = Math.imul(j, X), n = Math.imul(j, J), n = n + Math.imul(Z, X) | 0, d = Math.imul(Z, J), l = l + Math.imul(W, Q) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K, Q) | 0, d = d + Math.imul(K, ee) | 0, l = l + Math.imul(z, te) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H2, te) | 0, d = d + Math.imul(H2, re2) | 0, l = l + Math.imul(F4, ie) | 0, n = n + Math.imul(F4, ne) | 0, n = n + Math.imul(U, ie) | 0, d = d + Math.imul(U, ne) | 0, l = l + Math.imul(C, fe) | 0, n = n + Math.imul(C, ae) | 0, n = n + Math.imul(O, fe) | 0, d = d + Math.imul(O, ae) | 0, l = l + Math.imul(k, oe) | 0, n = n + Math.imul(k, se) | 0, n = n + Math.imul(D, oe) | 0, d = d + Math.imul(D, se) | 0, l = l + Math.imul(R, he) | 0, n = n + Math.imul(R, ue) | 0, n = n + Math.imul(I, he) | 0, d = d + Math.imul(I, ue) | 0, l = l + Math.imul(g, le) | 0, n = n + Math.imul(g, de) | 0, n = n + Math.imul(_, le) | 0, d = d + Math.imul(_, de) | 0;
        var je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l = Math.imul(V3, X), n = Math.imul(V3, J), n = n + Math.imul($, X) | 0, d = Math.imul($, J), l = l + Math.imul(j, Q) | 0, n = n + Math.imul(j, ee) | 0, n = n + Math.imul(Z, Q) | 0, d = d + Math.imul(Z, ee) | 0, l = l + Math.imul(W, te) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K, te) | 0, d = d + Math.imul(K, re2) | 0, l = l + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H2, ie) | 0, d = d + Math.imul(H2, ne) | 0, l = l + Math.imul(F4, fe) | 0, n = n + Math.imul(F4, ae) | 0, n = n + Math.imul(U, fe) | 0, d = d + Math.imul(U, ae) | 0, l = l + Math.imul(C, oe) | 0, n = n + Math.imul(C, se) | 0, n = n + Math.imul(O, oe) | 0, d = d + Math.imul(O, se) | 0, l = l + Math.imul(k, he) | 0, n = n + Math.imul(k, ue) | 0, n = n + Math.imul(D, he) | 0, d = d + Math.imul(D, ue) | 0, l = l + Math.imul(R, le) | 0, n = n + Math.imul(R, de) | 0, n = n + Math.imul(I, le) | 0, d = d + Math.imul(I, de) | 0, l = l + Math.imul(g, ce2) | 0, n = n + Math.imul(g, pe) | 0, n = n + Math.imul(_, ce2) | 0, d = d + Math.imul(_, pe) | 0;
        var Ze = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ze >>> 26) | 0, Ze &= 67108863, l = Math.imul(G, X), n = Math.imul(G, J), n = n + Math.imul(Y2, X) | 0, d = Math.imul(Y2, J), l = l + Math.imul(V3, Q) | 0, n = n + Math.imul(V3, ee) | 0, n = n + Math.imul($, Q) | 0, d = d + Math.imul($, ee) | 0, l = l + Math.imul(j, te) | 0, n = n + Math.imul(j, re2) | 0, n = n + Math.imul(Z, te) | 0, d = d + Math.imul(Z, re2) | 0, l = l + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K, ie) | 0, d = d + Math.imul(K, ne) | 0, l = l + Math.imul(z, fe) | 0, n = n + Math.imul(z, ae) | 0, n = n + Math.imul(H2, fe) | 0, d = d + Math.imul(H2, ae) | 0, l = l + Math.imul(F4, oe) | 0, n = n + Math.imul(F4, se) | 0, n = n + Math.imul(U, oe) | 0, d = d + Math.imul(U, se) | 0, l = l + Math.imul(C, he) | 0, n = n + Math.imul(C, ue) | 0, n = n + Math.imul(O, he) | 0, d = d + Math.imul(O, ue) | 0, l = l + Math.imul(k, le) | 0, n = n + Math.imul(k, de) | 0, n = n + Math.imul(D, le) | 0, d = d + Math.imul(D, de) | 0, l = l + Math.imul(R, ce2) | 0, n = n + Math.imul(R, pe) | 0, n = n + Math.imul(I, ce2) | 0, d = d + Math.imul(I, pe) | 0, l = l + Math.imul(g, ve) | 0, n = n + Math.imul(g, be) | 0, n = n + Math.imul(_, ve) | 0, d = d + Math.imul(_, be) | 0;
        var Ve = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l = Math.imul(G, Q), n = Math.imul(G, ee), n = n + Math.imul(Y2, Q) | 0, d = Math.imul(Y2, ee), l = l + Math.imul(V3, te) | 0, n = n + Math.imul(V3, re2) | 0, n = n + Math.imul($, te) | 0, d = d + Math.imul($, re2) | 0, l = l + Math.imul(j, ie) | 0, n = n + Math.imul(j, ne) | 0, n = n + Math.imul(Z, ie) | 0, d = d + Math.imul(Z, ne) | 0, l = l + Math.imul(W, fe) | 0, n = n + Math.imul(W, ae) | 0, n = n + Math.imul(K, fe) | 0, d = d + Math.imul(K, ae) | 0, l = l + Math.imul(z, oe) | 0, n = n + Math.imul(z, se) | 0, n = n + Math.imul(H2, oe) | 0, d = d + Math.imul(H2, se) | 0, l = l + Math.imul(F4, he) | 0, n = n + Math.imul(F4, ue) | 0, n = n + Math.imul(U, he) | 0, d = d + Math.imul(U, ue) | 0, l = l + Math.imul(C, le) | 0, n = n + Math.imul(C, de) | 0, n = n + Math.imul(O, le) | 0, d = d + Math.imul(O, de) | 0, l = l + Math.imul(k, ce2) | 0, n = n + Math.imul(k, pe) | 0, n = n + Math.imul(D, ce2) | 0, d = d + Math.imul(D, pe) | 0, l = l + Math.imul(R, ve) | 0, n = n + Math.imul(R, be) | 0, n = n + Math.imul(I, ve) | 0, d = d + Math.imul(I, be) | 0;
        var $e = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + ($e >>> 26) | 0, $e &= 67108863, l = Math.imul(G, te), n = Math.imul(G, re2), n = n + Math.imul(Y2, te) | 0, d = Math.imul(Y2, re2), l = l + Math.imul(V3, ie) | 0, n = n + Math.imul(V3, ne) | 0, n = n + Math.imul($, ie) | 0, d = d + Math.imul($, ne) | 0, l = l + Math.imul(j, fe) | 0, n = n + Math.imul(j, ae) | 0, n = n + Math.imul(Z, fe) | 0, d = d + Math.imul(Z, ae) | 0, l = l + Math.imul(W, oe) | 0, n = n + Math.imul(W, se) | 0, n = n + Math.imul(K, oe) | 0, d = d + Math.imul(K, se) | 0, l = l + Math.imul(z, he) | 0, n = n + Math.imul(z, ue) | 0, n = n + Math.imul(H2, he) | 0, d = d + Math.imul(H2, ue) | 0, l = l + Math.imul(F4, le) | 0, n = n + Math.imul(F4, de) | 0, n = n + Math.imul(U, le) | 0, d = d + Math.imul(U, de) | 0, l = l + Math.imul(C, ce2) | 0, n = n + Math.imul(C, pe) | 0, n = n + Math.imul(O, ce2) | 0, d = d + Math.imul(O, pe) | 0, l = l + Math.imul(k, ve) | 0, n = n + Math.imul(k, be) | 0, n = n + Math.imul(D, ve) | 0, d = d + Math.imul(D, be) | 0;
        var Ge = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l = Math.imul(G, ie), n = Math.imul(G, ne), n = n + Math.imul(Y2, ie) | 0, d = Math.imul(Y2, ne), l = l + Math.imul(V3, fe) | 0, n = n + Math.imul(V3, ae) | 0, n = n + Math.imul($, fe) | 0, d = d + Math.imul($, ae) | 0, l = l + Math.imul(j, oe) | 0, n = n + Math.imul(j, se) | 0, n = n + Math.imul(Z, oe) | 0, d = d + Math.imul(Z, se) | 0, l = l + Math.imul(W, he) | 0, n = n + Math.imul(W, ue) | 0, n = n + Math.imul(K, he) | 0, d = d + Math.imul(K, ue) | 0, l = l + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H2, le) | 0, d = d + Math.imul(H2, de) | 0, l = l + Math.imul(F4, ce2) | 0, n = n + Math.imul(F4, pe) | 0, n = n + Math.imul(U, ce2) | 0, d = d + Math.imul(U, pe) | 0, l = l + Math.imul(C, ve) | 0, n = n + Math.imul(C, be) | 0, n = n + Math.imul(O, ve) | 0, d = d + Math.imul(O, be) | 0;
        var Ye = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l = Math.imul(G, fe), n = Math.imul(G, ae), n = n + Math.imul(Y2, fe) | 0, d = Math.imul(Y2, ae), l = l + Math.imul(V3, oe) | 0, n = n + Math.imul(V3, se) | 0, n = n + Math.imul($, oe) | 0, d = d + Math.imul($, se) | 0, l = l + Math.imul(j, he) | 0, n = n + Math.imul(j, ue) | 0, n = n + Math.imul(Z, he) | 0, d = d + Math.imul(Z, ue) | 0, l = l + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K, le) | 0, d = d + Math.imul(K, de) | 0, l = l + Math.imul(z, ce2) | 0, n = n + Math.imul(z, pe) | 0, n = n + Math.imul(H2, ce2) | 0, d = d + Math.imul(H2, pe) | 0, l = l + Math.imul(F4, ve) | 0, n = n + Math.imul(F4, be) | 0, n = n + Math.imul(U, ve) | 0, d = d + Math.imul(U, be) | 0;
        var Xe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l = Math.imul(G, oe), n = Math.imul(G, se), n = n + Math.imul(Y2, oe) | 0, d = Math.imul(Y2, se), l = l + Math.imul(V3, he) | 0, n = n + Math.imul(V3, ue) | 0, n = n + Math.imul($, he) | 0, d = d + Math.imul($, ue) | 0, l = l + Math.imul(j, le) | 0, n = n + Math.imul(j, de) | 0, n = n + Math.imul(Z, le) | 0, d = d + Math.imul(Z, de) | 0, l = l + Math.imul(W, ce2) | 0, n = n + Math.imul(W, pe) | 0, n = n + Math.imul(K, ce2) | 0, d = d + Math.imul(K, pe) | 0, l = l + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H2, ve) | 0, d = d + Math.imul(H2, be) | 0;
        var Je = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l = Math.imul(G, he), n = Math.imul(G, ue), n = n + Math.imul(Y2, he) | 0, d = Math.imul(Y2, ue), l = l + Math.imul(V3, le) | 0, n = n + Math.imul(V3, de) | 0, n = n + Math.imul($, le) | 0, d = d + Math.imul($, de) | 0, l = l + Math.imul(j, ce2) | 0, n = n + Math.imul(j, pe) | 0, n = n + Math.imul(Z, ce2) | 0, d = d + Math.imul(Z, pe) | 0, l = l + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K, ve) | 0, d = d + Math.imul(K, be) | 0;
        var Qe = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (Qe >>> 26) | 0, Qe &= 67108863, l = Math.imul(G, le), n = Math.imul(G, de), n = n + Math.imul(Y2, le) | 0, d = Math.imul(Y2, de), l = l + Math.imul(V3, ce2) | 0, n = n + Math.imul(V3, pe) | 0, n = n + Math.imul($, ce2) | 0, d = d + Math.imul($, pe) | 0, l = l + Math.imul(j, ve) | 0, n = n + Math.imul(j, be) | 0, n = n + Math.imul(Z, ve) | 0, d = d + Math.imul(Z, be) | 0;
        var et = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, l = Math.imul(G, ce2), n = Math.imul(G, pe), n = n + Math.imul(Y2, ce2) | 0, d = Math.imul(Y2, pe), l = l + Math.imul(V3, ve) | 0, n = n + Math.imul(V3, be) | 0, n = n + Math.imul($, ve) | 0, d = d + Math.imul($, be) | 0;
        var tt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        b = (d + (n >>> 13) | 0) + (tt2 >>> 26) | 0, tt2 &= 67108863, l = Math.imul(G, ve), n = Math.imul(G, be), n = n + Math.imul(Y2, ve) | 0, d = Math.imul(Y2, be);
        var rt2 = (b + l | 0) + ((n & 8191) << 13) | 0;
        return b = (d + (n >>> 13) | 0) + (rt2 >>> 26) | 0, rt2 &= 67108863, c[0] = ft, c[1] = Be, c[2] = qe2, c[3] = ze, c[4] = He, c[5] = We, c[6] = Ke, c[7] = je, c[8] = Ze, c[9] = Ve, c[10] = $e, c[11] = Ge, c[12] = Ye, c[13] = Xe, c[14] = Je, c[15] = Qe, c[16] = et, c[17] = tt2, c[18] = rt2, b !== 0 && (c[19] = b, h.length++), h;
      };
      Math.imul || (L = q);
      function ge(v, i, a) {
        a.negative = i.negative ^ v.negative, a.length = v.length + i.length;
        for (var h = 0, s = 0, u = 0;u < a.length - 1; u++) {
          var c = s;
          s = 0;
          for (var b = h & 67108863, l = Math.min(u, i.length - 1), n = Math.max(0, u - v.length + 1);n <= l; n++) {
            var d = u - n, w = v.words[d] | 0, g = i.words[n] | 0, _ = w * g, A = _ & 67108863;
            c = c + (_ / 67108864 | 0) | 0, A = A + b | 0, b = A & 67108863, c = c + (A >>> 26) | 0, s += c >>> 26, c &= 67108863;
          }
          a.words[u] = b, h = c, c = s;
        }
        return h !== 0 ? a.words[u] = h : a.length--, a.strip();
      }
      function _e(v, i, a) {
        var h = new N4;
        return h.mulp(v, i, a);
      }
      f.prototype.mulTo = function(i, a) {
        var h, s = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h = L(this, i, a) : s < 63 ? h = q(this, i, a) : s < 1024 ? h = ge(this, i, a) : h = _e(this, i, a), h;
      };
      function N4(v, i) {
        this.x = v, this.y = i;
      }
      N4.prototype.makeRBT = function(i) {
        for (var a = new Array(i), h = f.prototype._countBits(i) - 1, s = 0;s < i; s++)
          a[s] = this.revBin(s, h, i);
        return a;
      }, N4.prototype.revBin = function(i, a, h) {
        if (i === 0 || i === h - 1)
          return i;
        for (var s = 0, u = 0;u < a; u++)
          s |= (i & 1) << a - u - 1, i >>= 1;
        return s;
      }, N4.prototype.permute = function(i, a, h, s, u, c) {
        for (var b = 0;b < c; b++)
          s[b] = a[i[b]], u[b] = h[i[b]];
      }, N4.prototype.transform = function(i, a, h, s, u, c) {
        this.permute(c, i, a, h, s, u);
        for (var b = 1;b < u; b <<= 1)
          for (var l = b << 1, n = Math.cos(2 * Math.PI / l), d = Math.sin(2 * Math.PI / l), w = 0;w < u; w += l)
            for (var g = n, _ = d, A = 0;A < b; A++) {
              var R = h[w + A], I = s[w + A], Me = h[w + A + b], k = s[w + A + b], D = g * Me - _ * k;
              k = g * k + _ * Me, Me = D, h[w + A] = R + Me, s[w + A] = I + k, h[w + A + b] = R - Me, s[w + A + b] = I - k, A !== l && (D = n * g - d * _, _ = n * _ + d * g, g = D);
            }
      }, N4.prototype.guessLen13b = function(i, a) {
        var h = Math.max(a, i) | 1, s = h & 1, u = 0;
        for (h = h / 2 | 0;h; h = h >>> 1)
          u++;
        return 1 << u + 1 + s;
      }, N4.prototype.conjugate = function(i, a, h) {
        if (!(h <= 1))
          for (var s = 0;s < h / 2; s++) {
            var u = i[s];
            i[s] = i[h - s - 1], i[h - s - 1] = u, u = a[s], a[s] = -a[h - s - 1], a[h - s - 1] = -u;
          }
      }, N4.prototype.normalize13b = function(i, a) {
        for (var h = 0, s = 0;s < a / 2; s++) {
          var u = Math.round(i[2 * s + 1] / a) * 8192 + Math.round(i[2 * s] / a) + h;
          i[s] = u & 67108863, u < 67108864 ? h = 0 : h = u / 67108864 | 0;
        }
        return i;
      }, N4.prototype.convert13b = function(i, a, h, s) {
        for (var u = 0, c = 0;c < a; c++)
          u = u + (i[c] | 0), h[2 * c] = u & 8191, u = u >>> 13, h[2 * c + 1] = u & 8191, u = u >>> 13;
        for (c = 2 * a;c < s; ++c)
          h[c] = 0;
        r(u === 0), r((u & -8192) === 0);
      }, N4.prototype.stub = function(i) {
        for (var a = new Array(i), h = 0;h < i; h++)
          a[h] = 0;
        return a;
      }, N4.prototype.mulp = function(i, a, h) {
        var s = 2 * this.guessLen13b(i.length, a.length), u = this.makeRBT(s), c = this.stub(s), b = new Array(s), l = new Array(s), n = new Array(s), d = new Array(s), w = new Array(s), g = new Array(s), _ = h.words;
        _.length = s, this.convert13b(i.words, i.length, b, s), this.convert13b(a.words, a.length, d, s), this.transform(b, c, l, n, s, u), this.transform(d, c, w, g, s, u);
        for (var A = 0;A < s; A++) {
          var R = l[A] * w[A] - n[A] * g[A];
          n[A] = l[A] * g[A] + n[A] * w[A], l[A] = R;
        }
        return this.conjugate(l, n, s), this.transform(l, n, _, c, s, u), this.conjugate(_, c, s), this.normalize13b(_, s), h.negative = i.negative ^ a.negative, h.length = i.length + a.length, h.strip();
      }, f.prototype.mul = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), this.mulTo(i, a);
      }, f.prototype.mulf = function(i) {
        var a = new f(null);
        return a.words = new Array(this.length + i.length), _e(this, i, a);
      }, f.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a = 0, h = 0;h < this.length; h++) {
          var s = (this.words[h] | 0) * i, u = (s & 67108863) + (a & 67108863);
          a >>= 26, a += s / 67108864 | 0, a += u >>> 26, this.words[h] = u & 67108863;
        }
        return a !== 0 && (this.words[h] = a, this.length++), this;
      }, f.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f.prototype.sqr = function() {
        return this.mul(this);
      }, f.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f.prototype.pow = function(i) {
        var a = B(i);
        if (a.length === 0)
          return new f(1);
        for (var h = this, s = 0;s < a.length && a[s] === 0; s++, h = h.sqr())
          ;
        if (++s < a.length)
          for (var u = h.sqr();s < a.length; s++, u = u.sqr())
            a[s] !== 0 && (h = h.mul(u));
        return h;
      }, f.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 67108863 >>> 26 - a << 26 - a, u;
        if (a !== 0) {
          var c = 0;
          for (u = 0;u < this.length; u++) {
            var b = this.words[u] & s, l = (this.words[u] | 0) - b << a;
            this.words[u] = l | c, c = b >>> 26 - a;
          }
          c && (this.words[u] = c, this.length++);
        }
        if (h !== 0) {
          for (u = this.length - 1;u >= 0; u--)
            this.words[u + h] = this.words[u];
          for (u = 0;u < h; u++)
            this.words[u] = 0;
          this.length += h;
        }
        return this.strip();
      }, f.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f.prototype.iushrn = function(i, a, h) {
        r(typeof i == "number" && i >= 0);
        var s;
        a ? s = (a - a % 26) / 26 : s = 0;
        var u = i % 26, c = Math.min((i - u) / 26, this.length), b = 67108863 ^ 67108863 >>> u << u, l = h;
        if (s -= c, s = Math.max(0, s), l) {
          for (var n = 0;n < c; n++)
            l.words[n] = this.words[n];
          l.length = c;
        }
        if (c !== 0)
          if (this.length > c)
            for (this.length -= c, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c];
          else
            this.words[0] = 0, this.length = 1;
        var d = 0;
        for (n = this.length - 1;n >= 0 && (d !== 0 || n >= s); n--) {
          var w = this.words[n] | 0;
          this.words[n] = d << 26 - u | w >>> u, d = w & b;
        }
        return l && d !== 0 && (l.words[l.length++] = d), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f.prototype.ishrn = function(i, a, h) {
        return r(this.negative === 0), this.iushrn(i, a, h);
      }, f.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return false;
        var u = this.words[h];
        return !!(u & s);
      }, f.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a = i % 26, h = (i - a) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h)
          return this;
        if (a !== 0 && h++, this.length = Math.min(h, this.length), a !== 0) {
          var s = 67108863 ^ 67108863 >>> a << a;
          this.words[this.length - 1] &= s;
        }
        return this.strip();
      }, f.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a = 0;a < this.length && this.words[a] >= 67108864; a++)
          this.words[a] -= 67108864, a === this.length - 1 ? this.words[a + 1] = 1 : this.words[a + 1]++;
        return this.length = Math.max(this.length, a + 1), this;
      }, f.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a = 0;a < this.length && this.words[a] < 0; a++)
            this.words[a] += 67108864, this.words[a + 1] -= 1;
        return this.strip();
      }, f.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f.prototype.abs = function() {
        return this.clone().iabs();
      }, f.prototype._ishlnsubmul = function(i, a, h) {
        var s = i.length + h, u;
        this._expand(s);
        var c, b = 0;
        for (u = 0;u < i.length; u++) {
          c = (this.words[u + h] | 0) + b;
          var l = (i.words[u] | 0) * a;
          c -= l & 67108863, b = (c >> 26) - (l / 67108864 | 0), this.words[u + h] = c & 67108863;
        }
        for (;u < this.length - h; u++)
          c = (this.words[u + h] | 0) + b, b = c >> 26, this.words[u + h] = c & 67108863;
        if (b === 0)
          return this.strip();
        for (r(b === -1), b = 0, u = 0;u < this.length; u++)
          c = -(this.words[u] | 0) + b, b = c >> 26, this.words[u] = c & 67108863;
        return this.negative = 1, this.strip();
      }, f.prototype._wordDiv = function(i, a) {
        var h = this.length - i.length, s = this.clone(), u = i, c = u.words[u.length - 1] | 0, b = this._countBits(c);
        h = 26 - b, h !== 0 && (u = u.ushln(h), s.iushln(h), c = u.words[u.length - 1] | 0);
        var l = s.length - u.length, n;
        if (a !== "mod") {
          n = new f(null), n.length = l + 1, n.words = new Array(n.length);
          for (var d = 0;d < n.length; d++)
            n.words[d] = 0;
        }
        var w = s.clone()._ishlnsubmul(u, 1, l);
        w.negative === 0 && (s = w, n && (n.words[l] = 1));
        for (var g = l - 1;g >= 0; g--) {
          var _ = (s.words[u.length + g] | 0) * 67108864 + (s.words[u.length + g - 1] | 0);
          for (_ = Math.min(_ / c | 0, 67108863), s._ishlnsubmul(u, _, g);s.negative !== 0; )
            _--, s.negative = 0, s._ishlnsubmul(u, 1, g), s.isZero() || (s.negative ^= 1);
          n && (n.words[g] = _);
        }
        return n && n.strip(), s.strip(), a !== "div" && h !== 0 && s.iushrn(h), { div: n || null, mod: s };
      }, f.prototype.divmod = function(i, a, h) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f(0), mod: new f(0) };
        var s, u, c;
        return this.negative !== 0 && i.negative === 0 ? (c = this.neg().divmod(i, a), a !== "mod" && (s = c.div.neg()), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.iadd(i)), { div: s, mod: u }) : this.negative === 0 && i.negative !== 0 ? (c = this.divmod(i.neg(), a), a !== "mod" && (s = c.div.neg()), { div: s, mod: c.mod }) : (this.negative & i.negative) !== 0 ? (c = this.neg().divmod(i.neg(), a), a !== "div" && (u = c.mod.neg(), h && u.negative !== 0 && u.isub(i)), { div: c.div, mod: u }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f(0), mod: this } : i.length === 1 ? a === "div" ? { div: this.divn(i.words[0]), mod: null } : a === "mod" ? { div: null, mod: new f(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f(this.modn(i.words[0])) } : this._wordDiv(i, a);
      }, f.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f.prototype.divRound = function(i) {
        var a = this.divmod(i);
        if (a.mod.isZero())
          return a.div;
        var h = a.div.negative !== 0 ? a.mod.isub(i) : a.mod, s = i.ushrn(1), u = i.andln(1), c = h.cmp(s);
        return c < 0 || u === 1 && c === 0 ? a.div : a.div.negative !== 0 ? a.div.isubn(1) : a.div.iaddn(1);
      }, f.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a = (1 << 26) % i, h = 0, s = this.length - 1;s >= 0; s--)
          h = (a * h + (this.words[s] | 0)) % i;
        return h;
      }, f.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = (this.words[h] | 0) + a * 67108864;
          this.words[h] = s / i | 0, a = s % i;
        }
        return this.strip();
      }, f.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = new f(0), b = new f(1), l = 0;a.isEven() && h.isEven(); )
          a.iushrn(1), h.iushrn(1), ++l;
        for (var n = h.clone(), d = a.clone();!a.isZero(); ) {
          for (var w = 0, g = 1;(a.words[0] & g) === 0 && w < 26; ++w, g <<= 1)
            ;
          if (w > 0)
            for (a.iushrn(w);w-- > 0; )
              (s.isOdd() || u.isOdd()) && (s.iadd(n), u.isub(d)), s.iushrn(1), u.iushrn(1);
          for (var _ = 0, A = 1;(h.words[0] & A) === 0 && _ < 26; ++_, A <<= 1)
            ;
          if (_ > 0)
            for (h.iushrn(_);_-- > 0; )
              (c.isOdd() || b.isOdd()) && (c.iadd(n), b.isub(d)), c.iushrn(1), b.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(c), u.isub(b)) : (h.isub(a), c.isub(s), b.isub(u));
        }
        return { a: c, b, gcd: h.iushln(l) };
      }, f.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a = this, h = i.clone();
        a.negative !== 0 ? a = a.umod(i) : a = a.clone();
        for (var s = new f(1), u = new f(0), c = h.clone();a.cmpn(1) > 0 && h.cmpn(1) > 0; ) {
          for (var b = 0, l = 1;(a.words[0] & l) === 0 && b < 26; ++b, l <<= 1)
            ;
          if (b > 0)
            for (a.iushrn(b);b-- > 0; )
              s.isOdd() && s.iadd(c), s.iushrn(1);
          for (var n = 0, d = 1;(h.words[0] & d) === 0 && n < 26; ++n, d <<= 1)
            ;
          if (n > 0)
            for (h.iushrn(n);n-- > 0; )
              u.isOdd() && u.iadd(c), u.iushrn(1);
          a.cmp(h) >= 0 ? (a.isub(h), s.isub(u)) : (h.isub(a), u.isub(s));
        }
        var w;
        return a.cmpn(1) === 0 ? w = s : w = u, w.cmpn(0) < 0 && w.iadd(i), w;
      }, f.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a = this.clone(), h = i.clone();
        a.negative = 0, h.negative = 0;
        for (var s = 0;a.isEven() && h.isEven(); s++)
          a.iushrn(1), h.iushrn(1);
        do {
          for (;a.isEven(); )
            a.iushrn(1);
          for (;h.isEven(); )
            h.iushrn(1);
          var u = a.cmp(h);
          if (u < 0) {
            var c = a;
            a = h, h = c;
          } else if (u === 0 || h.cmpn(1) === 0)
            break;
          a.isub(h);
        } while (true);
        return h.iushln(s);
      }, f.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a = i % 26, h = (i - a) / 26, s = 1 << a;
        if (this.length <= h)
          return this._expand(h + 1), this.words[h] |= s, this;
        for (var u = s, c = h;u !== 0 && c < this.length; c++) {
          var b = this.words[c] | 0;
          b += u, u = b >>> 26, b &= 67108863, this.words[c] = b;
        }
        return u !== 0 && (this.words[c] = u, this.length++), this;
      }, f.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f.prototype.cmpn = function(i) {
        var a = i < 0;
        if (this.negative !== 0 && !a)
          return -1;
        if (this.negative === 0 && a)
          return 1;
        this.strip();
        var h;
        if (this.length > 1)
          h = 1;
        else {
          a && (i = -i), r(i <= 67108863, "Number is too big");
          var s = this.words[0] | 0;
          h = s === i ? 0 : s < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h | 0 : h;
      }, f.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a = this.ucmp(i);
        return this.negative !== 0 ? -a | 0 : a;
      }, f.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a = 0, h = this.length - 1;h >= 0; h--) {
          var s = this.words[h] | 0, u = i.words[h] | 0;
          if (s !== u) {
            s < u ? a = -1 : s > u && (a = 1);
            break;
          }
        }
        return a;
      }, f.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f.red = function(i) {
        return new P(i);
      }, f.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v, i) {
        this.name = v, this.p = new f(i, 16), this.n = this.p.bitLength(), this.k = new f(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a = i, h;
        do
          this.split(a, this.tmp), a = this.imulK(a), a = a.iadd(this.tmp), h = a.bitLength();
        while (h > this.n);
        var s = h < this.n ? -1 : a.ucmp(this.p);
        return s === 0 ? (a.words[0] = 0, a.length = 1) : s > 0 ? a.isub(this.p) : a.strip !== undefined ? a.strip() : a._strip(), a;
      }, ye.prototype.split = function(i, a) {
        i.iushrn(this.n, 0, a);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o(xe, ye), xe.prototype.split = function(i, a) {
        for (var h = 4194303, s = Math.min(i.length, 9), u = 0;u < s; u++)
          a.words[u] = i.words[u];
        if (a.length = s, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c = i.words[9];
        for (a.words[a.length++] = c & h, u = 10;u < i.length; u++) {
          var b = i.words[u] | 0;
          i.words[u - 10] = (b & h) << 4 | c >>> 22, c = b;
        }
        c >>>= 22, i.words[u - 10] = c, c === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = i.words[h] | 0;
          a += s * 977, i.words[h] = a & 67108863, a = s * 64 + (a / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a = 0, h = 0;h < i.length; h++) {
          var s = (i.words[h] | 0) * 19 + a, u = s & 67108863;
          s >>>= 26, i.words[h] = u, a = s;
        }
        return a !== 0 && (i.words[i.length++] = a), i;
      }, f._prime = function(i) {
        if (we[i])
          return we[i];
        var a;
        if (i === "k256")
          a = new xe;
        else if (i === "p224")
          a = new Re;
        else if (i === "p192")
          a = new Ee;
        else if (i === "p25519")
          a = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a, a;
      };
      function P(v) {
        if (typeof v == "string") {
          var i = f._prime(v);
          this.m = i.p, this.prime = i;
        } else
          r(v.gtn(1), "modulus must be greater than 1"), this.m = v, this.prime = null;
      }
      P.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P.prototype._verify2 = function(i, a) {
        r((i.negative | a.negative) === 0, "red works only with positives"), r(i.red && i.red === a.red, "red works only with red numbers");
      }, P.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P.prototype.add = function(i, a) {
        this._verify2(i, a);
        var h = i.add(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h._forceRed(this);
      }, P.prototype.iadd = function(i, a) {
        this._verify2(i, a);
        var h = i.iadd(a);
        return h.cmp(this.m) >= 0 && h.isub(this.m), h;
      }, P.prototype.sub = function(i, a) {
        this._verify2(i, a);
        var h = i.sub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h._forceRed(this);
      }, P.prototype.isub = function(i, a) {
        this._verify2(i, a);
        var h = i.isub(a);
        return h.cmpn(0) < 0 && h.iadd(this.m), h;
      }, P.prototype.shl = function(i, a) {
        return this._verify1(i), this.imod(i.ushln(a));
      }, P.prototype.imul = function(i, a) {
        return this._verify2(i, a), this.imod(i.imul(a));
      }, P.prototype.mul = function(i, a) {
        return this._verify2(i, a), this.imod(i.mul(a));
      }, P.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a = this.m.andln(3);
        if (r(a % 2 === 1), a === 3) {
          var h = this.m.add(new f(1)).iushrn(2);
          return this.pow(i, h);
        }
        for (var s = this.m.subn(1), u = 0;!s.isZero() && s.andln(1) === 0; )
          u++, s.iushrn(1);
        r(!s.isZero());
        var c = new f(1).toRed(this), b = c.redNeg(), l = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f(2 * n * n).toRed(this);this.pow(n, l).cmp(b) !== 0; )
          n.redIAdd(b);
        for (var d = this.pow(n, s), w = this.pow(i, s.addn(1).iushrn(1)), g = this.pow(i, s), _ = u;g.cmp(c) !== 0; ) {
          for (var A = g, R = 0;A.cmp(c) !== 0; R++)
            A = A.redSqr();
          r(R < _);
          var I = this.pow(d, new f(1).iushln(_ - R - 1));
          w = w.redMul(I), d = I.redSqr(), g = g.redMul(d), _ = R;
        }
        return w;
      }, P.prototype.invm = function(i) {
        var a = i._invmp(this.m);
        return a.negative !== 0 ? (a.negative = 0, this.imod(a).redNeg()) : this.imod(a);
      }, P.prototype.pow = function(i, a) {
        if (a.isZero())
          return new f(1).toRed(this);
        if (a.cmpn(1) === 0)
          return i.clone();
        var h = 4, s = new Array(1 << h);
        s[0] = new f(1).toRed(this), s[1] = i;
        for (var u = 2;u < s.length; u++)
          s[u] = this.mul(s[u - 1], i);
        var c = s[0], b = 0, l = 0, n = a.bitLength() % 26;
        for (n === 0 && (n = 26), u = a.length - 1;u >= 0; u--) {
          for (var d = a.words[u], w = n - 1;w >= 0; w--) {
            var g = d >> w & 1;
            if (c !== s[0] && (c = this.sqr(c)), g === 0 && b === 0) {
              l = 0;
              continue;
            }
            b <<= 1, b |= g, l++, !(l !== h && (u !== 0 || w !== 0)) && (c = this.mul(c, s[b]), l = 0, b = 0);
          }
          n = 26;
        }
        return c;
      }, P.prototype.convertTo = function(i) {
        var a = i.umod(this.m);
        return a === i ? a.clone() : a;
      }, P.prototype.convertFrom = function(i) {
        var a = i.clone();
        return a.red = null, a;
      }, f.mont = function(i) {
        return new Se2(i);
      };
      function Se2(v) {
        P.call(this, v), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o(Se2, P), Se2.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se2.prototype.convertFrom = function(i) {
        var a = this.imod(i.mul(this.rinv));
        return a.red = null, a;
      }, Se2.prototype.imul = function(i, a) {
        if (i.isZero() || a.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h = i.imul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.mul = function(i, a) {
        if (i.isZero() || a.isZero())
          return new f(0)._forceRed(this);
        var h = i.mul(a), s = h.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = h.isub(s).iushrn(this.shift), c = u;
        return u.cmp(this.m) >= 0 ? c = u.isub(this.m) : u.cmpn(0) < 0 && (c = u.iadd(this.m)), c._forceRed(this);
      }, Se2.prototype.invm = function(i) {
        var a = this.imod(i._invmp(this.m).mul(this.r2));
        return a._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e) {
      return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j3 = T((SL, K3) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks(), Kr2 = Te().Buffer;
    K3.exports = function(e, r, o) {
      var f;
      e.padding ? f = e.padding : o ? f = 1 : f = 4;
      var p2 = _q(e), m;
      if (f === 4)
        m = Aq(p2, r);
      else if (f === 1)
        m = Rq(p2, r, o);
      else if (f === 3) {
        if (m = new Rd(r), m.cmp(p2.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o ? Eq(m, p2) : Sq(m, p2);
    };
    function Aq(t, e) {
      var r = t.modulus.byteLength(), o = e.length, f = xq("sha1").update(Kr2.alloc(0)).digest(), p2 = f.length, m = 2 * p2;
      if (o > r - m - 2)
        throw new Error("message too long");
      var y = Kr2.alloc(r - o - m - 2), M = r - p2 - 1, x = Ad(p2), S = W3(Kr2.concat([f, y, Kr2.alloc(1, 1), e], M), H3(x, M)), E2 = W3(x, H3(S, p2));
      return new Rd(Kr2.concat([Kr2.alloc(1), E2, S], r));
    }
    function Rq(t, e, r) {
      var o = e.length, f = t.modulus.byteLength();
      if (o > f - 11)
        throw new Error("message too long");
      var p2;
      return r ? p2 = Kr2.alloc(f - o - 3, 255) : p2 = Bq(f - o - 3), new Rd(Kr2.concat([Kr2.from([0, r ? 1 : 2]), p2, Kr2.alloc(1), e], f));
    }
    function Bq(t) {
      for (var e = Kr2.allocUnsafe(t), r = 0, o = Ad(t * 2), f = 0, p2;r < t; )
        f === o.length && (o = Ad(t * 2), f = 0), p2 = o[f++], p2 && (e[r++] = p2);
      return e;
    }
  });
  Y3 = T((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V3 = xd(), $3 = w0(), Iq = Ks(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e, r, o) {
      var f;
      e.padding ? f = e.padding : o ? f = 1 : f = 4;
      var p2 = qq(e), m = p2.modulus.byteLength();
      if (r.length > m || new $3(r).cmp(p2.modulus) >= 0)
        throw new Error("decryption error");
      var y;
      o ? y = kq(new $3(r), p2) : y = Iq(r, p2);
      var M = Za.alloc(m - y.length);
      if (y = Za.concat([M, y], m), f === 4)
        return Lq(p2, y);
      if (f === 1)
        return Nq(p2, y, o);
      if (f === 3)
        return y;
      throw new Error("unknown padding");
    };
    function Lq(t, e) {
      var r = t.modulus.byteLength(), o = Tq("sha1").update(Za.alloc(0)).digest(), f = o.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p2 = e.slice(1, f + 1), m = e.slice(f + 1), y = V3(p2, Z3(m, f)), M = V3(m, Z3(y, r - f - 1));
      if (Dq(o, M.slice(0, f)))
        throw new Error("decryption error");
      for (var x = f;M[x] === 0; )
        x++;
      if (M[x++] !== 1)
        throw new Error("decryption error");
      return M.slice(x);
    }
    function Nq(t, e, r) {
      for (var o = e.slice(0, 2), f = 2, p2 = 0;e[f++] !== 0; )
        if (f >= e.length) {
          p2++;
          break;
        }
      var m = e.slice(2, f - 1);
      if ((o.toString("hex") !== "0002" && !r || o.toString("hex") !== "0001" && r) && p2++, m.length < 8 && p2++, p2)
        throw new Error("decryption error");
      return e.slice(f);
    }
    function Dq(t, e) {
      t = Za.from(t), e = Za.from(e);
      var r = 0, o = t.length;
      t.length !== e.length && (r++, o = Math.min(t.length, e.length));
      for (var f = -1;++f < o; )
        r += t[f] ^ e[f];
      return r;
    }
  });
  X3 = T((Vn) => {
    Vn.publicEncrypt = j3();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e, r) {
      return Vn.publicEncrypt(e, r, true);
    };
    Vn.publicDecrypt = function(e, r) {
      return Vn.privateDecrypt(e, r, true);
    };
  });
  ow = T((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q3 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e)
        throw new RangeError("offset out of range");
    }
    function fw(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e, r, o) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o = r, r = t.length - e;
      else if (typeof o != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o);
    }
    function aw(t, e, r, o) {
      if (true) {
        var f = t.buffer, p2 = new Uint8Array(f, e, r);
        if (Bd.getRandomValues(p2), o) {
          process.nextTick(function() {
            o(null, t);
          });
          return;
        }
        return t;
      }
      if (o) {
        Q3(r, function(y, M) {
          if (y)
            return o(y);
          M.copy(t, e), o(null, t);
        });
        return;
      }
      var m = Q3(r);
      return m.copy(t, e), t;
    }
    function Cq(t, e, r) {
      if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
    }
  });
  qd = T((ke) => {
    ke.randomBytes = ke.rng = ke.pseudoRandomBytes = ke.prng = on();
    ke.createHash = ke.Hash = bf();
    ke.createHmac = ke.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke.pbkdf2 = sw.pbkdf2;
    ke.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke.Cipher = ui.Cipher;
    ke.createCipher = ui.createCipher;
    ke.Cipheriv = ui.Cipheriv;
    ke.createCipheriv = ui.createCipheriv;
    ke.Decipher = ui.Decipher;
    ke.createDecipher = ui.createDecipher;
    ke.Decipheriv = ui.Decipheriv;
    ke.createDecipheriv = ui.createDecipheriv;
    ke.getCiphers = ui.getCiphers;
    ke.listCiphers = ui.listCiphers;
    var $a = hg();
    ke.DiffieHellmanGroup = $a.DiffieHellmanGroup;
    ke.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
    ke.getDiffieHellman = $a.getDiffieHellman;
    ke.createDiffieHellman = $a.createDiffieHellman;
    ke.DiffieHellman = $a.DiffieHellman;
    var M0 = k3();
    ke.createSign = M0.createSign;
    ke.Sign = M0.Sign;
    ke.createVerify = M0.createVerify;
    ke.Verify = M0.Verify;
    ke.createECDH = P3();
    var _0 = X3();
    ke.publicEncrypt = _0.publicEncrypt;
    ke.privateEncrypt = _0.privateEncrypt;
    ke.publicDecrypt = _0.publicDecrypt;
    ke.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke.randomFill = hw.randomFill;
    ke.randomFillSync = hw.randomFillSync;
    ke.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt = {};
  Ja(Xt, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot(Xt, rn(qd()));
  zq = rn(qd());
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o } = e;
    if (typeof r != "number" || typeof o != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Id = "scryptSync" in crypto ? (t, e, r, o) => {
    let f = crypto.scryptSync(t, e, r, o);
    return Ga !== "buffer" ? new Buffer(f).toString(Ga) : new Buffer(f);
  } : undefined;
  Td = "scryptSync" in crypto ? function(t, e, r, o, f) {
    if (typeof o == "function" && (f = o, o = undefined), typeof f != "function") {
      var p2 = new TypeError("callback must be a function");
      throw p2.code = "ERR_INVALID_CALLBACK", p2;
    }
    try {
      let m = crypto.scryptSync(t, e, r, o);
      process.nextTick(f, null, Ga !== "buffer" ? new Buffer(m).toString(Ga) : new Buffer(m));
    } catch (m) {
      throw m;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS((exports, module) => {
  (function(global2, pool2, math) {
    var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten2(options.entropy ? [seed, tostring(pool2)] : seed == null ? autoseed() : seed, 3), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool2);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
        if (state) {
          if (state.S) {
            copy(state, arc4);
          }
          prng2.state = function() {
            return copy(arc4, {});
          };
        }
        if (is_math_call) {
          math[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0;i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      }
      (me.g = function(count) {
        var t3, r = 0, i3 = me.i, j2 = me.j, s3 = me.S;
        while (count--) {
          t3 = s3[i3 = mask & i3 + 1];
          r = r * width + s3[mask & (s3[i3] = s3[j2 = mask & j2 + t3]) + (s3[j2] = t3)];
        }
        me.i = i3;
        me.j = j2;
        return r;
      })(width);
    }
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten2(obj, depth) {
      var result = [], typ = typeof obj, prop;
      if (depth && typ == "object") {
        for (prop in obj) {
          try {
            result.push(flatten2(obj[prop], depth - 1));
          } catch (e) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global2.navigator, plugins = browser && browser.plugins;
        return [+new Date, global2, plugins, global2.screen, tostring(pool2)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math.random(), pool2);
    if (typeof module == "object" && exports) {
      module.exports = seedrandom;
      try {
        nodecrypto = (init_crypto(), __toCommonJS(exports_crypto));
      } catch (ex) {
      }
    } else if (typeof define == "function" && define.amd) {
      define(function() {
        return seedrandom;
      });
    } else {
      math["seed" + rngname] = seedrandom;
    }
  })(typeof self !== "undefined" ? self : exports, [], Math);
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS((exports, module) => {
  var alea = require_alea();
  var xor128 = require_xor128();
  var xorwow = require_xorwow();
  var xorshift7 = require_xorshift7();
  var xor4096 = require_xor4096();
  var tychei = require_tychei();
  var sr = require_seedrandom();
  sr.alea = alea;
  sr.xor128 = xor128;
  sr.xorwow = xorwow;
  sr.xorshift7 = xorshift7;
  sr.xor4096 = xor4096;
  sr.tychei = tychei;
  module.exports = sr;
});

// node_modules/@tensorflow/tfjs-core/dist/test_util.js
var exports_test_util = {};
__export(exports_test_util, {
  testEpsilon: () => testEpsilon,
  play: () => play,
  expectValuesInRange: () => expectValuesInRange,
  expectPromiseToFail: () => expectPromiseToFail,
  expectNumbersClose: () => expectNumbersClose,
  expectArraysEqual: () => expectArraysEqual,
  expectArraysClose: () => expectArraysClose,
  expectArrayBuffersEqual: () => expectArrayBuffersEqual,
  encodeStrings: () => encodeStrings,
  createVideoElement: () => createVideoElement,
  TEST_EPSILON_FLOAT16: () => TEST_EPSILON_FLOAT16
});
function expectArraysClose(actual, expected, epsilon) {
  if (epsilon == null) {
    epsilon = testEpsilon();
  }
  return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon));
}
function testEpsilon() {
  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;
}
function expectArraysPredicate(actual, expected, predicate) {
  let checkClassType = true;
  if (isTypedArray(actual) || isTypedArray(expected)) {
    checkClassType = false;
  }
  if (isTypedArray(actual) && isTypedArray(expected)) {
    checkClassType = true;
  }
  if (checkClassType) {
    const aType = actual.constructor.name;
    const bType = expected.constructor.name;
    if (aType !== bType) {
      throw new Error(`Arrays are of different type. Actual: ${aType}. ` + `Expected: ${bType}`);
    }
  }
  if (Array.isArray(actual) && Array.isArray(expected)) {
    const actualShape = inferShape(actual);
    const expectedShape = inferShape(expected);
    if (!arraysEqual(actualShape, expectedShape)) {
      throw new Error(`Arrays have different shapes. ` + `Actual: [${actualShape}]. Expected: [${expectedShape}]`);
    }
  }
  const actualFlat = isTypedArray(actual) ? actual : flatten(actual);
  const expectedFlat = isTypedArray(expected) ? expected : flatten(expected);
  if (actualFlat.length !== expectedFlat.length) {
    throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs ` + `expected: ${expectedFlat.length}.\n` + `Actual:   ${actualFlat}.\n` + `Expected: ${expectedFlat}.`);
  }
  for (let i = 0;i < expectedFlat.length; ++i) {
    const a = actualFlat[i];
    const e = expectedFlat[i];
    if (!predicate(a, e)) {
      throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\n` + `Actual:   ${actualFlat}.\n` + `Expected: ${expectedFlat}.`);
    }
  }
  if (typeof expect !== "undefined") {
    expect().nothing();
  }
}
function expectPromiseToFail(fn, done) {
  fn().then(() => done.fail(), () => done());
  if (typeof expect !== "undefined") {
    expect().nothing();
  }
}
function expectArraysEqual(actual, expected) {
  const exp4 = typeof expected === "string" || typeof expected === "number" || typeof expected === "boolean" ? [expected] : expected;
  if (isString(actual) || isString(actual[0]) || isString(expected) || isString(expected[0])) {
    return expectArraysPredicate(actual, exp4, (a, b) => a == b);
  }
  return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));
}
function expectNumbersClose(a, e, epsilon) {
  if (epsilon == null) {
    epsilon = testEpsilon();
  }
  if (!areClose(a, e, epsilon)) {
    throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);
  }
  if (typeof expect !== "undefined") {
    expect().nothing();
  }
}
function areClose(a, e, epsilon) {
  if (!isFinite(a) && !isFinite(e)) {
    return true;
  }
  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
    return false;
  }
  return true;
}
function expectValuesInRange(actual, low, high) {
  for (let i = 0;i < actual.length; i++) {
    if (actual[i] < low || actual[i] > high) {
      throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);
    }
  }
}
function expectArrayBuffersEqual(actual, expected) {
  const actualArray = new Float32Array(actual);
  const expectedArray = new Float32Array(expected);
  if (actualArray.length !== expectedArray.length) {
    throw new Error("Expected ArrayBuffer to be of length " + `${expectedArray.length}, but it was ${actualArray.length}`);
  }
  for (let i = 0;i < expectedArray.length; i++) {
    if (actualArray[i] !== expectedArray[i]) {
      throw new Error(`Expected ArrayBuffer value at ${i} to be ` + `${expectedArray[i]} but got ${actualArray[i]} instead`);
    }
  }
}
function encodeStrings(a) {
  for (let i = 0;i < a.length; i++) {
    const val = a[i];
    if (Array.isArray(val)) {
      encodeStrings(val);
    } else {
      a[i] = encodeString(val);
    }
  }
  return a;
}
function createVideoElement(source) {
  const video = document.createElement("video");
  if ("playsInline" in video) {
    video.playsInline = true;
  }
  video.muted = true;
  video.loop = true;
  video.style.position = "fixed";
  video.style.left = "0px";
  video.style.top = "0px";
  video.preload = "auto";
  video.appendChild(source);
  return new Promise((resolve) => {
    video.addEventListener("loadeddata", (_) => resolve(video));
    video.load();
  });
}
async function play(video) {
  await video.play();
  if ("requestVideoFrameCallback" in video) {
    await new Promise((resolve) => {
      video.requestVideoFrameCallback(resolve);
    });
  }
}
var TEST_EPSILON_FLOAT32 = 0.001, TEST_EPSILON_FLOAT16 = 0.1;
var init_test_util = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/rand_util.js
class MPRandGauss {
  constructor(mean3, stdDeviation, dtype, truncated, seed) {
    this.mean = mean3;
    this.stdDev = stdDeviation;
    this.dtype = dtype;
    this.nextVal = NaN;
    this.truncated = truncated;
    if (this.truncated) {
      this.upper = this.mean + this.stdDev * 2;
      this.lower = this.mean - this.stdDev * 2;
    }
    const seedValue = seed ? seed : Math.random();
    this.random = seedrandom.alea(seedValue.toString());
  }
  nextValue() {
    if (!isNaN(this.nextVal)) {
      const value = this.nextVal;
      this.nextVal = NaN;
      return value;
    }
    let resultX, resultY;
    let isValid = false;
    while (!isValid) {
      let v1, v2, s;
      do {
        v1 = 2 * this.random() - 1;
        v2 = 2 * this.random() - 1;
        s = v1 * v1 + v2 * v2;
      } while (s >= 1 || s === 0);
      const mul5 = Math.sqrt(-2 * Math.log(s) / s);
      resultX = this.mean + this.stdDev * v1 * mul5;
      resultY = this.mean + this.stdDev * v2 * mul5;
      if (!this.truncated || this.isValidTruncated(resultX)) {
        isValid = true;
      }
    }
    if (!this.truncated || this.isValidTruncated(resultY)) {
      this.nextVal = this.convertValue(resultY);
    }
    return this.convertValue(resultX);
  }
  convertValue(value) {
    if (this.dtype == null || this.dtype === "float32") {
      return value;
    }
    return Math.round(value);
  }
  isValidTruncated(value) {
    return value <= this.upper && value >= this.lower;
  }
}

class RandGamma {
  constructor(alpha, beta, dtype, seed) {
    this.alpha = alpha;
    this.beta = 1 / beta;
    this.dtype = dtype;
    const seedValue = seed ? seed : Math.random();
    this.randu = seedrandom.alea(seedValue.toString());
    this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());
    if (alpha < 1) {
      this.d = alpha + 2 / 3;
    } else {
      this.d = alpha - 1 / 3;
    }
    this.c = 1 / Math.sqrt(9 * this.d);
  }
  nextValue() {
    let x2, v0, v1, x, u, v;
    while (true) {
      do {
        x = this.randn.nextValue();
        v = 1 + this.c * x;
      } while (v <= 0);
      v *= v * v;
      x2 = x * x;
      v0 = 1 - 0.331 * x2 * x2;
      v1 = 0.5 * x2 + this.d * (1 - v + Math.log(v));
      u = this.randu();
      if (u < v0 || Math.log(u) < v1) {
        break;
      }
    }
    v = 1 / this.beta * this.d * v;
    if (this.alpha < 1) {
      v *= Math.pow(this.randu(), 1 / this.alpha);
    }
    return this.convertValue(v);
  }
  convertValue(value) {
    if (this.dtype === "float32") {
      return value;
    }
    return Math.round(value);
  }
}

class UniformRandom {
  constructor(min3 = 0, max5 = 1, dtype, seed) {
    this.canReturnFloat = () => this.dtype == null || this.dtype === "float32";
    this.min = min3;
    this.range = max5 - min3;
    this.dtype = dtype;
    if (seed == null) {
      seed = Math.random();
    }
    if (typeof seed === "number") {
      seed = seed.toString();
    }
    if (!this.canReturnFloat() && this.range <= 1) {
      throw new Error(`The difference between ${min3} - ${max5} <= 1 and dtype is not float`);
    }
    this.random = seedrandom.alea(seed);
  }
  convertValue(value) {
    if (this.canReturnFloat()) {
      return value;
    }
    return Math.round(value);
  }
  nextValue() {
    return this.convertValue(this.min + this.range * this.random());
  }
}
var seedrandom;
var init_rand_util = __esm(() => {
  seedrandom = __toESM(require_seedrandom2(), 1);
  init_test_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/random_gamma.js
function randomGamma_(shape, alpha, beta = 1, dtype = "float32", seed) {
  assertNonNegativeIntegerDimensions(shape);
  if (beta == null) {
    beta = 1;
  }
  if (dtype == null) {
    dtype = "float32";
  }
  if (dtype !== "float32" && dtype !== "int32") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  const rgamma = new RandGamma(alpha, beta, dtype, seed);
  const res = buffer(shape, dtype);
  for (let i = 0;i < res.values.length; i++) {
    res.values[i] = rgamma.nextValue();
  }
  return res.toTensor();
}
var randomGamma;
var init_random_gamma = __esm(() => {
  init_buffer();
  init_operation();
  init_rand_util();
  randomGamma = op({ randomGamma_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/random_normal.js
function randomNormal_(shape, mean3 = 0, stdDev = 1, dtype, seed) {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  const randGauss = new MPRandGauss(mean3, stdDev, dtype, false, seed);
  const res = buffer(shape, dtype);
  for (let i = 0;i < res.values.length; i++) {
    res.values[i] = randGauss.nextValue();
  }
  return res.toTensor();
}
var randomNormal;
var init_random_normal = __esm(() => {
  init_buffer();
  init_operation();
  init_rand_util();
  randomNormal = op({ randomNormal_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/random_standard_normal.js
function randomStandardNormal_(shape, dtype, seed) {
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type ${dtype}`);
  }
  return randomNormal(shape, 0, 1, dtype, seed);
}
var randomStandardNormal;
var init_random_standard_normal = __esm(() => {
  init_operation();
  init_random_normal();
  randomStandardNormal = op({ randomStandardNormal_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/random_uniform.js
function randomUniform_(shape, minval = 0, maxval = 1, dtype = "float32", seed) {
  assertNonNegativeIntegerDimensions(shape);
  const res = buffer(shape, dtype);
  const random = new UniformRandom(minval, maxval, null, seed);
  for (let i = 0;i < res.values.length; i++) {
    res.values[i] = random.nextValue();
  }
  return res.toTensor();
}
var randomUniform;
var init_random_uniform = __esm(() => {
  init_buffer();
  init_operation();
  init_rand_util();
  randomUniform = op({ randomUniform_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/random_uniform_int.js
function randomUniformInt_(shape, minval, maxval, seed) {
  return randomUniform(shape, minval, maxval, "int32", seed);
}
var randomUniformInt;
var init_random_uniform_int = __esm(() => {
  init_operation();
  init_random_uniform();
  randomUniformInt = op({ randomUniformInt_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/range.js
function range(start, stop, step = 1, dtype = "float32") {
  if (step === 0) {
    throw new Error("Cannot have a step of zero");
  }
  const attrs = { start, stop, step, dtype };
  return ENGINE.runKernel(Range, {}, attrs);
}
var init_range = __esm(() => {
  init_engine();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/real.js
function real_(input) {
  const $input = convertToTensor(input, "input", "real");
  const inputs = { input: $input };
  return ENGINE.runKernel(Real, inputs);
}
var real;
var init_real = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  real = op({ real_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reciprocal.js
function reciprocal_(x) {
  const $x = convertToTensor(x, "x", "reciprocal");
  const inputs = { x: $x };
  return ENGINE.runKernel(Reciprocal, inputs);
}
var reciprocal;
var init_reciprocal = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  reciprocal = op({ reciprocal_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/relu.js
function relu_(x) {
  const $x = convertToTensor(x, "x", "relu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Relu, inputs);
}
var relu;
var init_relu = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  relu = op({ relu_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/relu6.js
function relu6_(x) {
  const $x = convertToTensor(x, "x", "relu6");
  const inputs = { x: $x };
  return ENGINE.runKernel(Relu6, inputs);
}
var relu6;
var init_relu6 = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  relu6 = op({ relu6_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reverse.js
function reverse_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  const inputs = { x: $x };
  const attrs = { dims: axis };
  return ENGINE.runKernel(Reverse, inputs, attrs);
}
var reverse;
var init_reverse = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  reverse = op({ reverse_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reverse_1d.js
function reverse1d_(x) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);
  return reverse($x, 0);
}
var reverse1d;
var init_reverse_1d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reverse();
  reverse1d = op({ reverse1d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reverse_2d.js
function reverse2d_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
var reverse2d;
var init_reverse_2d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reverse();
  reverse2d = op({ reverse2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reverse_3d.js
function reverse3d_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
var reverse3d;
var init_reverse_3d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reverse();
  reverse3d = op({ reverse3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reverse_4d.js
function reverse4d_(x, axis) {
  const $x = convertToTensor(x, "x", "reverse");
  assert($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);
  return reverse($x, axis);
}
var reverse4d;
var init_reverse_4d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reverse();
  reverse4d = op({ reverse4d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/round.js
function round_(x) {
  const $x = convertToTensor(x, "x", "round");
  const inputs = { x: $x };
  return ENGINE.runKernel(Round, inputs);
}
var round2;
var init_round = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  round2 = op({ round_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/rsqrt.js
function rsqrt_(x) {
  const $x = convertToTensor(x, "x", "rsqrt", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Rsqrt, inputs);
}
var rsqrt;
var init_rsqrt = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  rsqrt = op({ rsqrt_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/selu.js
function selu_(x) {
  const $x = convertToTensor(x, "x", "selu");
  const inputs = { x: $x };
  return ENGINE.runKernel(Selu, inputs);
}
var selu;
var init_selu = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  selu = op({ selu_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/separable_conv2d.js
function separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad6, dilation = [1, 1], dataFormat = "NHWC") {
  const $x = convertToTensor(x, "x", "separableConv2d");
  const $depthwiseFilter = convertToTensor(depthwiseFilter, "depthwiseFilter", "separableConv2d");
  const $pointwiseFilter = convertToTensor(pointwiseFilter, "pointwiseFilter", "separableConv2d");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  if (dataFormat === "NCHW") {
    throw new Error("separableConv2d currently does not support dataFormat NCHW; only " + "NHWC is supported");
  }
  assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got ` + `rank ${x4D.rank}.`);
  assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but ` + `got rank ${$depthwiseFilter.rank}.`);
  assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but ` + `got rank ${$depthwiseFilter.rank}.`);
  assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter ` + ` must be 1, but got ${$pointwiseFilter.shape[0]}.`);
  assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise ` + `filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);
  const inChannels = $depthwiseFilter.shape[2];
  const channelMultiplier = $depthwiseFilter.shape[3];
  assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter ` + `must be ${inChannels * channelMultiplier}, ` + `but got ${$pointwiseFilter.shape[2]}.`);
  const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad6, dataFormat, dilation);
  const pointwiseStride = 1;
  const res = conv2d(depthwise, $pointwiseFilter, pointwiseStride, "valid", dataFormat);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var separableConv2d;
var init_separable_conv2d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_conv2d();
  init_depthwise_conv2d();
  init_operation();
  init_reshape();
  separableConv2d = op({ separableConv2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/setdiff1d_async.js
async function setdiff1dAsync_(x, y) {
  const $x = convertToTensor(x, "x", "setdiff1d");
  const $y = convertToTensor(y, "y", "setdiff1d");
  assert($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);
  assert($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);
  assert($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);
  const xVals = await $x.data();
  const yVals = await $y.data();
  const ySet = new Set(yVals);
  let outputSize = 0;
  for (let i = 0;i < xVals.length; i++) {
    if (!ySet.has(xVals[i])) {
      outputSize++;
    }
  }
  const buffer7 = new TensorBuffer([outputSize], $x.dtype);
  const indices = new TensorBuffer([outputSize], "int32");
  for (let i = 0, p2 = 0;i < xVals.length; i++) {
    if (!ySet.has(xVals[i])) {
      buffer7.values[p2] = xVals[i];
      indices.values[p2] = i;
      p2++;
    }
  }
  return [buffer7.toTensor(), indices.toTensor()];
}
var setdiff1dAsync;
var init_setdiff1d_async = __esm(() => {
  init_tensor();
  init_tensor_util_env();
  init_util();
  setdiff1dAsync = setdiff1dAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sign.js
function sign_(x) {
  const $x = convertToTensor(x, "x", "sign");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sign, inputs);
}
var sign;
var init_sign = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sign = op({ sign_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sin.js
function sin_(x) {
  const $x = convertToTensor(x, "x", "sin", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sin, inputs);
}
var sin;
var init_sin = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sin = op({ sin_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sinh.js
function sinh_(x) {
  const $x = convertToTensor(x, "x", "sinh");
  const inputs = { x: $x };
  return ENGINE.runKernel(Sinh, inputs);
}
var sinh;
var init_sinh = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sinh = op({ sinh_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/slice1d.js
function slice1d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice1d");
  assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, [begin], [size]);
}
var slice1d;
var init_slice1d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_slice();
  slice1d = op({ slice1d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/slice2d.js
function slice2d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice2d");
  assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size);
}
var slice2d;
var init_slice2d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_slice();
  slice2d = op({ slice2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/slice3d.js
function slice3d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice3d");
  assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size);
}
var slice3d;
var init_slice3d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_slice();
  slice3d = op({ slice3d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/slice4d.js
function slice4d_(x, begin, size) {
  const $x = convertToTensor(x, "x", "slice4d");
  assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);
  return slice($x, begin, size);
}
var slice4d;
var init_slice4d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_slice();
  slice4d = op({ slice4d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/softmax.js
function softmax_(logits, dim = -1) {
  const $logits = convertToTensor(logits, "logits", "softmax", "float32");
  if (dim === -1) {
    dim = $logits.rank - 1;
  }
  if (dim !== $logits.rank - 1) {
    throw Error("Softmax along a non-last dimension is not yet supported. " + `Logits was rank ${$logits.rank} and dim was ${dim}`);
  }
  const inputs = { logits: $logits };
  const attrs = { dim };
  return ENGINE.runKernel(Softmax, inputs, attrs);
}
var softmax;
var init_softmax = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  softmax = op({ softmax_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/spectral/fft.js
function fft_(input) {
  assert(input.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 ` + `but got ${input.dtype}.`);
  const inputs = { input };
  return ENGINE.runKernel(FFT, inputs);
}
var fft;
var init_fft = __esm(() => {
  init_engine();
  init_util();
  init_operation();
  fft = op({ fft_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/spectral/ifft.js
function ifft_(input) {
  assert(input.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 ` + `but got ${input.dtype}.`);
  const inputs = { input };
  return ENGINE.runKernel(IFFT, inputs);
}
var ifft;
var init_ifft = __esm(() => {
  init_engine();
  init_util();
  init_operation();
  ifft = op({ ifft_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/spectral/irfft.js
function irfft_(input) {
  const innerDimensionSize = input.shape[input.shape.length - 1];
  const batch = input.size / innerDimensionSize;
  let ret;
  if (innerDimensionSize <= 2) {
    const complexInput = reshape(input, [batch, innerDimensionSize]);
    ret = ifft(complexInput);
  } else {
    const outputShape = [batch, 2 * (innerDimensionSize - 1)];
    const realInput = reshape(real(input), [batch, innerDimensionSize]);
    const imagInput = reshape(imag(input), [batch, innerDimensionSize]);
    const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);
    const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));
    const r = concat([realInput, realConjugate], 1);
    const i = concat([imagInput, imagConjugate], 1);
    const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);
    ret = ifft(complexInput);
  }
  ret = real(ret);
  if (input.rank === 3 && input.shape[0] !== 0) {
    const temp = ret;
    const batch2 = input.shape[0];
    ret = reshape(ret, [batch2, ret.shape[0] / batch2, ret.shape[1]]);
    temp.dispose();
  }
  return ret;
}
var irfft;
var init_irfft = __esm(() => {
  init_complex();
  init_concat();
  init_imag();
  init_mul();
  init_operation();
  init_real();
  init_reshape();
  init_reverse();
  init_scalar();
  init_slice();
  init_ifft();
  irfft = op({ irfft_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/split.js
function split_(x, numOrSizeSplits, axis = 0) {
  const $x = convertToTensor(x, "x", "split");
  const inputs = { x: $x };
  const attr = { numOrSizeSplits, axis };
  return ENGINE.runKernel(SplitV, inputs, attr);
}
var split;
var init_split = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  split = op({ split_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/spectral/rfft.js
function rfft_(input, fftLength) {
  assert(input.dtype === "float32", () => `The dtype for rfft() must be real value but got ${input.dtype}`);
  let innerDimensionSize = input.shape[input.shape.length - 1];
  const batch = input.size / innerDimensionSize;
  let adjustedInput;
  if (fftLength != null && fftLength < innerDimensionSize) {
    const begin = input.shape.map((v) => 0);
    const size = input.shape.map((v) => v);
    size[input.shape.length - 1] = fftLength;
    adjustedInput = slice(input, begin, size);
    innerDimensionSize = fftLength;
  } else if (fftLength != null && fftLength > innerDimensionSize) {
    const zerosShape = input.shape.map((v) => v);
    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;
    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);
    innerDimensionSize = fftLength;
  } else {
    adjustedInput = input;
  }
  const zerosInput = zerosLike(adjustedInput);
  const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);
  const ret = fft(complexInput);
  const half = Math.floor(innerDimensionSize / 2) + 1;
  const realValues = real(ret);
  const imagValues = imag(ret);
  const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);
  const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);
  const outputShape = adjustedInput.shape.slice();
  outputShape[adjustedInput.shape.length - 1] = half;
  return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);
}
var rfft;
var init_rfft = __esm(() => {
  init_util();
  init_complex();
  init_concat();
  init_imag();
  init_operation();
  init_real();
  init_reshape();
  init_slice();
  init_split();
  init_zeros();
  init_zeros_like();
  init_fft();
  rfft = op({ rfft_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/squared_difference.js
function squaredDifference_(a, b) {
  let $a = convertToTensor(a, "a", "squaredDifference");
  let $b = convertToTensor(b, "b", "squaredDifference");
  [$a, $b] = makeTypesMatch($a, $b);
  assertAndGetBroadcastShape($a.shape, $b.shape);
  const inputs = { a: $a, b: $b };
  const attrs = {};
  return ENGINE.runKernel(SquaredDifference, inputs, attrs);
}
var squaredDifference;
var init_squared_difference = __esm(() => {
  init_engine();
  init_tensor_util();
  init_tensor_util_env();
  init_operation();
  squaredDifference = op({ squaredDifference_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/squeeze.js
function squeeze_(x, axis) {
  const $x = convertToTensor(x, "x", "squeeze", "string_or_numeric");
  return reshape($x, squeezeShape($x.shape, axis).newShape);
}
var squeeze;
var init_squeeze = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reshape();
  squeeze = op({ squeeze_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/stack.js
function stack_(tensors, axis = 0) {
  const $tensors = convertToTensorArray(tensors, "tensors", "stack", "string_or_numeric");
  assert($tensors.length >= 1, () => "Pass at least one tensor to tf.stack");
  if ($tensors.length > 0) {
    assert(axis <= $tensors[0].rank, () => "Axis must be <= rank of the tensor");
  }
  const inputs = $tensors;
  const attrs = { axis };
  return ENGINE.runKernel(Pack, inputs, attrs);
}
var stack;
var init_stack = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  stack = op({ stack_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/step.js
function step_(x, alpha = 0) {
  const $x = convertToTensor(x, "x", "step");
  const inputs = { x: $x };
  const attrs = { alpha };
  return ENGINE.runKernel(Step, inputs, attrs);
}
var step;
var init_step = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  step = op({ step_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/strided_slice.js
function stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {
  const $x = convertToTensor(x, "x", "stridedSlice", "string_or_numeric");
  const inputs = { x: $x };
  const attrs = {
    begin,
    end,
    strides,
    beginMask,
    endMask,
    ellipsisMask,
    newAxisMask,
    shrinkAxisMask
  };
  return ENGINE.runKernel(StridedSlice, inputs, attrs);
}
var stridedSlice;
var init_strided_slice = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  stridedSlice = op({ stridedSlice_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tan.js
function tan_(x) {
  const $x = convertToTensor(x, "x", "tan", "float32");
  const inputs = { x: $x };
  return ENGINE.runKernel(Tan, inputs);
}
var tan;
var init_tan = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  tan = op({ tan_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor1d.js
function tensor1d(values, dtype) {
  assertNonNull(values);
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 1) {
    throw new Error("tensor1d() requires values to be a flat/TypedArray");
  }
  const shape = null;
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor1d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor2d.js
function tensor2d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 2) {
    throw new Error("tensor2d() requires shape to have two numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 2 && inferredShape.length !== 1) {
    throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor2d() requires shape to be provided when `values` " + "are a flat/TypedArray");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor2d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor3d.js
function tensor3d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 3) {
    throw new Error("tensor3d() requires shape to have three numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 3 && inferredShape.length !== 1) {
    throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor3d() requires shape to be provided when `values` " + "are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor3d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor4d.js
function tensor4d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 4) {
    throw new Error("tensor4d() requires shape to have four numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 4 && inferredShape.length !== 1) {
    throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor4d() requires shape to be provided when `values` " + "are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor4d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor5d.js
function tensor5d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 5) {
    throw new Error("tensor5d() requires shape to have five numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 5 && inferredShape.length !== 1) {
    throw new Error("tensor5d() requires values to be " + "number[][][][][] or flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor5d() requires shape to be provided when `values` " + "are a flat array");
  }
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor5d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor6d.js
function tensor6d(values, shape, dtype) {
  assertNonNull(values);
  if (shape != null && shape.length !== 6) {
    throw new Error("tensor6d() requires shape to have six numbers");
  }
  const inferredShape = inferShape(values, dtype);
  if (inferredShape.length !== 6 && inferredShape.length !== 1) {
    throw new Error("tensor6d() requires values to be number[][][][][][] or " + "flat/TypedArray");
  }
  if (inferredShape.length === 1 && shape == null) {
    throw new Error("tensor6d() requires shape to be provided when `values` " + "are a flat array");
  }
  shape = shape || inferredShape;
  return makeTensor(values, shape, inferredShape, dtype);
}
var init_tensor6d = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor_ops_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd_util.js
var exports_scatter_nd_util = {};
__export(exports_scatter_nd_util, {
  validateUpdateShape: () => validateUpdateShape,
  validateInput: () => validateInput,
  calculateShapes: () => calculateShapes
});
function validateUpdateShape(shape, indices, updates) {
  const sliceDim = indices.rank > 1 ? indices.shape[indices.rank - 1] : 1;
  const batchDim = indices.rank > 1 ? indices.rank - 1 : 1;
  const shapeError = "Must have updates.shape = indices.shape[:batchDim] + " + `shape[sliceDim:], got updates.shape: ${updates.shape}` + `, indices.shape: ${indices.shape}, shape: ${shape}` + `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;
  if (updates.rank < batchDim) {
    throw new Error(shapeError + ` update.rank < ${batchDim}. `);
  }
  if (shape.length < sliceDim + (updates.rank - batchDim)) {
    throw new Error(shapeError + ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);
  }
  if (updates.rank !== batchDim + shape.length - sliceDim) {
    throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);
  }
  for (let d = 0;d < batchDim; ++d) {
    if (updates.shape[d] !== indices.shape[d]) {
      throw new Error(shapeError + ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);
    }
  }
  for (let d = 0;d < updates.rank - batchDim; ++d) {
    if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {
      throw new Error(shapeError + ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);
    }
  }
}
function validateInput(updates, indices, shape) {
  if (indices.rank < 1) {
    throw new Error("tf.scatterND() expects the indices to be rank 1 or higher," + ` but the rank was ${indices.rank}.`);
  }
  if (updates.rank < 1) {
    throw new Error("tf.scatterND() expects the updates to be rank 1 or higher," + ` but the rank was ${updates.rank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);
  }
  if (shape.length < 1) {
    throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);
  }
  if (shape.length === 0) {
    if (indices.size === 0) {
      throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);
    }
    if (updates.size === 0) {
      throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);
    }
  }
  validateUpdateShape(shape, indices, updates);
}
function calculateShapes(updates, indices, shape) {
  const indicesRank = indices.shape.length;
  const sliceRank = indicesRank > 1 ? indices.shape[indicesRank - 1] : 1;
  const totalNd = shape.length;
  let sliceSize = 1;
  for (let i = sliceRank;i < totalNd; ++i) {
    sliceSize *= shape[i];
  }
  const safeSliceDim = sliceRank < 1 ? 1 : sliceRank;
  const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;
  const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];
  const outputSize = sizeFromShape(shape);
  return { sliceRank, numUpdates, sliceSize, strides, outputSize };
}
var init_scatter_nd_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/tensor_scatter_update.js
function tensorScatterUpdate_(tensor12, indices, updates) {
  const $tensor = convertToTensor(tensor12, "tensor", "tensorScatterupdate");
  const $indices = convertToTensor(indices, "indices", "tensorScatterupdate", "int32");
  const $updates = convertToTensor(updates, "updates", "tensorScatterupdate");
  validateInput($updates, $indices, $tensor.shape);
  if ($tensor.dtype !== $updates.dtype) {
    throw new Error(`tensor and updates must have the same dtype, instead they are ${$tensor.dtype} and ${$updates.dtype}.`);
  }
  const inputs = {
    tensor: $tensor,
    indices: $indices,
    updates: $updates
  };
  const attrs = {};
  return ENGINE.runKernel(TensorScatterUpdate, inputs, attrs);
}
var tensorScatterUpdate;
var init_tensor_scatter_update = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  init_scatter_nd_util();
  tensorScatterUpdate = op({ tensorScatterUpdate_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/topk.js
function topk_(x, k = 1, sorted = true) {
  const $x = convertToTensor(x, "x", "topk");
  if ($x.rank === 0) {
    throw new Error("topk() expects the input to be of rank 1 or higher");
  }
  const lastDim = $x.shape[$x.shape.length - 1];
  if (k < 0) {
    throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);
  }
  if (k > lastDim) {
    throw new Error(`'k' passed to topk() must be <= the last dimension (${lastDim}) ` + `but got ${k}`);
  }
  const inputs = { x: $x };
  const attrs = { k, sorted };
  const [values, indices] = ENGINE.runKernel(TopK, inputs, attrs);
  return { values, indices };
}
var topk;
var init_topk = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  topk = op({ topk_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/truncated_normal.js
function truncatedNormal_(shape, mean3 = 0, stdDev = 1, dtype, seed) {
  assertNonNegativeIntegerDimensions(shape);
  if (dtype != null && dtype === "bool") {
    throw new Error(`Unsupported data type \$ { dtype }`);
  }
  const randGauss = new MPRandGauss(mean3, stdDev, dtype, true, seed);
  const res = buffer(shape, dtype);
  for (let i = 0;i < res.values.length; i++) {
    res.values[i] = randGauss.nextValue();
  }
  return res.toTensor();
}
var truncatedNormal;
var init_truncated_normal = __esm(() => {
  init_buffer();
  init_operation();
  init_rand_util();
  truncatedNormal = op({ truncatedNormal_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/unique.js
function unique_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "unique", "string_or_numeric");
  assert($x.rank > 0, () => "The input tensor must be at least 1D");
  const inputs = { x: $x };
  const attrs = { axis };
  const [values, indices] = ENGINE.runKernel(Unique, inputs, attrs);
  return { values, indices };
}
var unique;
var init_unique = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  unique = op({ unique_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/unsorted_segment_sum.js
function unsortedSegmentSum_(x, segmentIds, numSegments) {
  const $x = convertToTensor(x, "x", "unsortedSegmentSum");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "unsortedSegmentSum", "int32");
  assert(isInt(numSegments), () => "numSegments must be of dtype int");
  const inputs = { x: $x, segmentIds: $segmentIds };
  const attrs = { numSegments };
  return ENGINE.runKernel(UnsortedSegmentSum, inputs, attrs);
}
var unsortedSegmentSum;
var init_unsorted_segment_sum = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  unsortedSegmentSum = op({ unsortedSegmentSum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/unstack.js
function unstack_(x, axis = 0) {
  const $x = convertToTensor(x, "x", "unstack", "string_or_numeric");
  assert(axis >= -$x.shape.length && axis < $x.shape.length, () => `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);
  const inputs = { value: $x };
  const attrs = { axis };
  return ENGINE.runKernel(Unpack, inputs, attrs);
}
var unstack;
var init_unstack = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  unstack = op({ unstack_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/upper_bound.js
function upperBound(sortedSequence, values) {
  return searchSorted(sortedSequence, values, "right");
}
var init_upper_bound = __esm(() => {
  init_search_sorted();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/variable.js
function variable(initialValue, trainable = true, name, dtype) {
  return ENGINE.makeVariable(initialValue, trainable, name, dtype);
}
var init_variable = __esm(() => {
  init_engine();
});

// node_modules/@tensorflow/tfjs-core/dist/backends/where_impl.js
function whereImpl(condShape, condVals) {
  const indices = [];
  for (let i = 0;i < condVals.length; i++) {
    if (condVals[i]) {
      indices.push(i);
    }
  }
  const inBuffer = buffer(condShape, "int32");
  const out = buffer([indices.length, condShape.length], "int32");
  for (let i = 0;i < indices.length; i++) {
    const loc = inBuffer.indexToLoc(indices[i]);
    const offset = i * condShape.length;
    out.values.set(loc, offset);
  }
  return out.toTensor();
}
var init_where_impl = __esm(() => {
  init_buffer();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/where_async.js
async function whereAsync_(condition) {
  const $condition = convertToTensor(condition, "condition", "whereAsync", "bool");
  const vals = await $condition.data();
  const res = whereImpl($condition.shape, vals);
  if (condition !== $condition) {
    $condition.dispose();
  }
  return res;
}
var whereAsync;
var init_where_async = __esm(() => {
  init_where_impl();
  init_tensor_util_env();
  whereAsync = whereAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/boolean_mask.js
async function booleanMaskAsync_(tensor12, mask, axis) {
  const $tensor = convertToTensor(tensor12, "tensor", "boolMask");
  const $mask = convertToTensor(mask, "mask", "boolMask", "bool");
  const axisFrom = axis == null ? 0 : axis;
  const maskDim = $mask.rank;
  const tensorShape = $tensor.shape;
  assert(maskDim > 0, () => "mask cannot be scalar");
  assertShapesMatch(tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape, `mask's shape must match the first K dimensions of tensor's shape,`);
  let leadingSize = 1;
  for (let i = axisFrom;i < axisFrom + maskDim; i++) {
    leadingSize *= tensorShape[i];
  }
  const targetTensorShape = tensorShape.slice(0, axisFrom).concat([leadingSize], tensorShape.slice(axisFrom + maskDim));
  const reshapedTensor = reshape($tensor, targetTensorShape);
  const reshapedMask = reshape($mask, [-1]);
  const positivePositions = await whereAsync(reshapedMask);
  const indices = squeeze(positivePositions, [1]);
  const res = gather(reshapedTensor, indices, axisFrom);
  if (tensor12 !== $tensor) {
    $tensor.dispose();
  }
  if (mask !== $mask) {
    $mask.dispose();
  }
  indices.dispose();
  reshapedTensor.dispose();
  reshapedMask.dispose();
  positivePositions.dispose();
  return res;
}
var booleanMaskAsync;
var init_boolean_mask = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_gather();
  init_reshape();
  init_squeeze();
  init_where_async();
  booleanMaskAsync = booleanMaskAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/transpose.js
function transpose_(x, perm, conjugate) {
  const $x = convertToTensor(x, "x", "transpose");
  if (perm == null) {
    perm = $x.shape.map((s, i) => i).reverse();
  }
  assert($x.rank === perm.length, () => `Error in transpose: rank of input ${$x.rank} ` + `must match length of perm ${perm}.`);
  perm.forEach((axis) => {
    assert(axis >= 0 && axis < $x.rank, () => `All entries in 'perm' must be between 0 and ${$x.rank - 1}` + ` but got ${perm}`);
  });
  if ($x.rank <= 1) {
    return $x.clone();
  }
  const inputs = { x: $x };
  const attrs = { perm };
  if ($x.dtype === "complex64") {
    return tidy(() => {
      let $real = real($x);
      let $imag = imag($x);
      $real = ENGINE.runKernel(Transpose, { x: $real }, attrs);
      $imag = ENGINE.runKernel(Transpose, { x: $imag }, attrs);
      if (conjugate) {
        $imag = neg($imag);
      }
      return complex($real, $imag);
    });
  }
  return ENGINE.runKernel(Transpose, inputs, attrs);
}
var transpose;
var init_transpose = __esm(() => {
  init_engine();
  init_globals();
  init_tensor_util_env();
  init_util();
  init_complex();
  init_imag();
  init_neg();
  init_operation();
  init_real();
  transpose = op({ transpose_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/moving_average.js
function movingAverage_(v, x, decay, step2, zeroDebias = true) {
  const $v = convertToTensor(v, "v", "movingAverage");
  const $x = convertToTensor(x, "x", "movingAverage");
  const $decay = convertToTensor(decay, "decay", "movingAverage");
  assertTypesMatch($v, $x);
  assert(arraysEqual($v.shape, $x.shape), () => "Shape mismatch in v and x");
  const one = scalar(1);
  const oneMinusDecay = sub(one, $decay);
  let update = mul(sub($x, $v), oneMinusDecay);
  if (zeroDebias) {
    assert(step2 != null, () => "When using zeroDebias: true, step is required.");
    const $step = convertToTensor(step2, "step", "movingAverage");
    update = div(update, sub(one, pow($decay, $step)));
  }
  return add2($v, update);
}
var movingAverage;
var init_moving_average = __esm(() => {
  init_tensor_util();
  init_tensor_util_env();
  init_util();
  init_add();
  init_div();
  init_mul();
  init_operation();
  init_pow();
  init_scalar();
  init_sub();
  movingAverage = op({ movingAverage_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd.js
function scatterND_(indices, updates, shape) {
  assertNonNegativeIntegerDimensions(shape);
  const $indices = convertToTensor(indices, "indices", "scatterND", "int32");
  const $updates = convertToTensor(updates, "updates", "scatterND");
  validateInput($updates, $indices, shape);
  const inputs = { indices: $indices, updates: $updates };
  const attrs = { shape };
  return ENGINE.runKernel(ScatterNd, inputs, attrs);
}
var scatterND;
var init_scatter_nd = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  init_scatter_nd_util();
  scatterND = op({ scatterND_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense_util.js
function validateInput2(sparseIndices, sparseValues, outputShape, defaultValues) {
  if (sparseIndices.dtype !== "int32") {
    throw new Error("tf.sparseToDense() expects the indices to be int32 type," + ` but the dtype was ${sparseIndices.dtype}.`);
  }
  if (sparseIndices.rank > 2) {
    throw new Error("sparseIndices should be a scalar, vector, or matrix," + ` but got shape ${sparseIndices.shape}.`);
  }
  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;
  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;
  if (outputShape.length !== numDims) {
    throw new Error("outputShape has incorrect number of elements:," + ` ${outputShape.length}, should be: ${numDims}.`);
  }
  const numValues = sparseValues.size;
  if (!(sparseValues.rank === 0 || sparseValues.rank === 1 && numValues === numElems)) {
    throw new Error("sparseValues has incorrect shape " + `${sparseValues.shape}, should be [] or [${numElems}]`);
  }
  if (sparseValues.dtype !== defaultValues.dtype) {
    throw new Error("sparseValues.dtype must match defaultValues.dtype");
  }
}

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense.js
function sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {
  assertNonNegativeIntegerDimensions(outputShape);
  const $sparseIndices = convertToTensor(sparseIndices, "sparseIndices", "sparseToDense", "int32");
  const $sparseValues = convertToTensor(sparseValues, "sparseValues", "sparseToDense", "string_or_numeric");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseToDense", $sparseValues.dtype);
  validateInput2($sparseIndices, $sparseValues, outputShape, $defaultValue);
  const inputs = {
    sparseIndices: $sparseIndices,
    sparseValues: $sparseValues,
    defaultValue: $defaultValue
  };
  const attrs = { outputShape };
  return ENGINE.runKernel(SparseToDense, inputs, attrs);
}
var sparseToDense;
var init_sparse_to_dense = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sparseToDense = op({ sparseToDense_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd.js
function gatherND_(x, indices) {
  const $indices = convertToTensor(indices, "indices", "gatherND", "int32");
  const $x = convertToTensor(x, "x", "gatherND", "string_or_numeric");
  const inputs = { params: $x, indices: $indices };
  return ENGINE.runKernel(GatherNd, inputs);
}
var gatherND;
var init_gather_nd = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  gatherND = op({ gatherND_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/dropout_util.js
function getNoiseShape(x, noiseShape) {
  if (noiseShape == null) {
    return x.shape.slice();
  }
  if (arraysEqual(x.shape, noiseShape)) {
    return noiseShape;
  }
  if (x.shape.length === noiseShape.length) {
    const newDimension = [];
    for (let i = 0;i < x.shape.length; i++) {
      if (noiseShape[i] == null && x.shape[i] != null) {
        newDimension.push(x.shape[i]);
      } else {
        newDimension.push(noiseShape[i]);
      }
    }
    return newDimension;
  }
  return noiseShape;
}
var init_dropout_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/dropout.js
function dropout_(x, rate, noiseShape, seed) {
  const $x = convertToTensor(x, "x", "dropout");
  assert($x.dtype === "float32", () => `x has to be a floating point tensor since it's going to be ` + `scaled, but got a ${$x.dtype} tensor instead.`);
  assert(rate >= 0 && rate < 1, () => `rate must be a float in the range [0, 1), but got ${rate}.`);
  if (rate === 0) {
    return x instanceof Tensor ? $x.clone() : $x;
  }
  const $noiseShape = getNoiseShape($x, noiseShape);
  const keepProb = 1 - rate;
  const multiplier = div(floor(add2(randomUniform($noiseShape, 0, 1, "float32", seed), keepProb)), keepProb);
  return mul($x, multiplier);
}
var dropout;
var init_dropout = __esm(() => {
  init_tensor();
  init_tensor_util_env();
  init_util();
  init_add();
  init_div();
  init_dropout_util();
  init_floor();
  init_mul();
  init_operation();
  init_random_uniform();
  dropout = op({ dropout_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/signal_ops_util.js
function enclosingPowerOfTwo(value) {
  return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2))));
}
function cosineWindow(windowLength, a, b) {
  const even = 1 - windowLength % 2;
  const newValues = new Float32Array(windowLength);
  for (let i = 0;i < windowLength; ++i) {
    const cosArg = 2 * Math.PI * i / (windowLength + even - 1);
    newValues[i] = a - b * Math.cos(cosArg);
  }
  return tensor1d(newValues, "float32");
}
var init_signal_ops_util = __esm(() => {
  init_tensor1d();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/in_top_k.js
async function inTopKAsync_(predictions, targets, k = 1) {
  const $predictions = convertToTensor(predictions, "predictions", "inTopK");
  const $targets = convertToTensor(targets, "targets", "inTopK");
  assert($predictions.rank > 1, () => "inTopK() expects the predictions to be of rank 2 or higher, " + `but got ${$predictions.rank}`);
  assert($predictions.rank - 1 === $targets.rank, () => `predictions rank should be 1 larger than ` + `targets rank, but got predictions rank ` + `${$predictions.rank} and targets rank ${$targets.rank}`);
  assertShapesMatch($predictions.shape.slice(0, $predictions.shape.length - 1), $targets.shape, `predictions's shape should be align with the targets' shape, ` + "except the last dimension.");
  const lastDim = $predictions.shape[$predictions.shape.length - 1];
  assert(k > 0 && k <= lastDim, () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` + `dimension (${lastDim}), but got ${k}`);
  const predictionsVals = await $predictions.data();
  const targetsVals = await $targets.data();
  const [batch, size] = [predictionsVals.length / lastDim, lastDim];
  const precision = getTypedArrayFromDType("bool", batch);
  for (let b = 0;b < batch; b++) {
    const offset = b * size;
    const vals = predictionsVals.subarray(offset, offset + size);
    const valAndInd = [];
    for (let i = 0;i < vals.length; i++) {
      valAndInd.push({ value: vals[i], index: i });
    }
    valAndInd.sort((a, b3) => b3.value - a.value);
    precision[b] = 0;
    for (let i = 0;i < k; i++) {
      if (valAndInd[i].index === targetsVals[b]) {
        precision[b] = 1;
        break;
      }
    }
  }
  if (predictions !== $predictions) {
    $predictions.dispose();
  }
  if (targets !== $targets) {
    $targets.dispose();
  }
  return tensor4(precision, $targets.shape, "bool");
}
var inTopKAsync;
var init_in_top_k = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_tensor2();
  inTopKAsync = inTopKAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv2d_backprop_filter.js
function conv2DBackpropFilter_(x, dy2, filterShape, strides, pad6, dataFormat = "NHWC", dimRoundingMode) {
  let x4D = x;
  if (x.rank === 3) {
    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
  }
  let dy4D = dy2;
  if (dy4D.rank === 3) {
    dy4D = reshape(dy2, [1, dy2.shape[0], dy2.shape[1], dy2.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` + `${x4D.shape}.`);
  assert(dy4D.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` + `${dy4D.shape}.`);
  assert(filterShape.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` + `${filterShape}.`);
  const inDepth = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  const outDepth = dataFormat === "NHWC" ? dy4D.shape[3] : dy4D.shape[1];
  assert(inDepth === filterShape[2], () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` + `match input depth in filter (${filterShape[2]}.`);
  assert(outDepth === filterShape[3], () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` + `match output depth for filter (${filterShape[3]}).`);
  checkPadOnDimRoundingMode("conv2dDerFilter", pad6, dimRoundingMode);
  const inputs = { x: x4D, dy: dy4D };
  const attrs = { strides, pad: pad6, dataFormat, dimRoundingMode, filterShape };
  return ENGINE.runKernel(Conv2DBackpropFilter, inputs, attrs);
}
var conv2DBackpropFilter;
var init_conv2d_backprop_filter = __esm(() => {
  init_engine();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  conv2DBackpropFilter = op({ conv2DBackpropFilter_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fused_util.js
function getFusedDyActivation(dy2, y, activation) {
  if (activation == null || activation === "linear") {
    return dy2;
  }
  if (activation === "relu") {
    return mul(dy2, step(y));
  }
  throw new Error(`Cannot compute gradient for fused activation ${activation}.`);
}
function getFusedBiasGradient(bias, dyActivation) {
  let res = dyActivation;
  const reduceAxes = getReductionAxes(bias.shape, dyActivation.shape);
  if (reduceAxes.length > 0) {
    res = sum2(res, reduceAxes);
  }
  return reshape(res, bias.shape);
}
function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {
  if (activation === "linear") {
    return x;
  } else if (activation === "relu") {
    return relu(x);
  } else if (activation === "elu") {
    return elu(x);
  } else if (activation === "relu6") {
    return relu6(x);
  } else if (activation === "prelu") {
    return prelu(x, preluActivationWeights);
  } else if (activation === "leakyrelu") {
    return leakyRelu(x, leakyreluAlpha);
  } else if (activation === "sigmoid") {
    return sigmoid(x);
  }
  throw new Error(`Unknown fused activation ${activation}.`);
}
var shouldFuse = (gradientDepth, activation) => {
  const gradientMode = gradientDepth > 0;
  return !gradientMode || activation === "linear";
};
var init_fused_util = __esm(() => {
  init_elu();
  init_leaky_relu();
  init_mul();
  init_prelu();
  init_relu();
  init_relu6();
  init_reshape();
  init_sigmoid();
  init_step();
  init_sum();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fused/conv2d.js
function fusedConv2d_({ x, filter, strides, pad: pad6, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
  activation = activation || "linear";
  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
    assert(dataFormat === "NHWC", () => `Error in fused conv2d: got dataFormat of ${dataFormat} but ` + `only NHWC is currently supported for the case of gradient depth ` + `is 0 and the activation is not linear.`);
    let result = conv2d(x, filter, strides, pad6, dataFormat, dilations, dimRoundingMode);
    if (bias != null) {
      result = add2(result, bias);
    }
    return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
  }
  const $x = convertToTensor(x, "x", "conv2d", "float32");
  const $filter = convertToTensor(filter, "filter", "conv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ` + `${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ` + `${$filter.rank}.`);
  checkPadOnDimRoundingMode("fused conv2d", pad6, dimRoundingMode);
  const inputChannels = dataFormat === "NHWC" ? x4D.shape[3] : x4D.shape[1];
  assert($filter.shape[2] === inputChannels, () => `Error in conv2d: depth of input (${inputChannels}) must match ` + `input depth for filter ${$filter.shape[2]}.`);
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in conv2D: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad6, dimRoundingMode);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused conv2d");
    [$bias] = makeTypesMatch($bias, $x);
    if (dataFormat === "NHWC") {
      assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
    } else {
      assert($bias.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor ` + `bias for NCHW format but got the bias of ` + `rank-${$bias.shape.length}.`);
      assert($bias.shape.length === 0 || $bias.shape[0] === convInfo.outChannels || $bias.shape[0] === 1, () => `Error in fused conv2d: bias shape (${$bias.shape}) is not ` + `compatible with the number of output channels ` + `(${convInfo.outChannels})`);
    }
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    const alphaShape = preluActivationWeights.shape;
    assert(alphaShape.length <= 1 || alphaShape.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or ` + `3-D Tensor PReLU activation weights but got a tensor of ` + `rank-${alphaShape.length}.`);
    if (alphaShape.length === 1) {
      assert(alphaShape[0] === 1 || alphaShape[0] === convInfo.outChannels, () => `Error in fused conv2d: PReLU activation weights ` + `(${alphaShape}) is not compatible with the number of output ` + `channels (${convInfo.outChannels}).`);
    } else if (alphaShape.length === 3) {
      try {
        assertAndGetBroadcastShape(alphaShape, convInfo.outShape);
      } catch (e) {
        const errMsg = `Error in fused conv2d: PReLU activation weights (${alphaShape}) ` + `is not compatible with the output shape of the conv2d ` + `(${convInfo.outShape}).`;
        throw Error(errMsg);
      }
    }
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused conv2d");
  }
  const grad2 = (dy2, saved) => {
    assert(dataFormat === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);
    const [$filter2, x4D2, y, $bias2] = saved;
    const dyActivation = getFusedDyActivation(dy2, y, activation);
    assert(tupleValuesAreOne(dilations), () => "Error in gradient of fused conv2D: " + `dilation rates greater than 1 ` + `are not yet supported in gradients. Got dilations '${dilations}'`);
    const xDer = conv2DBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad6);
    const filterDer = conv2DBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad6);
    const der = [xDer, filterDer];
    if ($bias2 != null) {
      const biasDer = getFusedBiasGradient($bias2, dyActivation);
      der.push(biasDer);
    }
    return der;
  };
  const inputs = {
    x: x4D,
    filter: $filter,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = {
    strides,
    pad: pad6,
    dataFormat,
    dilations,
    dimRoundingMode,
    activation,
    leakyreluAlpha
  };
  if (bias == null) {
    const customOp = customGrad((x4D2, filter2, save) => {
      let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
      save([filter2, x4D2, res]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOp(x4D, $filter);
  } else {
    const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
      let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);
      save([filter2, x4D2, res, bias2]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOpWithBias(x4D, $filter, $bias);
  }
}
var conv2d5;
var init_conv2d2 = __esm(() => {
  init_engine();
  init_gradients();
  init_tensor_util();
  init_tensor_util_env();
  init_util();
  init_add();
  init_conv2d();
  init_conv2d_backprop_filter();
  init_conv2d_backprop_input();
  init_conv_util();
  init_fused_util();
  init_operation();
  init_reshape();
  conv2d5 = op({ fusedConv2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_filter.js
function depthwiseConv2dNativeBackpropFilter_(x, dy2, filterShape, strides, pad6, dilations = [1, 1], dimRoundingMode) {
  let x4D = x;
  if (x.rank === 3) {
    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);
  }
  let dy4D = dy2;
  if (dy4D.rank === 3) {
    dy4D = reshape(dy2, [1, dy2.shape[0], dy2.shape[1], dy2.shape[2]]);
  }
  const inputs = { x: x4D, dy: dy4D };
  const attrs = { strides, pad: pad6, dimRoundingMode, dilations, filterShape };
  return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter, inputs, attrs);
}
var depthwiseConv2dNativeBackpropFilter;
var init_depthwise_conv2d_native_backprop_filter = __esm(() => {
  init_engine();
  init_operation();
  init_reshape();
  depthwiseConv2dNativeBackpropFilter = op({ depthwiseConv2dNativeBackpropFilter_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/depthwise_conv2d_native_backprop_input.js
function depthwiseConv2dNativeBackpropInput_(xShape, dy2, filter, strides, pad6, dilations = [1, 1], dimRoundingMode) {
  let dy4D = dy2;
  let reshapedTo4D = false;
  if (dy2.rank === 3) {
    reshapedTo4D = true;
    dy4D = reshape(dy2, [1, dy2.shape[0], dy2.shape[1], dy2.shape[2]]);
  }
  const inputs = { dy: dy4D, filter };
  const attrs = { strides, pad: pad6, dimRoundingMode, dilations, inputShape: xShape };
  const res = ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var depthwiseConv2dNativeBackpropInput;
var init_depthwise_conv2d_native_backprop_input = __esm(() => {
  init_engine();
  init_operation();
  init_reshape();
  depthwiseConv2dNativeBackpropInput = op({ depthwiseConv2dNativeBackpropInput_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fused/depthwise_conv2d.js
function fusedDepthwiseConv2d_({ x, filter, strides, pad: pad6, dataFormat = "NHWC", dilations = [1, 1], dimRoundingMode, bias, activation = "linear", preluActivationWeights, leakyreluAlpha }) {
  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
    let result = depthwiseConv2d(x, filter, strides, pad6, dataFormat, dilations, dimRoundingMode);
    if (bias != null) {
      result = add2(result, bias);
    }
    return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
  }
  const $x = convertToTensor(x, "x", "depthwiseConv2d", "float32");
  const $filter = convertToTensor(filter, "filter", "depthwiseConv2d", "float32");
  let x4D = $x;
  let reshapedTo4D = false;
  if ($x.rank === 3) {
    reshapedTo4D = true;
    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);
  }
  assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got ` + `rank ${x4D.rank}.`);
  assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, ` + `but got rank ${$filter.rank}.`);
  assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels ` + `(${x4D.shape[3]}) must match the inChannels dimension in ` + `filter ${$filter.shape[2]}.`);
  if (dilations == null) {
    dilations = [1, 1];
  }
  assert(eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in fused depthwiseConv2d: Either strides or dilations must " + `be 1. Got strides ${strides} and dilations '${dilations}'`);
  checkPadOnDimRoundingMode("fused depthwiseConv2d", pad6, dimRoundingMode);
  const convInfo = computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad6, dimRoundingMode, true);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused conv2d");
    [$bias] = makeTypesMatch($bias, $x);
    assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused depthwiseConv2d");
  }
  const grad2 = (dy2, saved) => {
    assert(tupleValuesAreOne(dilations), () => "Error in gradient of fused depthwiseConv2d: dilation rates " + `greater than 1 are not yet supported. Got dilations ` + `'${dilations}'`);
    const [$filter2, x4D2, y, bias2] = saved;
    const dyActivation = getFusedDyActivation(dy2, y, activation);
    const xDer = depthwiseConv2dNativeBackpropInput(x4D2.shape, dyActivation, $filter2, strides, pad6, dilations, dimRoundingMode);
    const filterDer = depthwiseConv2dNativeBackpropFilter(x4D2, dyActivation, $filter2.shape, strides, pad6, dilations, dimRoundingMode);
    if (bias2 != null) {
      const biasDer = getFusedBiasGradient($bias, dyActivation);
      return [xDer, filterDer, biasDer];
    }
    return [xDer, filterDer];
  };
  const inputs = {
    x: x4D,
    filter: $filter,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = {
    strides,
    pad: pad6,
    dataFormat,
    dilations,
    dimRoundingMode,
    activation,
    leakyreluAlpha
  };
  if (bias == null) {
    const customOp = customGrad((x4D2, filter2, save) => {
      let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
      save([filter2, x4D2, res]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOp(x4D, $filter);
  } else {
    const customOpWithBias = customGrad((x4D2, filter2, bias2, save) => {
      let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);
      save([filter2, x4D2, res, bias2]);
      if (reshapedTo4D) {
        res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
      }
      return { value: res, gradFunc: grad2 };
    });
    return customOpWithBias(x4D, $filter, $bias);
  }
}
var depthwiseConv2d2;
var init_depthwise_conv2d2 = __esm(() => {
  init_engine();
  init_gradients();
  init_tensor_util();
  init_tensor_util_env();
  init_util();
  init_add();
  init_conv_util();
  init_depthwise_conv2d();
  init_depthwise_conv2d_native_backprop_filter();
  init_depthwise_conv2d_native_backprop_input();
  init_fused_util();
  init_operation();
  init_reshape();
  depthwiseConv2d2 = op({ fusedDepthwiseConv2d_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fused/mat_mul.js
function fusedMatMul_({ a, b, transposeA = false, transposeB = false, bias, activation = "linear", preluActivationWeights, leakyreluAlpha = 0.2 }) {
  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {
    let result = matMul(a, b, transposeA, transposeB);
    if (bias != null) {
      result = add2(result, bias);
    }
    return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);
  }
  let $a = convertToTensor(a, "a", "fused matMul");
  let $b = convertToTensor(b, "b", "fused matMul");
  [$a, $b] = makeTypesMatch($a, $b);
  const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];
  const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];
  const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];
  const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];
  const outerDimsA = $a.shape.slice(0, -2);
  const outerDimsB = $b.shape.slice(0, -2);
  const batchDimA = sizeFromShape(outerDimsA);
  const batchDimB = sizeFromShape(outerDimsB);
  assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${$a.shape} and ` + `${$b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`);
  const outShapeOuterDims = assertAndGetBroadcastShape($a.shape.slice(0, -2), $b.shape.slice(0, -2));
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  const a3D = transposeA ? reshape($a, [batchDimA, innerShapeA, outerShapeA]) : reshape($a, [batchDimA, outerShapeA, innerShapeA]);
  const b3D = transposeB ? reshape($b, [batchDimB, outerShapeB, innerShapeB]) : reshape($b, [batchDimB, innerShapeB, outerShapeB]);
  let $bias;
  if (bias != null) {
    $bias = convertToTensor(bias, "bias", "fused matMul");
    [$bias] = makeTypesMatch($bias, $a);
    assertAndGetBroadcastShape(outShape, $bias.shape);
  }
  let $preluActivationWeights;
  if (preluActivationWeights != null) {
    $preluActivationWeights = convertToTensor(preluActivationWeights, "prelu weights", "fused matMul");
  }
  const grad2 = (dy2, saved) => {
    const [a3D2, b3D2, y, $bias2] = saved;
    const dyActivation = getFusedDyActivation(reshape(dy2, y.shape), y, activation);
    let aDer;
    let bDer;
    if (!transposeA && !transposeB) {
      aDer = matMul(dyActivation, b3D2, false, true);
      bDer = matMul(a3D2, dyActivation, true, false);
    } else if (!transposeA && transposeB) {
      aDer = matMul(dyActivation, b3D2, false, false);
      bDer = matMul(dyActivation, a3D2, true, false);
    } else if (transposeA && !transposeB) {
      aDer = matMul(b3D2, dyActivation, false, true);
      bDer = matMul(a3D2, dyActivation, false, false);
    } else {
      aDer = matMul(b3D2, dyActivation, true, true);
      bDer = matMul(dyActivation, a3D2, true, true);
    }
    if (bias != null) {
      const biasDer = getFusedBiasGradient($bias2, dyActivation);
      return [aDer, bDer, biasDer];
    } else {
      return [aDer, bDer];
    }
  };
  const inputs = {
    a: a3D,
    b: b3D,
    bias: $bias,
    preluActivationWeights: $preluActivationWeights
  };
  const attrs = { transposeA, transposeB, activation, leakyreluAlpha };
  if (bias == null) {
    const customOp = customGrad((a3D2, b3D2, save) => {
      const res = ENGINE.runKernel(_FusedMatMul, inputs, attrs);
      save([a3D2, b3D2, res]);
      return { value: reshape(res, outShape), gradFunc: grad2 };
    });
    return customOp(a3D, b3D);
  } else {
    const customOpWithBias = customGrad((a3D2, b3D2, $bias2, save) => {
      const res = ENGINE.runKernel(_FusedMatMul, inputs, attrs);
      save([a3D2, b3D2, res, $bias2]);
      return { value: reshape(res, outShape), gradFunc: grad2 };
    });
    return customOpWithBias(a3D, b3D, $bias);
  }
}
var matMul2;
var init_mat_mul2 = __esm(() => {
  init_engine();
  init_gradients();
  init_tensor_util();
  init_tensor_util_env();
  init_util();
  init_add();
  init_fused_util();
  init_mat_mul();
  init_operation();
  init_reshape();
  matMul2 = op({ fusedMatMul_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fused_ops.js
var exports_fused_ops = {};
__export(exports_fused_ops, {
  matMul: () => matMul2,
  depthwiseConv2d: () => depthwiseConv2d2,
  conv2d: () => conv2d5
});
var init_fused_ops = __esm(() => {
  init_conv2d2();
  init_depthwise_conv2d2();
  init_mat_mul2();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/signal/hamming_window.js
function hammingWindow_(windowLength) {
  return cosineWindow(windowLength, 0.54, 0.46);
}
var hammingWindow;
var init_hamming_window = __esm(() => {
  init_operation();
  init_signal_ops_util();
  hammingWindow = op({ hammingWindow_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/signal/hann_window.js
function hannWindow_(windowLength) {
  return cosineWindow(windowLength, 0.5, 0.5);
}
var hannWindow;
var init_hann_window = __esm(() => {
  init_operation();
  init_signal_ops_util();
  hannWindow = op({ hannWindow_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/signal/frame.js
function frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {
  let start = 0;
  const output = [];
  while (start + frameLength <= signal.size) {
    output.push(slice(signal, start, frameLength));
    start += frameStep;
  }
  if (padEnd) {
    while (start < signal.size) {
      const padLen = start + frameLength - signal.size;
      const pad6 = concat([
        slice(signal, start, frameLength - padLen),
        fill([padLen], padValue)
      ]);
      output.push(pad6);
      start += frameStep;
    }
  }
  if (output.length === 0) {
    return tensor2d([], [0, frameLength]);
  }
  return reshape(concat(output), [output.length, frameLength]);
}
var frame;
var init_frame = __esm(() => {
  init_concat();
  init_fill();
  init_operation();
  init_reshape();
  init_slice();
  init_tensor2d();
  frame = op({ frame_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/signal/stft.js
function stft_(signal, frameLength, frameStep, fftLength, windowFn = hannWindow) {
  if (fftLength == null) {
    fftLength = enclosingPowerOfTwo(frameLength);
  }
  const framedSignal = frame(signal, frameLength, frameStep);
  const windowedSignal = mul(framedSignal, windowFn(frameLength));
  return rfft(windowedSignal, fftLength);
}
var stft;
var init_stft = __esm(() => {
  init_mul();
  init_operation();
  init_signal_ops_util();
  init_rfft();
  init_frame();
  init_hann_window();
  stft = op({ stft_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/crop_and_resize.js
function cropAndResize_(image, boxes, boxInd, cropSize, method = "bilinear", extrapolationValue = 0) {
  const $image = convertToTensor(image, "image", "cropAndResize");
  const $boxes = convertToTensor(boxes, "boxes", "cropAndResize", "float32");
  const $boxInd = convertToTensor(boxInd, "boxInd", "cropAndResize", "int32");
  const numBoxes = $boxes.shape[0];
  assert($image.rank === 4, () => "Error in cropAndResize: image must be rank 4," + `but got rank ${$image.rank}.`);
  assert($boxes.rank === 2 && $boxes.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` + `but had shape ${$boxes.shape}.`);
  assert($boxInd.rank === 1 && $boxInd.shape[0] === numBoxes, () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` + `but had shape ${$boxes.shape}.`);
  assert(cropSize.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got ` + `length ${cropSize.length}.`);
  assert(cropSize[0] >= 1 && cropSize[1] >= 1, () => `cropSize must be atleast [1,1], but was ${cropSize}`);
  assert(method === "bilinear" || method === "nearest", () => `method must be bilinear or nearest, but was ${method}`);
  const inputs = { image: $image, boxes: $boxes, boxInd: $boxInd };
  const attrs = { method, extrapolationValue, cropSize };
  const res = ENGINE.runKernel(CropAndResize, inputs, attrs);
  return res;
}
var cropAndResize;
var init_crop_and_resize = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  cropAndResize = op({ cropAndResize_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/flip_left_right.js
function flipLeftRight_(image) {
  const $image = convertToTensor(image, "image", "flipLeftRight", "float32");
  assert($image.rank === 4, () => "Error in flipLeftRight: image must be rank 4," + `but got rank ${$image.rank}.`);
  const inputs = { image: $image };
  const res = ENGINE.runKernel(FlipLeftRight, inputs, {});
  return res;
}
var flipLeftRight;
var init_flip_left_right = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  flipLeftRight = op({ flipLeftRight_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/grayscale_to_rgb.js
function grayscaleToRGB_(image) {
  const $image = convertToTensor(image, "image", "grayscaleToRGB");
  const lastDimsIdx = $image.rank - 1;
  const lastDims = $image.shape[lastDimsIdx];
  assert($image.rank >= 2, () => "Error in grayscaleToRGB: images must be at least rank 2, " + `but got rank ${$image.rank}.`);
  assert(lastDims === 1, () => "Error in grayscaleToRGB: last dimension of a grayscale image " + `should be size 1, but got size ${lastDims}.`);
  const reps = new Array($image.rank);
  reps.fill(1, 0, lastDimsIdx);
  reps[lastDimsIdx] = 3;
  return tile($image, reps);
}
var grayscaleToRGB;
var init_grayscale_to_rgb = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_operation();
  init_tile();
  grayscaleToRGB = op({ grayscaleToRGB_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/rgb_to_grayscale.js
function rgbToGrayscale_(image) {
  const $image = convertToTensor(image, "image", "RGBToGrayscale");
  const lastDimsIdx = $image.rank - 1;
  const lastDims = $image.shape[lastDimsIdx];
  assert($image.rank >= 2, () => "Error in RGBToGrayscale: images must be at least rank 2, " + `but got rank ${$image.rank}.`);
  assert(lastDims === 3, () => "Error in RGBToGrayscale: last dimension of an RGB image " + `should be size 3, but got size ${lastDims}.`);
  const origDtype = $image.dtype;
  const fltImage = cast($image, "float32");
  const rgbWeights = tensor1d([0.2989, 0.587, 0.114]);
  let grayFloat;
  switch ($image.rank) {
    case 2:
      grayFloat = einsum("ij,j->i", fltImage, rgbWeights);
      break;
    case 3:
      grayFloat = einsum("ijk,k->ij", fltImage, rgbWeights);
      break;
    case 4:
      grayFloat = einsum("ijkl,l->ijk", fltImage, rgbWeights);
      break;
    case 5:
      grayFloat = einsum("ijklm,m->ijkl", fltImage, rgbWeights);
      break;
    case 6:
      grayFloat = einsum("ijklmn,n->ijklm", fltImage, rgbWeights);
      break;
    default:
      throw new Error("Not a valid tensor rank.");
  }
  grayFloat = expandDims(grayFloat, -1);
  return cast(grayFloat, origDtype);
}
var rgbToGrayscale;
var init_rgb_to_grayscale = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_cast();
  init_einsum();
  init_expand_dims();
  init_operation();
  init_tensor1d();
  rgbToGrayscale = op({ rgbToGrayscale_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/rotate_with_offset.js
function rotateWithOffset_(image, radians, fillValue = 0, center = 0.5) {
  const $image = convertToTensor(image, "image", "rotateWithOffset", "float32");
  assert($image.rank === 4, () => "Error in rotateWithOffset: image must be rank 4," + `but got rank ${$image.rank}.`);
  const inputs = { image: $image };
  const attrs = { radians, fillValue, center };
  const res = ENGINE.runKernel(RotateWithOffset, inputs, attrs);
  return res;
}
var rotateWithOffset;
var init_rotate_with_offset = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  rotateWithOffset = op({ rotateWithOffset_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/nonmax_util.js
function nonMaxSuppSanityCheck(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
  if (iouThreshold == null) {
    iouThreshold = 0.5;
  }
  if (scoreThreshold == null) {
    scoreThreshold = Number.NEGATIVE_INFINITY;
  }
  if (softNmsSigma == null) {
    softNmsSigma = 0;
  }
  const numBoxes = boxes.shape[0];
  maxOutputSize = Math.min(maxOutputSize, numBoxes);
  assert(0 <= iouThreshold && iouThreshold <= 1, () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);
  assert(boxes.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);
  assert(boxes.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);
  assert(scores.rank === 1, () => "scores must be a 1D tensor");
  assert(scores.shape[0] === numBoxes, () => `scores has incompatible shape with boxes. Expected ${numBoxes}, ` + `but was ${scores.shape[0]}`);
  assert(0 <= softNmsSigma && softNmsSigma <= 1, () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);
  return { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
}
var init_nonmax_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression.js
function nonMaxSuppression_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression", "float32");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression", "float32");
  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
  maxOutputSize = inputs.maxOutputSize;
  iouThreshold = inputs.iouThreshold;
  scoreThreshold = inputs.scoreThreshold;
  const attrs = { maxOutputSize, iouThreshold, scoreThreshold };
  return ENGINE.runKernel(NonMaxSuppressionV3, { boxes: $boxes, scores: $scores }, attrs);
}
var nonMaxSuppression;
var init_non_max_suppression = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_nonmax_util();
  init_operation();
  nonMaxSuppression = op({ nonMaxSuppression_ });
});

// node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js
function binaryInsert(arr, element, comparator) {
  const index = binarySearch(arr, element, comparator);
  const insertionPoint = index < 0 ? -(index + 1) : index;
  arr.splice(insertionPoint, 0, element);
}
function binarySearch(arr, target, comparator) {
  return binarySearch_(arr, target, comparator || defaultComparator);
}
function defaultComparator(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function binarySearch_(arr, target, comparator) {
  let left = 0;
  let right = arr.length;
  let middle = 0;
  let found = false;
  while (left < right) {
    middle = left + (right - left >>> 1);
    const compareResult = comparator(target, arr[middle]);
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      found = !compareResult;
    }
  }
  return found ? left : -left - 1;
}

// node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js
function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {
  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0);
}
function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {
  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0, false, padToMaxOutputSize, true);
}
function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {
  return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true);
}
function nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {
  const candidates = [];
  for (let i = 0;i < scores.length; i++) {
    if (scores[i] > scoreThreshold) {
      candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });
    }
  }
  candidates.sort(ascendingComparator);
  const scale = softNmsSigma > 0 ? -0.5 / softNmsSigma : 0;
  const selectedIndices = [];
  const selectedScores = [];
  while (selectedIndices.length < maxOutputSize && candidates.length > 0) {
    const candidate = candidates.pop();
    const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;
    if (originalScore < scoreThreshold) {
      break;
    }
    let ignoreCandidate = false;
    for (let j = selectedIndices.length - 1;j >= suppressBeginIndex; --j) {
      const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);
      if (iou >= iouThreshold) {
        ignoreCandidate = true;
        break;
      }
      candidate.score = candidate.score * suppressWeight(iouThreshold, scale, iou);
      if (candidate.score <= scoreThreshold) {
        break;
      }
    }
    candidate.suppressBeginIndex = selectedIndices.length;
    if (!ignoreCandidate) {
      if (candidate.score === originalScore) {
        selectedIndices.push(boxIndex);
        selectedScores.push(candidate.score);
      } else if (candidate.score > scoreThreshold) {
        binaryInsert(candidates, candidate, ascendingComparator);
      }
    }
  }
  const validOutputs = selectedIndices.length;
  const elemsToPad = maxOutputSize - validOutputs;
  if (padToMaxOutputSize && elemsToPad > 0) {
    selectedIndices.push(...new Array(elemsToPad).fill(0));
    selectedScores.push(...new Array(elemsToPad).fill(0));
  }
  const result = { selectedIndices };
  if (returnScoresTensor) {
    result["selectedScores"] = selectedScores;
  }
  if (returnValidOutputs) {
    result["validOutputs"] = validOutputs;
  }
  return result;
}
function intersectionOverUnion(boxes, i, j) {
  const iCoord = boxes.subarray(i * 4, i * 4 + 4);
  const jCoord = boxes.subarray(j * 4, j * 4 + 4);
  const yminI = Math.min(iCoord[0], iCoord[2]);
  const xminI = Math.min(iCoord[1], iCoord[3]);
  const ymaxI = Math.max(iCoord[0], iCoord[2]);
  const xmaxI = Math.max(iCoord[1], iCoord[3]);
  const yminJ = Math.min(jCoord[0], jCoord[2]);
  const xminJ = Math.min(jCoord[1], jCoord[3]);
  const ymaxJ = Math.max(jCoord[0], jCoord[2]);
  const xmaxJ = Math.max(jCoord[1], jCoord[3]);
  const areaI = (ymaxI - yminI) * (xmaxI - xminI);
  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);
  if (areaI <= 0 || areaJ <= 0) {
    return 0;
  }
  const intersectionYmin = Math.max(yminI, yminJ);
  const intersectionXmin = Math.max(xminI, xminJ);
  const intersectionYmax = Math.min(ymaxI, ymaxJ);
  const intersectionXmax = Math.min(xmaxI, xmaxJ);
  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0) * Math.max(intersectionXmax - intersectionXmin, 0);
  return intersectionArea / (areaI + areaJ - intersectionArea);
}
function suppressWeight(iouThreshold, scale, iou) {
  const weight = Math.exp(scale * iou * iou);
  return iou <= iouThreshold ? weight : 0;
}
function ascendingComparator(c1, c2) {
  return c1.score - c2.score || c1.score === c2.score && c2.boxIndex - c1.boxIndex;
}
var init_non_max_suppression_impl = () => {
};

// node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_async.js
async function nonMaxSuppressionAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const inputs = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);
  maxOutputSize = inputs.maxOutputSize;
  iouThreshold = inputs.iouThreshold;
  scoreThreshold = inputs.scoreThreshold;
  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
  const boxesVals = boxesAndScores[0];
  const scoresVals = boxesAndScores[1];
  const { selectedIndices } = nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return tensor1d(selectedIndices, "int32");
}
var nonMaxSuppressionAsync;
var init_non_max_suppression_async = __esm(() => {
  init_non_max_suppression_impl();
  init_tensor_util_env();
  init_nonmax_util();
  init_tensor1d();
  nonMaxSuppressionAsync = nonMaxSuppressionAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score.js
function nonMaxSuppressionWithScore_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  maxOutputSize = params.maxOutputSize;
  iouThreshold = params.iouThreshold;
  scoreThreshold = params.scoreThreshold;
  softNmsSigma = params.softNmsSigma;
  const inputs = { boxes: $boxes, scores: $scores };
  const attrs = { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma };
  const result = ENGINE.runKernel(NonMaxSuppressionV5, inputs, attrs);
  return { selectedIndices: result[0], selectedScores: result[1] };
}
var nonMaxSuppressionWithScore;
var init_non_max_suppression_with_score = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_nonmax_util();
  init_operation();
  nonMaxSuppressionWithScore = op({ nonMaxSuppressionWithScore_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_with_score_async.js
async function nonMaxSuppressionWithScoreAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, softNmsSigma = 0) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  maxOutputSize = params.maxOutputSize;
  iouThreshold = params.iouThreshold;
  scoreThreshold = params.scoreThreshold;
  softNmsSigma = params.softNmsSigma;
  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);
  const boxesVals = boxesAndScores[0];
  const scoresVals = boxesAndScores[1];
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return {
    selectedIndices: tensor1d(selectedIndices, "int32"),
    selectedScores: tensor1d(selectedScores)
  };
}
var nonMaxSuppressionWithScoreAsync;
var init_non_max_suppression_with_score_async = __esm(() => {
  init_non_max_suppression_impl();
  init_tensor_util_env();
  init_nonmax_util();
  init_tensor1d();
  nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded.js
function nonMaxSuppressionPadded_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppression");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppression");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
  const $maxOutputSize = params.maxOutputSize;
  const $iouThreshold = params.iouThreshold;
  const $scoreThreshold = params.scoreThreshold;
  const inputs = { boxes: $boxes, scores: $scores };
  const attrs = {
    maxOutputSize: $maxOutputSize,
    iouThreshold: $iouThreshold,
    scoreThreshold: $scoreThreshold,
    padToMaxOutputSize
  };
  const result = ENGINE.runKernel(NonMaxSuppressionV4, inputs, attrs);
  return { selectedIndices: result[0], validOutputs: result[1] };
}
var nonMaxSuppressionPadded;
var init_non_max_suppression_padded = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_nonmax_util();
  init_operation();
  nonMaxSuppressionPadded = op({ nonMaxSuppressionPadded_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/non_max_suppression_padded_async.js
async function nonMaxSuppressionPaddedAsync_(boxes, scores, maxOutputSize, iouThreshold = 0.5, scoreThreshold = Number.NEGATIVE_INFINITY, padToMaxOutputSize = false) {
  const $boxes = convertToTensor(boxes, "boxes", "nonMaxSuppressionAsync");
  const $scores = convertToTensor(scores, "scores", "nonMaxSuppressionAsync");
  const params = nonMaxSuppSanityCheck($boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold, null);
  const $maxOutputSize = params.maxOutputSize;
  const $iouThreshold = params.iouThreshold;
  const $scoreThreshold = params.scoreThreshold;
  const [boxesVals, scoresVals] = await Promise.all([$boxes.data(), $scores.data()]);
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl(boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold, padToMaxOutputSize);
  if ($boxes !== boxes) {
    $boxes.dispose();
  }
  if ($scores !== scores) {
    $scores.dispose();
  }
  return {
    selectedIndices: tensor1d(selectedIndices, "int32"),
    validOutputs: scalar(validOutputs, "int32")
  };
}
var nonMaxSuppressionPaddedAsync;
var init_non_max_suppression_padded_async = __esm(() => {
  init_non_max_suppression_impl();
  init_tensor_util_env();
  init_nonmax_util();
  init_scalar();
  init_tensor1d();
  nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_bilinear.js
function resizeBilinear_(images, size, alignCorners = false, halfPixelCenters = false) {
  const $images = convertToTensor(images, "images", "resizeBilinear");
  assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` + `rank ${$images.rank}.`);
  assert(size.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ` + `${size}.`);
  assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeBilinear: If halfPixelCenters is true, ` + `alignCorners must be false.`);
  let batchImages = $images;
  let reshapedTo4D = false;
  if ($images.rank === 3) {
    reshapedTo4D = true;
    batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
  }
  const [] = size;
  const inputs = { images: batchImages };
  const attrs = { alignCorners, halfPixelCenters, size };
  const res = ENGINE.runKernel(ResizeBilinear, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var resizeBilinear;
var init_resize_bilinear = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reshape();
  resizeBilinear = op({ resizeBilinear_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/resize_nearest_neighbor.js
function resizeNearestNeighbor_(images, size, alignCorners = false, halfPixelCenters = false) {
  const $images = convertToTensor(images, "images", "resizeNearestNeighbor");
  assert($images.rank === 3 || $images.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` + `rank ${$images.rank}.`);
  assert(size.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` + `${size}.`);
  assert($images.dtype === "float32" || $images.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype");
  assert(halfPixelCenters === false || alignCorners === false, () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, ` + `alignCorners must be false.`);
  let batchImages = $images;
  let reshapedTo4D = false;
  if ($images.rank === 3) {
    reshapedTo4D = true;
    batchImages = reshape($images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);
  }
  const [] = size;
  const inputs = { images: batchImages };
  const attrs = { alignCorners, halfPixelCenters, size };
  const res = ENGINE.runKernel(ResizeNearestNeighbor, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var resizeNearestNeighbor;
var init_resize_nearest_neighbor = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reshape();
  resizeNearestNeighbor = op({ resizeNearestNeighbor_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/threshold.js
function threshold_(image, method = "binary", inverted = false, threshValue = 0.5) {
  const $image = convertToTensor(image, "image", "threshold");
  const RED_INTENCITY_COEF = 0.2989;
  const GREEN_INTENCITY_COEF = 0.587;
  const BLUE_INTENCITY_COEF = 0.114;
  const totalPixelsInImage = $image.shape[0] * $image.shape[1];
  let $threshold = mul(tensor1d([threshValue]), 255);
  let r, g, b, grayscale;
  assert($image.rank === 3, () => "Error in threshold: image must be rank 3," + `but got rank ${$image.rank}.`);
  assert($image.shape[2] === 3 || $image.shape[2] === 1, () => "Error in threshold: " + "image color channel must be equal to 3 or 1" + `but got ${$image.shape[2]}.`);
  assert($image.dtype === "int32" || $image.dtype === "float32", () => "Error in dtype: image dtype must be int32 or float32," + `but got dtype ${$image.dtype}.`);
  assert(method === "otsu" || method === "binary", () => `Method must be binary or otsu, but was ${method}`);
  if ($image.shape[2] === 3) {
    [r, g, b] = split($image, [1, 1, 1], -1);
    const $r = mul(r, RED_INTENCITY_COEF);
    const $g = mul(g, GREEN_INTENCITY_COEF);
    const $b = mul(b, BLUE_INTENCITY_COEF);
    grayscale = add2(add2($r, $g), $b);
  } else {
    grayscale = image;
  }
  if (method === "otsu") {
    const $histogram = bincount(cast(round2(grayscale), "int32"), tensor4([]), 256);
    $threshold = otsu($histogram, totalPixelsInImage);
  }
  const invCondition = inverted ? lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);
  const result = cast(mul(invCondition, 255), "int32");
  return result;
}
function otsu(histogram, total) {
  let bestThresh = tensor1d([-1]);
  let bestInBetVar = tensor1d([0]);
  let cInBetVar = tensor1d([0]);
  let classFirst, classSecond, meanFirst, meanSec, weightForeground, weightBack;
  for (let index = 0;index < histogram.size - 1; index++) {
    classFirst = slice(histogram, 0, index + 1);
    classSecond = slice(histogram, index + 1);
    weightForeground = div(sum2(classFirst), total);
    weightBack = div(sum2(classSecond), total);
    const meanFirstDivA = sum2(mul(classFirst, range(0, classFirst.size)));
    meanFirst = div(meanFirstDivA, sum2(classFirst));
    const meanSecFill = fill(classSecond.shape, classFirst.size);
    const meanSecAdd = add2(range(0, classSecond.size), meanSecFill);
    const meanSecMul = mul(classSecond, meanSecAdd);
    meanSec = div(sum2(meanSecMul), sum2(classSecond));
    const cInBetVarSubA = sub(meanFirst, meanSec);
    const cInBetVarSubB = sub(meanFirst, meanSec);
    const cInBetVarMul = mul(weightForeground, weightBack);
    cInBetVar = mul(mul(cInBetVarMul, cInBetVarSubA), cInBetVarSubB);
    const condition = greater(cInBetVar, bestInBetVar);
    bestInBetVar = where(condition, cInBetVar, bestInBetVar);
    bestThresh = where(condition, tensor1d([index]), bestThresh);
  }
  return bestThresh;
}
var threshold;
var init_threshold = __esm(() => {
  init_tensor1d();
  init_operation();
  init_cast();
  init_split();
  init_bincount();
  init_less_equal();
  init_greater();
  init_sum();
  init_add();
  init_mul();
  init_div();
  init_sub();
  init_round();
  init_where();
  init_fill();
  init_slice();
  init_range();
  init_tensor2();
  init_util();
  init_tensor_util_env();
  threshold = op({ threshold_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/image/transform.js
function transform_(image, transforms, interpolation = "nearest", fillMode = "constant", fillValue = 0, outputShape) {
  const $image = convertToTensor(image, "image", "transform", "float32");
  const $transforms = convertToTensor(transforms, "transforms", "transform", "float32");
  assert($image.rank === 4, () => "Error in transform: image must be rank 4," + `but got rank ${$image.rank}.`);
  assert($transforms.rank === 2 && ($transforms.shape[0] === $image.shape[0] || $transforms.shape[0] === 1) && $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
  assert(outputShape == null || outputShape.length === 2, () => "Error in transform: outputShape must be [height, width] or null, " + `but got ${outputShape}.`);
  const inputs = { image: $image, transforms: $transforms };
  const attrs = { interpolation, fillMode, fillValue, outputShape };
  return ENGINE.runKernel(Transform, inputs, attrs);
}
var transform;
var init_transform = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  transform = op({ transform_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/linalg/band_part.js
function bandPart_(a, numLower, numUpper) {
  const $a = convertToTensor(a, "a", "bandPart");
  assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
  const shape = $a.shape;
  const [M, N4] = $a.shape.slice(-2);
  let $numLower;
  let $numUpper;
  if (typeof numLower === "number") {
    assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
    assert(numLower <= M, () => `bandPart(): numLower (${numLower})` + ` must not be greater than the number of rows (${M}).`);
    $numLower = convertToTensor(numLower < 0 ? M : numLower, "numLower", "bandPart");
  } else {
    assert(numLower.dtype === "int32", () => `bandPart(): numLower's dtype must be an int32.`);
    $numLower = where(less(numLower, 0), M, minimum(numLower, M));
  }
  if (typeof numUpper === "number") {
    assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
    assert(numUpper <= N4, () => `bandPart(): numUpper (${numUpper})` + ` must not be greater than the number of columns (${N4}).`);
    $numUpper = convertToTensor(numUpper < 0 ? N4 : numUpper, "numUpper", "bandPart");
  } else {
    assert(numUpper.dtype === "int32", () => `bandPart(): numUpper's dtype must be an int32.`);
    $numUpper = where(less(numUpper, 0), N4, minimum(numUpper, N4));
  }
  const i = reshape(range(0, M, 1, "int32"), [-1, 1]);
  const j = range(0, N4, 1, "int32");
  const ij = sub(i, j);
  const inBand = logicalAnd(lessEqual(ij, $numLower), greaterEqual(ij, neg($numUpper)));
  const zero = zeros([M, N4], $a.dtype);
  return reshape(stack(unstack(reshape($a, [-1, M, N4])).map((mat) => where(inBand, mat, zero))), shape);
}
var bandPart;
var init_band_part = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_greater_equal();
  init_less();
  init_less_equal();
  init_logical_and();
  init_minimum();
  init_neg();
  init_operation();
  init_range();
  init_reshape();
  init_stack();
  init_sub();
  init_unstack();
  init_where();
  init_zeros();
  bandPart = op({ bandPart_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/linalg/gram_schmidt.js
function gramSchmidt_(xs) {
  let inputIsTensor2D;
  if (Array.isArray(xs)) {
    inputIsTensor2D = false;
    assert(xs != null && xs.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or " + "empty");
    const dim = xs[0].shape[0];
    for (let i = 1;i < xs.length; ++i) {
      assert(xs[i].shape[0] === dim, () => "Gram-Schmidt: Non-unique lengths found in the input vectors: " + `(${xs[i].shape[0]} vs. ${dim})`);
    }
  } else {
    inputIsTensor2D = true;
    xs = split(xs, xs.shape[0], 0).map((x) => squeeze(x, [0]));
  }
  assert(xs.length <= xs[0].shape[0], () => `Gram-Schmidt: Number of vectors (${xs.length}) exceeds ` + `number of dimensions (${xs[0].shape[0]}).`);
  const ys = [];
  const xs1d = xs;
  for (let i = 0;i < xs.length; ++i) {
    ys.push(ENGINE.tidy(() => {
      let x = xs1d[i];
      if (i > 0) {
        for (let j = 0;j < i; ++j) {
          const proj = mul(sum2(mul(ys[j], x)), ys[j]);
          x = sub(x, proj);
        }
      }
      return div(x, norm(x, "euclidean"));
    }));
  }
  if (inputIsTensor2D) {
    return stack(ys, 0);
  } else {
    return ys;
  }
}
var gramSchmidt;
var init_gram_schmidt = __esm(() => {
  init_engine();
  init_util();
  init_div();
  init_mul();
  init_norm();
  init_operation();
  init_split();
  init_squeeze();
  init_stack();
  init_sub();
  init_sum();
  gramSchmidt = op({ gramSchmidt_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/linalg/qr.js
function qr_(x, fullMatrices = false) {
  assert(x.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${x.rank}`);
  if (x.rank === 2) {
    return qr2d(x, fullMatrices);
  } else {
    const outerDimsProd = x.shape.slice(0, x.shape.length - 2).reduce((value, prev) => value * prev);
    const x2ds = unstack(reshape(x, [
      outerDimsProd,
      x.shape[x.shape.length - 2],
      x.shape[x.shape.length - 1]
    ]), 0);
    const q2ds = [];
    const r2ds = [];
    x2ds.forEach((x2d) => {
      const [q2d, r2d] = qr2d(x2d, fullMatrices);
      q2ds.push(q2d);
      r2ds.push(r2d);
    });
    const q = reshape(stack(q2ds, 0), x.shape);
    const r = reshape(stack(r2ds, 0), x.shape);
    return [q, r];
  }
}
function qr2d(x, fullMatrices = false) {
  return ENGINE.tidy(() => {
    assert(x.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${x.shape.length}D Tensor.`);
    const m = x.shape[0];
    const n = x.shape[1];
    let q = eye(m);
    let r = clone(x);
    const one2D = tensor2d([[1]], [1, 1]);
    let w = clone(one2D);
    const iters = m >= n ? n : m;
    for (let j = 0;j < iters; ++j) {
      const rTemp = r;
      const wTemp = w;
      const qTemp = q;
      [w, r, q] = ENGINE.tidy(() => {
        const rjEnd1 = slice(r, [j, j], [m - j, 1]);
        const normX = norm(rjEnd1);
        const rjj = slice(r, [j, j], [1, 1]);
        const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));
        const u1 = sub(rjj, mul(s, normX));
        const wPre = div(rjEnd1, u1);
        if (wPre.shape[0] === 1) {
          w = clone(one2D);
        } else {
          w = concat([
            one2D,
            slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]])
          ], 0);
        }
        const tau = neg(div(matMul(s, u1), normX));
        const rjEndAll = slice(r, [j, 0], [m - j, n]);
        const tauTimesW = mul(tau, w);
        const wT = transpose(w);
        if (j === 0) {
          r = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
        } else {
          const rTimesTau = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));
          r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);
        }
        const tawTimesWT = transpose(tauTimesW);
        const qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);
        if (j === 0) {
          q = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
        } else {
          const qTimesTau = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));
          q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);
        }
        return [w, r, q];
      });
      dispose([rTemp, wTemp, qTemp]);
    }
    if (!fullMatrices && m > n) {
      q = slice(q, [0, 0], [m, n]);
      r = slice(r, [0, 0], [n, n]);
    }
    return [q, r];
  });
}
var qr;
var init_qr = __esm(() => {
  init_engine();
  init_globals();
  init_util();
  init_clone();
  init_concat();
  init_div();
  init_eye();
  init_greater();
  init_mat_mul();
  init_mul();
  init_neg();
  init_norm();
  init_operation();
  init_reshape();
  init_slice();
  init_stack();
  init_sub();
  init_tensor2d();
  init_transpose();
  init_unstack();
  init_where();
  qr = op({ qr_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/loss_ops_utils.js
var Reduction;
var init_loss_ops_utils = __esm(() => {
  (function(Reduction2) {
    Reduction2[Reduction2["NONE"] = 0] = "NONE";
    Reduction2[Reduction2["MEAN"] = 1] = "MEAN";
    Reduction2[Reduction2["SUM"] = 2] = "SUM";
    Reduction2[Reduction2["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
  })(Reduction || (Reduction = {}));
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/compute_weighted_loss.js
function computeWeightedLoss_(losses, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $losses = convertToTensor(losses, "losses", "computeWeightedLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "computeWeightedLoss");
  }
  const weightedLoss = $weights == null ? $losses : mul($losses, $weights);
  if (reduction === Reduction.NONE) {
    return weightedLoss;
  }
  if (reduction === Reduction.SUM) {
    return sum2(weightedLoss);
  }
  if (reduction === Reduction.MEAN) {
    if ($weights == null) {
      return mean(weightedLoss);
    } else {
      const broadcastFactor = $losses.size / $weights.size;
      const result = div(sum2(weightedLoss), sum2($weights));
      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) : result;
    }
  }
  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {
    if ($weights == null) {
      return div(sum2(weightedLoss), scalar($losses.size));
    } else {
      const broadcastedWeights = mul($weights, ones2($losses.shape));
      const numNonZeros = cast(sum2(notEqual(broadcastedWeights, scalar(0))), "float32");
      return div(sum2(weightedLoss), numNonZeros);
    }
  }
  throw Error(`Unknown reduction: ${reduction}`);
}
var computeWeightedLoss;
var init_compute_weighted_loss = __esm(() => {
  init_tensor_util_env();
  init_cast();
  init_div();
  init_loss_ops_utils();
  init_mean();
  init_mul();
  init_not_equal();
  init_ones();
  init_operation();
  init_scalar();
  init_sum();
  computeWeightedLoss = op({ computeWeightedLoss_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/absolute_difference.js
function absoluteDifference_(labels, predictions, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "absoluteDifference");
  const $predictions = convertToTensor(predictions, "predictions", "absoluteDifference");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "absoluteDifference");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in absoluteDifference: ");
  const losses = abs(sub($labels, $predictions));
  return computeWeightedLoss(losses, $weights, reduction);
}
var absoluteDifference;
var init_absolute_difference = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_abs();
  init_loss_ops_utils();
  init_operation();
  init_sub();
  init_compute_weighted_loss();
  absoluteDifference = op({ absoluteDifference_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/cosine_distance.js
function cosineDistance_(labels, predictions, axis, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "cosineDistance");
  const $predictions = convertToTensor(predictions, "predictions", "cosineDistance");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "cosineDistance");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in cosineDistance: ");
  const one = scalar(1);
  const losses = sub(one, sum2(mul($labels, $predictions), axis, true));
  return computeWeightedLoss(losses, $weights, reduction);
}
var cosineDistance;
var init_cosine_distance = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_loss_ops_utils();
  init_mul();
  init_operation();
  init_scalar();
  init_sub();
  init_sum();
  init_compute_weighted_loss();
  cosineDistance = op({ cosineDistance_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/hinge_loss.js
function hingeLoss_(labels, predictions, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $labels = convertToTensor(labels, "labels", "hingeLoss");
  const $predictions = convertToTensor(predictions, "predictions", "hingeLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "hingeLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in hingeLoss: ");
  const one = scalar(1);
  $labels = sub(mul(scalar(2), $labels), one);
  const losses = relu(sub(one, mul($labels, $predictions)));
  return computeWeightedLoss(losses, $weights, reduction);
}
var hingeLoss;
var init_hinge_loss = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_loss_ops_utils();
  init_mul();
  init_operation();
  init_relu();
  init_scalar();
  init_sub();
  init_compute_weighted_loss();
  hingeLoss = op({ hingeLoss_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/huber_loss.js
function huberLoss_(labels, predictions, weights, delta = 1, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "huberLoss");
  const $predictions = convertToTensor(predictions, "predictions", "huberLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "huberLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in huberLoss: ");
  const deltaScalar = scalar(delta);
  const error = abs(sub($predictions, $labels));
  const quadratic = minimum(error, deltaScalar);
  const linear = sub(error, quadratic);
  const losses = add2(mul(scalar(0.5), square(quadratic)), mul(deltaScalar, linear));
  return computeWeightedLoss(losses, $weights, reduction);
}
var huberLoss;
var init_huber_loss = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_abs();
  init_add();
  init_loss_ops_utils();
  init_minimum();
  init_mul();
  init_operation();
  init_scalar();
  init_square();
  init_sub();
  init_compute_weighted_loss();
  huberLoss = op({ huberLoss_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/log_loss.js
function logLoss_(labels, predictions, weights, epsilon = 0.0000001, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "logLoss");
  const $predictions = convertToTensor(predictions, "predictions", "logLoss");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "logLoss");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in logLoss: ");
  const one = scalar(1);
  const epsilonScalar = scalar(epsilon);
  const l1 = neg(mul($labels, log2(add2($predictions, epsilonScalar))));
  const l2 = mul(sub(one, $labels), log2(add2(sub(one, $predictions), epsilonScalar)));
  const losses = sub(l1, l2);
  return computeWeightedLoss(losses, $weights, reduction);
}
var logLoss;
var init_log_loss = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_add();
  init_log2();
  init_loss_ops_utils();
  init_mul();
  init_neg();
  init_operation();
  init_scalar();
  init_sub();
  init_compute_weighted_loss();
  logLoss = op({ logLoss_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/mean_squared_error.js
function meanSquaredError_(labels, predictions, weights, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  const $labels = convertToTensor(labels, "labels", "meanSquaredError");
  const $predictions = convertToTensor(predictions, "predictions", "meanSquaredError");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "meanSquaredError");
  }
  assertShapesMatch($labels.shape, $predictions.shape, "Error in meanSquaredError: ");
  const losses = squaredDifference($labels, $predictions);
  return computeWeightedLoss(losses, $weights, reduction);
}
var meanSquaredError;
var init_mean_squared_error = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_loss_ops_utils();
  init_operation();
  init_squared_difference();
  init_compute_weighted_loss();
  meanSquaredError = op({ meanSquaredError_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/sigmoid_cross_entropy.js
function sigmoidCrossEntropyWithLogits_(labels, logits) {
  const $labels = convertToTensor(labels, "labels", "sigmoidCrossEntropyWithLogits");
  const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropyWithLogits");
  assertShapesMatch($labels.shape, $logits.shape, "Error in sigmoidCrossEntropyWithLogits: ");
  const maxOutput = relu($logits);
  const outputXTarget = mul($logits, $labels);
  const sigmoidOutput = log1p(exp(neg(abs($logits))));
  return add2(sub(maxOutput, outputXTarget), sigmoidOutput);
}
function sigmoidCrossEntropy_(multiClassLabels, logits, weights, labelSmoothing = 0, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $multiClassLabels = convertToTensor(multiClassLabels, "multiClassLabels", "sigmoidCrossEntropy");
  const $logits = convertToTensor(logits, "logits", "sigmoidCrossEntropy");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "sigmoidCrossEntropy");
  }
  assertShapesMatch($multiClassLabels.shape, $logits.shape, "Error in sigmoidCrossEntropy: ");
  if (labelSmoothing > 0) {
    const labelSmoothingScalar = scalar(labelSmoothing);
    const one = scalar(1);
    const half = scalar(0.5);
    $multiClassLabels = add2(mul($multiClassLabels, sub(one, labelSmoothingScalar)), mul(half, labelSmoothingScalar));
  }
  const losses = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);
  return computeWeightedLoss(losses, $weights, reduction);
}
var sigmoidCrossEntropy;
var init_sigmoid_cross_entropy = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_abs();
  init_add();
  init_exp();
  init_log1p();
  init_loss_ops_utils();
  init_mul();
  init_neg();
  init_operation();
  init_relu();
  init_scalar();
  init_sub();
  init_compute_weighted_loss();
  sigmoidCrossEntropy = op({ sigmoidCrossEntropy_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/losses/softmax_cross_entropy.js
function softmaxCrossEntropyWithLogits_(labels, logits, dim = -1) {
  if (dim === -1) {
    dim = logits.rank - 1;
  }
  if (dim !== logits.rank - 1) {
    throw Error(`Softmax cross entropy along a non-last dimension is not yet ` + `supported. Labels / logits was rank ${logits.rank} ` + `and dim was ${dim}`);
  }
  const customOp = customGrad((labels2, logits2, save) => {
    const keepDims = true;
    const lse = logSumExp(logits2, [dim], keepDims);
    const logResult = sub(cast(logits2, "float32"), lse);
    save([labels2, logResult]);
    const costVector = neg(mul(logResult, labels2));
    const value = sum2(costVector, [dim]);
    const gradFunc = (dy2, saved) => {
      const [labels3, logResult2] = saved;
      const dyShape = expandShapeToKeepDim(dy2.shape, [dim]);
      return [
        mul(reshape(dy2, dyShape), sub(cast(labels3, "float32"), exp(logResult2))),
        mul(reshape(dy2, dyShape), sub(exp(logResult2), cast(labels3, "float32")))
      ];
    };
    return { value, gradFunc };
  });
  return customOp(labels, logits);
}
function softmaxCrossEntropy_(onehotLabels, logits, weights, labelSmoothing = 0, reduction = Reduction.SUM_BY_NONZERO_WEIGHTS) {
  let $onehotLabels = convertToTensor(onehotLabels, "onehotLabels", "softmaxCrossEntropy");
  const $logits = convertToTensor(logits, "logits", "softmaxCrossEntropy");
  let $weights = null;
  if (weights != null) {
    $weights = convertToTensor(weights, "weights", "softmaxCrossEntropy");
  }
  assertShapesMatch($onehotLabels.shape, $logits.shape, "Error in softmaxCrossEntropy: ");
  if (labelSmoothing > 0) {
    const labelSmoothingScalar = scalar(labelSmoothing);
    const one = scalar(1);
    const numClasses = scalar($onehotLabels.shape[1]);
    $onehotLabels = add2(mul($onehotLabels, sub(one, labelSmoothingScalar)), div(labelSmoothingScalar, numClasses));
  }
  const losses = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);
  return computeWeightedLoss(losses, $weights, reduction);
}
var softmaxCrossEntropy;
var init_softmax_cross_entropy = __esm(() => {
  init_gradients();
  init_tensor_util_env();
  init_util();
  init_add();
  init_axis_util();
  init_cast();
  init_div();
  init_exp();
  init_log_sum_exp();
  init_loss_ops_utils();
  init_mul();
  init_neg();
  init_operation();
  init_reshape();
  init_scalar();
  init_sub();
  init_sum();
  init_compute_weighted_loss();
  softmaxCrossEntropy = op({ softmaxCrossEntropy_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows.js
function sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {
  const $indices = convertToTensor(indices, "indices", "sparseFillEmptyRows", "int32");
  const $values = convertToTensor(values, "values", "sparseFillEmptyRows");
  const $denseShape = convertToTensor(denseShape, "denseShape", "sparseFillEmptyRows", "int32");
  const $defaultValue = convertToTensor(defaultValue, "defaultValue", "sparseFillEmptyRows", $values.dtype);
  if ($indices.rank !== 2) {
    throw new Error(`Indices should be Tensor2D but received shape
        ${$indices.shape}`);
  }
  if ($values.rank !== 1) {
    throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);
  }
  if ($denseShape.rank !== 1) {
    throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);
  }
  if ($defaultValue.rank !== 0) {
    throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);
  }
  const inputs = {
    indices: $indices,
    values: $values,
    denseShape: $denseShape,
    defaultValue: $defaultValue
  };
  const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);
  return {
    outputIndices: result[0],
    outputValues: result[1],
    emptyRowIndicator: result[2],
    reverseIndexMap: result[3]
  };
}
var sparseFillEmptyRows;
var init_sparse_fill_empty_rows = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sparseFillEmptyRows = op({ sparseFillEmptyRows_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape.js
function sparseReshape_(inputIndices, inputShape, newShape) {
  const $inputIndices = convertToTensor(inputIndices, "inputIndices", "sparseReshape", "int32");
  const $inputShape = convertToTensor(inputShape, "inputShape", "sparseReshape", "int32");
  const $newShape = convertToTensor(newShape, "newShape", "sparseReshape", "int32");
  if ($inputIndices.rank !== 2) {
    throw new Error(`Input indices should be Tensor2D but received shape
        ${$inputIndices.shape}`);
  }
  if ($inputShape.rank !== 1) {
    throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);
  }
  if ($newShape.rank !== 1) {
    throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);
  }
  const inputs = {
    inputIndices: $inputIndices,
    inputShape: $inputShape,
    newShape: $newShape
  };
  const result = ENGINE.runKernel(SparseReshape, inputs);
  return { outputIndices: result[0], outputShape: result[1] };
}
var sparseReshape;
var init_sparse_reshape = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sparseReshape = op({ sparseReshape_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_mean.js
function sparseSegmentMean_(data, indices, segmentIds) {
  const $data = convertToTensor(data, "data", "sparseSegmentMean");
  const $indices = convertToTensor(indices, "indices", "sparseSegmentMean", "int32");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentMean", "int32");
  if ($data.rank < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if ($indices.rank !== 1) {
    throw new Error(`Indices should be Tensor1D but received shape
          ${$indices.shape}`);
  }
  if ($segmentIds.rank !== 1) {
    throw new Error(`Segment ids should be Tensor1D but received shape
          ${$segmentIds.shape}`);
  }
  const inputs = {
    data: $data,
    indices: $indices,
    segmentIds: $segmentIds
  };
  return ENGINE.runKernel(SparseSegmentMean, inputs);
}
var sparseSegmentMean;
var init_sparse_segment_mean = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sparseSegmentMean = op({ sparseSegmentMean_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_sum.js
function sparseSegmentSum_(data, indices, segmentIds) {
  const $data = convertToTensor(data, "data", "sparseSegmentSum");
  const $indices = convertToTensor(indices, "indices", "sparseSegmentSum", "int32");
  const $segmentIds = convertToTensor(segmentIds, "segmentIds", "sparseSegmentSum", "int32");
  if ($data.rank < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if ($indices.rank !== 1) {
    throw new Error(`Indices should be Tensor1D but received shape
         ${$indices.shape}`);
  }
  if ($segmentIds.rank !== 1) {
    throw new Error(`Segment ids should be Tensor1D but received shape
         ${$segmentIds.shape}`);
  }
  const inputs = {
    data: $data,
    indices: $indices,
    segmentIds: $segmentIds
  };
  return ENGINE.runKernel(SparseSegmentSum, inputs);
}
var sparseSegmentSum;
var init_sparse_segment_sum = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  sparseSegmentSum = op({ sparseSegmentSum_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/string/string_n_grams.js
function stringNGrams_(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
  const $data = convertToTensor(data, "data", "stringNGrams", "string");
  if ($data.dtype !== "string") {
    throw new Error("Data must be of datatype string");
  }
  if ($data.shape.length !== 1) {
    throw new Error(`Data must be a vector, saw: ${$data.shape}`);
  }
  const $dataSplits = convertToTensor(dataSplits, "dataSplits", "stringNGrams");
  if ($dataSplits.dtype !== "int32") {
    throw new Error("Data splits must be of datatype int32");
  }
  const attrs = {
    separator,
    nGramWidths,
    leftPad,
    rightPad: rightPad2,
    padWidth,
    preserveShortSequences
  };
  const inputs = { data: $data, dataSplits: $dataSplits };
  const result = ENGINE.runKernel(StringNGrams, inputs, attrs);
  return { nGrams: result[0], nGramsSplits: result[1] };
}
var stringNGrams;
var init_string_n_grams = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  stringNGrams = op({ stringNGrams_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/string/string_split.js
function stringSplit_(input, delimiter, skipEmpty = true) {
  const $input = convertToTensor(input, "input", "stringSplit", "string");
  const $delimiter = convertToTensor(delimiter, "delimiter", "stringSplit", "string");
  if ($input.rank !== 1) {
    throw new Error(`Input should be Tensor1D but received shape ${$input.shape}`);
  }
  if ($delimiter.rank !== 0) {
    throw new Error(`Delimiter should be a scalar but received shape ${$delimiter.shape}`);
  }
  const attrs = { skipEmpty };
  const inputs = { input: $input, delimiter: $delimiter };
  const result = ENGINE.runKernel(StringSplit, inputs, attrs);
  return { indices: result[0], values: result[1], shape: result[2] };
}
var stringSplit;
var init_string_split = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  stringSplit = op({ stringSplit_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/string/string_to_hash_bucket_fast.js
function stringToHashBucketFast_(input, numBuckets) {
  const $input = convertToTensor(input, "input", "stringToHashBucketFast", "string");
  const attrs = { numBuckets };
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const inputs = { input: $input };
  return ENGINE.runKernel(StringToHashBucketFast, inputs, attrs);
}
var stringToHashBucketFast;
var init_string_to_hash_bucket_fast = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  stringToHashBucketFast = op({ stringToHashBucketFast_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/string/static_regex_replace.js
function staticRegexReplace_(input, pattern, rewrite, replaceGlobal = true) {
  const $input = convertToTensor(input, "input", "staticRegexReplace", "string");
  const attrs = { pattern, rewrite, replaceGlobal };
  return ENGINE.runKernel(StaticRegexReplace, { x: $input }, attrs);
}
var staticRegexReplace;
var init_static_regex_replace = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_operation();
  staticRegexReplace = op({ staticRegexReplace_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ops.js
var spectral, signal, image, linalg, losses, sparse, string;
var init_ops = __esm(() => {
  init_abs();
  init_acos();
  init_acosh();
  init_add();
  init_add_n();
  init_all();
  init_any();
  init_arg_max();
  init_arg_min();
  init_asin();
  init_asinh();
  init_atan();
  init_atan2();
  init_atanh();
  init_avg_pool();
  init_avg_pool_3d();
  init_basic_lstm_cell();
  init_batch_to_space_nd();
  init_batchnorm();
  init_batchnorm2d();
  init_batchnorm3d();
  init_batchnorm4d();
  init_bincount();
  init_bitwise_and();
  init_broadcast_args();
  init_broadcast_to();
  init_buffer();
  init_cast();
  init_ceil();
  init_clip_by_value();
  init_clone();
  init_complex();
  init_concat();
  init_concat_1d();
  init_concat_2d();
  init_concat_3d();
  init_concat_4d();
  init_conv1d();
  init_conv2d();
  init_conv2d_transpose();
  init_conv3d();
  init_conv3d_transpose();
  init_cos();
  init_cosh();
  init_cumprod();
  init_cumsum();
  init_dense_bincount();
  init_depth_to_space();
  init_depthwise_conv2d();
  init_diag();
  init_dilation2d();
  init_div();
  init_div_no_nan();
  init_dot();
  init_einsum();
  init_elu();
  init_ensure_shape();
  init_equal();
  init_erf();
  init_euclidean_norm();
  init_exp();
  init_expand_dims();
  init_expm1();
  init_eye();
  init_fill();
  init_floor();
  init_floorDiv();
  init_gather();
  init_greater();
  init_greater_equal();
  init_imag();
  init_is_finite();
  init_is_inf();
  init_is_nan();
  init_leaky_relu();
  init_less();
  init_less_equal();
  init_linspace();
  init_local_response_normalization();
  init_log2();
  init_log1p();
  init_log_sigmoid();
  init_log_softmax();
  init_log_sum_exp();
  init_logical_and();
  init_logical_not();
  init_logical_or();
  init_logical_xor();
  init_lower_bound();
  init_mat_mul();
  init_max();
  init_max_pool();
  init_max_pool_3d();
  init_max_pool_with_argmax();
  init_maximum();
  init_mean();
  init_meshgrid();
  init_min();
  init_minimum();
  init_mirror_pad();
  init_mod();
  init_moments();
  init_mul();
  init_multi_rnn_cell();
  init_multinomial();
  init_neg();
  init_not_equal();
  init_one_hot();
  init_ones();
  init_ones_like();
  init_outer_product();
  init_pad();
  init_pad1d();
  init_pad2d();
  init_pad3d();
  init_pad4d();
  init_pool();
  init_pow();
  init_prelu();
  init_prod();
  init_ragged_gather();
  init_ragged_range();
  init_ragged_tensor_to_tensor();
  init_rand();
  init_random_gamma();
  init_random_normal();
  init_random_standard_normal();
  init_random_uniform();
  init_random_uniform_int();
  init_range();
  init_real();
  init_reciprocal();
  init_relu();
  init_relu6();
  init_reshape();
  init_reverse();
  init_reverse_1d();
  init_reverse_2d();
  init_reverse_3d();
  init_reverse_4d();
  init_round();
  init_rsqrt();
  init_scalar();
  init_selu();
  init_separable_conv2d();
  init_setdiff1d_async();
  init_sigmoid();
  init_sign();
  init_sin();
  init_sinh();
  init_slice();
  init_slice1d();
  init_slice2d();
  init_slice3d();
  init_slice4d();
  init_softmax();
  init_softplus();
  init_space_to_batch_nd();
  init_fft();
  init_ifft();
  init_irfft();
  init_rfft();
  init_split();
  init_sqrt();
  init_square();
  init_squared_difference();
  init_squeeze();
  init_stack();
  init_step();
  init_strided_slice();
  init_sub();
  init_sum();
  init_tan();
  init_tanh();
  init_tensor2();
  init_tensor1d();
  init_tensor2d();
  init_tensor3d();
  init_tensor4d();
  init_tensor5d();
  init_tensor6d();
  init_tensor_scatter_update();
  init_tile();
  init_topk();
  init_truncated_normal();
  init_unique();
  init_unsorted_segment_sum();
  init_unstack();
  init_upper_bound();
  init_variable();
  init_where();
  init_where_async();
  init_zeros();
  init_zeros_like();
  init_boolean_mask();
  init_transpose();
  init_norm();
  init_moving_average();
  init_scatter_nd();
  init_search_sorted();
  init_sparse_to_dense();
  init_gather_nd();
  init_dropout();
  init_signal_ops_util();
  init_in_top_k();
  init_operation();
  init_rfft();
  init_fft();
  init_ifft();
  init_irfft();
  init_fused_ops();
  init_hamming_window();
  init_hann_window();
  init_frame();
  init_stft();
  init_crop_and_resize();
  init_flip_left_right();
  init_grayscale_to_rgb();
  init_rgb_to_grayscale();
  init_rotate_with_offset();
  init_non_max_suppression();
  init_non_max_suppression_async();
  init_non_max_suppression_with_score();
  init_non_max_suppression_with_score_async();
  init_non_max_suppression_padded();
  init_non_max_suppression_padded_async();
  init_resize_bilinear();
  init_resize_nearest_neighbor();
  init_threshold();
  init_transform();
  init_band_part();
  init_gram_schmidt();
  init_qr();
  init_absolute_difference();
  init_compute_weighted_loss();
  init_cosine_distance();
  init_hinge_loss();
  init_huber_loss();
  init_log_loss();
  init_mean_squared_error();
  init_sigmoid_cross_entropy();
  init_softmax_cross_entropy();
  init_sparse_fill_empty_rows();
  init_sparse_reshape();
  init_sparse_segment_mean();
  init_sparse_segment_sum();
  init_string_n_grams();
  init_string_split();
  init_string_to_hash_bucket_fast();
  init_static_regex_replace();
  spectral = {
    fft,
    ifft,
    rfft,
    irfft
  };
  signal = {
    hammingWindow,
    hannWindow,
    frame,
    stft
  };
  image = {
    flipLeftRight,
    grayscaleToRGB,
    resizeNearestNeighbor,
    resizeBilinear,
    rgbToGrayscale,
    rotateWithOffset,
    cropAndResize,
    nonMaxSuppression,
    nonMaxSuppressionAsync,
    nonMaxSuppressionWithScore,
    nonMaxSuppressionWithScoreAsync,
    nonMaxSuppressionPadded,
    nonMaxSuppressionPaddedAsync,
    threshold,
    transform
  };
  linalg = {
    bandPart,
    gramSchmidt,
    qr
  };
  losses = {
    absoluteDifference,
    computeWeightedLoss,
    cosineDistance,
    hingeLoss,
    huberLoss,
    logLoss,
    meanSquaredError,
    sigmoidCrossEntropy,
    softmaxCrossEntropy
  };
  sparse = {
    sparseFillEmptyRows,
    sparseReshape,
    sparseSegmentMean,
    sparseSegmentSum
  };
  string = {
    stringNGrams,
    stringSplit,
    stringToHashBucketFast,
    staticRegexReplace
  };
});

// node_modules/@tensorflow/tfjs-core/dist/serialization.js
var exports_serialization = {};
__export(exports_serialization, {
  registerClass: () => registerClass,
  getRegisteredName: () => getRegisteredName,
  SerializationMap: () => SerializationMap,
  Serializable: () => Serializable
});
function registerClass(cls, pkg, name) {
  assert(cls.className != null, () => `Class being registered does not have the static className ` + `property defined.`);
  assert(typeof cls.className === "string", () => `className is required to be a string, but got type ` + typeof cls.className);
  assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, ` + `which is disallowed.`);
  if (typeof pkg === "undefined") {
    pkg = "Custom";
  }
  if (typeof name === "undefined") {
    name = cls.className;
  }
  const className = name;
  const registerName = pkg + ">" + className;
  SerializationMap.register(cls);
  GLOBAL_CUSTOM_OBJECT.set(registerName, cls);
  GLOBAL_CUSTOM_NAMES.set(cls, registerName);
  return cls;
}
function getRegisteredName(cls) {
  if (GLOBAL_CUSTOM_NAMES.has(cls)) {
    return GLOBAL_CUSTOM_NAMES.get(cls);
  } else {
    return cls.className;
  }
}

class Serializable {
  getClassName() {
    return this.constructor.className;
  }
  static fromConfig(cls, config) {
    return new cls(config);
  }
}

class SerializationMap {
  constructor() {
    this.classNameMap = {};
  }
  static getMap() {
    if (SerializationMap.instance == null) {
      SerializationMap.instance = new SerializationMap;
    }
    return SerializationMap.instance;
  }
  static register(cls) {
    SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];
  }
}
var GLOBAL_CUSTOM_OBJECT, GLOBAL_CUSTOM_NAMES;
var init_serialization = __esm(() => {
  init_util();
  GLOBAL_CUSTOM_OBJECT = new Map;
  GLOBAL_CUSTOM_NAMES = new Map;
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/optimizer.js
var Optimizer;
var init_optimizer = __esm(() => {
  init_globals();
  init_gradients();
  init_ops();
  init_serialization();
  Optimizer = class Optimizer extends Serializable {
    minimize(f, returnCost = false, varList) {
      const { value, grads: grads2 } = this.computeGradients(f, varList);
      if (varList != null) {
        const gradArray = varList.map((v) => ({ name: v.name, tensor: grads2[v.name] }));
        this.applyGradients(gradArray);
      } else {
        this.applyGradients(grads2);
      }
      dispose(grads2);
      if (returnCost) {
        return value;
      } else {
        value.dispose();
        return null;
      }
    }
    get iterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return this.iterations_;
    }
    incrementIterations() {
      this.iterations_ = this.iterations + 1;
    }
    computeGradients(f, varList) {
      return variableGrads(f, varList);
    }
    dispose() {
      if (this.iterations_ != null) {
        dispose(this.iterations_);
      }
    }
    async saveIterations() {
      if (this.iterations_ == null) {
        this.iterations_ = 0;
      }
      return {
        name: "iter",
        tensor: scalar(this.iterations_, "int32")
      };
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(weightValues) {
      throw new Error(`setWeights() is not implemented for this optimizer class ` + `${this.getClassName()}`);
    }
    async extractIterations(weightValues) {
      this.iterations_ = (await weightValues[0].tensor.data())[0];
      return weightValues.slice(1);
    }
  };
  Object.defineProperty(Optimizer, Symbol.hasInstance, {
    value: (instance) => {
      return instance.minimize != null && instance.computeGradients != null && instance.applyGradients != null;
    }
  });
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/adadelta_optimizer.js
var AdadeltaOptimizer;
var init_adadelta_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_add();
  init_div();
  init_mul();
  init_ops();
  init_square();
  init_zeros_like();
  init_optimizer();
  AdadeltaOptimizer = class AdadeltaOptimizer extends Optimizer {
    static get className() {
      return "Adadelta";
    }
    constructor(learningRate, rho, epsilon = null) {
      super();
      this.learningRate = learningRate;
      this.rho = rho;
      this.epsilon = epsilon;
      this.accumulatedGrads = [];
      this.accumulatedUpdates = [];
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedGrads[i] == null) {
          this.accumulatedGrads[i] = {
            originalName: `${name}/accum_grad`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedUpdates[i] == null) {
          this.accumulatedUpdates[i] = {
            originalName: `${name}/accum_var`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i].variable;
        const accumulatedUpdate = this.accumulatedUpdates[i].variable;
        tidy(() => {
          const newAccumulatedGrad = add2(mul(accumulatedGrad, this.rho), mul(square(gradient), 1 - this.rho));
          const updates = mul(div(sqrt(add2(accumulatedUpdate, this.epsilon)), sqrt(add2(accumulatedGrad, this.epsilon))), gradient);
          const newAccumulatedUpdate = add2(mul(accumulatedUpdate, this.rho), mul(square(updates), 1 - this.rho));
          accumulatedGrad.assign(newAccumulatedGrad);
          accumulatedUpdate.assign(newAccumulatedUpdate);
          const newValue = add2(mul(updates, -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedUpdates != null) {
        dispose(this.accumulatedGrads.map((v) => v.variable));
        dispose(this.accumulatedUpdates.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedGrads, ...this.accumulatedUpdates];
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedGrads = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedUpdates = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        rho: this.rho,
        epsilon: this.epsilon
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["rho"], config["epsilon"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/adagrad_optimizer.js
var AdagradOptimizer;
var init_adagrad_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_add();
  init_div();
  init_fill();
  init_mul();
  init_sqrt();
  init_square();
  init_optimizer();
  AdagradOptimizer = class AdagradOptimizer extends Optimizer {
    static get className() {
      return "Adagrad";
    }
    constructor(learningRate, initialAccumulatorValue = 0.1) {
      super();
      this.learningRate = learningRate;
      this.initialAccumulatorValue = initialAccumulatorValue;
      this.accumulatedGrads = [];
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulatedGrads[i] == null) {
          const trainable = false;
          this.accumulatedGrads[i] = {
            originalName: `${name}/accumulator`,
            variable: tidy(() => fill(value.shape, this.initialAccumulatorValue).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedGrad = this.accumulatedGrads[i].variable;
        tidy(() => {
          const newAccumulatedGrad = add2(accumulatedGrad, square(gradient));
          accumulatedGrad.assign(newAccumulatedGrad);
          const newValue = add2(mul(div(gradient, sqrt(add2(newAccumulatedGrad, ENGINE.backend.epsilon()))), -this.learningRate), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedGrads != null) {
        dispose(this.accumulatedGrads.map((v) => v.variable));
      }
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulatedGrads.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulatedGrads = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        initialAccumulatorValue: this.initialAccumulatorValue
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["initialAccumulatorValue"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/adam_optimizer.js
var AdamOptimizer;
var init_adam_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_add();
  init_div();
  init_mul();
  init_pow();
  init_scalar();
  init_sqrt();
  init_square();
  init_sub();
  init_zeros_like();
  init_optimizer();
  AdamOptimizer = class AdamOptimizer extends Optimizer {
    static get className() {
      return "Adam";
    }
    constructor(learningRate, beta1, beta2, epsilon = null) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon;
      this.accumulatedFirstMoment = [];
      this.accumulatedSecondMoment = [];
      tidy(() => {
        this.accBeta1 = scalar(beta1).variable();
        this.accBeta2 = scalar(beta2).variable();
      });
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub(1, this.accBeta1);
        const oneMinusAccBeta2 = sub(1, this.accBeta2);
        varNames.forEach((name, i) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i] == null) {
            this.accumulatedFirstMoment[i] = {
              originalName: `${name}/m`,
              variable: tidy(() => zerosLike(value).variable(trainable))
            };
          }
          if (this.accumulatedSecondMoment[i] == null) {
            this.accumulatedSecondMoment[i] = {
              originalName: `${name}/v`,
              variable: tidy(() => zerosLike(value).variable(trainable))
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i].variable;
          const secondMoment = this.accumulatedSecondMoment[i].variable;
          const newFirstMoment = add2(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
          const newSecondMoment = add2(mul(secondMoment, this.beta2), mul(square(gradient), 1 - this.beta2));
          const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);
          const biasCorrectedSecondMoment = div(newSecondMoment, oneMinusAccBeta2);
          firstMoment.assign(newFirstMoment);
          secondMoment.assign(newSecondMoment);
          const newValue = add2(mul(div(biasCorrectedFirstMoment, add2(sqrt(biasCorrectedSecondMoment), this.epsilon)), -this.learningRate), value);
          value.assign(newValue);
        });
        this.accBeta1.assign(mul(this.accBeta1, this.beta1));
        this.accBeta2.assign(mul(this.accBeta2, this.beta2));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.accBeta2.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v) => v.variable));
      }
      if (this.accumulatedSecondMoment != null) {
        dispose(this.accumulatedSecondMoment.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      tidy(() => {
        this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));
        this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));
      });
      const variableCount = weightValues.length / 2;
      const trainable = false;
      this.accumulatedFirstMoment = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedSecondMoment = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/adamax_optimizer.js
var AdamaxOptimizer;
var init_adamax_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_abs();
  init_add();
  init_div();
  init_maximum();
  init_mul();
  init_scalar();
  init_sub();
  init_zeros_like();
  init_optimizer();
  AdamaxOptimizer = class AdamaxOptimizer extends Optimizer {
    static get className() {
      return "Adamax";
    }
    constructor(learningRate, beta1, beta2, epsilon = null, decay = 0) {
      super();
      this.learningRate = learningRate;
      this.beta1 = beta1;
      this.beta2 = beta2;
      this.epsilon = epsilon;
      this.decay = decay;
      this.accumulatedFirstMoment = [];
      this.accumulatedWeightedInfNorm = [];
      tidy(() => {
        this.iteration = scalar(0).variable();
        this.accBeta1 = scalar(beta1).variable();
      });
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      tidy(() => {
        const oneMinusAccBeta1 = sub(1, this.accBeta1);
        const lr = div(-this.learningRate, add2(mul(this.iteration, this.decay), 1));
        variableNames.forEach((name, i) => {
          const value = ENGINE.registeredVariables[name];
          const trainable = false;
          if (this.accumulatedFirstMoment[i] == null) {
            this.accumulatedFirstMoment[i] = {
              originalName: `${name}/m`,
              variable: zerosLike(value).variable(trainable)
            };
          }
          if (this.accumulatedWeightedInfNorm[i] == null) {
            this.accumulatedWeightedInfNorm[i] = {
              originalName: `${name}/v`,
              variable: zerosLike(value).variable(trainable)
            };
          }
          const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
          if (gradient == null) {
            return;
          }
          const firstMoment = this.accumulatedFirstMoment[i].variable;
          const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;
          const newFirstMoment = add2(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));
          const ut0 = mul(weightedInfNorm, this.beta2);
          const ut1 = abs(gradient);
          const newWeightedInfNorm = maximum(ut0, ut1);
          firstMoment.assign(newFirstMoment);
          weightedInfNorm.assign(newWeightedInfNorm);
          const newValue = add2(mul(div(lr, oneMinusAccBeta1), div(newFirstMoment, add2(newWeightedInfNorm, this.epsilon))), value);
          value.assign(newValue);
        });
        this.iteration.assign(add2(this.iteration, 1));
        this.accBeta1.assign(mul(this.accBeta1, this.beta1));
      });
      this.incrementIterations();
    }
    dispose() {
      this.accBeta1.dispose();
      this.iteration.dispose();
      if (this.accumulatedFirstMoment != null) {
        dispose(this.accumulatedFirstMoment.map((v) => v.variable));
      }
      if (this.accumulatedWeightedInfNorm != null) {
        dispose(this.accumulatedWeightedInfNorm.map((v) => v.variable));
      }
    }
    async getWeights() {
      throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(weightValues) {
      throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        beta1: this.beta1,
        beta2: this.beta2,
        epsilon: this.epsilon,
        decay: this.decay
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["beta1"], config["beta2"], config["epsilon"], config["decay"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/sgd_optimizer.js
var SGDOptimizer;
var init_sgd_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_add();
  init_mul();
  init_scalar();
  init_optimizer();
  SGDOptimizer = class SGDOptimizer extends Optimizer {
    static get className() {
      return "SGD";
    }
    constructor(learningRate) {
      super();
      this.learningRate = learningRate;
      this.setLearningRate(learningRate);
    }
    applyGradients(variableGradients) {
      const varNames = Array.isArray(variableGradients) ? variableGradients.map((v) => v.name) : Object.keys(variableGradients);
      varNames.forEach((name, i) => {
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const value = ENGINE.registeredVariables[name];
        tidy(() => {
          const newValue = add2(mul(this.c, gradient), value);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    setLearningRate(learningRate) {
      this.learningRate = learningRate;
      if (this.c != null) {
        this.c.dispose();
      }
      this.c = keep(scalar(-learningRate));
    }
    dispose() {
      this.c.dispose();
    }
    async getWeights() {
      return [await this.saveIterations()];
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      if (weightValues.length !== 0) {
        throw new Error("SGD optimizer does not have settable weights.");
      }
    }
    getConfig() {
      return { learningRate: this.learningRate };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/momentum_optimizer.js
var MomentumOptimizer;
var init_momentum_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_add();
  init_mul();
  init_scalar();
  init_zeros_like();
  init_sgd_optimizer();
  MomentumOptimizer = class MomentumOptimizer extends SGDOptimizer {
    static get className() {
      return "Momentum";
    }
    constructor(learningRate, momentum, useNesterov = false) {
      super(learningRate);
      this.learningRate = learningRate;
      this.momentum = momentum;
      this.useNesterov = useNesterov;
      this.accumulations = [];
      this.m = scalar(this.momentum);
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        if (this.accumulations[i] == null) {
          const trainable = false;
          this.accumulations[i] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const accumulation = this.accumulations[i].variable;
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        tidy(() => {
          let newValue;
          const newAccumulation = add2(mul(this.m, accumulation), gradient);
          if (this.useNesterov) {
            newValue = add2(mul(this.c, add2(gradient, mul(newAccumulation, this.m))), value);
          } else {
            newValue = add2(mul(this.c, newAccumulation), value);
          }
          accumulation.assign(newAccumulation);
          value.assign(newValue);
        });
      });
      this.incrementIterations();
    }
    dispose() {
      this.m.dispose();
      if (this.accumulations != null) {
        dispose(this.accumulations.map((v) => v.variable));
      }
    }
    setMomentum(momentum) {
      this.momentum = momentum;
    }
    async getWeights() {
      return [await this.saveIterations()].concat(this.accumulations.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const trainable = false;
      this.accumulations = weightValues.map((v) => ({ originalName: v.name, variable: v.tensor.variable(trainable) }));
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        momentum: this.momentum,
        useNesterov: this.useNesterov
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["momentum"], config["useNesterov"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/rmsprop_optimizer.js
var RMSPropOptimizer;
var init_rmsprop_optimizer = __esm(() => {
  init_engine();
  init_globals();
  init_add();
  init_div();
  init_mul();
  init_sqrt();
  init_square();
  init_sub();
  init_zeros_like();
  init_optimizer();
  RMSPropOptimizer = class RMSPropOptimizer extends Optimizer {
    static get className() {
      return "RMSProp";
    }
    constructor(learningRate, decay = 0.9, momentum = 0, epsilon = null, centered = false) {
      super();
      this.learningRate = learningRate;
      this.decay = decay;
      this.momentum = momentum;
      this.epsilon = epsilon;
      this.accumulatedMeanSquares = [];
      this.accumulatedMoments = [];
      this.accumulatedMeanGrads = [];
      this.centered = centered;
      if (epsilon == null) {
        this.epsilon = ENGINE.backend.epsilon();
      }
      if (learningRate == null) {
        throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
      }
    }
    applyGradients(variableGradients) {
      const variableNames = Array.isArray(variableGradients) ? variableGradients.map((item) => item.name) : Object.keys(variableGradients);
      variableNames.forEach((name, i) => {
        const value = ENGINE.registeredVariables[name];
        const trainable = false;
        if (this.accumulatedMeanSquares[i] == null) {
          this.accumulatedMeanSquares[i] = {
            originalName: `${name}/rms`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedMoments[i] == null) {
          this.accumulatedMoments[i] = {
            originalName: `${name}/momentum`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        if (this.accumulatedMeanGrads[i] == null && this.centered) {
          this.accumulatedMeanGrads[i] = {
            originalName: `${name}/mg`,
            variable: tidy(() => zerosLike(value).variable(trainable))
          };
        }
        const gradient = Array.isArray(variableGradients) ? variableGradients[i].tensor : variableGradients[name];
        if (gradient == null) {
          return;
        }
        const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;
        const accumulatedMoments = this.accumulatedMoments[i].variable;
        tidy(() => {
          const newAccumulatedMeanSquare = add2(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
          if (this.centered) {
            const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;
            const newAccumulatedMeanGrad = add2(mul(accumulatedMeanGrad, this.decay), mul(gradient, 1 - this.decay));
            const gradContribution = div(mul(gradient, this.learningRate), sqrt(sub(newAccumulatedMeanSquare, add2(square(newAccumulatedMeanGrad), this.epsilon))));
            const newAccumulatedMoments = add2(mul(accumulatedMoments, this.momentum), gradContribution);
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
            accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub(value, newAccumulatedMoments);
            value.assign(newValue);
          } else {
            const newAccumulatedMeanSquare2 = add2(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
            const newAccumulatedMoments = add2(mul(accumulatedMoments, this.momentum), div(mul(gradient, this.learningRate), sqrt(add2(newAccumulatedMeanSquare2, this.epsilon))));
            accumulatedMeanSquare.assign(newAccumulatedMeanSquare2);
            accumulatedMoments.assign(newAccumulatedMoments);
            const newValue = sub(value, newAccumulatedMoments);
            value.assign(newValue);
          }
        });
      });
      this.incrementIterations();
    }
    dispose() {
      if (this.accumulatedMeanSquares != null) {
        dispose(this.accumulatedMeanSquares.map((v) => v.variable));
      }
      if (this.accumulatedMeanGrads != null && this.centered) {
        dispose(this.accumulatedMeanGrads.map((v) => v.variable));
      }
      if (this.accumulatedMoments != null) {
        dispose(this.accumulatedMoments.map((v) => v.variable));
      }
    }
    async getWeights() {
      const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
      if (this.centered) {
        variables.push(...this.accumulatedMeanGrads);
      }
      return [await this.saveIterations()].concat(variables.map((v) => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
      weightValues = await this.extractIterations(weightValues);
      const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
      const trainable = false;
      this.accumulatedMeanSquares = weightValues.slice(0, variableCount).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      this.accumulatedMoments = weightValues.slice(variableCount, variableCount * 2).map((v) => ({
        originalName: v.name,
        variable: v.tensor.variable(trainable)
      }));
      if (this.centered) {
        this.accumulatedMeanGrads = weightValues.slice(variableCount * 2, variableCount * 3).map((v) => ({
          originalName: v.name,
          variable: v.tensor.variable(trainable)
        }));
      }
    }
    getConfig() {
      return {
        learningRate: this.learningRate,
        decay: this.decay,
        momentum: this.momentum,
        epsilon: this.epsilon,
        centered: this.centered
      };
    }
    static fromConfig(cls, config) {
      return new cls(config["learningRate"], config["decay"], config["momentum"], config["epsilon"], config["centered"]);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/optimizers/register_optimizers.js
function registerOptimizers() {
  for (const optimizer7 of OPTIMIZERS) {
    registerClass(optimizer7);
  }
}
var OPTIMIZERS;
var init_register_optimizers = __esm(() => {
  init_adadelta_optimizer();
  init_adagrad_optimizer();
  init_adam_optimizer();
  init_adamax_optimizer();
  init_momentum_optimizer();
  init_rmsprop_optimizer();
  init_sgd_optimizer();
  init_serialization();
  OPTIMIZERS = [
    AdadeltaOptimizer,
    AdagradOptimizer,
    AdamOptimizer,
    AdamaxOptimizer,
    MomentumOptimizer,
    RMSPropOptimizer,
    SGDOptimizer
  ];
});

// node_modules/@tensorflow/tfjs-core/dist/io/browser_files.js
function defer(f) {
  return new Promise((resolve) => setTimeout(resolve)).then(f);
}
function browserDownloads(fileNamePrefix = "model") {
  return new BrowserDownloads(fileNamePrefix);
}
function browserFiles(files) {
  return new BrowserFiles(files);
}

class BrowserDownloads {
  constructor(fileNamePrefix) {
    if (!env().getBool("IS_BROWSER")) {
      throw new Error("browserDownloads() cannot proceed because the current environment " + "is not a browser.");
    }
    if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {
      fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);
    }
    if (fileNamePrefix == null || fileNamePrefix.length === 0) {
      fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;
    }
    this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;
    this.weightDataFileName = fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;
  }
  async save(modelArtifacts) {
    if (typeof document === "undefined") {
      throw new Error("Browser downloads are not supported in " + "this environment since `document` is not present");
    }
    const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
    const weightsURL = window.URL.createObjectURL(new Blob([weightBuffer], { type: "application/octet-stream" }));
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserDownloads.save() does not support saving model topology " + "in binary formats yet.");
    } else {
      const weightsManifest = [{
        paths: ["./" + this.weightDataFileName],
        weights: modelArtifacts.weightSpecs
      }];
      const modelJSON = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
      const modelJsonURL = window.URL.createObjectURL(new Blob([JSON.stringify(modelJSON)], { type: "application/json" }));
      const jsonAnchor = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
      jsonAnchor.download = this.modelJsonFileName;
      jsonAnchor.href = modelJsonURL;
      await defer(() => jsonAnchor.dispatchEvent(new MouseEvent("click")));
      if (modelArtifacts.weightData != null) {
        const weightDataAnchor = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
        weightDataAnchor.download = this.weightDataFileName;
        weightDataAnchor.href = weightsURL;
        await defer(() => weightDataAnchor.dispatchEvent(new MouseEvent("click")));
      }
      return { modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts) };
    }
  }
}

class BrowserFiles {
  constructor(files) {
    if (files == null || files.length < 1) {
      throw new Error(`When calling browserFiles, at least 1 file is required, ` + `but received ${files}`);
    }
    this.jsonFile = files[0];
    this.weightsFiles = files.slice(1);
  }
  async load() {
    return new Promise((resolve, reject) => {
      const jsonReader = new FileReader;
      jsonReader.onload = (event) => {
        const modelJSON = JSON.parse(event.target.result);
        const modelTopology = modelJSON.modelTopology;
        if (modelTopology == null) {
          reject(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
          return;
        }
        const weightsManifest = modelJSON.weightsManifest;
        if (weightsManifest == null) {
          reject(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
          return;
        }
        if (this.weightsFiles.length === 0) {
          resolve({ modelTopology });
          return;
        }
        const modelArtifactsPromise = getModelArtifactsForJSON(modelJSON, (weightsManifest2) => this.loadWeights(weightsManifest2));
        resolve(modelArtifactsPromise);
      };
      jsonReader.onerror = (error) => reject(`Failed to read model topology and weights manifest JSON ` + `from file '${this.jsonFile.name}'. BrowserFiles supports loading ` + `Keras-style tf.Model artifacts only.`);
      jsonReader.readAsText(this.jsonFile);
    });
  }
  loadWeights(weightsManifest) {
    const weightSpecs = [];
    const paths = [];
    for (const entry of weightsManifest) {
      weightSpecs.push(...entry.weights);
      paths.push(...entry.paths);
    }
    const pathToFile = this.checkManifestAndWeightFiles(weightsManifest);
    const promises = paths.map((path) => this.loadWeightsFile(path, pathToFile[path]));
    return Promise.all(promises).then((buffers) => [weightSpecs, buffers]);
  }
  loadWeightsFile(path, file) {
    return new Promise((resolve, reject) => {
      const weightFileReader = new FileReader;
      weightFileReader.onload = (event) => {
        const weightData = event.target.result;
        resolve(weightData);
      };
      weightFileReader.onerror = (error) => reject(`Failed to weights data from file of path '${path}'.`);
      weightFileReader.readAsArrayBuffer(file);
    });
  }
  checkManifestAndWeightFiles(manifest) {
    const basenames = [];
    const fileNames = this.weightsFiles.map((file) => basename(file.name));
    const pathToFile = {};
    for (const group of manifest) {
      group.paths.forEach((path) => {
        const pathBasename = basename(path);
        if (basenames.indexOf(pathBasename) !== -1) {
          throw new Error(`Duplicate file basename found in weights manifest: ` + `'${pathBasename}'`);
        }
        basenames.push(pathBasename);
        if (fileNames.indexOf(pathBasename) === -1) {
          throw new Error(`Weight file with basename '${pathBasename}' is not provided.`);
        } else {
          pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];
        }
      });
    }
    if (basenames.length !== this.weightsFiles.length) {
      throw new Error(`Mismatch in the number of files in weights manifest ` + `(${basenames.length}) and the number of weight files provided ` + `(${this.weightsFiles.length}).`);
    }
    return pathToFile;
  }
}
var DEFAULT_FILE_NAME_PREFIX = "model", DEFAULT_JSON_EXTENSION_NAME = ".json", DEFAULT_WEIGHT_DATA_EXTENSION_NAME = ".weights.bin", browserDownloadsRouter = (url) => {
  if (!env().getBool("IS_BROWSER")) {
    return null;
  } else {
    if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {
      return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));
    } else {
      return null;
    }
  }
};
var init_browser_files = __esm(() => {
  init_flags();
  init_environment();
  init_io_utils();
  init_composite_array_buffer();
  BrowserDownloads.URL_SCHEME = "downloads://";
  IORouterRegistry.registerSaveRouter(browserDownloadsRouter);
});

// node_modules/@tensorflow/tfjs-core/dist/io/progress.js
function monitorPromisesProgress(promises, onProgress, startFraction, endFraction) {
  checkPromises(promises);
  startFraction = startFraction == null ? 0 : startFraction;
  endFraction = endFraction == null ? 1 : endFraction;
  checkFraction(startFraction, endFraction);
  let resolvedPromise = 0;
  const registerMonitor = (promise) => {
    promise.then((value) => {
      const fraction = startFraction + ++resolvedPromise / promises.length * (endFraction - startFraction);
      onProgress(fraction);
      return value;
    });
    return promise;
  };
  function checkPromises(promises2) {
    assert(promises2 != null && Array.isArray(promises2) && promises2.length > 0, () => "promises must be a none empty array");
  }
  function checkFraction(startFraction2, endFraction2) {
    assert(startFraction2 >= 0 && startFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but ` + `got startFraction ${startFraction2}`);
    assert(endFraction2 >= 0 && endFraction2 <= 1, () => `Progress fraction must be in range [0, 1], but ` + `got endFraction ${endFraction2}`);
    assert(endFraction2 >= startFraction2, () => `startFraction must be no more than endFraction, but ` + `got startFraction ${startFraction2} and endFraction ` + `${endFraction2}`);
  }
  return Promise.all(promises.map(registerMonitor));
}
var init_progress = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/io/weights_loader.js
async function loadWeightsAsArrayBuffer(fetchURLs, loadOptions) {
  if (loadOptions == null) {
    loadOptions = {};
  }
  const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
  const requests = fetchURLs.map((fetchURL) => fetchFunc(fetchURL, loadOptions.requestInit, { isBinary: true }));
  const fetchStartFraction = 0;
  const fetchEndFraction = 0.5;
  const responses = loadOptions.onProgress == null ? await Promise.all(requests) : await monitorPromisesProgress(requests, loadOptions.onProgress, fetchStartFraction, fetchEndFraction);
  const bufferPromises = responses.map((response) => response.arrayBuffer());
  const bufferStartFraction = 0.5;
  const bufferEndFraction = 1;
  const buffers = loadOptions.onProgress == null ? await Promise.all(bufferPromises) : await monitorPromisesProgress(bufferPromises, loadOptions.onProgress, bufferStartFraction, bufferEndFraction);
  return buffers;
}
function streamWeights(fetchURLs, loadOptions) {
  var _a;
  const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch : loadOptions.fetchFunc;
  let fetchIndex = 0;
  let chunkReader;
  (_a = loadOptions.onProgress) === null || _a === undefined || _a.call(loadOptions, 0);
  return new ReadableStream({
    pull: async (controller) => {
      var _a2;
      while (fetchIndex < fetchURLs.length) {
        if (!chunkReader) {
          const body = (await fetchFunc(fetchURLs[fetchIndex], loadOptions.requestInit, { isBinary: true })).body;
          chunkReader = body.getReader();
        }
        const { done, value } = await chunkReader.read();
        if (done) {
          fetchIndex++;
          chunkReader = undefined;
          (_a2 = loadOptions.onProgress) === null || _a2 === undefined || _a2.call(loadOptions, fetchIndex / fetchURLs.length);
          continue;
        }
        controller.enqueue(value);
        return;
      }
      controller.close();
    }
  });
}
async function loadWeights(manifest, filePathPrefix = "", weightNames, requestInit) {
  const fetchWeights = (fetchUrls) => loadWeightsAsArrayBuffer(fetchUrls, { requestInit });
  const loadWeights2 = weightsLoaderFactory(fetchWeights);
  return loadWeights2(manifest, filePathPrefix, weightNames);
}
function weightsLoaderFactory(fetchWeightsFunction) {
  return async (manifest, filePathPrefix = "", weightNames) => {
    const groupIndicesToFetchMap = manifest.map(() => false);
    const groupWeightsToFetch = {};
    const weightsFound = weightNames != null ? weightNames.map(() => false) : [];
    const allManifestWeightNames = [];
    manifest.forEach((manifestGroupConfig, groupIndex) => {
      let groupOffset = 0;
      manifestGroupConfig.weights.forEach((weightsEntry) => {
        const rawDtype = "quantization" in weightsEntry ? weightsEntry.quantization.dtype : weightsEntry.dtype;
        const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] * sizeFromShape(weightsEntry.shape);
        const enqueueWeightsForFetchingFn = () => {
          groupIndicesToFetchMap[groupIndex] = true;
          if (groupWeightsToFetch[groupIndex] == null) {
            groupWeightsToFetch[groupIndex] = [];
          }
          groupWeightsToFetch[groupIndex].push({
            manifestEntry: weightsEntry,
            groupOffset,
            sizeBytes: weightsBytes
          });
        };
        if (weightNames != null) {
          weightNames.forEach((weightName, weightIndex) => {
            if (weightName === weightsEntry.name) {
              enqueueWeightsForFetchingFn();
              weightsFound[weightIndex] = true;
            }
          });
        } else {
          enqueueWeightsForFetchingFn();
        }
        allManifestWeightNames.push(weightsEntry.name);
        groupOffset += weightsBytes;
      });
    });
    if (!weightsFound.every((found) => found)) {
      const weightsNotFound = weightNames.filter((_, i) => !weightsFound[i]);
      throw new Error(`Could not find weights in manifest with names: ` + `${weightsNotFound.join(", ")}. \n` + `Manifest JSON has weights with names: ` + `${allManifestWeightNames.join(", ")}.`);
    }
    const groupIndicesToFetch = groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {
      if (shouldFetch) {
        accumulator.push(i);
      }
      return accumulator;
    }, []);
    const fetchUrls = [];
    groupIndicesToFetch.forEach((i) => {
      manifest[i].paths.forEach((filepath) => {
        const fetchUrl = filePathPrefix + (!filePathPrefix.endsWith("/") ? "/" : "") + filepath;
        fetchUrls.push(fetchUrl);
      });
    });
    const buffers = await fetchWeightsFunction(fetchUrls);
    const weightsTensorMap = {};
    let bufferIndexOffset = 0;
    groupIndicesToFetch.forEach((i) => {
      const numBuffers = manifest[i].paths.length;
      const weightsBuffer = new CompositeArrayBuffer(buffers.slice(bufferIndexOffset, bufferIndexOffset + numBuffers));
      const weightsEntries = groupWeightsToFetch[i];
      weightsEntries.forEach((weightsEntry) => {
        const byteBuffer = weightsBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
        const nameToTensorMap = decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);
        for (const name in nameToTensorMap) {
          weightsTensorMap[name] = nameToTensorMap[name];
        }
      });
      bufferIndexOffset += numBuffers;
    });
    return weightsTensorMap;
  };
}
var init_weights_loader = __esm(() => {
  init_environment();
  init_util();
  init_composite_array_buffer();
  init_io_utils();
  init_progress();
  init_types2();
});

// node_modules/@tensorflow/tfjs-core/dist/io/http.js
function parseUrl(url) {
  const lastSlash = url.lastIndexOf("/");
  const lastSearchParam = url.lastIndexOf("?");
  const prefix = url.substring(0, lastSlash);
  const suffix = lastSearchParam > lastSlash ? url.substring(lastSearchParam) : "";
  return [prefix + "/", suffix];
}
function isHTTPScheme(url) {
  return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;
}
function http(path, loadOptions) {
  return new HTTPRequest(path, loadOptions);
}
function browserHTTPRequest(path, loadOptions) {
  return http(path, loadOptions);
}

class HTTPRequest {
  constructor(path, loadOptions) {
    this.DEFAULT_METHOD = "POST";
    if (loadOptions == null) {
      loadOptions = {};
    }
    this.weightPathPrefix = loadOptions.weightPathPrefix;
    this.weightUrlConverter = loadOptions.weightUrlConverter;
    if (loadOptions.fetchFunc != null) {
      assert(typeof loadOptions.fetchFunc === "function", () => "Must pass a function that matches the signature of " + "`fetch` (see " + "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");
      this.fetch = loadOptions.fetchFunc;
    } else {
      this.fetch = env().platform.fetch;
    }
    assert(path != null && path.length > 0, () => "URL path for http must not be null, undefined or " + "empty.");
    if (Array.isArray(path)) {
      assert(path.length === 2, () => "URL paths for http must have a length of 2, " + `(actual length is ${path.length}).`);
    }
    this.path = path;
    if (loadOptions.requestInit != null && loadOptions.requestInit.body != null) {
      throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    }
    this.requestInit = loadOptions.requestInit || {};
    this.loadOptions = loadOptions;
  }
  async save(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
      throw new Error("BrowserHTTPRequest.save() does not support saving model topology " + "in binary formats yet.");
    }
    const init = Object.assign({ method: this.DEFAULT_METHOD }, this.requestInit);
    init.body = new FormData;
    const weightsManifest = [{
      paths: ["./model.weights.bin"],
      weights: modelArtifacts.weightSpecs
    }];
    const modelTopologyAndWeightManifest = getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);
    init.body.append("model.json", new Blob([JSON.stringify(modelTopologyAndWeightManifest)], { type: JSON_TYPE }), "model.json");
    if (modelArtifacts.weightData != null) {
      const weightBuffer = CompositeArrayBuffer.join(modelArtifacts.weightData);
      init.body.append("model.weights.bin", new Blob([weightBuffer], { type: OCTET_STREAM_MIME_TYPE }), "model.weights.bin");
    }
    const response = await this.fetch(this.path, init);
    if (response.ok) {
      return {
        modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),
        responses: [response]
      };
    } else {
      throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ` + `${response.status}.`);
    }
  }
  async loadModelJSON() {
    const modelConfigRequest = await this.fetch(this.path, this.requestInit);
    if (!modelConfigRequest.ok) {
      throw new Error(`Request to ${this.path} failed with status code ` + `${modelConfigRequest.status}. Please verify this URL points to ` + `the model JSON of the model to load.`);
    }
    let modelJSON;
    try {
      modelJSON = await modelConfigRequest.json();
    } catch (e) {
      let message = `Failed to parse model JSON of response from ${this.path}.`;
      if (this.path.endsWith(".pb")) {
        message += " Your path contains a .pb file extension. " + "Support for .pb models have been removed in TensorFlow.js 1.0 " + "in favor of .json models. You can re-convert your Python " + "TensorFlow model using the TensorFlow.js 1.0 conversion scripts " + "or you can convert your.pb models with the \'pb2json\'" + "NPM script in the tensorflow/tfjs-converter repository.";
      } else {
        message += " Please make sure the server is serving valid " + "JSON for this request.";
      }
      throw new Error(message);
    }
    const modelTopology = modelJSON.modelTopology;
    const weightsManifest = modelJSON.weightsManifest;
    if (modelTopology == null && weightsManifest == null) {
      throw new Error(`The JSON from HTTP path ${this.path} contains neither model ` + `topology or manifest for weights.`);
    }
    return modelJSON;
  }
  async load() {
    if (this.loadOptions.streamWeights) {
      return this.loadStream();
    }
    const modelJSON = await this.loadModelJSON();
    return getModelArtifactsForJSON(modelJSON, (weightsManifest) => this.loadWeights(weightsManifest));
  }
  async loadStream() {
    const modelJSON = await this.loadModelJSON();
    const fetchURLs = await this.getWeightUrls(modelJSON.weightsManifest);
    const weightSpecs = getWeightSpecs(modelJSON.weightsManifest);
    const stream = () => streamWeights(fetchURLs, this.loadOptions);
    return Object.assign(Object.assign({}, modelJSON), { weightSpecs, getWeightStream: stream });
  }
  async getWeightUrls(weightsManifest) {
    const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;
    const [prefix, suffix] = parseUrl(weightPath);
    const pathPrefix = this.weightPathPrefix || prefix;
    const fetchURLs = [];
    const urlPromises = [];
    for (const weightsGroup of weightsManifest) {
      for (const path of weightsGroup.paths) {
        if (this.weightUrlConverter != null) {
          urlPromises.push(this.weightUrlConverter(path));
        } else {
          fetchURLs.push(pathPrefix + path + suffix);
        }
      }
    }
    if (this.weightUrlConverter) {
      fetchURLs.push(...await Promise.all(urlPromises));
    }
    return fetchURLs;
  }
  async loadWeights(weightsManifest) {
    const fetchURLs = await this.getWeightUrls(weightsManifest);
    const weightSpecs = getWeightSpecs(weightsManifest);
    const buffers = await loadWeightsAsArrayBuffer(fetchURLs, this.loadOptions);
    return [weightSpecs, buffers];
  }
}
var OCTET_STREAM_MIME_TYPE = "application/octet-stream", JSON_TYPE = "application/json", httpRouter = (url, loadOptions) => {
  if (typeof fetch === "undefined" && (loadOptions == null || loadOptions.fetchFunc == null)) {
    return null;
  } else {
    let isHTTP = true;
    if (Array.isArray(url)) {
      isHTTP = url.every((urlItem) => isHTTPScheme(urlItem));
    } else {
      isHTTP = isHTTPScheme(url);
    }
    if (isHTTP) {
      return http(url, loadOptions);
    }
  }
  return null;
};
var init_http = __esm(() => {
  init_environment();
  init_util();
  init_io_utils();
  init_composite_array_buffer();
  init_weights_loader();
  HTTPRequest.URL_SCHEME_REGEX = /^https?:\/\//;
  IORouterRegistry.registerSaveRouter(httpRouter);
  IORouterRegistry.registerLoadRouter(httpRouter);
});

// node_modules/@tensorflow/tfjs-core/dist/io/passthrough.js
function fromMemory(modelArtifacts, weightSpecs, weightData, trainingConfig) {
  const args = arguments;
  return new PassthroughAsync(fromMemorySync(...args));
}
function fromMemorySync(modelArtifacts, weightSpecs, weightData, trainingConfig) {
  if (arguments.length === 1) {
    const isModelArtifacts = modelArtifacts.modelTopology != null || modelArtifacts.weightSpecs != null;
    if (isModelArtifacts) {
      return new PassthroughLoader(modelArtifacts);
    } else {
      console.warn("Please call tf.io.fromMemory() with only one argument. " + "The argument should be of type ModelArtifacts. " + "The multi-argument signature of tf.io.fromMemory() has been " + "deprecated and will be removed in a future release.");
      return new PassthroughLoader({ modelTopology: modelArtifacts });
    }
  } else {
    console.warn("Please call tf.io.fromMemory() with only one argument. " + "The argument should be of type ModelArtifacts. " + "The multi-argument signature of tf.io.fromMemory() has been " + "deprecated and will be removed in a future release.");
    return new PassthroughLoader({
      modelTopology: modelArtifacts,
      weightSpecs,
      weightData,
      trainingConfig
    });
  }
}
function withSaveHandler(saveHandler) {
  return new PassthroughSaver(saveHandler);
}
function withSaveHandlerSync(saveHandler) {
  return new PassthroughSaver(saveHandler);
}

class PassthroughLoader {
  constructor(modelArtifacts) {
    this.modelArtifacts = modelArtifacts;
  }
  load() {
    return this.modelArtifacts;
  }
}

class PassthroughSaver {
  constructor(saveHandler) {
    this.saveHandler = saveHandler;
  }
  save(modelArtifacts) {
    return this.saveHandler(modelArtifacts);
  }
}

class PassthroughAsync {
  constructor(handler) {
    if (handler.load) {
      this.load = () => Promise.resolve(handler.load());
    }
    if (handler.save) {
      this.save = (modelArtifacts) => Promise.resolve(handler.save(modelArtifacts));
    }
  }
}

// node_modules/@tensorflow/tfjs-core/dist/io/io.js
var exports_io = {};
__export(exports_io, {
  withSaveHandlerSync: () => withSaveHandlerSync,
  withSaveHandler: () => withSaveHandler,
  weightsLoaderFactory: () => weightsLoaderFactory,
  removeModel: () => removeModel,
  registerSaveRouter: () => registerSaveRouter,
  registerLoadRouter: () => registerLoadRouter,
  moveModel: () => moveModel,
  loadWeights: () => loadWeights,
  listModels: () => listModels,
  isHTTPScheme: () => isHTTPScheme,
  http: () => http,
  getWeightSpecs: () => getWeightSpecs,
  getSaveHandlers: () => getSaveHandlers,
  getModelArtifactsInfoForJSON: () => getModelArtifactsInfoForJSON,
  getModelArtifactsForJSONSync: () => getModelArtifactsForJSONSync,
  getModelArtifactsForJSON: () => getModelArtifactsForJSON,
  getLoadHandlers: () => getLoadHandlers,
  fromMemorySync: () => fromMemorySync,
  fromMemory: () => fromMemory,
  encodeWeights: () => encodeWeights,
  decodeWeightsStream: () => decodeWeightsStream,
  decodeWeights: () => decodeWeights,
  copyModel: () => copyModel,
  concatenateArrayBuffers: () => concatenateArrayBuffers,
  browserHTTPRequest: () => browserHTTPRequest,
  browserFiles: () => browserFiles,
  CompositeArrayBuffer: () => CompositeArrayBuffer
});
var init_io = __esm(() => {
  init_indexed_db();
  init_local_storage();
  init_browser_files();
  init_http();
  init_io_utils();
  init_weights_loader();
  init_composite_array_buffer();
  init_model_management();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/confusion_matrix.js
function confusionMatrix_(labels, predictions, numClasses) {
  const $labels = convertToTensor(labels, "labels", "confusionMatrix");
  const $predictions = convertToTensor(predictions, "predictions", "confusionMatrix");
  assert(numClasses == null || numClasses > 0 && Number.isInteger(numClasses), () => `If provided, numClasses must be a positive integer, ` + `but got ${numClasses}`);
  assert($labels.rank === 1, () => `Expected the rank of labels to be 1, but got ${$labels.rank}`);
  assert($predictions.rank === 1, () => `Expected the rank of predictions to be 1, ` + `but got ${$predictions.rank}`);
  assert($labels.shape[0] === $predictions.shape[0], () => `Mismatch in the number of examples: ` + `${$labels.shape[0]} vs. ${$predictions.shape[0]}. ` + `Labels and predictions should have the same number of elements.`);
  assert(numClasses > 0 && Number.isInteger(numClasses), () => `numClasses is required to be a positive integer, but got ` + `${numClasses}`);
  const oneHotLabels = oneHot(cast($labels, "int32"), numClasses);
  const oneHotPredictions = oneHot(cast($predictions, "int32"), numClasses);
  const oneHotLabelsT = transpose(oneHotLabels);
  const product = matMul(oneHotLabelsT, oneHotPredictions);
  return cast(product, "int32");
}
var confusionMatrix;
var init_confusion_matrix = __esm(() => {
  init_tensor_util_env();
  init_util();
  init_cast();
  init_mat_mul();
  init_one_hot();
  init_operation();
  init_transpose();
  confusionMatrix = op({ confusionMatrix_ });
});

// node_modules/@tensorflow/tfjs-core/dist/math.js
var exports_math = {};
__export(exports_math, {
  confusionMatrix: () => confusionMatrix
});
var init_math = __esm(() => {
  init_confusion_matrix();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/browser.js
var exports_browser = {};
__export(exports_browser, {
  toPixels: () => toPixels,
  fromPixelsAsync: () => fromPixelsAsync,
  fromPixels: () => fromPixels,
  draw: () => draw
});
function fromPixels_(pixels, numChannels = 3) {
  if (numChannels > 4) {
    throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  }
  if (pixels == null) {
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  }
  let isPixelData = false;
  let isImageData = false;
  let isVideo = false;
  let isImage = false;
  let isCanvasLike = false;
  let isImageBitmap = false;
  if (pixels.data instanceof Uint8Array) {
    isPixelData = true;
  } else if (typeof ImageData !== "undefined" && pixels instanceof ImageData) {
    isImageData = true;
  } else if (typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement) {
    isVideo = true;
  } else if (typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement) {
    isImage = true;
  } else if (pixels.getContext != null) {
    isCanvasLike = true;
  } else if (typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap) {
    isImageBitmap = true;
  } else {
    throw new Error("pixels passed to tf.browser.fromPixels() must be either an " + `HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData ` + `in browser, or OffscreenCanvas, ImageData in webworker` + ` or {data: Uint32Array, width: number, height: number}, ` + `but was ${pixels.constructor.name}`);
  }
  const kernel = getKernel(FromPixels, ENGINE.backendName);
  if (kernel != null) {
    const inputs = { pixels };
    const attrs = { numChannels };
    return ENGINE.runKernel(FromPixels, inputs, attrs);
  }
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  let vals;
  if (isCanvasLike) {
    vals = pixels.getContext("2d").getImageData(0, 0, width, height).data;
  } else if (isImageData || isPixelData) {
    vals = pixels.data;
  } else if (isImage || isVideo || isImageBitmap) {
    if (fromPixels2DContext == null) {
      if (typeof document === "undefined") {
        if (typeof OffscreenCanvas !== "undefined" && typeof OffscreenCanvasRenderingContext2D !== "undefined") {
          fromPixels2DContext = new OffscreenCanvas(1, 1).getContext("2d");
        } else {
          throw new Error("Cannot parse input in current context. " + "Reason: OffscreenCanvas Context2D rendering is not supported.");
        }
      } else {
        fromPixels2DContext = document.createElement("canvas").getContext("2d", { willReadFrequently: true });
      }
    }
    fromPixels2DContext.canvas.width = width;
    fromPixels2DContext.canvas.height = height;
    fromPixels2DContext.drawImage(pixels, 0, 0, width, height);
    vals = fromPixels2DContext.getImageData(0, 0, width, height).data;
  }
  let values;
  if (numChannels === 4) {
    values = new Int32Array(vals);
  } else {
    const numPixels = width * height;
    values = new Int32Array(numPixels * numChannels);
    for (let i = 0;i < numPixels; i++) {
      for (let channel = 0;channel < numChannels; ++channel) {
        values[i * numChannels + channel] = vals[i * 4 + channel];
      }
    }
  }
  const outShape = [height, width, numChannels];
  return tensor3d(values, outShape, "int32");
}
function isPixelData(pixels) {
  return pixels != null && pixels.data instanceof Uint8Array;
}
function isImageBitmapFullySupported() {
  return typeof window !== "undefined" && typeof ImageBitmap !== "undefined" && window.hasOwnProperty("createImageBitmap");
}
function isNonEmptyPixels(pixels) {
  return pixels != null && pixels.width !== 0 && pixels.height !== 0;
}
function canWrapPixelsToImageBitmap(pixels) {
  return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) && isNonEmptyPixels(pixels) && !isPixelData(pixels);
}
async function fromPixelsAsync(pixels, numChannels = 3) {
  let inputs = null;
  if (env().getBool("WRAP_TO_IMAGEBITMAP") && canWrapPixelsToImageBitmap(pixels)) {
    let imageBitmap;
    try {
      imageBitmap = await createImageBitmap(pixels, { premultiplyAlpha: "none" });
    } catch (e) {
      imageBitmap = null;
    }
    if (imageBitmap != null && imageBitmap.width === pixels.width && imageBitmap.height === pixels.height) {
      inputs = imageBitmap;
    } else {
      inputs = pixels;
    }
  } else {
    inputs = pixels;
  }
  return fromPixels_(inputs, numChannels);
}
function validateImgTensor(img) {
  if (img.rank !== 2 && img.rank !== 3) {
    throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${img.rank}.`);
  }
  const depth = img.rank === 2 ? 1 : img.shape[2];
  if (depth > 4 || depth === 2) {
    throw new Error(`toPixels only supports depth of size ` + `1, 3 or 4 but got ${depth}`);
  }
  if (img.dtype !== "float32" && img.dtype !== "int32") {
    throw new Error(`Unsupported type for toPixels: ${img.dtype}.` + ` Please use float32 or int32 tensors.`);
  }
}
function validateImageOptions(imageOptions) {
  const alpha = (imageOptions === null || imageOptions === undefined ? undefined : imageOptions.alpha) || 1;
  if (alpha > 1 || alpha < 0) {
    throw new Error(`Alpha value ${alpha} is suppoed to be in range [0 - 1].`);
  }
}
async function toPixels(img, canvas) {
  let $img = convertToTensor(img, "img", "toPixels");
  if (!(img instanceof Tensor)) {
    const originalImgTensor = $img;
    $img = cast(originalImgTensor, "int32");
    originalImgTensor.dispose();
  }
  validateImgTensor($img);
  const [height, width] = $img.shape.slice(0, 2);
  const depth = $img.rank === 2 ? 1 : $img.shape[2];
  const data = await $img.data();
  const multiplier = $img.dtype === "float32" ? 255 : 1;
  const bytes = new Uint8ClampedArray(width * height * 4);
  for (let i = 0;i < height * width; ++i) {
    const rgba = [0, 0, 0, 255];
    for (let d = 0;d < depth; d++) {
      const value = data[i * depth + d];
      if ($img.dtype === "float32") {
        if (value < 0 || value > 1) {
          throw new Error(`Tensor values for a float32 Tensor must be in the ` + `range [0 - 1] but encountered ${value}.`);
        }
      } else if ($img.dtype === "int32") {
        if (value < 0 || value > 255) {
          throw new Error(`Tensor values for a int32 Tensor must be in the ` + `range [0 - 255] but encountered ${value}.`);
        }
      }
      if (depth === 1) {
        rgba[0] = value * multiplier;
        rgba[1] = value * multiplier;
        rgba[2] = value * multiplier;
      } else {
        rgba[d] = value * multiplier;
      }
    }
    const j = i * 4;
    bytes[j + 0] = Math.round(rgba[0]);
    bytes[j + 1] = Math.round(rgba[1]);
    bytes[j + 2] = Math.round(rgba[2]);
    bytes[j + 3] = Math.round(rgba[3]);
  }
  if (canvas != null) {
    if (!hasToPixelsWarned) {
      const kernel = getKernel(Draw, ENGINE.backendName);
      if (kernel != null) {
        console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. " + "Please try tf.browser.draw instead.");
        hasToPixelsWarned = true;
      }
    }
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    const imageData = new ImageData(bytes, width, height);
    ctx.putImageData(imageData, 0, 0);
  }
  if ($img !== img) {
    $img.dispose();
  }
  return bytes;
}
function draw(image2, canvas, options) {
  let $img = convertToTensor(image2, "img", "draw");
  if (!(image2 instanceof Tensor)) {
    const originalImgTensor = $img;
    $img = cast(originalImgTensor, "int32");
    originalImgTensor.dispose();
  }
  validateImgTensor($img);
  validateImageOptions(options === null || options === undefined ? undefined : options.imageOptions);
  const inputs = { image: $img };
  const attrs = { canvas, options };
  ENGINE.runKernel(Draw, inputs, attrs);
}
var fromPixels2DContext, hasToPixelsWarned = false, fromPixels;
var init_browser = __esm(() => {
  init_engine();
  init_environment();
  init_kernel_registry();
  init_tensor();
  init_tensor_util_env();
  init_cast();
  init_operation();
  init_tensor3d();
  fromPixels = op({ fromPixels_ });
});

// node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd_util.js
var exports_gather_nd_util = {};
__export(exports_gather_nd_util, {
  prepareAndValidate: () => prepareAndValidate
});
function prepareAndValidate(tensor16, indices) {
  const tensorRank = tensor16.shape.length;
  const indicesRank = indices.shape.length;
  if (tensorRank < 1) {
    throw new Error("tf.gatherND() expects the input to be rank 1 or higher," + ` but the rank was ${tensorRank}.`);
  }
  if (indicesRank < 1) {
    throw new Error("tf.gatherND() expects the indices to be rank 1 or higher," + ` but the rank was ${indicesRank}.`);
  }
  if (indices.dtype !== "int32") {
    throw new Error("tf.gatherND() expects the indices to be int32 type," + ` but the dtype was ${indices.dtype}.`);
  }
  if (indices.shape[indicesRank - 1] > tensorRank) {
    throw new Error("index innermost dimension length must be <= tensor rank; saw: " + `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);
  }
  if (sizeFromShape(tensor16.shape) === 0) {
    throw new Error("Requested more than 0 entries, but input is empty." + ` Input shape: ${tensor16.shape}.`);
  }
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  let nResult = 1;
  for (let i = 0;i < indicesShape.length - 1; ++i) {
    nResult *= indicesShape[i];
  }
  const inputShape = tensor16.shape;
  const resultShape = indicesShape.slice();
  resultShape.pop();
  let sliceSize = 1;
  for (let i = sliceRank;i < tensorRank; ++i) {
    sliceSize *= inputShape[i];
    resultShape.push(inputShape[i]);
  }
  const strides = [
    ...computeStrides(tensor16.shape).map((stride) => stride / sliceSize),
    1
  ].slice(0, sliceRank);
  return [resultShape, nResult, sliceSize, strides];
}
var init_gather_nd_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/slice_util.js
var exports_slice_util = {};
__export(exports_slice_util, {
  stridesWithElidedDims: () => stridesWithElidedDims,
  stridesForAxis: () => stridesForAxis,
  stopIndicesWithElidedDims: () => stopIndicesWithElidedDims,
  stopForAxis: () => stopForAxis,
  startIndicesWithElidedDims: () => startIndicesWithElidedDims,
  startForAxis: () => startForAxis,
  sliceInfo: () => sliceInfo,
  parseSliceParams: () => parseSliceParams,
  maskToAxes: () => maskToAxes,
  isSliceContinous: () => isSliceContinous,
  getNormalizedAxes: () => getNormalizedAxes,
  computeOutShape: () => computeOutShape,
  computeFlatOffset: () => computeFlatOffset,
  assertParamsValid: () => assertParamsValid
});
function assertParamsValid(input, begin, size) {
  const inputRank = input.shape.length;
  assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` + `match the rank of the array (${inputRank}).`);
  assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` + `match the rank of the array (${inputRank}).`);
  for (let i = 0;i < inputRank; ++i) {
    assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` + `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);
  }
}
function maskToAxes(mask) {
  const axes = [];
  let axis = 0;
  while (mask > 0) {
    if (mask & 1) {
      axes.push(axis);
    }
    mask /= 2;
    axis++;
  }
  return axes;
}
function computeOutShape(begin, end, strides) {
  const size = [];
  for (let axis = 0;axis < begin.length; axis++) {
    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);
  }
  return size;
}
function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {
  const newStrides = [...strides];
  for (let i = newStrides.length;i < inputShape.length; i++) {
    newStrides.push(1);
  }
  for (let i = 0;i < numElidedAxes; i++) {
    if (i === 0) {
      newStrides[ellipsisInsertionIndex] = 1;
    } else {
      newStrides.splice(ellipsisInsertionIndex, 0, 1);
      newStrides.pop();
    }
  }
  return newStrides;
}
function unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {
  if (normalizedAxis <= ellipsisInsertionIndex) {
    return normalizedAxis;
  }
  return normalizedAxis - (numElidedAxes - 1);
}
function getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {
  const elidedAxes = [];
  for (let i = 0;i < numElidedAxes; i++) {
    elidedAxes.push(ellipsisInsertionIndex + i);
  }
  return elidedAxes;
}
function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {
  const inputRank = inputShape.length;
  let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);
  if (ellipsisAxes.length && numInterpolatedAxes > 0) {
    const fullIndex = ellipsisAxes[0];
    const numElidedAxes = numInterpolatedAxes + 1;
    normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);
    normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);
    normalizedStrides = stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);
  } else {
    for (let axis = 0;axis < inputRank; axis++) {
      normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);
      normalizedEnd[axis] = stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);
      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);
    }
  }
  return {
    begin: normalizedBegin,
    end: normalizedEnd,
    strides: normalizedStrides
  };
}
function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0;axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = 0;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalBegin[originalAxis];
      if (beginMask & 1 << originalAxis) {
        originalValue = 0;
      }
      newIndices[axis] = originalValue;
    }
  }
  return newIndices;
}
function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {
  const newIndices = [...inputShape];
  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);
  for (let axis = 0;axis < newIndices.length; axis++) {
    if (elidedAxes.indexOf(axis) > -1) {
      newIndices[axis] = Number.MAX_SAFE_INTEGER;
    } else {
      const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);
      let originalValue = originalEnd[originalAxis];
      if (endMask & 1 << originalAxis) {
        originalValue = Number.MAX_SAFE_INTEGER;
      }
      newIndices[axis] = originalValue;
    }
  }
  for (let i = 0;i < newIndices.length; i++) {
    const axisSize = inputShape[i];
    if (newIndices[i] < 0) {
      newIndices[i] += axisSize;
    }
    newIndices[i] = clamp(0, newIndices[i], inputShape[i]);
  }
  return newIndices;
}
function stridesForAxis(strides, axis, ellipsisMask) {
  let stride = strides[axis];
  if (ellipsisMask & 1 << axis || stride == null) {
    stride = 1;
  }
  return stride;
}
function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {
  let start = startIndices[axis];
  const stride = strides[axis] || 1;
  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {
    if (stride > 0) {
      start = Number.MIN_SAFE_INTEGER;
    } else {
      start = Number.MAX_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (start < 0) {
    start += axisSize;
  }
  start = clamp(0, start, axisSize - 1);
  return start;
}
function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {
  let stop = stopIndices[axis];
  const stride = strides[axis] || 1;
  if (endMask & 1 << axis || ellipsisMask & 1 << axis || stop == null) {
    if (stride > 0) {
      stop = Number.MAX_SAFE_INTEGER;
    } else {
      stop = Number.MIN_SAFE_INTEGER;
    }
  }
  const axisSize = inputShape[axis];
  if (stop < 0) {
    stop += axisSize;
  }
  if (stride > 0) {
    stop = clamp(0, stop, axisSize);
  } else {
    stop = clamp(-1, stop, axisSize - 1);
  }
  return stop;
}
function isSliceContinous(shape, begin, size) {
  let firstNonOneAxis = size.length;
  for (let i = 0;i < size.length; i++) {
    if (size[i] > 1) {
      firstNonOneAxis = i;
      break;
    }
  }
  for (let i = firstNonOneAxis + 1;i < size.length; i++) {
    if (begin[i] > 0 || size[i] !== shape[i]) {
      return false;
    }
  }
  return true;
}
function computeFlatOffset(begin, strides) {
  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;
  for (let i = 0;i < begin.length - 1; i++) {
    flatOffset += begin[i] * strides[i];
  }
  return flatOffset;
}
function parseSliceParams(x, begin, size) {
  let begin_;
  const xRank = x.shape.length;
  if (typeof begin === "number") {
    begin_ = [begin, ...new Array(xRank - 1).fill(0)];
  } else if (begin.length < xRank) {
    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));
  } else {
    begin_ = begin.slice();
  }
  begin_.forEach((d) => {
    assert(d !== -1, () => "slice() does not support negative begin indexing.");
  });
  let size_;
  if (size == null) {
    size_ = new Array(xRank).fill(-1);
  } else if (typeof size === "number") {
    size_ = [size, ...new Array(xRank - 1).fill(-1)];
  } else if (size.length < xRank) {
    size_ = size.concat(new Array(xRank - size.length).fill(-1));
  } else {
    size_ = size;
  }
  size_ = size_.map((d, i) => {
    if (d >= 0) {
      return d;
    } else {
      assert(d === -1, () => `Negative size values should be exactly -1 but got ` + `${d} for the slice() size at index ${i}.`);
      return x.shape[i] - begin_[i];
    }
  });
  return [begin_, size_];
}
function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
  let stridesNonNull;
  if (strides == null) {
    stridesNonNull = new Array(begin.length);
    stridesNonNull.fill(1);
  } else {
    stridesNonNull = strides;
  }
  if (ellipsisMask != null && (ellipsisMask & ellipsisMask - 1) !== 0) {
    throw new Error("Multiple ellipses in slice is not allowed.");
  }
  let ellipsisSeen = false;
  const sparseSpec = {
    dims: stridesNonNull.length,
    numAddAxisAfterEllipsis: 0,
    begin: begin.slice(),
    end: end.slice(),
    strides: stridesNonNull.slice(),
    beginMask,
    endMask,
    ellipsisMask,
    newAxisMask,
    shrinkAxisMask
  };
  for (let i = 0;i < sparseSpec.dims; i++) {
    if (ellipsisSeen && (1 << i & newAxisMask) !== 0) {
      sparseSpec.numAddAxisAfterEllipsis++;
    }
    if (1 << i & ellipsisMask) {
      ellipsisSeen = true;
    }
  }
  if (!ellipsisSeen) {
    sparseSpec.ellipsisMask |= 1 << sparseSpec.dims;
    sparseSpec.dims++;
  }
  const denseSpec = {
    dims: xShape.length,
    beginMask: 0,
    endMask: 0,
    beginValid: false,
    endValid: false
  };
  buildDenseSpec(sparseSpec, denseSpec);
  let isIdentity = true;
  let sliceDim0 = true;
  let isSimpleSlice = true;
  const processingShape = [];
  const finalShape = [];
  for (let i = 0;i < xShape.length; ++i) {
    if (denseSpec.strides[i] === 0) {
      throw Error(`strides[${i}] must be non-zero`);
    }
    const shrinkI = !!(denseSpec.shrinkAxisMask & 1 << i);
    const dimI = xShape[i];
    if (dimI === -1) {
      processingShape.push(shrinkI ? 1 : -1);
      continue;
    }
    const masks = [denseSpec.beginMask & 1 << i, denseSpec.endMask & 1 << i];
    const validRange = [
      denseSpec.strides[i] > 0 ? 0 : -1,
      denseSpec.strides[i] > 0 ? dimI : dimI - 1
    ];
    if (shrinkI && denseSpec.strides[i] <= 0) {
      throw Error("only stride 1 allowed on non-range indexing.");
    }
    isSimpleSlice = isSimpleSlice && denseSpec.strides[i] === 1;
    const beginAndEndMasked = !!(denseSpec.beginMask & 1 << i && denseSpec.endMask & 1 << i);
    if (denseSpec.beginValid && denseSpec.endValid) {
      if (shrinkI) {
        const xFwd = denseSpec.begin[i] < 0 ? dimI + denseSpec.begin[i] : denseSpec.begin[i];
        denseSpec.begin[i] = xFwd;
        denseSpec.end[i] = denseSpec.begin[i] + 1;
        if (xFwd < 0 || xFwd >= dimI) {
          throw Error(`slice index ${denseSpec.begin[i]} of dimension ${i} out of bounds.`);
        }
      } else {
        denseSpec.begin[i] = canonical(denseSpec.begin[i], 0, denseSpec.strides[i], dimI, masks, validRange);
        denseSpec.end[i] = canonical(denseSpec.end[i], 1, denseSpec.strides[i], dimI, masks, validRange);
      }
      const takeAllInDimension = denseSpec.strides[i] === 1 && denseSpec.begin[i] === 0 && denseSpec.end[i] === dimI;
      isIdentity = isIdentity && takeAllInDimension;
      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || takeAllInDimension);
    } else {
      isIdentity = isIdentity && (denseSpec.strides[i] === 1 && beginAndEndMasked);
      sliceDim0 = sliceDim0 && (i === 0 && denseSpec.strides[i] === 1 || beginAndEndMasked);
    }
    let intervalLength;
    let knownInterval = false;
    if (denseSpec.beginValid && denseSpec.endValid) {
      intervalLength = denseSpec.end[i] - denseSpec.begin[i];
      knownInterval = true;
    } else if (shrinkI) {
      intervalLength = 1;
      knownInterval = true;
    } else if (beginAndEndMasked) {
      if (dimI >= 0) {
        if (denseSpec.strides[i] < 0) {
          intervalLength = -dimI;
        } else {
          intervalLength = dimI;
        }
        knownInterval = true;
      }
    }
    if (knownInterval) {
      let sizeI;
      if (intervalLength === 0 || intervalLength < 0 !== denseSpec.strides[i] < 0) {
        sizeI = 0;
      } else {
        sizeI = Math.trunc(intervalLength / denseSpec.strides[i]) + (intervalLength % denseSpec.strides[i] !== 0 ? 1 : 0);
      }
      processingShape.push(sizeI);
    } else {
      processingShape.push(-1);
    }
  }
  for (let denseDim = 0;denseDim < denseSpec.finalShapeGatherIndices.length; ++denseDim) {
    const gatherIndex = denseSpec.finalShapeGatherIndices[denseDim];
    if (gatherIndex >= 0) {
      finalShape.push(processingShape[gatherIndex]);
    } else if (gatherIndex === NEW_AXIS) {
      finalShape.push(1);
    }
  }
  const finalShapeSparse = finalShape.filter((dim, i) => denseSpec.finalShapeGatherIndices[i] !== NEW_AXIS);
  return {
    finalShapeSparse,
    finalShape,
    isIdentity,
    sliceDim0,
    isSimpleSlice,
    begin: denseSpec.begin,
    end: denseSpec.end,
    strides: denseSpec.strides
  };
}
function buildDenseSpec(sparse2, dense) {
  dense.beginMask = 0;
  dense.endMask = 0;
  dense.shrinkAxisMask = 0;
  let fullIndex = 0;
  dense.beginValid = sparse2.begin != null;
  dense.endValid = sparse2.end != null;
  dense.begin = new Array(dense.dims);
  dense.end = new Array(dense.dims);
  dense.strides = new Array(dense.dims);
  dense.finalShapeGatherIndices = [];
  dense.finalShapeGatherIndicesSparse = [];
  dense.inputShapeGatherIndicesSparse = new Array(dense.dims);
  for (let i = 0;i < sparse2.dims; i++) {
    if (1 << i & sparse2.ellipsisMask) {
      const nextIndex = Math.min(dense.dims - (sparse2.dims - i) + 1 + sparse2.numAddAxisAfterEllipsis, dense.dims);
      for (;fullIndex < nextIndex; fullIndex++) {
        dense.begin[fullIndex] = 0;
        dense.end[fullIndex] = 0;
        dense.strides[fullIndex] = 1;
        dense.beginMask |= 1 << fullIndex;
        dense.endMask |= 1 << fullIndex;
        dense.finalShapeGatherIndices.push(fullIndex);
        dense.finalShapeGatherIndicesSparse.push(-1);
        dense.inputShapeGatherIndicesSparse[fullIndex] = i;
      }
    } else if (1 << i & sparse2.newAxisMask) {
      dense.finalShapeGatherIndices.push(NEW_AXIS);
      dense.finalShapeGatherIndicesSparse.push(-1);
    } else {
      if (fullIndex === dense.begin.length) {
        throw Error(`Index out of range using input dim ${fullIndex}; input ` + `has only ${dense.dims} dims, ${dense.begin.length}.`);
      }
      if (sparse2.begin != null) {
        dense.begin[fullIndex] = sparse2.begin[i];
      }
      if (sparse2.end != null) {
        dense.end[fullIndex] = sparse2.end[i];
      }
      dense.strides[fullIndex] = sparse2.strides[i];
      if (sparse2.beginMask & 1 << i) {
        dense.beginMask |= 1 << fullIndex;
      }
      if (sparse2.endMask & 1 << i) {
        dense.endMask |= 1 << fullIndex;
      }
      if (sparse2.shrinkAxisMask & 1 << i) {
        dense.finalShapeGatherIndices.push(SHRINK_AXIS);
        dense.finalShapeGatherIndicesSparse.push(-1);
        dense.shrinkAxisMask |= 1 << fullIndex;
      } else {
        dense.finalShapeGatherIndices.push(fullIndex);
        dense.finalShapeGatherIndicesSparse.push(i);
      }
      dense.inputShapeGatherIndicesSparse[fullIndex] = i;
      fullIndex++;
    }
  }
}
function canonical(x, c, strideI, dimI, masks, validRange) {
  if (masks[c]) {
    return strideI > 0 ? validRange[c] : validRange[c + 1 & 1];
  } else {
    const xFwd = x < 0 ? dimI + x : x;
    return xFwd < validRange[0] ? validRange[0] : xFwd > validRange[1] ? validRange[1] : xFwd;
  }
}
var NEW_AXIS = -2, SHRINK_AXIS = -1;
var init_slice_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/version.js
var version = "4.22.0";
var init_version = () => {
};

// node_modules/@tensorflow/tfjs-core/dist/optimizers/optimizer_constructors.js
class OptimizerConstructors {
  static sgd(learningRate) {
    return new SGDOptimizer(learningRate);
  }
  static momentum(learningRate, momentum, useNesterov = false) {
    return new MomentumOptimizer(learningRate, momentum, useNesterov);
  }
  static rmsprop(learningRate, decay = 0.9, momentum = 0, epsilon = null, centered = false) {
    return new RMSPropOptimizer(learningRate, decay, momentum, epsilon, centered);
  }
  static adam(learningRate = 0.001, beta1 = 0.9, beta2 = 0.999, epsilon = null) {
    return new AdamOptimizer(learningRate, beta1, beta2, epsilon);
  }
  static adadelta(learningRate = 0.001, rho = 0.95, epsilon = null) {
    return new AdadeltaOptimizer(learningRate, rho, epsilon);
  }
  static adamax(learningRate = 0.002, beta1 = 0.9, beta2 = 0.999, epsilon = null, decay = 0) {
    return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);
  }
  static adagrad(learningRate, initialAccumulatorValue = 0.1) {
    return new AdagradOptimizer(learningRate, initialAccumulatorValue);
  }
}
var init_optimizer_constructors = __esm(() => {
  init_adadelta_optimizer();
  init_adagrad_optimizer();
  init_adam_optimizer();
  init_adamax_optimizer();
  init_momentum_optimizer();
  init_rmsprop_optimizer();
  init_sgd_optimizer();
});

// node_modules/@tensorflow/tfjs-core/dist/train.js
var train;
var init_train = __esm(() => {
  init_optimizer_constructors();
  train = OptimizerConstructors;
});

// node_modules/@tensorflow/tfjs-core/dist/browser_util.js
function nextFrame() {
  return new Promise((resolve) => delayCallback(() => resolve()));
}
var delayCallback;
var init_browser_util = __esm(() => {
  delayCallback = (() => {
    if (typeof requestAnimationFrame !== "undefined") {
      return requestAnimationFrame;
    } else if (typeof setImmediate !== "undefined") {
      return setImmediate;
    }
    return (f) => f();
  })();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/concat_util.js
function assertParamsConsistent(shapes, axis) {
  const rank = shapes[0].length;
  shapes.forEach((shape, i) => {
    assert(shape.length === rank, () => `Error in concat${rank}D: rank of tensors[${i}] must be the same ` + `as the rank of the rest (${rank})`);
  });
  assert(axis >= 0 && axis < rank, () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);
  const firstShape = shapes[0];
  shapes.forEach((shape, i) => {
    for (let r = 0;r < rank; r++) {
      assert(r === axis || shape[r] === firstShape[r], () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) ` + `does not match the shape of the rest (${firstShape}) ` + `along the non-concatenated axis ${i}.`);
    }
  });
}
function computeOutShape2(shapes, axis) {
  const outputShape = shapes[0].slice();
  for (let i = 1;i < shapes.length; i++) {
    outputShape[axis] += shapes[i][axis];
  }
  return outputShape;
}
var init_concat_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/fused_types.js
var init_fused_types = () => {
};

// node_modules/@tensorflow/tfjs-core/dist/ops/ragged_to_dense_util.js
function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {
  let outputShape = new Array;
  if (valueShape == null && shape == null) {
    return outputShape;
  }
  if (shape == null) {
    while (outputShape.length < raggedRank + valueShape.length) {
      outputShape.push(-1);
    }
  } else {
    outputShape = shape.slice();
  }
  if (valueShape == null) {
    return outputShape;
  }
  if (raggedRank + valueShape.length !== outputShape.length) {
    throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);
  }
  for (let i = 1;i < valueShape.length; ++i) {
    const valueDim = valueShape[i];
    const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];
    const outputShapeDim = outputShape[outputShapeDimIndex];
    if (valueDim >= 0) {
      if (outputShapeDim >= 0) {
        if (outputShapeDim !== valueDim) {
          throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);
        }
      } else {
        outputShape[outputShapeDimIndex] = valueDim;
      }
    }
  }
  return outputShape;
}
function getRowPartitionTypesHelper(rowPartitionTypeStrings) {
  const stringToType = {
    FIRST_DIM_SIZE: RowPartitionType.FIRST_DIM_SIZE,
    VALUE_ROWIDS: RowPartitionType.VALUE_ROWIDS,
    ROW_LENGTHS: RowPartitionType.ROW_LENGTHS,
    ROW_SPLITS: RowPartitionType.ROW_SPLITS,
    ROW_LIMITS: RowPartitionType.ROW_LIMITS,
    ROW_STARTS: RowPartitionType.ROW_STARTS
  };
  const result = [];
  for (const typeStr of rowPartitionTypeStrings) {
    if (typeStr in stringToType) {
      result.push(stringToType[typeStr]);
    } else {
      break;
    }
  }
  return result;
}
function getRaggedRank(rowPartitionTypes) {
  if (rowPartitionTypes.length === 0) {
    return 0;
  }
  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {
    return rowPartitionTypes.length - 1;
  }
  return rowPartitionTypes.length;
}
function validateDefaultValueShape(defaultValueShape, valueShape) {
  if (defaultValueShape == null || valueShape == null) {
    return;
  }
  const defaultNDims = defaultValueShape.length;
  const valuesNDims = valueShape.length;
  if (defaultNDims >= valuesNDims) {
    throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);
  }
  for (let i = 0;i < Math.min(defaultNDims, valuesNDims - 1); ++i) {
    const defaultDim = defaultValueShape[i];
    const valueDim = valueShape[i + 1];
    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {
      throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);
    }
  }
}
var RowPartitionType;
var init_ragged_to_dense_util = __esm(() => {
  (function(RowPartitionType2) {
    RowPartitionType2[RowPartitionType2["FIRST_DIM_SIZE"] = 0] = "FIRST_DIM_SIZE";
    RowPartitionType2[RowPartitionType2["VALUE_ROWIDS"] = 1] = "VALUE_ROWIDS";
    RowPartitionType2[RowPartitionType2["ROW_LENGTHS"] = 2] = "ROW_LENGTHS";
    RowPartitionType2[RowPartitionType2["ROW_SPLITS"] = 3] = "ROW_SPLITS";
    RowPartitionType2[RowPartitionType2["ROW_LIMITS"] = 4] = "ROW_LIMITS";
    RowPartitionType2[RowPartitionType2["ROW_STARTS"] = 5] = "ROW_STARTS";
  })(RowPartitionType || (RowPartitionType = {}));
});

// node_modules/@tensorflow/tfjs-core/dist/ops/reduce_util.js
function computeOptimalWindowSize(inSize) {
  if (inSize <= PARALLELIZE_THRESHOLD) {
    return inSize;
  }
  return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
var PARALLELIZE_THRESHOLD = 30;
var init_reduce_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/rotate_util.js
function getImageCenter(center, imageHeight, imageWidth) {
  const centerX = imageWidth * (typeof center === "number" ? center : center[0]);
  const centerY = imageHeight * (typeof center === "number" ? center : center[1]);
  return [centerX, centerY];
}

// node_modules/@tensorflow/tfjs-core/dist/ops/array_ops_util.js
function getReshaped(inputShape, blockShape, prod2, batchToSpace = true) {
  let reshaped = [];
  if (batchToSpace) {
    reshaped = reshaped.concat(blockShape.slice(0));
    reshaped.push(inputShape[0] / prod2);
    reshaped = reshaped.concat(inputShape.slice(1));
  } else {
    reshaped = reshaped.concat(inputShape[0]);
    const spatialLength = blockShape.length;
    for (let i = 0;i < spatialLength; ++i) {
      reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);
    }
    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));
  }
  return reshaped;
}
function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {
  const permuted = [];
  if (batchToSpace) {
    permuted.push(blockShapeRank);
    for (let i = blockShapeRank + 1;i < reshapedRank; ++i) {
      if (i <= 2 * blockShapeRank) {
        permuted.push(i);
        permuted.push(i - (blockShapeRank + 1));
      } else {
        permuted.push(i);
      }
    }
  } else {
    const permutedBeforeBatch = [];
    const permutedAfterBatch = [];
    for (let i = 1;i < reshapedRank; ++i) {
      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {
        permutedAfterBatch.push(i);
      } else {
        permutedBeforeBatch.push(i);
      }
    }
    permuted.push(...permutedBeforeBatch);
    permuted.push(0);
    permuted.push(...permutedAfterBatch);
  }
  return permuted;
}
function getReshapedPermuted(inputShape, blockShape, prod2, batchToSpace = true) {
  const reshapedPermuted = [];
  if (batchToSpace) {
    reshapedPermuted.push(inputShape[0] / prod2);
  } else {
    reshapedPermuted.push(inputShape[0] * prod2);
  }
  for (let i = 1;i < inputShape.length; ++i) {
    if (i <= blockShape.length) {
      if (batchToSpace) {
        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);
      } else {
        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);
      }
    } else {
      reshapedPermuted.push(inputShape[i]);
    }
  }
  return reshapedPermuted;
}
function getSliceBeginCoords(crops, blockShape) {
  const sliceBeginCoords = [0];
  for (let i = 0;i < blockShape; ++i) {
    sliceBeginCoords.push(crops[i][0]);
  }
  return sliceBeginCoords;
}
function getSliceSize(uncroppedShape, crops, blockShape) {
  const sliceSize = uncroppedShape.slice(0, 1);
  for (let i = 0;i < blockShape; ++i) {
    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);
  }
  return sliceSize;
}

// node_modules/@tensorflow/tfjs-core/dist/ops/selu_util.js
var SELU_SCALEALPHA = 1.7580993408473768, SELU_SCALE = 1.0507009873554805;

// node_modules/@tensorflow/tfjs-core/dist/ops/erf_util.js
var ERF_P = 0.3275911, ERF_A1 = 0.254829592, ERF_A2 = -0.284496736, ERF_A3 = 1.421413741, ERF_A4 = -1.453152027, ERF_A5 = 1.061405429;

// node_modules/@tensorflow/tfjs-core/dist/backends/complex_util.js
function mergeRealAndImagArrays(real5, imag5) {
  if (real5.length !== imag5.length) {
    throw new Error(`Cannot merge real and imag arrays of different lengths. real:` + `${real5.length}, imag: ${imag5.length}.`);
  }
  const result = new Float32Array(real5.length * 2);
  for (let i = 0;i < result.length; i += 2) {
    result[i] = real5[i / 2];
    result[i + 1] = imag5[i / 2];
  }
  return result;
}
function splitRealAndImagArrays(complex8) {
  const real5 = new Float32Array(complex8.length / 2);
  const imag5 = new Float32Array(complex8.length / 2);
  for (let i = 0;i < complex8.length; i += 2) {
    real5[i / 2] = complex8[i];
    imag5[i / 2] = complex8[i + 1];
  }
  return { real: real5, imag: imag5 };
}
function complexWithEvenIndex(complex8) {
  const len = Math.ceil(complex8.length / 4);
  const real5 = new Float32Array(len);
  const imag5 = new Float32Array(len);
  for (let i = 0;i < complex8.length; i += 4) {
    real5[Math.floor(i / 4)] = complex8[i];
    imag5[Math.floor(i / 4)] = complex8[i + 1];
  }
  return { real: real5, imag: imag5 };
}
function complexWithOddIndex(complex8) {
  const len = Math.floor(complex8.length / 4);
  const real5 = new Float32Array(len);
  const imag5 = new Float32Array(len);
  for (let i = 2;i < complex8.length; i += 4) {
    real5[Math.floor(i / 4)] = complex8[i];
    imag5[Math.floor(i / 4)] = complex8[i + 1];
  }
  return { real: real5, imag: imag5 };
}
function getComplexWithIndex(complex8, index) {
  const real5 = complex8[index * 2];
  const imag5 = complex8[index * 2 + 1];
  return { real: real5, imag: imag5 };
}
function assignToTypedArray(data, real5, imag5, index) {
  data[index * 2] = real5;
  data[index * 2 + 1] = imag5;
}
function exponents(n, inverse) {
  const real5 = new Float32Array(n / 2);
  const imag5 = new Float32Array(n / 2);
  for (let i = 0;i < Math.ceil(n / 2); i++) {
    const x = (inverse ? 2 : -2) * Math.PI * (i / n);
    real5[i] = Math.cos(x);
    imag5[i] = Math.sin(x);
  }
  return { real: real5, imag: imag5 };
}
function exponent(k, n, inverse) {
  const x = (inverse ? 2 : -2) * Math.PI * (k / n);
  const real5 = Math.cos(x);
  const imag5 = Math.sin(x);
  return { real: real5, imag: imag5 };
}

// node_modules/@tensorflow/tfjs-core/dist/backends/einsum_util.js
function decodeEinsumEquation(equation, numTensors) {
  equation = equation.replace(/\s/g, "");
  const numArrows = (equation.length - equation.replace(ARROW_REGEX, "").length) / ARROW.length;
  if (numArrows < 1) {
    throw new Error("Equations without an arrow are not supported.");
  } else if (numArrows > 1) {
    throw new Error(`Equation must contain exactly one arrow ("${ARROW}").`);
  }
  const [inputString, outputString] = equation.split(ARROW);
  assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation ("${ELLIPSIS}") is not supported yet.`);
  const inputTerms = inputString.split(COMMA);
  const numInputs = inputTerms.length;
  if (numTensors !== numInputs) {
    throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);
  }
  if (numInputs > 2) {
    throw new Error("Support for more than 2 input tensors is not implemented yet.");
  }
  const allDims = [];
  for (let i = 0;i < outputString.length; ++i) {
    const dimName = outputString[i];
    if (!inputTerms.some((inputTerm) => inputTerm.indexOf(dimName) !== -1)) {
      throw new Error(`Output subscripts contain the label ${dimName} ` + `not present in the input subscripts.`);
    }
    if (allDims.indexOf(dimName) === -1) {
      allDims.push(dimName);
    }
  }
  for (let i = 0;i < inputString.length; ++i) {
    const dimName = inputString[i];
    if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {
      allDims.push(dimName);
    }
  }
  const idDims = new Array(inputTerms.length);
  for (let i = 0;i < numInputs; ++i) {
    if (new Set(inputTerms[i].split("")).size !== inputTerms[i].length) {
      throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. ` + `Support for duplicate axes in input is not implemented yet.`);
    }
    idDims[i] = [];
    for (let j = 0;j < inputTerms[i].length; ++j) {
      idDims[i].push(allDims.indexOf(inputTerms[i][j]));
    }
  }
  const numDims = allDims.length;
  const numOutDims = outputString.length;
  const summedDims = [];
  for (let i = numOutDims;i < numDims; ++i) {
    summedDims.push(i);
  }
  return { allDims, summedDims, idDims };
}
function getEinsumPermutation(nDims, idDims) {
  let permutationIndices = new Array(nDims);
  permutationIndices.fill(-1);
  for (let i = 0;i < idDims.length; ++i) {
    permutationIndices[idDims[i]] = i;
  }
  const expandDims2 = [];
  for (let i = 0;i < nDims; ++i) {
    if (permutationIndices[i] === -1) {
      expandDims2.push(i);
    }
  }
  permutationIndices = permutationIndices.filter((d) => d !== -1);
  return { permutationIndices, expandDims: expandDims2 };
}
function checkEinsumDimSizes(nDims, idDims, tensors) {
  const dimSizes = new Array(nDims);
  for (let i = 0;i < tensors.length; ++i) {
    const shape = tensors[i].shape;
    for (let j = 0;j < idDims[i].length; ++j) {
      if (dimSizes[idDims[i][j]] === undefined) {
        dimSizes[idDims[i][j]] = shape[j];
      } else {
        assert(dimSizes[idDims[i][j]] === shape[j], () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} ` + `of input shaped ${JSON.stringify(shape)}, ` + `but got dimension ${shape[j]}`);
      }
    }
  }
}
function getEinsumComputePath(summedDims, idDims) {
  const path = summedDims;
  const steps = [];
  let nSteps = 0;
  if (summedDims.length === 0) {
    path.push(-1);
  }
  nSteps = summedDims.length + 1;
  for (let i = 0;i < nSteps; ++i) {
    steps.push([]);
  }
  const computedTermIndices = [];
  for (let i = 0;i < path.length; ++i) {
    const summedDim = path[i];
    const termIndices = findTermsWithDim(idDims, summedDim);
    for (const termIndex of termIndices) {
      if (computedTermIndices.indexOf(termIndex) === -1) {
        steps[i].push(termIndex);
        computedTermIndices.push(termIndex);
      }
    }
  }
  return { path, steps };
}
function isIdentityPermutation(perm) {
  return perm.every((dim, index) => dim === index);
}
function findTermsWithDim(idDims, dim) {
  const termIndices = [];
  for (let i = 0;i < idDims.length; ++i) {
    if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {
      termIndices.push(i);
    }
  }
  return termIndices;
}
var ARROW = "->", ARROW_REGEX, COMMA = ",", ELLIPSIS = "...";
var init_einsum_util = __esm(() => {
  ARROW_REGEX = /->/g;
});

// node_modules/@tensorflow/tfjs-core/dist/ops/split_util.js
function prepareSplitSize(x, numOrSizeSplits, axis = 0) {
  let splitSizes = [];
  if (typeof numOrSizeSplits === "number") {
    assert(x.shape[axis] % numOrSizeSplits === 0, () => "Number of splits must evenly divide the axis.");
    splitSizes = new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);
  } else {
    const numOfNegs = numOrSizeSplits.reduce((count, value) => {
      if (value === -1) {
        count += 1;
      }
      return count;
    }, 0);
    assert(numOfNegs <= 1, () => "There should be only one negative value in split array.");
    const negIndex = numOrSizeSplits.indexOf(-1);
    if (negIndex !== -1) {
      const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);
      numOrSizeSplits[negIndex] = x.shape[axis] - total;
    }
    assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => "The sum of sizes must match the size of the axis dimension.");
    splitSizes = numOrSizeSplits;
  }
  return splitSizes;
}
var init_split_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows_util.js
function getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesLength) {
  return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${indicesLength}`;
}
function getSparseFillEmptyRowsNegativeIndexErrorMessage(index, value) {
  return `indices(${index}, 0) is invalid: ${value} < 0`;
}
function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(index, value, limit) {
  return `indices(${index}, 0) is invalid: ${value} >= ${limit}`;
}

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape_util.js
function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(dim1, dim2) {
  return `only one output dimension may be -1, not both ${dim1} and ${dim2}`;
}
function getSparseReshapeNegativeOutputDimErrorMessage(dim, value) {
  return `size ${dim} must be non-negative, not ${value}`;
}
function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage() {
  return "reshape cannot infer the missing input size for an empty tensor " + "unless all specified input sizes are non-zero";
}
function getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape) {
  const inputSize = sizeFromShape(inputShape);
  const outputSize = sizeFromShape(outputShape);
  return `Input to reshape is a SparseTensor with ${inputSize}
  dense values, but the requested shape requires a multiple of ${outputSize}. inputShape=${inputShape} outputShape= ${outputShape}`;
}
function getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape) {
  const inputSize = sizeFromShape(inputShape);
  const outputSize = sizeFromShape(outputShape);
  return `Input to reshape is a tensor with ${inputSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`;
}
var init_sparse_reshape_util = __esm(() => {
  init_util();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_reduction_util.js
function getSparseSegmentReductionNegativeSegmentIdsErrorMessage() {
  return `segment ids must be >= 0`;
}
function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage() {
  return `segment ids are not increasing`;
}
function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(segmentId, outputRows) {
  return `Segment id ${segmentId} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`;
}
function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(index, indexValue, inputRows) {
  return `Bad: indices[${index}] == ${indexValue} out of range [0, ${inputRows})`;
}

// node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js
var exports_segment_util = {};
__export(exports_segment_util, {
  segOpComputeOptimalWindowSize: () => segOpComputeOptimalWindowSize,
  computeOutShape: () => computeOutShape3,
  collectGatherOpShapeInfo: () => collectGatherOpShapeInfo
});
function segOpComputeOptimalWindowSize(inSize, numSegments) {
  let done = false;
  let res;
  if (inSize <= PARALLELIZE_THRESHOLD) {
    res = inSize;
    done = true;
  } else {
    res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
  }
  while (!done) {
    if (res > numSegments || res === inSize) {
      done = true;
    } else {
      res = nearestDivisor(inSize, res + 1);
    }
  }
  return res;
}
function computeOutShape3(aShape, axis, numSegments) {
  const outShape = [];
  const rank = aShape.length;
  for (let dim = 0;dim < rank; dim++) {
    if (dim !== axis) {
      outShape.push(aShape[dim]);
    } else {
      outShape.push(numSegments);
    }
  }
  return outShape;
}
function collectGatherOpShapeInfo(x, indices, axis, batchDims) {
  const indicesRank = indices.shape.length;
  const xRank = x.shape.length;
  if (batchDims !== 0) {
    if (batchDims < -indicesRank || batchDims > indicesRank) {
      throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);
    }
  }
  if (batchDims < 0) {
    batchDims += indicesRank;
  }
  if (batchDims > xRank) {
    throw new Error(`batchDims (${batchDims}) must be less than rank(x) (
    ${xRank}).`);
  }
  if (axis < batchDims) {
    throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);
  }
  for (let i = 0;i < batchDims; ++i) {
    if (x.shape[i] !== indices.shape[i]) {
      throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);
    }
  }
  const dimSize = x.shape[axis];
  const outputShape = [];
  let batchSize = 1;
  let outerSize = 1;
  let sliceSize = 1;
  for (let i = 0;i < batchDims; ++i) {
    outputShape.push(x.shape[i]);
    batchSize *= x.shape[i];
  }
  for (let i = batchDims;i < axis; i++) {
    outputShape.push(x.shape[i]);
    outerSize *= x.shape[i];
  }
  for (let i = batchDims;i < indicesRank; i++) {
    outputShape.push(indices.shape[i]);
  }
  for (let i = axis + 1;i < xRank; i++) {
    outputShape.push(x.shape[i]);
    sliceSize *= x.shape[i];
  }
  return { batchSize, sliceSize, outerSize, dimSize, outputShape };
}
var init_segment_util = __esm(() => {
  init_util();
  init_reduce_util();
});

// node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js
var exports_backend_util = {};
__export(exports_backend_util, {
  warn: () => warn,
  validateUpdateShape: () => validateUpdateShape,
  validateInput: () => validateInput,
  validateDefaultValueShape: () => validateDefaultValueShape,
  upcastType: () => upcastType,
  tupleValuesAreOne: () => tupleValuesAreOne,
  stridesOrDilationsArePositive: () => stridesOrDilationsArePositive,
  splitRealAndImagArrays: () => splitRealAndImagArrays,
  slice_util: () => exports_slice_util,
  shouldFuse: () => shouldFuse,
  segment_util: () => exports_segment_util,
  prepareSplitSize: () => prepareSplitSize,
  prepareAndValidate: () => prepareAndValidate,
  mergeRealAndImagArrays: () => mergeRealAndImagArrays,
  log: () => log,
  isIdentityPermutation: () => isIdentityPermutation,
  getUndoAxesPermutation: () => getUndoAxesPermutation,
  getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage,
  getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage,
  getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => getSparseSegmentReductionNegativeSegmentIdsErrorMessage,
  getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => getSparseSegmentReductionIndicesOutOfRangeErrorMessage,
  getSparseReshapeNegativeOutputDimErrorMessage: () => getSparseReshapeNegativeOutputDimErrorMessage,
  getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => getSparseReshapeMultipleNegativeOneOutputDimErrorMessage,
  getSparseReshapeInputOutputMultipleErrorMessage: () => getSparseReshapeInputOutputMultipleErrorMessage,
  getSparseReshapeInputOutputMismatchErrorMessage: () => getSparseReshapeInputOutputMismatchErrorMessage,
  getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => getSparseReshapeEmptyTensorZeroOutputDimErrorMessage,
  getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => getSparseFillEmptyRowsOutOfRangeIndexErrorMessage,
  getSparseFillEmptyRowsNegativeIndexErrorMessage: () => getSparseFillEmptyRowsNegativeIndexErrorMessage,
  getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => getSparseFillEmptyRowsIndicesDenseShapeMismatch,
  getSliceSize: () => getSliceSize,
  getSliceBeginCoords: () => getSliceBeginCoords,
  getRowPartitionTypesHelper: () => getRowPartitionTypesHelper,
  getReshapedPermuted: () => getReshapedPermuted,
  getReshaped: () => getReshaped,
  getReductionAxes: () => getReductionAxes,
  getRaggedRank: () => getRaggedRank,
  getPermuted: () => getPermuted,
  getInnerMostAxes: () => getInnerMostAxes,
  getImageCenter: () => getImageCenter,
  getFusedDyActivation: () => getFusedDyActivation,
  getFusedBiasGradient: () => getFusedBiasGradient,
  getEinsumPermutation: () => getEinsumPermutation,
  getEinsumComputePath: () => getEinsumComputePath,
  getComplexWithIndex: () => getComplexWithIndex,
  getBroadcastDims: () => getBroadcastDims,
  getAxesPermutation: () => getAxesPermutation,
  fromUint8ToStringArray: () => fromUint8ToStringArray,
  fromStringArrayToUint8: () => fromStringArrayToUint8,
  exponents: () => exponents,
  exponent: () => exponent,
  expandShapeToKeepDim: () => expandShapeToKeepDim,
  eitherStridesOrDilationsAreOne: () => eitherStridesOrDilationsAreOne,
  decodeEinsumEquation: () => decodeEinsumEquation,
  convertConv2DDataFormat: () => convertConv2DDataFormat,
  computePool3DInfo: () => computePool3DInfo,
  computePool2DInfo: () => computePool2DInfo,
  computeOutShape: () => computeOutShape2,
  computeOutAndReduceShapes: () => computeOutAndReduceShapes,
  computeOptimalWindowSize: () => computeOptimalWindowSize,
  computeDilation2DInfo: () => computeDilation2DInfo,
  computeDefaultPad: () => computeDefaultPad,
  computeConv3DInfo: () => computeConv3DInfo,
  computeConv2DInfo: () => computeConv2DInfo,
  complexWithOddIndex: () => complexWithOddIndex,
  complexWithEvenIndex: () => complexWithEvenIndex,
  combineRaggedTensorToTensorShapes: () => combineRaggedTensorToTensorShapes,
  combineLocations: () => combineLocations,
  checkPadOnDimRoundingMode: () => checkPadOnDimRoundingMode,
  checkEinsumDimSizes: () => checkEinsumDimSizes,
  calculateShapes: () => calculateShapes,
  axesAreInnerMostDims: () => axesAreInnerMostDims,
  assignToTypedArray: () => assignToTypedArray,
  assertParamsConsistent: () => assertParamsConsistent,
  assertAxesAreInnerMostDims: () => assertAxesAreInnerMostDims,
  assertAndGetBroadcastShape: () => assertAndGetBroadcastShape,
  applyActivation: () => applyActivation,
  SELU_SCALEALPHA: () => SELU_SCALEALPHA,
  SELU_SCALE: () => SELU_SCALE,
  RowPartitionType: () => RowPartitionType,
  PARALLELIZE_THRESHOLD: () => PARALLELIZE_THRESHOLD,
  ERF_P: () => ERF_P,
  ERF_A5: () => ERF_A5,
  ERF_A4: () => ERF_A4,
  ERF_A3: () => ERF_A3,
  ERF_A2: () => ERF_A2,
  ERF_A1: () => ERF_A1
});
function fromUint8ToStringArray(vals) {
  try {
    return vals.map((val) => decodeString(val));
  } catch (err) {
    throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);
  }
}
function fromStringArrayToUint8(strings) {
  return strings.map((s) => encodeString(s));
}
var init_backend_util = __esm(() => {
  init_util();
  init_axis_util();
  init_concat_util();
  init_conv_util();
  init_fused_util();
  init_fused_types();
  init_ragged_to_dense_util();
  init_reduce_util();
  init_slice_util();
  init_types();
  init_gather_nd_util();
  init_scatter_nd_util();
  init_fused_util();
  init_log();
  init_einsum_util();
  init_split_util();
  init_sparse_reshape_util();
  init_segment_util();
});

// node_modules/@tensorflow/tfjs-core/dist/backends/kernel_impls.js
var exports_kernel_impls = {};
__export(exports_kernel_impls, {
  whereImpl: () => whereImpl,
  nonMaxSuppressionV5Impl: () => nonMaxSuppressionV5Impl,
  nonMaxSuppressionV4Impl: () => nonMaxSuppressionV4Impl,
  nonMaxSuppressionV3Impl: () => nonMaxSuppressionV3Impl
});
var init_kernel_impls = __esm(() => {
  init_non_max_suppression_impl();
  init_where_impl();
});

// node_modules/@tensorflow/tfjs-core/dist/base.js
var init_base = __esm(() => {
  init_io();
  init_math();
  init_browser();
  init_gather_nd_util();
  init_scatter_nd_util();
  init_slice_util();
  init_serialization();
  init_tensor_util();
  init_test_util();
  init_util();
  init_version();
  init_adadelta_optimizer();
  init_adagrad_optimizer();
  init_adam_optimizer();
  init_adamax_optimizer();
  init_momentum_optimizer();
  init_optimizer();
  init_optimizer_constructors();
  init_rmsprop_optimizer();
  init_sgd_optimizer();
  init_tensor();
  init_types();
  init_ops();
  init_loss_ops_utils();
  init_train();
  init_globals();
  init_kernel_registry();
  init_gradients();
  init_environment();
  init_browser_util();
  init_backend_util();
  init_kernel_impls();
});

// node_modules/@tensorflow/tfjs-core/dist/index.js
var init_dist = __esm(() => {
  init_base_side_effects();
  init_register_optimizers();
  init_base();
  registerOptimizers();
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Abs_grad.js
var absGradConfig;
var init_Abs_grad = __esm(() => {
  init_cast();
  init_mul();
  init_step();
  absGradConfig = {
    kernelName: Abs,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(dy2, step(cast(x, "float32"), -1)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Acos_grad.js
var acosGradConfig;
var init_Acos_grad = __esm(() => {
  init_cast();
  init_div();
  init_neg();
  init_scalar();
  init_sqrt();
  init_square();
  init_sub();
  acosGradConfig = {
    kernelName: Acos,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const a = square(cast(x, "float32"));
          const b = sqrt(sub(scalar(1), a));
          return neg(div(dy2, b));
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Acosh_grad.js
var acoshGradConfig;
var init_Acosh_grad = __esm(() => {
  init_cast();
  init_div();
  init_sqrt();
  init_square();
  init_sub();
  acoshGradConfig = {
    kernelName: Acosh,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const a = sqrt(sub(square(cast(x, "float32")), 1));
          return div(dy2, a);
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Add_grad.js
var addGradConfig;
var init_Add_grad = __esm(() => {
  init_reshape();
  init_sum();
  addGradConfig = {
    kernelName: Add,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        let res = dy2;
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, a.shape);
      };
      const derB = () => {
        let res = dy2;
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, b.shape);
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/AddN_grad.js
var addNGradConfig;
var init_AddN_grad = __esm(() => {
  addNGradConfig = {
    kernelName: AddN,
    saveAllInputs: true,
    gradFunc: (dy2, saved) => {
      const ders = {};
      saved.forEach((_, i) => {
        ders[i] = () => dy2.clone();
      });
      return ders;
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ArgMax_grad.js
var argMaxGradConfig;
var init_ArgMax_grad = __esm(() => {
  init_zeros_like();
  argMaxGradConfig = {
    kernelName: ArgMax,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => zerosLike(x) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ArgMin_grad.js
var argMinGradConfig;
var init_ArgMin_grad = __esm(() => {
  init_zeros_like();
  argMinGradConfig = {
    kernelName: ArgMin,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => zerosLike(x) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Asin_grad.js
var asinGradConfig;
var init_Asin_grad = __esm(() => {
  init_cast();
  init_div();
  init_scalar();
  init_sqrt();
  init_square();
  init_sub();
  asinGradConfig = {
    kernelName: Asin,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, sqrt(sub(scalar(1), square(cast(x, "float32"))))) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Asinh_grad.js
var asinhGradConfig;
var init_Asinh_grad = __esm(() => {
  init_add();
  init_cast();
  init_div();
  init_scalar();
  init_sqrt();
  init_square();
  asinhGradConfig = {
    kernelName: Asinh,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const a = sqrt(add2(scalar(1), square(cast(x, "float32"))));
          return div(dy2, a);
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Atan2_grad.js
var atan2GradConfig;
var init_Atan2_grad = __esm(() => {
  init_add();
  init_div();
  init_mul();
  init_neg();
  init_reshape();
  init_square();
  init_sum();
  atan2GradConfig = {
    kernelName: Atan2,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const d = add2(square(a), square(b));
        let res = mul(dy2, div(b, d));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, a.shape);
      };
      const derB = () => {
        const d = add2(square(a), square(b));
        let res = neg(mul(dy2, div(a, d)));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, b.shape);
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Atan_grad.js
var atanGradConfig;
var init_Atan_grad = __esm(() => {
  init_add();
  init_cast();
  init_div();
  init_square();
  atanGradConfig = {
    kernelName: Atan,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, add2(square(cast(x, "float32")), 1)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Atanh_grad.js
var atanhGradConfig;
var init_Atanh_grad = __esm(() => {
  init_cast();
  init_div();
  init_square();
  init_sub();
  init_scalar();
  atanhGradConfig = {
    kernelName: Atanh,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, sub(scalar(1), square(cast(x, "float32")))) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_3d_grad.js
function avgPool3dGrad_(dy2, input, filterSize, strides, pad6, dimRoundingMode) {
  const $dy = convertToTensor(dy2, "dy", "avgPool3dGrad");
  const $input = convertToTensor(input, "input", "avgPool3dGrad");
  let dy5D = $dy;
  let input5D = $input;
  let reshapedTo5D = false;
  if ($input.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
    input5D = reshape($input, [
      1,
      $input.shape[0],
      $input.shape[1],
      $input.shape[2],
      $input.shape[3]
    ]);
  }
  assert(dy5D.rank === 5, () => `Error in avgPool3dGrad: dy must be rank 5 but got rank ` + `${dy5D.rank}.`);
  assert(input5D.rank === 5, () => `Error in avgPool3dGrad: input must be rank 5 but got rank ` + `${input5D.rank}.`);
  checkPadOnDimRoundingMode("avgPool3dGrad", pad6, dimRoundingMode);
  const inputs = { dy: dy5D, input: input5D };
  const attrs = { filterSize, strides, pad: pad6, dimRoundingMode };
  const res = ENGINE.runKernel(AvgPool3DGrad, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
var avgPool3dGrad;
var init_avg_pool_3d_grad = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  avgPool3dGrad = op({ avgPool3dGrad_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/AvgPool3D_grad.js
var avgPool3DGradConfig;
var init_AvgPool3D_grad = __esm(() => {
  init_avg_pool_3d_grad();
  avgPool3DGradConfig = {
    kernelName: AvgPool3D,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { filterSize, strides, pad: pad6, dimRoundingMode } = attrs;
      return {
        x: () => avgPool3dGrad(dy2, x, filterSize, strides, pad6, dimRoundingMode)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/ops/avg_pool_grad.js
function avgPoolGrad_(dy2, input, filterSize, strides, pad6) {
  const $dy = convertToTensor(dy2, "dy", "avgPoolGrad");
  const $input = convertToTensor(input, "input", "avgPoolGrad");
  assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy (${$dy.rank})`);
  let input4D = $input;
  let dy4D = $dy;
  let reshapedTo4D = false;
  if ($input.rank === 3) {
    reshapedTo4D = true;
    input4D = reshape($input, [1, $input.shape[0], $input.shape[1], $input.shape[2]]);
    dy4D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2]]);
  }
  assert(dy4D.rank === 4, () => `Error in avgPoolGrad: dy must be rank 4 but got rank ` + `${dy4D.rank}.`);
  assert(input4D.rank === 4, () => `Error in avgPoolGrad: input must be rank 4 but got rank ` + `${input4D.rank}.`);
  const inputs = { dy: dy4D, input: input4D };
  const attrs = { filterSize, strides, pad: pad6 };
  const res = ENGINE.runKernel(AvgPoolGrad, inputs, attrs);
  if (reshapedTo4D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);
  }
  return res;
}
var avgPoolGrad;
var init_avg_pool_grad = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_operation();
  init_reshape();
  avgPoolGrad = op({ avgPoolGrad_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/AvgPool_grad.js
var avgPoolGradConfig;
var init_AvgPool_grad = __esm(() => {
  init_avg_pool_grad();
  avgPoolGradConfig = {
    kernelName: AvgPool,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { filterSize, strides, pad: pad6 } = attrs;
      return { x: () => avgPoolGrad(dy2, x, filterSize, strides, pad6) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/BatchMatMul_grad.js
var batchMatMulGradConfig;
var init_BatchMatMul_grad = __esm(() => {
  init_mat_mul();
  batchMatMulGradConfig = {
    kernelName: BatchMatMul,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved, attrs) => {
      const [a, b] = saved;
      const { transposeA, transposeB } = attrs;
      if (!transposeA && !transposeB) {
        return {
          a: () => matMul(dy2, b, false, true),
          b: () => matMul(a, dy2, true, false)
        };
      } else if (!transposeA && transposeB) {
        return {
          a: () => matMul(dy2, b, false, false),
          b: () => matMul(dy2, a, true, false)
        };
      } else if (transposeA && !transposeB) {
        return {
          a: () => matMul(b, dy2, false, true),
          b: () => matMul(a, dy2, false, false)
        };
      } else {
        return {
          a: () => matMul(b, dy2, true, true),
          b: () => matMul(dy2, a, true, true)
        };
      }
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/BatchToSpaceND_grad.js
var batchToSpaceNDGradConfig;
var init_BatchToSpaceND_grad = __esm(() => {
  init_space_to_batch_nd();
  batchToSpaceNDGradConfig = {
    kernelName: BatchToSpaceND,
    gradFunc: (dy2, saved, attrs) => {
      const { blockShape, crops } = attrs;
      return { x: () => spaceToBatchND(dy2, blockShape, crops) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/BroadcastTo_grad.js
var broadcastToGradConfig;
var init_BroadcastTo_grad = __esm(() => {
  init_sum();
  broadcastToGradConfig = {
    kernelName: BroadcastTo,
    gradFunc: (dy2, saved, attrs) => {
      const broadCastToAttrs = attrs;
      const inputShape = broadCastToAttrs.inputShape;
      const outputShape = broadCastToAttrs.shape;
      const reps = Array.from(outputShape);
      for (let i = inputShape.length - 1;i >= 0; i--) {
        if (inputShape[i] === outputShape[i]) {
          reps[i] = 1;
        } else if (inputShape[i] !== 1) {
          throw new Error(`broadcastTo(): [${inputShape}] cannot be broadcast to [${outputShape}].`);
        }
      }
      const axes = [];
      for (let i = 0;i < reps.length; i++) {
        if (reps[i] > 1) {
          axes.push(i);
        }
      }
      return { x: () => sum2(dy2, axes, true) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Cast_grad.js
var castGradConfig;
var init_Cast_grad = __esm(() => {
  castGradConfig = {
    kernelName: Cast,
    gradFunc: (dy2) => {
      return { x: () => dy2.clone() };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Ceil_grad.js
var ceilGradConfig;
var init_Ceil_grad = __esm(() => {
  init_zeros_like();
  ceilGradConfig = {
    kernelName: Ceil,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ClipByValue_grad.js
var clipByValueGradConfig;
var init_ClipByValue_grad = __esm(() => {
  init_greater_equal();
  init_less_equal();
  init_logical_and();
  init_where();
  init_zeros_like();
  clipByValueGradConfig = {
    kernelName: ClipByValue,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { clipValueMin, clipValueMax } = attrs;
      return {
        x: () => where(logicalAnd(greaterEqual(x, clipValueMin), lessEqual(x, clipValueMax)), dy2, zerosLike(dy2))
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ComplexAbs_grad.js
var complexAbsGradConfig;
var init_ComplexAbs_grad = __esm(() => {
  init_Abs_grad();
  complexAbsGradConfig = {
    kernelName: ComplexAbs,
    inputsToSave: ["x"],
    gradFunc: absGradConfig.gradFunc
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Concat_grad.js
var concatGradConfig;
var init_Concat_grad = __esm(() => {
  init_split();
  init_util();
  concatGradConfig = {
    kernelName: Concat,
    saveAllInputs: true,
    gradFunc: (dy2, saved, attrs) => {
      const shapes = saved.map((t) => t.shape);
      const { axis } = attrs;
      const $axis = parseAxisParam(axis, saved[0].shape)[0];
      const sizeSplits = shapes.map((s) => s[$axis]);
      const derTensors = split(dy2, sizeSplits, $axis);
      return derTensors.map((t) => () => t);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Conv2D_grad.js
var conv2DGradConfig;
var init_Conv2D_grad = __esm(() => {
  init_conv2d_backprop_filter();
  init_conv2d_backprop_input();
  init_conv_util();
  init_util();
  conv2DGradConfig = {
    kernelName: Conv2D,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy2, saved, attrs) => {
      const [x4D, $filter] = saved;
      const { dilations, strides, pad: pad6, dataFormat } = attrs;
      assert(tupleValuesAreOne(dilations), () => "Error in gradient of conv2D: dilation rates greater than 1 " + `are not yet supported in gradients. Got dilations '${dilations}'`);
      return {
        x: () => conv2DBackpropInput(x4D.shape, dy2, $filter, strides, pad6, dataFormat),
        filter: () => conv2DBackpropFilter(x4D, dy2, $filter.shape, strides, pad6, dataFormat)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Conv2DBackpropInput_grad.js
var conv2DBackpropInputGradConfig;
var init_Conv2DBackpropInput_grad = __esm(() => {
  init_conv2d();
  init_conv2d_backprop_filter();
  conv2DBackpropInputGradConfig = {
    kernelName: Conv2DBackpropInput,
    inputsToSave: ["dy", "filter"],
    gradFunc: (ddx, saved, attrs) => {
      const [dy2, filter] = saved;
      const { strides, pad: pad6, dataFormat, dimRoundingMode } = attrs;
      return {
        dy: () => conv2d(ddx, filter, strides, pad6, dataFormat, 1, dimRoundingMode),
        filter: () => conv2DBackpropFilter(ddx, dy2, filter.shape, strides, pad6, dataFormat, dimRoundingMode)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/ops/conv3d_backprop_filter.js
function conv3DBackpropFilter_(x, dy2, filterShape, strides, pad6) {
  let x5D = x;
  if (x.rank === 4) {
    x5D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2], x.shape[3]]);
  }
  let dy5D = dy2;
  if (dy5D.rank === 4) {
    dy5D = reshape(dy2, [1, dy2.shape[0], dy2.shape[1], dy2.shape[2], dy2.shape[3]]);
  }
  assert(x5D.rank === 5, () => `Error in conv3dDerFilter: input must be rank 5, but got shape ` + `${x5D.shape}.`);
  assert(dy5D.rank === 5, () => `Error in conv3dDerFilter: dy must be rank 5, but got shape ` + `${dy5D.shape}.`);
  assert(filterShape.length === 5, () => `Error in conv3dDerFilter: filterShape must be length 5, but got ` + `${filterShape}.`);
  assert(x5D.shape[4] === filterShape[3], () => `Error in conv3dDerFilter: depth of input ${x5D.shape[4]}) must ` + `match input depth in filter (${filterShape[3]}.`);
  assert(dy5D.shape[4] === filterShape[4], () => `Error in conv3dDerFilter: depth of dy (${dy5D.shape[4]}) must ` + `match output depth for filter (${filterShape[4]}).`);
  const inputs = { x: x5D, dy: dy5D };
  const attrs = { strides, pad: pad6, filterShape };
  return ENGINE.runKernel(Conv3DBackpropFilterV2, inputs, attrs);
}
var conv3DBackpropFilter;
var init_conv3d_backprop_filter = __esm(() => {
  init_engine();
  init_util();
  init_operation();
  init_reshape();
  conv3DBackpropFilter = op({ conv3DBackpropFilter_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Conv3D_grad.js
var conv3DGradConfig;
var init_Conv3D_grad = __esm(() => {
  init_conv3d_backprop_filter();
  init_conv3d_backprop_input();
  init_conv_util();
  init_util();
  conv3DGradConfig = {
    kernelName: Conv3D,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy2, saved, attrs) => {
      const { dilations, strides, pad: pad6 } = attrs;
      assert(tupleValuesAreOne(dilations), () => "Error in gradient of conv3D: dilation rates greater than 1 are " + `not yet supported in gradients. Got dilations '${dilations}'`);
      const [x5D, $filter] = saved;
      return {
        x: () => conv3DBackpropInput(x5D.shape, dy2, $filter, strides, pad6),
        filter: () => conv3DBackpropFilter(x5D, dy2, $filter.shape, strides, pad6)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Cos_grad.js
var cosGradConfig;
var init_Cos_grad = __esm(() => {
  init_cast();
  init_mul();
  init_neg();
  init_sin();
  cosGradConfig = {
    kernelName: Cos,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(neg(sin(cast(x, "float32"))), dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Cosh_grad.js
var coshGradConfig;
var init_Cosh_grad = __esm(() => {
  init_cast();
  init_mul();
  init_sinh();
  coshGradConfig = {
    kernelName: Cosh,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(sinh(cast(x, "float32")), dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Cumsum_grad.js
var cumsumGradConfig;
var init_Cumsum_grad = __esm(() => {
  init_axis_util();
  init_cumsum();
  init_transpose();
  cumsumGradConfig = {
    kernelName: Cumsum,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { axis, exclusive, reverse: reverse7 } = attrs;
      return {
        x: () => {
          const permutation = getAxesPermutation([axis], x.rank);
          let out = cumsum(dy2, axis, exclusive, !reverse7);
          if (permutation != null) {
            out = transpose(out, permutation);
          }
          return out;
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/DepthwiseConv2dNative_grad.js
var depthwiseConv2dNativeGradConfig;
var init_DepthwiseConv2dNative_grad = __esm(() => {
  init_conv_util();
  init_depthwise_conv2d_native_backprop_filter();
  init_depthwise_conv2d_native_backprop_input();
  init_util();
  depthwiseConv2dNativeGradConfig = {
    kernelName: DepthwiseConv2dNative,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy2, saved, attrs) => {
      const { dilations, strides, pad: pad6, dimRoundingMode } = attrs;
      const $dilations = dilations == null ? [1, 1] : dilations;
      assert(tupleValuesAreOne($dilations), () => "Error in gradient of depthwiseConv2dNative: dilation rates " + `greater than 1 are not yet supported. Got dilations ` + `'${$dilations}'`);
      const [x, filter] = saved;
      assert(x.rank === 4, () => `Error in gradient of depthwiseConv2dNative: input must be ` + `rank 4, but got rank ${x.rank}.`);
      assert(filter.rank === 4, () => `Error in gradient of depthwiseConv2dNative: filter must be ` + `rank 4, but got rank ${filter.rank}.`);
      assert(x.shape[3] === filter.shape[2], () => `Error in gradient of depthwiseConv2d: number of input ` + `channels (${x.shape[3]}) must match the inChannels dimension ` + `in filter ${filter.shape[2]}.`);
      assert(eitherStridesOrDilationsAreOne(strides, $dilations), () => "Error in gradient of depthwiseConv2d: Either strides or " + `dilations must be  1. Got strides ${strides} and dilations ` + `'${$dilations}'.`);
      checkPadOnDimRoundingMode("depthwiseConv2d", pad6, dimRoundingMode);
      return {
        x: () => depthwiseConv2dNativeBackpropInput(x.shape, dy2, filter, strides, pad6, $dilations, dimRoundingMode),
        filter: () => depthwiseConv2dNativeBackpropFilter(x, dy2, filter.shape, strides, pad6, $dilations, dimRoundingMode)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Dilation2D_grad.js
var dilation2dGradConfig;
var init_Dilation2D_grad = __esm(() => {
  init_engine();
  dilation2dGradConfig = {
    kernelName: Dilation2D,
    inputsToSave: ["x", "filter"],
    gradFunc: (dy2, saved, attrs) => {
      const [x, filter] = saved;
      const inputInputs = { x, filter, dy: dy2 };
      const filterInputs = { x, filter, dy: dy2 };
      return {
        x: () => ENGINE.runKernel(Dilation2DBackpropInput, inputInputs, attrs),
        filter: () => ENGINE.runKernel(Dilation2DBackpropFilter, filterInputs, attrs)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Elu_grad.js
var eluGradConfig;
var init_Elu_grad = __esm(() => {
  init_engine();
  eluGradConfig = {
    kernelName: Elu,
    outputsToSave: [true],
    gradFunc: (dy2, saved) => {
      const [y] = saved;
      const inputs = { dy: dy2, y };
      return { x: () => ENGINE.runKernel(EluGrad, inputs) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Erf_grad.js
var erfGradConfig;
var init_Erf_grad = __esm(() => {
  init_exp();
  init_mul();
  init_neg();
  init_square();
  erfGradConfig = {
    kernelName: Erf,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      const a = mul(exp(neg(square(x))), 2 / Math.sqrt(Math.PI));
      return { x: () => mul(dy2, a) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Exp_grad.js
var expGradConfig;
var init_Exp_grad = __esm(() => {
  init_mul();
  expGradConfig = {
    kernelName: Exp,
    outputsToSave: [true],
    gradFunc: (dy2, saved) => {
      const [y] = saved;
      return { x: () => mul(dy2, y) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ExpandDims_grad.js
var expandDimsGradConfig;
var init_ExpandDims_grad = __esm(() => {
  init_reshape();
  expandDimsGradConfig = {
    kernelName: ExpandDims,
    inputsToSave: ["input"],
    gradFunc: (dy2, saved) => {
      const [input] = saved;
      return { input: () => reshape(dy2, input.shape) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Expm1_grad.js
var expm1GradConfig;
var init_Expm1_grad = __esm(() => {
  init_exp();
  init_mul();
  expm1GradConfig = {
    kernelName: Expm1,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(dy2, exp(x)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Floor_grad.js
var floorGradConfig;
var init_Floor_grad = __esm(() => {
  init_zeros_like();
  floorGradConfig = {
    kernelName: Floor,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/FloorDiv_grad.js
var floorDivGradConfig;
var init_FloorDiv_grad = __esm(() => {
  init_cast();
  init_div();
  init_mul();
  init_neg();
  init_reshape();
  init_square();
  init_sum();
  floorDivGradConfig = {
    kernelName: FloorDiv,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const res = div(dy2, cast(b, "float32"));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), a.shape);
        }
        return res;
      };
      const derB = () => {
        let res = mul(dy2, cast(a, "float32"));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = reshape(sum2(res, reduceAxes), b.shape);
        }
        const tmp = square(b);
        return neg(div(res, cast(tmp, "float32")));
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/FusedBatchNorm_grad.js
var fusedBatchNormGradConfig;
var init_FusedBatchNorm_grad = __esm(() => {
  init_add();
  init_mul();
  init_reshape();
  init_rsqrt();
  init_scalar();
  init_sub();
  init_sum();
  init_tile();
  fusedBatchNormGradConfig = {
    kernelName: FusedBatchNorm,
    inputsToSave: ["x", "mean", "variance", "scale"],
    gradFunc: (dy2, saved, attrs) => {
      const { varianceEpsilon } = attrs;
      const [x, mean4, variance, scale] = saved;
      const scaleValue = scale == null ? scalar(1) : scale;
      const reductionAxes = getReductionAxes(mean4.shape, x.shape);
      const tileShape = [];
      if (mean4.rank === 1) {
        for (let i = 0;i < x.shape.length - 1; ++i) {
          tileShape.push(x.shape[i]);
        }
        tileShape.push(1);
      }
      const xMinusMean = sub(x, mean4);
      const dyTimesScaleValue = mul(dy2, scaleValue);
      const oneOverSqrtVariance = rsqrt(add2(variance, scalar(varianceEpsilon)));
      const minusHalfRCube = mul(mul(mul(oneOverSqrtVariance, oneOverSqrtVariance), oneOverSqrtVariance), scalar(-0.5));
      const derX = () => {
        if (mean4.rank === 1) {
          return reshape(mul(mul(dy2, tile(reshape(oneOverSqrtVariance, [1, 1, 1, mean4.shape[0]]), tileShape)), scaleValue), x.shape);
        } else {
          return reshape(mul(mul(dy2, oneOverSqrtVariance), scaleValue), x.shape);
        }
      };
      const derMean = () => {
        let meanDer = mul(mul(oneOverSqrtVariance, scalar(-1)), dyTimesScaleValue);
        if (mean4.rank === 1) {
          meanDer = sum2(meanDer, reductionAxes);
        }
        return reshape(meanDer, mean4.shape);
      };
      const derVariance = () => {
        let varianceDer = mul(mul(minusHalfRCube, xMinusMean), dyTimesScaleValue);
        if (mean4.rank === 1) {
          varianceDer = sum2(varianceDer, reductionAxes);
        }
        return reshape(varianceDer, mean4.shape);
      };
      const derScale = () => {
        const xMinusMean2TimesRsqrt = mul(xMinusMean, oneOverSqrtVariance);
        let scaleDer = mul(dy2, xMinusMean2TimesRsqrt);
        if (mean4.rank === 1) {
          scaleDer = sum2(scaleDer, reductionAxes);
        }
        return reshape(scaleDer, mean4.shape);
      };
      const derOffset = () => {
        let offsetDer = dy2;
        if (mean4.rank === 1) {
          offsetDer = sum2(offsetDer, reductionAxes);
        }
        return reshape(offsetDer, mean4.shape);
      };
      return {
        x: derX,
        mean: derMean,
        variance: derVariance,
        scale: derScale,
        offset: derOffset
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/GatherV2_grad.js
function arrayRange(start, stop) {
  const result = [];
  for (let i = start;i < stop; ++i) {
    result.push(i);
  }
  return result;
}
function arrayConcat(arrays) {
  const result = [];
  for (let i = 0;i < arrays.length; ++i) {
    for (let j = 0;j < arrays[i].length; ++j) {
      result.push(arrays[i][j]);
    }
  }
  return result;
}
var gatherGradConfig;
var init_GatherV2_grad = __esm(() => {
  init_axis_util();
  init_reshape();
  init_stack();
  init_transpose();
  init_unsorted_segment_sum();
  init_util();
  gatherGradConfig = {
    kernelName: GatherV2,
    inputsToSave: ["x", "indices"],
    gradFunc: (dy2, saved, attrs) => {
      const [x, indices] = saved;
      const { axis, batchDims } = attrs;
      const parsedAxis = parseAxisParam(axis, x.shape)[0];
      const derXBatch = (x2, indices2, dy3) => {
        return () => {
          const paramsShape = x2.shape;
          const indicesSize = indices2.size;
          const outerShape = paramsShape.slice(0, parsedAxis);
          const outerDims = outerShape.length;
          const innerShape = paramsShape.slice(axis, paramsShape.length).slice(1);
          const innerDims = innerShape.length;
          const outerAxesIndices = arrayRange(0, outerDims);
          const innerAxesIndices = arrayRange(outerDims + 1, outerDims + 1 + innerDims);
          const valuesShape = arrayConcat([
            outerShape,
            [indicesSize],
            innerShape
          ]);
          const values = reshape(dy3, valuesShape);
          const reshapedIndices = reshape(indices2, [indicesSize]);
          const transposeDims = arrayConcat([[outerDims], outerAxesIndices, innerAxesIndices]);
          const valuesTranspose = transpose(values, transposeDims);
          let paramsGrad = unsortedSegmentSum(valuesTranspose, reshapedIndices, x2.shape[parsedAxis]);
          const invertTransposeDims = getUndoAxesPermutation(transposeDims);
          paramsGrad = transpose(paramsGrad, invertTransposeDims);
          return paramsGrad;
        };
      };
      if (batchDims === 1) {
        const batchSize = x.shape[0];
        const xBatch = x.split(batchSize, 0);
        const derXBatched = () => {
          const stacked = stack(xBatch.map((x2, i) => {
            return derXBatch(x2, indices.slice(i, 1), dy2.slice(i, 1))();
          }));
          return stacked.reshape(x.shape);
        };
        return { x: derXBatched, indices: () => indices };
      } else {
        return { x: derXBatch(x, indices, dy2), indices: () => indices };
      }
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/GreaterEqual_grad.js
var greaterEqualGradConfig;
var init_GreaterEqual_grad = __esm(() => {
  init_zeros_like();
  greaterEqualGradConfig = {
    kernelName: GreaterEqual,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      return { a: () => zerosLike(a), b: () => zerosLike(b) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Identity_grad.js
var identityGradConfig;
var init_Identity_grad = __esm(() => {
  init_cast();
  identityGradConfig = {
    kernelName: Identity,
    gradFunc: (dy2) => {
      return { x: () => cast(dy2, "float32") };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/IsFinite_grad.js
var isFiniteGradConfig;
var init_IsFinite_grad = __esm(() => {
  init_zeros_like();
  isFiniteGradConfig = {
    kernelName: IsFinite,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/IsInf_grad.js
var isInfGradConfig;
var init_IsInf_grad = __esm(() => {
  init_zeros_like();
  isInfGradConfig = {
    kernelName: IsInf,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/IsNan_grad.js
var isNanGradConfig;
var init_IsNan_grad = __esm(() => {
  init_zeros_like();
  isNanGradConfig = {
    kernelName: IsNan,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/LeakyRelu_grad.js
var leakyReluGradConfig;
var init_LeakyRelu_grad = __esm(() => {
  init_greater();
  init_mul();
  init_where();
  leakyReluGradConfig = {
    kernelName: LeakyRelu,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { alpha } = attrs;
      const mask = greater(x, 0);
      return { x: () => where(mask, dy2, mul(dy2, alpha)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Log1p_grad.js
var log1pGradConfig;
var init_Log1p_grad = __esm(() => {
  init_add();
  init_div();
  log1pGradConfig = {
    kernelName: Log1p,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, add2(x, 1)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Log_grad.js
var logGradConfig;
var init_Log_grad = __esm(() => {
  init_cast();
  init_div();
  logGradConfig = {
    kernelName: Log,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, cast(x, "float32")) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/LogSoftmax_grad.js
var logSoftmaxGradConfig;
var init_LogSoftmax_grad = __esm(() => {
  init_exp();
  init_mul();
  init_sub();
  init_sum();
  logSoftmaxGradConfig = {
    kernelName: LogSoftmax,
    inputsToSave: [],
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const [value] = saved;
      const { axis } = attrs;
      return {
        logits: () => {
          const keepDims = true;
          const softmax2 = exp(value);
          return sub(dy2, mul(sum2(dy2, axis, keepDims), softmax2));
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/ops/local_response_normalization_backprop.js
function localResponseNormalizationBackprop_(x, y, dy2, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5) {
  const inputs = { x, y, dy: dy2 };
  const attrs = { depthRadius, bias, alpha, beta };
  return ENGINE.runKernel(LRNGrad, inputs, attrs);
}
var localResponseNormalizationBackprop;
var init_local_response_normalization_backprop = __esm(() => {
  init_engine();
  init_operation();
  localResponseNormalizationBackprop = op({ localResponseNormalizationBackprop_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/LRN_grad.js
var lrnGradConfig;
var init_LRN_grad = __esm(() => {
  init_local_response_normalization_backprop();
  lrnGradConfig = {
    kernelName: LRN,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const [x, y] = saved;
      const { depthRadius, bias, alpha, beta } = attrs;
      return {
        x: () => localResponseNormalizationBackprop(x, y, dy2, depthRadius, bias, alpha, beta)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/min_max_grad_util.js
function gradForMinAndMax(dy2, y, xOrig, origAxes) {
  if (y.rank < xOrig.rank) {
    y = reshape(y, expandShapeToKeepDim(y.shape, origAxes));
  }
  if (dy2.rank < xOrig.rank) {
    dy2 = reshape(dy2, expandShapeToKeepDim(dy2.shape, origAxes));
  }
  return {
    x: () => {
      const dx = mul(dy2, cast(equal(xOrig, y), dy2.dtype));
      return dx;
    }
  };
}
var init_min_max_grad_util = __esm(() => {
  init_axis_util();
  init_cast();
  init_equal();
  init_mul();
  init_reshape();
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Max_grad.js
var maxGradConfig;
var init_Max_grad = __esm(() => {
  init_util();
  init_min_max_grad_util();
  maxGradConfig = {
    kernelName: Max,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const maxAttrs = attrs;
      const { reductionIndices } = maxAttrs;
      const x = saved[0];
      const y = saved[1];
      const origAxes = parseAxisParam(reductionIndices, x.shape);
      const maxGrad = gradForMinAndMax(dy2, y, x, origAxes);
      return {
        x: () => {
          return maxGrad["x"]();
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Maximum_grad.js
var maximumGradConfig;
var init_Maximum_grad = __esm(() => {
  init_cast();
  init_greater_equal();
  init_less();
  init_mul();
  maximumGradConfig = {
    kernelName: Maximum,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const derA = () => mul(dy2, cast(greaterEqual(a, b), "float32"));
      const derB = () => mul(dy2, cast(less(a, b), "float32"));
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_3d_grad.js
function maxPool3dGrad_(dy2, input, output, filterSize, strides, pad6, dimRoundingMode) {
  const $dy = convertToTensor(dy2, "dy", "maxPool3dGrad");
  const $input = convertToTensor(input, "input", "maxPool3dGrad");
  const $output = convertToTensor(output, "output", "maxPool3dGrad");
  let dy5D = $dy;
  let input5D = $input;
  let output5D = $output;
  let reshapedTo5D = false;
  if ($input.rank === 4) {
    reshapedTo5D = true;
    dy5D = reshape($dy, [1, $dy.shape[0], $dy.shape[1], $dy.shape[2], $dy.shape[3]]);
    input5D = reshape($input, [
      1,
      $input.shape[0],
      $input.shape[1],
      $input.shape[2],
      $input.shape[3]
    ]);
    output5D = reshape($output, [
      1,
      $output.shape[0],
      $output.shape[1],
      $output.shape[2],
      $output.shape[3]
    ]);
  }
  assert(dy5D.rank === 5, () => `Error in maxPool3dGrad: dy must be rank 5 but got rank ` + `${dy5D.rank}.`);
  assert(input5D.rank === 5, () => `Error in maxPool3dGrad: input must be rank 5 but got rank ` + `${input5D.rank}.`);
  assert(output5D.rank === 5, () => `Error in maxPool3dGrad: output must be rank 5 but got rank ` + `${output5D.rank}.`);
  checkPadOnDimRoundingMode("maxPool3dGrad", pad6, dimRoundingMode);
  const inputs = { dy: dy5D, input: input5D, output: output5D };
  const attrs = { filterSize, strides, pad: pad6, dimRoundingMode };
  const res = ENGINE.runKernel(MaxPool3DGrad, inputs, attrs);
  if (reshapedTo5D) {
    return reshape(res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]);
  }
  return res;
}
var maxPool3dGrad;
var init_max_pool_3d_grad = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  init_reshape();
  maxPool3dGrad = op({ maxPool3dGrad_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/MaxPool3D_grad.js
var maxPool3DGradConfig;
var init_MaxPool3D_grad = __esm(() => {
  init_max_pool_3d_grad();
  maxPool3DGradConfig = {
    kernelName: MaxPool3D,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const [x, y] = saved;
      const { filterSize, strides, pad: pad6, dimRoundingMode } = attrs;
      return {
        x: () => maxPool3dGrad(dy2, x, y, filterSize, strides, pad6, dimRoundingMode)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/ops/max_pool_grad.js
function maxPoolGrad_(dy2, input, output, filterSize, strides, pad6, dimRoundingMode) {
  const $dy = convertToTensor(dy2, "dy", "maxPoolGrad");
  const $input = convertToTensor(input, "input", "maxPoolGrad");
  const $output = convertToTensor(output, "output", "maxPoolGrad");
  assert($input.rank === $dy.rank, () => `Rank of input (${$input.rank}) does not match rank of dy ` + `(${$dy.rank})`);
  assert($dy.rank === 4, () => `Error in maxPoolGrad: dy must be rank 4 but got rank ` + `${$dy.rank}.`);
  assert($input.rank === 4, () => `Error in maxPoolGrad: input must be rank 4 but got rank ` + `${$input.rank}.`);
  checkPadOnDimRoundingMode("maxPoolGrad", pad6, dimRoundingMode);
  const inputs = { dy: $dy, input: $input, output: $output };
  const attrs = { filterSize, strides, pad: pad6, dimRoundingMode };
  return ENGINE.runKernel(MaxPoolGrad, inputs, attrs);
}
var maxPoolGrad;
var init_max_pool_grad = __esm(() => {
  init_engine();
  init_tensor_util_env();
  init_util();
  init_conv_util();
  init_operation();
  maxPoolGrad = op({ maxPoolGrad_ });
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/MaxPool_grad.js
var maxPoolGradConfig;
var init_MaxPool_grad = __esm(() => {
  init_max_pool_grad();
  maxPoolGradConfig = {
    kernelName: MaxPool,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const [x, y] = saved;
      const { filterSize, strides, pad: pad6 } = attrs;
      return {
        x: () => maxPoolGrad(dy2, x, y, filterSize, strides, pad6)
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Mean_grad.js
var meanGradConfig;
var init_Mean_grad = __esm(() => {
  init_axis_util();
  init_div();
  init_mul();
  init_ones();
  init_reshape();
  init_util();
  meanGradConfig = {
    kernelName: Mean,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { axis } = attrs;
      const axes = parseAxisParam(axis, x.shape);
      const shapes = computeOutAndReduceShapes(x.shape, axes);
      const reduceShape = shapes[1];
      const reduceSize = sizeFromShape(reduceShape);
      const derX = () => {
        const expandedDyShape = x.shape.slice();
        axes.forEach((axis2) => {
          expandedDyShape[axis2] = 1;
        });
        const expandedDy = reshape(dy2, expandedDyShape);
        const res = div(mul(expandedDy, ones2(x.shape, "float32")), reduceSize);
        return res;
      };
      return { x: derX };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Min_grad.js
var minGradConfig;
var init_Min_grad = __esm(() => {
  init_util();
  init_min_max_grad_util();
  minGradConfig = {
    kernelName: Min,
    inputsToSave: ["x"],
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const minAttrs = attrs;
      const { axis } = minAttrs;
      const [x, y] = saved;
      const origAxes = parseAxisParam(axis, x.shape);
      const minGrad = gradForMinAndMax(dy2, y, x, origAxes);
      return {
        x: () => {
          return minGrad["x"]();
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Minimum_grad.js
var minimumGradConfig;
var init_Minimum_grad = __esm(() => {
  init_cast();
  init_greater();
  init_less_equal();
  init_mul();
  minimumGradConfig = {
    kernelName: Minimum,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const derA = () => mul(dy2, cast(lessEqual(a, b), "float32"));
      const derB = () => mul(dy2, cast(greater(a, b), "float32"));
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/MirrorPad_grad.js
var mirrorPadGradConfig;
var init_MirrorPad_grad = __esm(() => {
  init_slice();
  mirrorPadGradConfig = {
    kernelName: MirrorPad,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const x = saved[0];
      const { paddings } = attrs;
      const begin = paddings.map((p2) => p2[0]);
      return { x: () => slice(dy2, begin, x.shape) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Mod_grad.js
var modGradConfig;
var init_Mod_grad = __esm(() => {
  init_div();
  init_floor();
  init_mul();
  init_neg();
  init_reshape();
  init_sum();
  modGradConfig = {
    kernelName: Mod,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(dy2, reduceAxes), a.shape);
        }
        return dy2;
      };
      const derB = () => {
        const res = mul(dy2, neg(floor(div(a, b))));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), b.shape);
        }
        return res;
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Multiply_grad.js
var multiplyGradConfig;
var init_Multiply_grad = __esm(() => {
  init_cast();
  init_mul();
  init_reshape();
  init_sum();
  multiplyGradConfig = {
    kernelName: Multiply,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const res = mul(dy2, cast(b, "float32"));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), a.shape);
        }
        return res;
      };
      const derB = () => {
        const res = mul(dy2, cast(a, "float32"));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), b.shape);
        }
        return res;
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Neg_grad.js
var negGradConfig;
var init_Neg_grad = __esm(() => {
  init_neg();
  negGradConfig = {
    kernelName: Neg,
    gradFunc: (dy2) => {
      return { x: () => neg(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/OneHot_grad.js
var oneHotGradConfig;
var init_OneHot_grad = __esm(() => {
  init_zeros();
  oneHotGradConfig = {
    kernelName: OneHot,
    inputsToSave: ["indices"],
    gradFunc: (dy2, saved) => {
      const indices = saved[0];
      return { indices: () => zeros(indices.shape, "float32") };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/OnesLike_grad.js
var onesLikeGradConfig;
var init_OnesLike_grad = __esm(() => {
  init_zeros_like();
  onesLikeGradConfig = {
    kernelName: OnesLike,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Pack_grad.js
var packGradConfig;
var init_Pack_grad = __esm(() => {
  init_unstack();
  packGradConfig = {
    kernelName: Pack,
    saveAllInputs: true,
    gradFunc: (dy2, saved, attrs) => {
      const { axis } = attrs;
      const derTensors = unstack(dy2, axis);
      return derTensors.map((t) => () => t);
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/PadV2_grad.js
var padV2GradConfig;
var init_PadV2_grad = __esm(() => {
  init_slice();
  padV2GradConfig = {
    kernelName: PadV2,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const x = saved[0];
      const { paddings } = attrs;
      const begin = paddings.map((p2) => p2[0]);
      return { x: () => slice(dy2, begin, x.shape) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Pow_grad.js
var powGradConfig;
var init_Pow_grad = __esm(() => {
  init_cast();
  init_greater();
  init_log2();
  init_mul();
  init_pow();
  init_reshape();
  init_scalar();
  init_sub();
  init_sum();
  init_where();
  init_zeros_like();
  powGradConfig = {
    kernelName: Pow,
    inputsToSave: ["a", "b"],
    outputsToSave: [true],
    gradFunc: (dy2, saved) => {
      const [a, b, y] = saved;
      const base2 = a;
      const exp9 = b;
      const outShape = assertAndGetBroadcastShape(base2.shape, exp9.shape);
      const derBase = () => {
        const expFloat = cast(exp9, "float32");
        let res = mul(dy2, mul(expFloat, pow(base2, sub(expFloat, scalar(1)))));
        const reduceAxes = getReductionAxes(base2.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, base2.shape);
      };
      const derExp = () => {
        const condition = greater(base2, 0);
        const logBase = where(condition, log2(base2), zerosLike(base2));
        let res = mul(dy2, mul(y, logBase));
        const reduceAxes = getReductionAxes(exp9.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, exp9.shape);
      };
      return { a: derBase, b: derExp };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Prelu_grad.js
var preluGradConfig;
var init_Prelu_grad = __esm(() => {
  init_greater();
  init_mul();
  init_reshape();
  init_sum();
  init_where();
  init_zeros_like();
  preluGradConfig = {
    kernelName: Prelu,
    inputsToSave: ["x", "alpha"],
    gradFunc: (dy2, saved) => {
      const [x, alpha] = saved;
      const mask = greater(x, 0);
      return {
        x: () => where(mask, dy2, mul(dy2, alpha)),
        alpha: () => {
          let res = where(mask, zerosLike(dy2), mul(dy2, x));
          const reduceAxes = getReductionAxes(alpha.shape, dy2.shape);
          if (reduceAxes.length > 0) {
            res = sum2(res, reduceAxes);
          }
          return reshape(res, alpha.shape);
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Prod_grad.js
function prodGradFn_(x, dy2, axis) {
  const expandedYShape = x.shape.slice();
  expandedYShape[axis] = 1;
  const expandedDy = reshape(dy2, expandedYShape);
  const xCumProd = cumprod(x, axis, true, false);
  const xCumRevProd = cumprod(x, axis, true, true);
  const dx = mul(xCumProd, xCumRevProd);
  return mul(expandedDy, dx);
}
function prodsGradFn_(x, dy2, axis) {
  const xRank = x.shape.length;
  const finalProdAxis = xRank - axis.length;
  const xPermutation = exports_backend_util.getAxesPermutation(axis, xRank);
  let permutedX = x;
  if (xPermutation != null) {
    permutedX = transpose(x, xPermutation);
  }
  const newShape = permutedX.shape.slice();
  const removedShape = newShape.splice(xRank - axis.length, axis.length);
  const endPartShape = removedShape.reduce((p2, c) => p2 * c, 1);
  newShape.push(endPartShape);
  const reshapedPermutedX = permutedX.reshape(newShape);
  let prodGrad = prodGradFn_(reshapedPermutedX, dy2, finalProdAxis);
  prodGrad = prodGrad.reshape(permutedX.shape);
  if (xPermutation != null) {
    const undoPermutation = exports_backend_util.getUndoAxesPermutation(xPermutation);
    prodGrad = transpose(prodGrad, undoPermutation);
  }
  return prodGrad;
}
var prodGradConfig;
var init_Prod_grad = __esm(() => {
  init_base();
  init_cumprod();
  init_mul();
  init_reshape();
  init_transpose();
  prodGradConfig = {
    kernelName: Prod,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { axis } = attrs;
      let axisArr = [];
      if (axis === undefined || axis === null) {
        axisArr = x.shape.map((_, i) => i);
      } else if (typeof axis === "number") {
        axisArr = [axis];
      } else {
        axisArr = axis;
      }
      return { x: () => prodsGradFn_(x, dy2, axisArr) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/RealDiv_grad.js
var divGradConfig;
var init_RealDiv_grad = __esm(() => {
  init_cast();
  init_div();
  init_mul();
  init_neg();
  init_reshape();
  init_square();
  init_sum();
  divGradConfig = {
    kernelName: RealDiv,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        const res = div(dy2, cast(b, "float32"));
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          return reshape(sum2(res, reduceAxes), a.shape);
        }
        return res;
      };
      const derB = () => {
        let res = mul(dy2, cast(a, "float32"));
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = reshape(sum2(res, reduceAxes), b.shape);
        }
        const tmp = square(b);
        return neg(div(res, cast(tmp, "float32")));
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Reciprocal_grad.js
var reciprocalGradConfig;
var init_Reciprocal_grad = __esm(() => {
  init_div();
  init_neg();
  init_square();
  reciprocalGradConfig = {
    kernelName: Reciprocal,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, neg(square(x))) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Relu6_grad.js
var relu6GradConfig;
var init_Relu6_grad = __esm(() => {
  init_cast();
  init_less_equal();
  init_mul();
  init_step();
  relu6GradConfig = {
    kernelName: Relu6,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      const mask = mul(lessEqual(x, 6), step(x));
      return { x: () => mul(dy2, cast(mask, "float32")) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Relu_grad.js
var reluGradConfig;
var init_Relu_grad = __esm(() => {
  init_cast();
  init_mul();
  init_step();
  reluGradConfig = {
    kernelName: Relu,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(dy2, cast(step(x), "float32")) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Reshape_grad.js
var reshapeGradConfig;
var init_Reshape_grad = __esm(() => {
  init_reshape();
  reshapeGradConfig = {
    kernelName: Reshape,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => reshape(dy2, x.shape) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ResizeBilinear_grad.js
var resizeBilinearGradConfig;
var init_ResizeBilinear_grad = __esm(() => {
  init_engine();
  resizeBilinearGradConfig = {
    kernelName: ResizeBilinear,
    inputsToSave: ["images"],
    gradFunc: (dy2, saved, attrs) => {
      const [images] = saved;
      const inputs = { dy: dy2, images };
      const imagesDer = () => ENGINE.runKernel(ResizeBilinearGrad, inputs, attrs);
      return { images: imagesDer };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ResizeNearestNeighbor_grad.js
var resizeNearestNeighborGradConfig;
var init_ResizeNearestNeighbor_grad = __esm(() => {
  init_engine();
  resizeNearestNeighborGradConfig = {
    kernelName: ResizeNearestNeighbor,
    inputsToSave: ["images"],
    gradFunc: (dy2, saved, attrs) => {
      const [images] = saved;
      const inputs = { dy: dy2, images };
      const imagesDer = () => ENGINE.runKernel(ResizeNearestNeighborGrad, inputs, attrs);
      return { images: imagesDer };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Reverse_grad.js
var reverseGradConfig;
var init_Reverse_grad = __esm(() => {
  init_reverse();
  init_util();
  reverseGradConfig = {
    kernelName: Reverse,
    gradFunc: (dy2, saved, attrs) => {
      const { dims } = attrs;
      const axes = parseAxisParam(dims, dy2.shape);
      return { x: () => reverse(dy2, axes) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Round_grad.js
var roundGradConfig;
var init_Round_grad = __esm(() => {
  init_zeros_like();
  roundGradConfig = {
    kernelName: Round,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Rsqrt_grad.js
var rsqrtGradConfig;
var init_Rsqrt_grad = __esm(() => {
  init_div();
  init_mul();
  init_neg();
  init_pow();
  rsqrtGradConfig = {
    kernelName: Rsqrt,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => neg(div(dy2, mul(pow(x, 1.5), 2))) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Select_grad.js
var selectGradConfig;
var init_Select_grad = __esm(() => {
  init_cast();
  init_logical_not();
  init_mul();
  init_zeros_like();
  selectGradConfig = {
    kernelName: Select,
    inputsToSave: ["condition"],
    gradFunc: (dy2, saved) => {
      const [condition] = saved;
      return {
        condition: () => cast(zerosLike(condition), "float32"),
        t: () => mul(dy2, cast(condition, dy2.dtype)),
        e: () => mul(dy2, cast(logicalNot(condition), dy2.dtype))
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Selu_grad.js
var seluGradConfig;
var init_Selu_grad = __esm(() => {
  init_cast();
  init_exp();
  init_greater();
  init_mul();
  init_scalar();
  init_where();
  seluGradConfig = {
    kernelName: Selu,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return {
        x: () => {
          const mask = greater(x, scalar(0));
          const scaleAlpha = scalar(SELU_SCALEALPHA);
          const scale = scalar(SELU_SCALE);
          const greaterThanZeroDer = mul(dy2, scale);
          const lessEqualZeroDer = mul(mul(dy2, scaleAlpha), exp(cast(x, "float32")));
          return where(mask, greaterThanZeroDer, lessEqualZeroDer);
        }
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sigmoid_grad.js
var sigmoidGradConfig;
var init_Sigmoid_grad = __esm(() => {
  init_mul();
  init_scalar();
  init_sub();
  sigmoidGradConfig = {
    kernelName: Sigmoid,
    outputsToSave: [true],
    gradFunc: (dy2, saved) => {
      const [y] = saved;
      return { x: () => mul(dy2, mul(y, sub(scalar(1), y))) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sign_grad.js
var signGradConfig;
var init_Sign_grad = __esm(() => {
  init_zeros_like();
  signGradConfig = {
    kernelName: Sign,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sin_grad.js
var sinGradConfig;
var init_Sin_grad = __esm(() => {
  init_cast();
  init_cos();
  init_mul();
  sinGradConfig = {
    kernelName: Sin,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(cos(cast(x, "float32")), dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sinh_grad.js
var sinhGradConfig;
var init_Sinh_grad = __esm(() => {
  init_cast();
  init_cosh();
  init_mul();
  sinhGradConfig = {
    kernelName: Sinh,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(cosh(cast(x, "float32")), dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Slice_grad.js
var sliceGradConfig;
var init_Slice_grad = __esm(() => {
  init_pad();
  init_slice_util();
  sliceGradConfig = {
    kernelName: Slice,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { begin, size } = attrs;
      const inputShape = x.shape;
      const [begin_, size_] = parseSliceParams(x, begin, size);
      const paddings = [];
      for (let i = 0;i < dy2.rank; i++) {
        paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);
      }
      return { x: () => pad(dy2, paddings) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Softmax_grad.js
var softmaxGradConfig;
var init_Softmax_grad = __esm(() => {
  init_mul();
  init_sub();
  init_sum();
  softmaxGradConfig = {
    kernelName: Softmax,
    outputsToSave: [true],
    gradFunc: (dy2, saved, attrs) => {
      const [y] = saved;
      const { dim } = attrs;
      const keepDims = true;
      const dyTimesY = mul(dy2, y);
      return {
        logits: () => sub(dyTimesY, mul(sum2(dyTimesY, [dim], keepDims), y))
      };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Softplus_grad.js
var softplusGradConfig;
var init_Softplus_grad = __esm(() => {
  init_mul();
  init_sigmoid();
  softplusGradConfig = {
    kernelName: Softplus,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(dy2, sigmoid(x)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/SpaceToBatchND_grad.js
var spaceToBatchNDGradConfig;
var init_SpaceToBatchND_grad = __esm(() => {
  init_batch_to_space_nd();
  spaceToBatchNDGradConfig = {
    kernelName: SpaceToBatchND,
    gradFunc: (dy2, saved, attrs) => {
      const { blockShape, paddings } = attrs;
      return { x: () => batchToSpaceND(dy2, blockShape, paddings) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/SplitV_grad.js
var splitVGradConfig;
var init_SplitV_grad = __esm(() => {
  init_concat();
  splitVGradConfig = {
    kernelName: SplitV,
    gradFunc: (dy2, saved, attrs) => {
      const { axis } = attrs;
      return { x: () => concat(dy2, axis) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sqrt_grad.js
var sqrtGradConfig;
var init_Sqrt_grad = __esm(() => {
  init_cast();
  init_div();
  init_mul();
  init_sqrt();
  sqrtGradConfig = {
    kernelName: Sqrt,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, mul(sqrt(cast(x, "float32")), 2)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Square_grad.js
var squareGradConfig;
var init_Square_grad = __esm(() => {
  init_cast();
  init_mul();
  squareGradConfig = {
    kernelName: Square,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => mul(dy2, mul(cast(x, "float32"), 2)) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/SquaredDifference_grad.js
var squaredDifferenceGradConfig;
var init_SquaredDifference_grad = __esm(() => {
  init_mul();
  init_scalar();
  init_sub();
  squaredDifferenceGradConfig = {
    kernelName: SquaredDifference,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const two = scalar(2);
      const derA = () => mul(dy2, mul(two, sub(a, b)));
      const derB = () => mul(dy2, mul(two, sub(b, a)));
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Step_grad.js
var stepGradConfig;
var init_Step_grad = __esm(() => {
  init_zeros_like();
  stepGradConfig = {
    kernelName: Step,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sub_grad.js
var subGradConfig;
var init_Sub_grad = __esm(() => {
  init_neg();
  init_reshape();
  init_sum();
  subGradConfig = {
    kernelName: Sub,
    inputsToSave: ["a", "b"],
    gradFunc: (dy2, saved) => {
      const [a, b] = saved;
      const outShape = assertAndGetBroadcastShape(a.shape, b.shape);
      const derA = () => {
        let res = dy2;
        const reduceAxes = getReductionAxes(a.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(res, a.shape);
      };
      const derB = () => {
        let res = dy2;
        const reduceAxes = getReductionAxes(b.shape, outShape);
        if (reduceAxes.length > 0) {
          res = sum2(res, reduceAxes);
        }
        return reshape(neg(res), b.shape);
      };
      return { a: derA, b: derB };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Sum_grad.js
var sumGradConfig;
var init_Sum_grad = __esm(() => {
  init_mul();
  init_ones();
  init_reshape();
  init_util();
  sumGradConfig = {
    kernelName: Sum,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const expandedDyShape = x.shape.slice();
      const { axis } = attrs;
      const axes = parseAxisParam(axis, x.shape);
      axes.forEach((axis2) => {
        expandedDyShape[axis2] = 1;
      });
      const expandedDy = reshape(dy2, expandedDyShape);
      const derX = mul(expandedDy, ones2(x.shape, "float32"));
      return { x: () => derX };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Tan_grad.js
var tanGradConfig;
var init_Tan_grad = __esm(() => {
  init_cos();
  init_div();
  init_square();
  tanGradConfig = {
    kernelName: Tan,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved) => {
      const [x] = saved;
      return { x: () => div(dy2, square(cos(x))) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Tanh_grad.js
var tanhGradConfig;
var init_Tanh_grad = __esm(() => {
  init_mul();
  init_scalar();
  init_square();
  init_sub();
  tanhGradConfig = {
    kernelName: Tanh,
    outputsToSave: [true],
    gradFunc: (dy2, saved) => {
      const [y] = saved;
      return { x: () => mul(sub(scalar(1), square(y)), dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Tile_grad.js
var tileGradConfig;
var init_Tile_grad = __esm(() => {
  init_add();
  init_slice();
  init_zeros_like();
  tileGradConfig = {
    kernelName: Tile,
    inputsToSave: ["x"],
    gradFunc: (dy2, saved, attrs) => {
      const [x] = saved;
      const { reps } = attrs;
      const derX = () => {
        let xGrad = zerosLike(x);
        if (x.rank === 1) {
          for (let i = 0;i < reps[0]; ++i) {
            xGrad = add2(xGrad, slice(dy2, [i * x.shape[0]], [x.shape[0]]));
          }
        } else if (x.rank === 2) {
          for (let i = 0;i < reps[0]; ++i) {
            for (let j = 0;j < reps[1]; ++j) {
              xGrad = add2(xGrad, slice(dy2, [i * x.shape[0], j * x.shape[1]], [
                x.shape[0],
                x.shape[1]
              ]));
            }
          }
        } else if (x.rank === 3) {
          for (let i = 0;i < reps[0]; ++i) {
            for (let j = 0;j < reps[1]; ++j) {
              for (let k = 0;k < reps[2]; ++k) {
                xGrad = add2(xGrad, slice(dy2, [i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));
              }
            }
          }
        } else if (x.rank === 4) {
          for (let i = 0;i < reps[0]; ++i) {
            for (let j = 0;j < reps[1]; ++j) {
              for (let k = 0;k < reps[2]; ++k) {
                for (let l = 0;l < reps[3]; ++l) {
                  xGrad = add2(xGrad, slice(dy2, [
                    i * x.shape[0],
                    j * x.shape[1],
                    k * x.shape[2],
                    l * x.shape[3]
                  ], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));
                }
              }
            }
          }
        } else {
          throw new Error(`Gradient for tile operation is not implemented for rank-` + `${x.rank} tensors yet.`);
        }
        return xGrad;
      };
      return { x: derX };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Transpose_grad.js
var transposeGradConfig;
var init_Transpose_grad = __esm(() => {
  init_axis_util();
  init_transpose();
  transposeGradConfig = {
    kernelName: Transpose,
    gradFunc: (dy2, saved, attrs) => {
      const transposeAttrs = attrs;
      const { perm } = transposeAttrs;
      const undoPerm = getUndoAxesPermutation(perm);
      return { x: () => transpose(dy2, undoPerm) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/Unpack_grad.js
var unpackGradConfig;
var init_Unpack_grad = __esm(() => {
  init_stack();
  unpackGradConfig = {
    kernelName: Unpack,
    gradFunc: (dy2, saved, attrs) => {
      const unpackAttrs = attrs;
      const { axis } = unpackAttrs;
      return { value: () => stack(dy2, axis) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/UnsortedSegmentSum_grad.js
function gatherDropNegatives(x, indices) {
  const zeroClippedIndices = maximum(indices, zerosLike(indices));
  const gathered = gather(x, zeroClippedIndices);
  let isPositive = greaterEqual(indices, scalar(0, "int32"));
  const numIters = gathered.rank - isPositive.rank;
  for (let i = 0;i < numIters; ++i) {
    isPositive = expandDims(isPositive, i + 1);
  }
  isPositive = logicalAnd(isPositive, ones2(gathered.shape, "bool"));
  const zeroSlice = zerosLike(gathered);
  return where(isPositive, gathered, zeroSlice);
}
var unsortedSegmentSumGradConfig;
var init_UnsortedSegmentSum_grad = __esm(() => {
  init_expand_dims();
  init_gather();
  init_greater_equal();
  init_logical_and();
  init_maximum();
  init_ones();
  init_scalar();
  init_where();
  init_zeros_like();
  unsortedSegmentSumGradConfig = {
    kernelName: UnsortedSegmentSum,
    inputsToSave: ["segmentIds"],
    gradFunc: (dy2, saved) => {
      const [segmentIds] = saved;
      const derX = () => {
        return gatherDropNegatives(dy2, segmentIds);
      };
      return { x: derX };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/gradients/ZerosLike_grad.js
var zerosLikeGradConfig;
var init_ZerosLike_grad = __esm(() => {
  init_zeros_like();
  zerosLikeGradConfig = {
    kernelName: ZerosLike,
    gradFunc: (dy2) => {
      return { x: () => zerosLike(dy2) };
    }
  };
});

// node_modules/@tensorflow/tfjs-core/dist/register_all_gradients.js
var gradConfigs;
var init_register_all_gradients = __esm(() => {
  init_Abs_grad();
  init_Acos_grad();
  init_Acosh_grad();
  init_Add_grad();
  init_AddN_grad();
  init_ArgMax_grad();
  init_ArgMin_grad();
  init_Asin_grad();
  init_Asinh_grad();
  init_Atan2_grad();
  init_Atan_grad();
  init_Atanh_grad();
  init_AvgPool3D_grad();
  init_AvgPool_grad();
  init_BatchMatMul_grad();
  init_BatchToSpaceND_grad();
  init_BroadcastTo_grad();
  init_Cast_grad();
  init_Ceil_grad();
  init_ClipByValue_grad();
  init_ComplexAbs_grad();
  init_Concat_grad();
  init_Conv2D_grad();
  init_Conv2DBackpropInput_grad();
  init_Conv3D_grad();
  init_Cos_grad();
  init_Cosh_grad();
  init_Cumsum_grad();
  init_DepthwiseConv2dNative_grad();
  init_Dilation2D_grad();
  init_Elu_grad();
  init_Erf_grad();
  init_Exp_grad();
  init_ExpandDims_grad();
  init_Expm1_grad();
  init_Floor_grad();
  init_FloorDiv_grad();
  init_FusedBatchNorm_grad();
  init_GatherV2_grad();
  init_GreaterEqual_grad();
  init_Identity_grad();
  init_IsFinite_grad();
  init_IsInf_grad();
  init_IsNan_grad();
  init_LeakyRelu_grad();
  init_Log1p_grad();
  init_Log_grad();
  init_LogSoftmax_grad();
  init_LRN_grad();
  init_Max_grad();
  init_Maximum_grad();
  init_MaxPool3D_grad();
  init_MaxPool_grad();
  init_Mean_grad();
  init_Min_grad();
  init_Minimum_grad();
  init_MirrorPad_grad();
  init_Mod_grad();
  init_Multiply_grad();
  init_Neg_grad();
  init_OneHot_grad();
  init_OnesLike_grad();
  init_Pack_grad();
  init_PadV2_grad();
  init_Pow_grad();
  init_Prelu_grad();
  init_Prod_grad();
  init_RealDiv_grad();
  init_Reciprocal_grad();
  init_Relu6_grad();
  init_Relu_grad();
  init_Reshape_grad();
  init_ResizeBilinear_grad();
  init_ResizeNearestNeighbor_grad();
  init_Reverse_grad();
  init_Round_grad();
  init_Rsqrt_grad();
  init_Select_grad();
  init_Selu_grad();
  init_Sigmoid_grad();
  init_Sign_grad();
  init_Sin_grad();
  init_Sinh_grad();
  init_Slice_grad();
  init_Softmax_grad();
  init_Softplus_grad();
  init_SpaceToBatchND_grad();
  init_SplitV_grad();
  init_Sqrt_grad();
  init_Square_grad();
  init_SquaredDifference_grad();
  init_Step_grad();
  init_Sub_grad();
  init_Sum_grad();
  init_Tan_grad();
  init_Tanh_grad();
  init_Tile_grad();
  init_Transpose_grad();
  init_Unpack_grad();
  init_UnsortedSegmentSum_grad();
  init_ZerosLike_grad();
  init_kernel_registry();
  gradConfigs = [
    absGradConfig,
    acosGradConfig,
    acoshGradConfig,
    addGradConfig,
    addNGradConfig,
    argMaxGradConfig,
    argMinGradConfig,
    asinGradConfig,
    asinhGradConfig,
    atan2GradConfig,
    atanGradConfig,
    atanhGradConfig,
    avgPool3DGradConfig,
    avgPoolGradConfig,
    batchMatMulGradConfig,
    batchToSpaceNDGradConfig,
    broadcastToGradConfig,
    castGradConfig,
    ceilGradConfig,
    clipByValueGradConfig,
    complexAbsGradConfig,
    concatGradConfig,
    conv2DBackpropInputGradConfig,
    conv2DGradConfig,
    conv3DGradConfig,
    cosGradConfig,
    coshGradConfig,
    cumsumGradConfig,
    depthwiseConv2dNativeGradConfig,
    dilation2dGradConfig,
    divGradConfig,
    eluGradConfig,
    erfGradConfig,
    expGradConfig,
    expandDimsGradConfig,
    expm1GradConfig,
    floorDivGradConfig,
    floorGradConfig,
    fusedBatchNormGradConfig,
    gatherGradConfig,
    greaterEqualGradConfig,
    identityGradConfig,
    isFiniteGradConfig,
    isInfGradConfig,
    isNanGradConfig,
    leakyReluGradConfig,
    log1pGradConfig,
    logGradConfig,
    logSoftmaxGradConfig,
    lrnGradConfig,
    maxGradConfig,
    maxGradConfig,
    maximumGradConfig,
    maxPool3DGradConfig,
    maxPoolGradConfig,
    meanGradConfig,
    minGradConfig,
    minimumGradConfig,
    mirrorPadGradConfig,
    modGradConfig,
    multiplyGradConfig,
    negGradConfig,
    oneHotGradConfig,
    onesLikeGradConfig,
    packGradConfig,
    padV2GradConfig,
    padV2GradConfig,
    powGradConfig,
    preluGradConfig,
    prodGradConfig,
    reciprocalGradConfig,
    relu6GradConfig,
    reluGradConfig,
    reshapeGradConfig,
    resizeBilinearGradConfig,
    resizeNearestNeighborGradConfig,
    reverseGradConfig,
    roundGradConfig,
    rsqrtGradConfig,
    selectGradConfig,
    seluGradConfig,
    sigmoidGradConfig,
    signGradConfig,
    sinGradConfig,
    sinhGradConfig,
    sliceGradConfig,
    softmaxGradConfig,
    softplusGradConfig,
    spaceToBatchNDGradConfig,
    spaceToBatchNDGradConfig,
    splitVGradConfig,
    splitVGradConfig,
    sqrtGradConfig,
    squaredDifferenceGradConfig,
    squareGradConfig,
    stepGradConfig,
    subGradConfig,
    sumGradConfig,
    tanGradConfig,
    tanhGradConfig,
    tileGradConfig,
    transposeGradConfig,
    unpackGradConfig,
    unsortedSegmentSumGradConfig,
    zerosLikeGradConfig
  ];
  for (const gradientConfig of gradConfigs) {
    registerGradient(gradientConfig);
  }
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/abs.js
var init_abs2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.abs = function() {
    this.throwIfDisposed();
    return abs(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/acos.js
var init_acos2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.acos = function() {
    this.throwIfDisposed();
    return acos(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/acosh.js
var init_acosh2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.acosh = function() {
    this.throwIfDisposed();
    return acosh(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/add.js
var init_add2 = __esm(() => {
  init_add();
  init_tensor();
  getGlobalTensorClass().prototype.add = function(b) {
    this.throwIfDisposed();
    return add2(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/all.js
var init_all2 = __esm(() => {
  init_all();
  init_tensor();
  getGlobalTensorClass().prototype.all = function(axis, keepDims) {
    this.throwIfDisposed();
    return all(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/any.js
var init_any2 = __esm(() => {
  init_any();
  init_tensor();
  getGlobalTensorClass().prototype.any = function(axis, keepDims) {
    this.throwIfDisposed();
    return any(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/arg_max.js
var init_arg_max2 = __esm(() => {
  init_arg_max();
  init_tensor();
  getGlobalTensorClass().prototype.argMax = function(axis) {
    this.throwIfDisposed();
    return argMax(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/arg_min.js
var init_arg_min2 = __esm(() => {
  init_arg_min();
  init_tensor();
  getGlobalTensorClass().prototype.argMin = function(axis) {
    this.throwIfDisposed();
    return argMin(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as_scalar.js
var init_as_scalar = __esm(() => {
  init_reshape();
  init_tensor();
  init_util();
  getGlobalTensorClass().prototype.asScalar = function() {
    this.throwIfDisposed();
    assert(this.size === 1, () => "The array must have only 1 element.");
    return reshape(this, []);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as_type.js
var init_as_type = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.asType = function(dtype) {
    this.throwIfDisposed();
    return cast(this, dtype);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as1d.js
var init_as1d = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.as1D = function() {
    this.throwIfDisposed();
    return reshape(this, [this.size]);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as2d.js
var init_as2d = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.as2D = function(rows, columns) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns]);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as3d.js
var init_as3d = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.as3D = function(rows, columns, depth) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns, depth]);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as4d.js
var init_as4d = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.as4D = function(rows, columns, depth, depth2) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns, depth, depth2]);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/as5d.js
var init_as5d = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.as5D = function(rows, columns, depth, depth2, depth3) {
    this.throwIfDisposed();
    return reshape(this, [rows, columns, depth, depth2, depth3]);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/asin.js
var init_asin2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.asin = function() {
    this.throwIfDisposed();
    return asin(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/asinh.js
var init_asinh2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.asinh = function() {
    this.throwIfDisposed();
    return asinh(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/atan.js
var init_atan3 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.atan = function() {
    this.throwIfDisposed();
    return atan(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/atan2.js
var init_atan22 = __esm(() => {
  init_atan2();
  init_tensor();
  getGlobalTensorClass().prototype.atan2 = function(b) {
    this.throwIfDisposed();
    return atan2(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/atanh.js
var init_atanh2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.atanh = function() {
    this.throwIfDisposed();
    return atanh(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/avg_pool.js
var init_avg_pool2 = __esm(() => {
  init_avg_pool();
  init_tensor();
  getGlobalTensorClass().prototype.avgPool = function(filterSize, strides, pad7, dimRoundingMode) {
    this.throwIfDisposed();
    return avgPool(this, filterSize, strides, pad7, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/batch_to_space_nd.js
var init_batch_to_space_nd2 = __esm(() => {
  init_batch_to_space_nd();
  init_tensor();
  getGlobalTensorClass().prototype.batchToSpaceND = function(blockShape, crops) {
    this.throwIfDisposed();
    return batchToSpaceND(this, blockShape, crops);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/batchnorm.js
var init_batchnorm2 = __esm(() => {
  init_batchnorm();
  init_tensor();
  getGlobalTensorClass().prototype.batchNorm = function(mean4, variance, offset, scale, varianceEpsilon) {
    this.throwIfDisposed();
    return batchNorm(this, mean4, variance, offset, scale, varianceEpsilon);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/broadcast_to.js
var init_broadcast_to2 = __esm(() => {
  init_broadcast_to();
  init_tensor();
  getGlobalTensorClass().prototype.broadcastTo = function(shape) {
    this.throwIfDisposed();
    return broadcastTo(this, shape);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cast.js
var init_cast2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.cast = function(dtype) {
    this.throwIfDisposed();
    return cast(this, dtype);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/ceil.js
var init_ceil2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.ceil = function() {
    this.throwIfDisposed();
    return ceil(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/clip_by_value.js
var init_clip_by_value2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.clipByValue = function(min3, max5) {
    this.throwIfDisposed();
    return clipByValue(this, min3, max5);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/concat.js
var init_concat2 = __esm(() => {
  init_concat();
  init_tensor();
  getGlobalTensorClass().prototype.concat = function(x, axis) {
    this.throwIfDisposed();
    if (x instanceof Tensor) {
      x = [x];
    }
    return concat([this, ...x], axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/conv1d.js
var init_conv1d2 = __esm(() => {
  init_conv1d();
  init_tensor();
  getGlobalTensorClass().prototype.conv1d = function(filter, stride, pad7, dataFormat, dilation, dimRoundingMode) {
    this.throwIfDisposed();
    return conv1d(this, filter, stride, pad7, dataFormat, dilation, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/conv2d_transpose.js
var init_conv2d_transpose2 = __esm(() => {
  init_conv2d_transpose();
  init_tensor();
  getGlobalTensorClass().prototype.conv2dTranspose = function(filter, outputShape, strides, pad7, dimRoundingMode) {
    this.throwIfDisposed();
    return conv2dTranspose(this, filter, outputShape, strides, pad7, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/conv2d.js
var init_conv2d3 = __esm(() => {
  init_conv2d();
  init_tensor();
  getGlobalTensorClass().prototype.conv2d = function(filter, strides, pad7, dataFormat, dilations, dimRoundingMode) {
    this.throwIfDisposed();
    return conv2d(this, filter, strides, pad7, dataFormat, dilations, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cos.js
var init_cos2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.cos = function() {
    this.throwIfDisposed();
    return cos(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cosh.js
var init_cosh2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.cosh = function() {
    this.throwIfDisposed();
    return cosh(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cumprod.js
var init_cumprod2 = __esm(() => {
  init_cumprod();
  init_tensor();
  getGlobalTensorClass().prototype.cumprod = function(axis, exclusive, reverse8) {
    this.throwIfDisposed();
    return cumprod(this, axis, exclusive, reverse8);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/cumsum.js
var init_cumsum2 = __esm(() => {
  init_cumsum();
  init_tensor();
  getGlobalTensorClass().prototype.cumsum = function(axis, exclusive, reverse8) {
    this.throwIfDisposed();
    return cumsum(this, axis, exclusive, reverse8);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/depth_to_space.js
var init_depth_to_space2 = __esm(() => {
  init_depth_to_space();
  init_tensor();
  getGlobalTensorClass().prototype.depthToSpace = function(blockSize, dataFormat) {
    this.throwIfDisposed();
    return depthToSpace(this, blockSize, dataFormat);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/depthwise_conv2d.js
var init_depthwise_conv2d3 = __esm(() => {
  init_depthwise_conv2d();
  init_tensor();
  getGlobalTensorClass().prototype.depthwiseConv2d = function(filter, strides, pad7, dataFormat, dilations, dimRoundingMode) {
    this.throwIfDisposed();
    return depthwiseConv2d(this, filter, strides, pad7, dataFormat, dilations, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/dilation2d.js
var init_dilation2d2 = __esm(() => {
  init_dilation2d();
  init_tensor();
  getGlobalTensorClass().prototype.dilation2d = function(filter, strides, pad7, dilations, dataFormat) {
    this.throwIfDisposed();
    return dilation2d(this, filter, strides, pad7, dilations, dataFormat);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/div_no_nan.js
var init_div_no_nan2 = __esm(() => {
  init_div_no_nan();
  init_tensor();
  getGlobalTensorClass().prototype.divNoNan = function(b) {
    this.throwIfDisposed();
    return divNoNan(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/div.js
var init_div2 = __esm(() => {
  init_div();
  init_tensor();
  getGlobalTensorClass().prototype.div = function(b) {
    this.throwIfDisposed();
    return div(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/dot.js
var init_dot2 = __esm(() => {
  init_dot();
  init_tensor();
  getGlobalTensorClass().prototype.dot = function(b) {
    this.throwIfDisposed();
    return dot(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/elu.js
var init_elu2 = __esm(() => {
  init_elu();
  init_tensor();
  getGlobalTensorClass().prototype.elu = function() {
    this.throwIfDisposed();
    return elu(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/equal.js
var init_equal2 = __esm(() => {
  init_equal();
  init_tensor();
  getGlobalTensorClass().prototype.equal = function(b) {
    this.throwIfDisposed();
    return equal(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/erf.js
var init_erf2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.erf = function() {
    this.throwIfDisposed();
    return erf(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/euclidean_norm.js
var init_euclidean_norm2 = __esm(() => {
  init_euclidean_norm();
  init_tensor();
  getGlobalTensorClass().prototype.euclideanNorm = function(axis, keepDims) {
    this.throwIfDisposed();
    return euclideanNorm(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/exp.js
var init_exp2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.exp = function() {
    this.throwIfDisposed();
    return exp(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/expand_dims.js
var init_expand_dims2 = __esm(() => {
  init_expand_dims();
  init_tensor();
  getGlobalTensorClass().prototype.expandDims = function(axis) {
    this.throwIfDisposed();
    return expandDims(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/expm1.js
var init_expm12 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.expm1 = function() {
    this.throwIfDisposed();
    return expm1(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/fft.js
var init_fft2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.fft = function() {
    this.throwIfDisposed();
    return fft(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/flatten.js
var init_flatten = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.flatten = function() {
    this.throwIfDisposed();
    return reshape(this, [this.size]);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/floor.js
var init_floor2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.floor = function() {
    this.throwIfDisposed();
    return floor(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/floorDiv.js
var init_floorDiv2 = __esm(() => {
  init_floorDiv();
  init_tensor();
  getGlobalTensorClass().prototype.floorDiv = function(b) {
    this.throwIfDisposed();
    return floorDiv(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/gather.js
var init_gather2 = __esm(() => {
  init_gather();
  init_tensor();
  getGlobalTensorClass().prototype.gather = function(indices, axis, batchDims) {
    this.throwIfDisposed();
    return gather(this, indices, axis, batchDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/greater_equal.js
var init_greater_equal2 = __esm(() => {
  init_greater_equal();
  init_tensor();
  getGlobalTensorClass().prototype.greaterEqual = function(b) {
    this.throwIfDisposed();
    return greaterEqual(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/greater.js
var init_greater2 = __esm(() => {
  init_greater();
  init_tensor();
  getGlobalTensorClass().prototype.greater = function(b) {
    this.throwIfDisposed();
    return greater(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/ifft.js
var init_ifft2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.ifft = function() {
    this.throwIfDisposed();
    return ifft(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/irfft.js
var init_irfft2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.irfft = function() {
    this.throwIfDisposed();
    return irfft(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/is_finite.js
var init_is_finite2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.isFinite = function() {
    this.throwIfDisposed();
    return isFinite2(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/is_inf.js
var init_is_inf2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.isInf = function() {
    this.throwIfDisposed();
    return isInf(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/is_nan.js
var init_is_nan2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.isNaN = function() {
    this.throwIfDisposed();
    return isNaN2(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/leaky_relu.js
var init_leaky_relu2 = __esm(() => {
  init_leaky_relu();
  init_tensor();
  getGlobalTensorClass().prototype.leakyRelu = function(alpha) {
    this.throwIfDisposed();
    return leakyRelu(this, alpha);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/less_equal.js
var init_less_equal2 = __esm(() => {
  init_less_equal();
  init_tensor();
  getGlobalTensorClass().prototype.lessEqual = function(b) {
    this.throwIfDisposed();
    return lessEqual(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/less.js
var init_less2 = __esm(() => {
  init_less();
  init_tensor();
  getGlobalTensorClass().prototype.less = function(b) {
    this.throwIfDisposed();
    return less(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/local_response_normalization.js
var init_local_response_normalization2 = __esm(() => {
  init_local_response_normalization();
  init_tensor();
  getGlobalTensorClass().prototype.localResponseNormalization = function(depthRadius, bias, alpha, beta) {
    this.throwIfDisposed();
    return localResponseNormalization(this, depthRadius, bias, alpha, beta);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log_sigmoid.js
var init_log_sigmoid2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.logSigmoid = function() {
    this.throwIfDisposed();
    return logSigmoid(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log_softmax.js
var init_log_softmax2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.logSoftmax = function(axis) {
    this.throwIfDisposed();
    return logSoftmax(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log_sum_exp.js
var init_log_sum_exp2 = __esm(() => {
  init_log_sum_exp();
  init_tensor();
  getGlobalTensorClass().prototype.logSumExp = function(axis, keepDims) {
    this.throwIfDisposed();
    return logSumExp(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log.js
var init_log3 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.log = function() {
    this.throwIfDisposed();
    return log2(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/log1p.js
var init_log1p2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.log1p = function() {
    this.throwIfDisposed();
    return log1p(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_and.js
var init_logical_and2 = __esm(() => {
  init_logical_and();
  init_tensor();
  getGlobalTensorClass().prototype.logicalAnd = function(b) {
    this.throwIfDisposed();
    return logicalAnd(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_not.js
var init_logical_not2 = __esm(() => {
  init_logical_not();
  init_tensor();
  getGlobalTensorClass().prototype.logicalNot = function() {
    this.throwIfDisposed();
    return logicalNot(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_or.js
var init_logical_or2 = __esm(() => {
  init_logical_or();
  init_tensor();
  getGlobalTensorClass().prototype.logicalOr = function(b) {
    this.throwIfDisposed();
    return logicalOr(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/logical_xor.js
var init_logical_xor2 = __esm(() => {
  init_logical_xor();
  init_tensor();
  getGlobalTensorClass().prototype.logicalXor = function(b) {
    this.throwIfDisposed();
    return logicalXor(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mat_mul.js
var init_mat_mul3 = __esm(() => {
  init_mat_mul();
  init_tensor();
  getGlobalTensorClass().prototype.matMul = function(b, transposeA, transposeB) {
    this.throwIfDisposed();
    return matMul(this, b, transposeA, transposeB);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/max_pool.js
var init_max_pool2 = __esm(() => {
  init_max_pool();
  init_tensor();
  getGlobalTensorClass().prototype.maxPool = function(filterSize, strides, pad7, dimRoundingMode) {
    this.throwIfDisposed();
    return maxPool(this, filterSize, strides, pad7, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/max.js
var init_max2 = __esm(() => {
  init_max();
  init_tensor();
  getGlobalTensorClass().prototype.max = function(axis, keepDims) {
    this.throwIfDisposed();
    return max(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/maximum.js
var init_maximum2 = __esm(() => {
  init_maximum();
  init_tensor();
  getGlobalTensorClass().prototype.maximum = function(b) {
    this.throwIfDisposed();
    return maximum(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mean.js
var init_mean2 = __esm(() => {
  init_mean();
  init_tensor();
  getGlobalTensorClass().prototype.mean = function(axis, keepDims) {
    this.throwIfDisposed();
    return mean(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/min.js
var init_min2 = __esm(() => {
  init_min();
  init_tensor();
  getGlobalTensorClass().prototype.min = function(axis, keepDims) {
    this.throwIfDisposed();
    return min(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/minimum.js
var init_minimum2 = __esm(() => {
  init_minimum();
  init_tensor();
  getGlobalTensorClass().prototype.minimum = function(b) {
    this.throwIfDisposed();
    return minimum(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mirror_pad.js
var init_mirror_pad2 = __esm(() => {
  init_mirror_pad();
  init_tensor();
  getGlobalTensorClass().prototype.mirrorPad = function(paddings, mode) {
    this.throwIfDisposed();
    return mirrorPad(this, paddings, mode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mod.js
var init_mod2 = __esm(() => {
  init_mod();
  init_tensor();
  getGlobalTensorClass().prototype.mod = function(b) {
    this.throwIfDisposed();
    return mod(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/mul.js
var init_mul2 = __esm(() => {
  init_mul();
  init_tensor();
  getGlobalTensorClass().prototype.mul = function(b) {
    this.throwIfDisposed();
    return mul(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/neg.js
var init_neg2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.neg = function() {
    this.throwIfDisposed();
    return neg(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/norm.js
var init_norm2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.norm = function(ord, axis, keepDims) {
    this.throwIfDisposed();
    return norm(this, ord, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/not_equal.js
var init_not_equal2 = __esm(() => {
  init_not_equal();
  init_tensor();
  getGlobalTensorClass().prototype.notEqual = function(b) {
    this.throwIfDisposed();
    return notEqual(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/one_hot.js
var init_one_hot2 = __esm(() => {
  init_one_hot();
  init_tensor();
  getGlobalTensorClass().prototype.oneHot = function(depth, onValue = 1, offValue = 0) {
    this.throwIfDisposed();
    return oneHot(this, depth, onValue, offValue);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/ones_like.js
var init_ones_like2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.onesLike = function() {
    this.throwIfDisposed();
    return onesLike(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/pad.js
var init_pad2 = __esm(() => {
  init_pad();
  init_tensor();
  getGlobalTensorClass().prototype.pad = function(paddings, constantValue) {
    this.throwIfDisposed();
    return pad(this, paddings, constantValue);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/pool.js
var init_pool2 = __esm(() => {
  init_pool();
  init_tensor();
  getGlobalTensorClass().prototype.pool = function(windowShape, poolingType, padding, dilationRate, strides, dimRoundingMode) {
    this.throwIfDisposed();
    return pool(this, windowShape, poolingType, padding, dilationRate, strides, dimRoundingMode);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/pow.js
var init_pow2 = __esm(() => {
  init_pow();
  init_tensor();
  getGlobalTensorClass().prototype.pow = function(exp10) {
    this.throwIfDisposed();
    return pow(this, exp10);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/prelu.js
var init_prelu2 = __esm(() => {
  init_prelu();
  init_tensor();
  getGlobalTensorClass().prototype.prelu = function(alpha) {
    this.throwIfDisposed();
    return prelu(this, alpha);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/prod.js
var init_prod2 = __esm(() => {
  init_prod();
  init_tensor();
  getGlobalTensorClass().prototype.prod = function(axis, keepDims) {
    this.throwIfDisposed();
    return prod(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reciprocal.js
var init_reciprocal2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.reciprocal = function() {
    this.throwIfDisposed();
    return reciprocal(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/relu.js
var init_relu2 = __esm(() => {
  init_relu();
  init_tensor();
  getGlobalTensorClass().prototype.relu = function() {
    this.throwIfDisposed();
    return relu(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/relu6.js
var init_relu62 = __esm(() => {
  init_relu6();
  init_tensor();
  getGlobalTensorClass().prototype.relu6 = function() {
    this.throwIfDisposed();
    return relu6(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reshape_as.js
var init_reshape_as = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.reshapeAs = function(x) {
    this.throwIfDisposed();
    return reshape(this, x.shape);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reshape.js
var init_reshape2 = __esm(() => {
  init_reshape();
  init_tensor();
  getGlobalTensorClass().prototype.reshape = function(shape) {
    this.throwIfDisposed();
    return reshape(this, shape);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/resize_bilinear.js
var init_resize_bilinear2 = __esm(() => {
  init_resize_bilinear();
  init_tensor();
  getGlobalTensorClass().prototype.resizeBilinear = function(newShape2D, alignCorners, halfPixelCenters) {
    this.throwIfDisposed();
    return resizeBilinear(this, newShape2D, alignCorners, halfPixelCenters);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/resize_nearest_neighbor.js
var init_resize_nearest_neighbor2 = __esm(() => {
  init_resize_nearest_neighbor();
  init_tensor();
  getGlobalTensorClass().prototype.resizeNearestNeighbor = function(newShape2D, alignCorners, halfFloatCenters) {
    this.throwIfDisposed();
    return resizeNearestNeighbor(this, newShape2D, alignCorners, halfFloatCenters);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/reverse.js
var init_reverse2 = __esm(() => {
  init_reverse();
  init_tensor();
  getGlobalTensorClass().prototype.reverse = function(axis) {
    this.throwIfDisposed();
    return reverse(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/rfft.js
var init_rfft2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.rfft = function() {
    this.throwIfDisposed();
    return rfft(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/round.js
var init_round2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.round = function() {
    this.throwIfDisposed();
    return round2(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/rsqrt.js
var init_rsqrt2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.rsqrt = function() {
    this.throwIfDisposed();
    return rsqrt(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/selu.js
var init_selu2 = __esm(() => {
  init_selu();
  init_tensor();
  getGlobalTensorClass().prototype.selu = function() {
    this.throwIfDisposed();
    return selu(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/separable_conv2d.js
var init_separable_conv2d2 = __esm(() => {
  init_separable_conv2d();
  init_tensor();
  getGlobalTensorClass().prototype.separableConv2d = function(depthwiseFilter, pointwiseFilter, strides, pad8, dilation, dataFormat) {
    this.throwIfDisposed();
    return separableConv2d(this, depthwiseFilter, pointwiseFilter, strides, pad8, dilation, dataFormat);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sigmoid.js
var init_sigmoid2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.sigmoid = function() {
    this.throwIfDisposed();
    return sigmoid(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sign.js
var init_sign2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.sign = function() {
    this.throwIfDisposed();
    return sign(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sin.js
var init_sin2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.sin = function() {
    this.throwIfDisposed();
    return sin(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sinh.js
var init_sinh2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.sinh = function() {
    this.throwIfDisposed();
    return sinh(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/slice.js
var init_slice2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.slice = function(begin, size) {
    this.throwIfDisposed();
    return slice(this, begin, size);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/softmax.js
var init_softmax2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.softmax = function(dim) {
    this.throwIfDisposed();
    return softmax(this, dim);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/softplus.js
var init_softplus2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.softplus = function() {
    this.throwIfDisposed();
    return softplus(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/space_to_batch_nd.js
var init_space_to_batch_nd2 = __esm(() => {
  init_space_to_batch_nd();
  init_tensor();
  getGlobalTensorClass().prototype.spaceToBatchND = function(blockShape, paddings) {
    this.throwIfDisposed();
    return spaceToBatchND(this, blockShape, paddings);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/split.js
var init_split2 = __esm(() => {
  init_split();
  init_tensor();
  getGlobalTensorClass().prototype.split = function(numOrSizeSplits, axis) {
    this.throwIfDisposed();
    return split(this, numOrSizeSplits, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sqrt.js
var init_sqrt2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.sqrt = function() {
    this.throwIfDisposed();
    return sqrt(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/square.js
var init_square2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.square = function() {
    this.throwIfDisposed();
    return square(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/squared_difference.js
var init_squared_difference2 = __esm(() => {
  init_squared_difference();
  init_tensor();
  getGlobalTensorClass().prototype.squaredDifference = function(b) {
    this.throwIfDisposed();
    return squaredDifference(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/squeeze.js
var init_squeeze2 = __esm(() => {
  init_squeeze();
  init_tensor();
  getGlobalTensorClass().prototype.squeeze = function(axis) {
    this.throwIfDisposed();
    return squeeze(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/stack.js
var init_stack2 = __esm(() => {
  init_stack();
  init_tensor();
  getGlobalTensorClass().prototype.stack = function(x, axis) {
    this.throwIfDisposed();
    const tensorsToBeStacked = x instanceof Tensor ? [this, x] : [this, ...x];
    return stack(tensorsToBeStacked, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/step.js
var init_step2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.step = function(alpha) {
    this.throwIfDisposed();
    return step(this, alpha);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/strided_slice.js
var init_strided_slice2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.stridedSlice = function(begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
    this.throwIfDisposed();
    return stridedSlice(this, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sub.js
var init_sub2 = __esm(() => {
  init_sub();
  init_tensor();
  getGlobalTensorClass().prototype.sub = function(b) {
    this.throwIfDisposed();
    return sub(this, b);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/sum.js
var init_sum2 = __esm(() => {
  init_sum();
  init_tensor();
  getGlobalTensorClass().prototype.sum = function(axis, keepDims) {
    this.throwIfDisposed();
    return sum2(this, axis, keepDims);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/tan.js
var init_tan2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.tan = function() {
    this.throwIfDisposed();
    return tan(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/tanh.js
var init_tanh2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.tanh = function() {
    this.throwIfDisposed();
    return tanh2(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/tile.js
var init_tile2 = __esm(() => {
  init_tile();
  init_tensor();
  getGlobalTensorClass().prototype.tile = function(reps) {
    this.throwIfDisposed();
    return tile(this, reps);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/to_bool.js
var init_to_bool = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.toBool = function() {
    this.throwIfDisposed();
    return cast(this, "bool");
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/to_float.js
var init_to_float = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.toFloat = function() {
    this.throwIfDisposed();
    return cast(this, "float32");
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/to_int.js
var init_to_int = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.toInt = function() {
    this.throwIfDisposed();
    return cast(this, "int32");
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/topk.js
var init_topk2 = __esm(() => {
  init_topk();
  init_tensor();
  getGlobalTensorClass().prototype.topk = function(k, sorted) {
    this.throwIfDisposed();
    return topk(this, k, sorted);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/transpose.js
var init_transpose2 = __esm(() => {
  init_transpose();
  init_tensor();
  getGlobalTensorClass().prototype.transpose = function(perm) {
    this.throwIfDisposed();
    return transpose(this, perm);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/unique.js
var init_unique2 = __esm(() => {
  init_unique();
  init_tensor();
  getGlobalTensorClass().prototype.unique = function(axis) {
    this.throwIfDisposed();
    return unique(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/unsorted_segment_sum.js
var init_unsorted_segment_sum2 = __esm(() => {
  init_unsorted_segment_sum();
  init_tensor();
  getGlobalTensorClass().prototype.unsortedSegmentSum = function(segmentIds, numSegments) {
    this.throwIfDisposed();
    return unsortedSegmentSum(this, segmentIds, numSegments);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/unstack.js
var init_unstack2 = __esm(() => {
  init_unstack();
  init_tensor();
  getGlobalTensorClass().prototype.unstack = function(axis) {
    this.throwIfDisposed();
    return unstack(this, axis);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/where.js
var init_where2 = __esm(() => {
  init_where();
  init_tensor();
  getGlobalTensorClass().prototype.where = function(condition, x) {
    this.throwIfDisposed();
    return where(condition, this, x);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/zeros_like.js
var init_zeros_like2 = __esm(() => {
  init_ops();
  init_tensor();
  getGlobalTensorClass().prototype.zerosLike = function() {
    this.throwIfDisposed();
    return zerosLike(this);
  };
});

// node_modules/@tensorflow/tfjs-core/dist/public/chained_ops/register_all_chained_ops.js
var init_register_all_chained_ops = __esm(() => {
  init_abs2();
  init_acos2();
  init_acosh2();
  init_add2();
  init_all2();
  init_any2();
  init_arg_max2();
  init_arg_min2();
  init_as_scalar();
  init_as_type();
  init_as1d();
  init_as2d();
  init_as3d();
  init_as4d();
  init_as5d();
  init_asin2();
  init_asinh2();
  init_atan3();
  init_atan22();
  init_atanh2();
  init_avg_pool2();
  init_batch_to_space_nd2();
  init_batchnorm2();
  init_broadcast_to2();
  init_cast2();
  init_ceil2();
  init_clip_by_value2();
  init_concat2();
  init_conv1d2();
  init_conv2d_transpose2();
  init_conv2d3();
  init_cos2();
  init_cosh2();
  init_cumprod2();
  init_cumsum2();
  init_depth_to_space2();
  init_depthwise_conv2d3();
  init_dilation2d2();
  init_div_no_nan2();
  init_div2();
  init_dot2();
  init_elu2();
  init_equal2();
  init_erf2();
  init_euclidean_norm2();
  init_exp2();
  init_expand_dims2();
  init_expm12();
  init_fft2();
  init_flatten();
  init_floor2();
  init_floorDiv2();
  init_gather2();
  init_greater_equal2();
  init_greater2();
  init_ifft2();
  init_irfft2();
  init_is_finite2();
  init_is_inf2();
  init_is_nan2();
  init_leaky_relu2();
  init_less_equal2();
  init_less2();
  init_local_response_normalization2();
  init_log_sigmoid2();
  init_log_softmax2();
  init_log_sum_exp2();
  init_log3();
  init_log1p2();
  init_logical_and2();
  init_logical_not2();
  init_logical_or2();
  init_logical_xor2();
  init_mat_mul3();
  init_max_pool2();
  init_max2();
  init_maximum2();
  init_mean2();
  init_min2();
  init_minimum2();
  init_mirror_pad2();
  init_mod2();
  init_mul2();
  init_neg2();
  init_norm2();
  init_not_equal2();
  init_one_hot2();
  init_ones_like2();
  init_pad2();
  init_pool2();
  init_pow2();
  init_prelu2();
  init_prod2();
  init_reciprocal2();
  init_relu2();
  init_relu62();
  init_reshape_as();
  init_reshape2();
  init_resize_bilinear2();
  init_resize_nearest_neighbor2();
  init_reverse2();
  init_rfft2();
  init_round2();
  init_rsqrt2();
  init_selu2();
  init_separable_conv2d2();
  init_sigmoid2();
  init_sign2();
  init_sin2();
  init_sinh2();
  init_slice2();
  init_softmax2();
  init_softplus2();
  init_space_to_batch_nd2();
  init_split2();
  init_sqrt2();
  init_square2();
  init_squared_difference2();
  init_squeeze2();
  init_stack2();
  init_step2();
  init_strided_slice2();
  init_sub2();
  init_sum2();
  init_tan2();
  init_tanh2();
  init_tile2();
  init_to_bool();
  init_to_float();
  init_to_int();
  init_topk2();
  init_transpose2();
  init_unique2();
  init_unsorted_segment_sum2();
  init_unstack2();
  init_where2();
  init_zeros_like2();
});

// node_modules/@tensorflow/tfjs-layers/dist/errors.js
var AttributeError, RuntimeError, ValueError, NotImplementedError, AssertionError;
var init_errors = __esm(() => {
  AttributeError = class AttributeError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, AttributeError.prototype);
    }
  };
  RuntimeError = class RuntimeError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, RuntimeError.prototype);
    }
  };
  ValueError = class ValueError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, ValueError.prototype);
    }
  };
  NotImplementedError = class NotImplementedError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, NotImplementedError.prototype);
    }
  };
  AssertionError = class AssertionError extends Error {
    constructor(message) {
      super(message);
      Object.setPrototypeOf(this, AssertionError.prototype);
    }
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/utils/executor_utils.js
class LruCache {
  constructor(maxEntries) {
    this.maxEntries = maxEntries || 100;
    this.cache = new Map;
  }
  get(key) {
    let entry;
    if (this.cache.has(key)) {
      entry = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, entry);
    }
    return entry;
  }
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxEntries) {
      const keyToDelete = this.cache.keys().next().value;
      this.cache.delete(keyToDelete);
    }
    this.cache.set(key, value);
  }
  getMaxEntries() {
    return this.maxEntries;
  }
  setMaxEntries(maxEntries) {
    if (maxEntries < 0) {
      throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${maxEntries}.`);
    }
    if (this.maxEntries > maxEntries) {
      for (let i = 0;i < this.maxEntries - maxEntries; i++) {
        const keyToDelete = this.cache.keys().next().value;
        this.cache.delete(keyToDelete);
      }
    }
    this.maxEntries = maxEntries;
  }
}

// node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js
function pyListRepeat(value, numValues) {
  if (Array.isArray(value)) {
    let newArray = [];
    for (let i = 0;i < numValues; i++) {
      newArray = newArray.concat(value);
    }
    return newArray;
  } else {
    const newArray = new Array(numValues);
    newArray.fill(value);
    return newArray;
  }
}
function assert2(val, message) {
  if (!val) {
    throw new AssertionError(message);
  }
}
function count(array, refernce) {
  let counter = 0;
  for (const item of array) {
    if (item === refernce) {
      counter++;
    }
  }
  return counter;
}
function singletonOrArray(xs) {
  if (xs.length === 1) {
    return xs[0];
  }
  return xs;
}
function toList(x) {
  if (Array.isArray(x)) {
    return x;
  }
  return [x];
}
function toSnakeCase(name) {
  const intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2");
  const insecure = intermediate.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
  if (insecure[0] !== "_") {
    return insecure;
  }
  return "private" + insecure;
}
function toCamelCase(identifier) {
  if (identifier.length <= 1) {
    return identifier;
  }
  if (identifier.indexOf("_") === -1) {
    return identifier;
  }
  return identifier.replace(/[_]+(\w|$)/g, (m, p1) => p1.toUpperCase());
}
function serializeKerasObject(instance) {
  if (instance === null || instance === undefined) {
    return null;
  }
  const dict = {};
  dict["className"] = instance.getClassName();
  dict["config"] = instance.getConfig();
  return dict;
}
function convertNDArrayScalarsInConfig(config) {
  if (config == null || typeof config !== "object") {
    return;
  } else if (Array.isArray(config)) {
    config.forEach((configItem) => convertNDArrayScalarsInConfig(configItem));
  } else {
    const fields = Object.keys(config);
    for (const field of fields) {
      const value = config[field];
      if (value != null && typeof value === "object") {
        if (!Array.isArray(value) && value["type"] === "ndarray" && typeof value["value"] === "number") {
          config[field] = value["value"];
        } else {
          convertNDArrayScalarsInConfig(value);
        }
      }
    }
  }
}
function deserializeKerasObject(identifier, moduleObjects = {}, customObjects = {}, printableModuleName = "object", fastWeightInit = false) {
  if (typeof identifier === "string") {
    const functionName = identifier;
    let fn;
    if (functionName in customObjects) {
      fn = customObjects[functionName];
    } else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {
      fn = _GLOBAL_CUSTOM_OBJECTS[functionName];
    } else {
      fn = moduleObjects[functionName];
      if (fn == null) {
        throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. ` + `This may be due to one of the following reasons:\n` + `1. The ${printableModuleName} is defined in Python, in which ` + `case it needs to be ported to TensorFlow.js or your JavaScript ` + `code.\n` + `2. The custom ${printableModuleName} is defined in JavaScript, ` + `but is not registered properly with ` + `tf.serialization.registerClass().`);
      }
    }
    return fn;
  } else {
    const config = identifier;
    if (config["className"] == null || config["config"] == null) {
      throw new ValueError(`${printableModuleName}: Improper config format: ` + `${JSON.stringify(config)}.\n` + `'className' and 'config' must set.`);
    }
    const className = config["className"];
    let cls, fromConfig;
    if (className in customObjects) {
      [cls, fromConfig] = customObjects[className];
    } else if (className in _GLOBAL_CUSTOM_OBJECTS) {
      [cls, fromConfig] = _GLOBAL_CUSTOM_OBJECTS["className"];
    } else if (className in moduleObjects) {
      [cls, fromConfig] = moduleObjects[className];
    }
    if (cls == null) {
      throw new ValueError(`Unknown ${printableModuleName}: ${className}. ` + `This may be due to one of the following reasons:\n` + `1. The ${printableModuleName} is defined in Python, in which ` + `case it needs to be ported to TensorFlow.js or your JavaScript ` + `code.\n` + `2. The custom ${printableModuleName} is defined in JavaScript, ` + `but is not registered properly with ` + `tf.serialization.registerClass().`);
    }
    if (fromConfig != null) {
      const customObjectsCombined = {};
      for (const key of Object.keys(_GLOBAL_CUSTOM_OBJECTS)) {
        customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];
      }
      for (const key of Object.keys(customObjects)) {
        customObjectsCombined[key] = customObjects[key];
      }
      const nestedConfig = config["config"];
      nestedConfig["customObjects"] = customObjectsCombined;
      const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
      for (const key of Object.keys(customObjects)) {
        _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
      }
      convertNDArrayScalarsInConfig(config["config"]);
      const returnObj = fromConfig(cls, config["config"], customObjects, fastWeightInit);
      _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
      return returnObj;
    } else {
      const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);
      for (const key of Object.keys(customObjects)) {
        _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];
      }
      const returnObj = new cls(config["config"]);
      _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);
      return returnObj;
    }
  }
}
function numberCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function reverseNumberCompare(a, b) {
  return -1 * numberCompare(a, b);
}
function unique4(xs) {
  if (xs == null) {
    return xs;
  }
  const out = [];
  for (const x of xs) {
    if (out.indexOf(x) === -1) {
      out.push(x);
    }
  }
  return out;
}
function isObjectEmpty(obj) {
  if (obj == null) {
    throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function checkStringTypeUnionValue(values, label, value) {
  if (value == null) {
    return;
  }
  if (values.indexOf(value) < 0) {
    throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values} or null/undefined.`);
  }
}
function checkArrayTypeAndLength(x, expectedType, minLength = 0, maxLength = Infinity) {
  assert2(minLength >= 0);
  assert2(maxLength >= minLength);
  return Array.isArray(x) && x.length >= minLength && x.length <= maxLength && x.every((e) => typeof e === expectedType);
}
function assertPositiveInteger(value, name) {
  if (Array.isArray(value)) {
    exports_util.assert(value.length > 0, () => `${name} is unexpectedly an empty array.`);
    value.forEach((v, i) => assertPositiveInteger(v, `element ${i + 1} of ${name}`));
  } else {
    exports_util.assert(Number.isInteger(value) && value > 0, () => `Expected ${name} to be a positive integer, but got ` + `${formatAsFriendlyString(value)}.`);
  }
}
function formatAsFriendlyString(value) {
  if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "[" + value.map((v) => formatAsFriendlyString(v)).join(",") + "]";
  } else if (typeof value === "string") {
    return `"${value}"`;
  } else {
    return `${value}`;
  }
}
function debounce(f, waitMs, nowFunc) {
  let lastTime = nowFunc != null ? nowFunc() : exports_util.now();
  let lastResult;
  const f2 = (...args) => {
    const now2 = nowFunc != null ? nowFunc() : exports_util.now();
    if (now2 - lastTime < waitMs) {
      return lastResult;
    }
    lastTime = now2;
    lastResult = f(...args);
    return lastResult;
  };
  return f2;
}
function mapActivationToFusedKernel(activationName) {
  if (activationName === "relu") {
    return "relu";
  }
  if (activationName === "linear") {
    return "linear";
  }
  if (activationName === "elu") {
    return "elu";
  }
  return null;
}
var _GLOBAL_CUSTOM_OBJECTS;
var init_generic_utils = __esm(() => {
  init_dist();
  init_errors();
  _GLOBAL_CUSTOM_OBJECTS = {};
});

// node_modules/@tensorflow/tfjs-layers/dist/backend/state.js
function getNextUniqueTensorId() {
  return _nextUniqueTensorId++;
}
function getUid(prefix = "") {
  if (!(prefix in _uidPrefixes)) {
    _uidPrefixes[prefix] = 0;
  }
  _uidPrefixes[prefix] += 1;
  return prefix + _uidPrefixes[prefix].toString();
}
var _nextUniqueTensorId = 0, _uidPrefixes;
var init_state = __esm(() => {
  _uidPrefixes = {};
});

// node_modules/@tensorflow/tfjs-layers/dist/keras_format/common.js
var VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES, VALID_BIDIRECTIONAL_MERGE_MODES;
var init_common = __esm(() => {
  VALID_DATA_FORMAT_VALUES = ["channelsFirst", "channelsLast"];
  VALID_INTERPOLATION_FORMAT_VALUES = ["nearest", "bilinear"];
  VALID_PADDING_MODE_VALUES = ["valid", "same", "causal"];
  VALID_POOL_MODE_VALUES = ["max", "avg"];
  VALID_BIDIRECTIONAL_MERGE_MODES = ["sum", "mul", "concat", "ave"];
});

// node_modules/@tensorflow/tfjs-layers/dist/common.js
function checkDataFormat(value) {
  checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, "DataFormat", value);
}
function checkInterpolationFormat(value) {
  checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, "InterpolationFormat", value);
}
function checkPaddingMode(value) {
  checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, "PaddingMode", value);
}
function checkPoolMode(value) {
  checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, "PoolMode", value);
}
function nameScope(name, fn) {
  _nameScopeStack.push(name);
  try {
    const val = fn();
    _nameScopeStack.pop();
    return val;
  } catch (e) {
    _nameScopeStack.pop();
    throw e;
  }
}
function currentNameScopePrefix() {
  if (_nameScopeStack.length === 0) {
    return "";
  } else {
    return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;
  }
}
function getScopedTensorName(tensorName) {
  if (!isValidTensorName(tensorName)) {
    throw new Error("Not a valid tensor name: \'" + tensorName + "\'");
  }
  return currentNameScopePrefix() + tensorName;
}
function getUniqueTensorName(scopedName) {
  if (!isValidTensorName(scopedName)) {
    throw new Error("Not a valid tensor name: \'" + scopedName + "\'");
  }
  if (!nameMap.has(scopedName)) {
    nameMap.set(scopedName, 0);
  }
  const index = nameMap.get(scopedName);
  nameMap.set(scopedName, nameMap.get(scopedName) + 1);
  if (index > 0) {
    const result = `${scopedName}_${index}`;
    nameMap.set(result, 1);
    return result;
  } else {
    return scopedName;
  }
}
function isValidTensorName(name) {
  return !!name.match(tensorNameRegex);
}
var nameMap, _nameScopeStack, _nameScopeDivider = "/", tensorNameRegex;
var init_common2 = __esm(() => {
  init_common();
  init_generic_utils();
  nameMap = new Map;
  _nameScopeStack = [];
  tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);
});

// node_modules/@tensorflow/tfjs-layers/dist/utils/math_utils.js
function isInteger(x) {
  return x === parseInt(x.toString(), 10);
}
function arrayProd(array, begin, end) {
  if (begin == null) {
    begin = 0;
  }
  if (end == null) {
    end = array.length;
  }
  let prod4 = 1;
  for (let i = begin;i < end; ++i) {
    prod4 *= array[i];
  }
  return prod4;
}
function min5(array) {
  if (array.length === 0) {
    return Number.NaN;
  }
  let min6 = Number.POSITIVE_INFINITY;
  for (let i = 0;i < array.length; i++) {
    const value = array[i];
    if (value < min6) {
      min6 = value;
    }
  }
  return min6;
}
function max7(array) {
  if (array.length === 0) {
    return Number.NaN;
  }
  let max8 = Number.NEGATIVE_INFINITY;
  for (let i = 0;i < array.length; i++) {
    const value = array[i];
    if (value > max8) {
      max8 = value;
    }
  }
  return max8;
}
function range4(begin, end) {
  if (end < begin) {
    throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);
  }
  const out = [];
  for (let i = begin;i < end; ++i) {
    out.push(i);
  }
  return out;
}
var init_math_utils = __esm(() => {
  init_errors();
});

// node_modules/@tensorflow/tfjs-layers/dist/backend/common.js
function epsilon() {
  if (_epsilon == null) {
    _epsilon = backend2().epsilon();
  }
  return _epsilon;
}
function imageDataFormat() {
  return "channelsLast";
}
var _epsilon;
var init_common3 = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js
function cast45(x, dtype) {
  return cast(x, dtype);
}
function expandDims2(x, axis = -1) {
  const outShape = x.shape.slice();
  if (axis < 0) {
    axis = outShape.length + axis + 1;
  }
  outShape.splice(axis, 0, 1);
  return reshape(x, outShape);
}
function repeat(x, n) {
  return tidy(() => {
    if (x.shape.length !== 2) {
      throw new ValueError(`repeat() expects a rank-2 tensor, but received a ` + `rank-${x.shape.length} tensor.`);
    }
    const y = expandDims2(x, 1);
    return tile7(y, [1, n, 1]);
  });
}
function flatten3(x) {
  const newShape = [arrayProd(x.shape)];
  return reshape(x, newShape);
}
function batchFlatten(x) {
  if (x.rank <= 1) {
    throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${x.rank}.`);
  }
  const newShape = [x.shape[0], arrayProd(x.shape, 1)];
  return reshape(x, newShape);
}
function sliceAlongFirstAxis(array, start, size) {
  return tidy(() => {
    switch (array.rank) {
      case 1:
        return slice1d(array, start, size);
      case 2:
        return slice2d(array, [start, 0], [size, array.shape[1]]);
      case 3:
        return slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);
      case 4:
        return slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);
      case 5:
        return slice(array, [start, 0, 0, 0, 0], [
          size,
          array.shape[1],
          array.shape[2],
          array.shape[3],
          array.shape[4]
        ]);
      case 6:
        return slice(array, [start, 0, 0, 0, 0, 0], [
          size,
          array.shape[1],
          array.shape[2],
          array.shape[3],
          array.shape[4],
          array.shape[5]
        ]);
      default:
        throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ` + `${array.rank}`);
    }
  });
}
function sliceAlongLastAxis(array, start, size) {
  return tidy(() => {
    switch (array.rank) {
      case 1:
        return slice1d(array, start, size);
      case 2:
        return slice2d(array, [0, start], [array.shape[0], size]);
      case 3:
        return slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);
      case 4:
        return slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);
      default:
        throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ` + `${array.rank}`);
    }
  });
}
function sliceAlongAxis(array, start, size, axis) {
  return tidy(() => {
    switch (array.rank) {
      case 1:
        return slice1d(array, start, size);
      case 2:
        switch (axis) {
          case 1:
            return sliceAlongFirstAxis(array, start, size);
          case 2:
            return sliceAlongLastAxis(array, start, size);
          default:
            throw new ValueError(`The axis is not within the rank of the tensor ` + `${axis}`);
        }
      case 3:
        switch (axis) {
          case 1:
            return sliceAlongFirstAxis(array, start, size);
          case 2:
            return slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);
          case 3:
            return sliceAlongLastAxis(array, start, size);
          default:
            throw new ValueError(`The axis is not within the rank of the tensor ` + `${axis}`);
        }
      case 4:
        switch (axis) {
          case 1:
            return sliceAlongFirstAxis(array, start, size);
          case 2:
            return slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);
          case 3:
            return slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);
          case 4:
            return sliceAlongLastAxis(array, start, size);
          default:
            throw new ValueError(`The axis is not within the rank of the tensor ` + `${axis}`);
        }
      default:
        throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ` + `${array.rank}`);
    }
  });
}
function concatenate(tensors, axis = -1) {
  let rank;
  if (axis < 0) {
    rank = tensors[0].rank;
    if (rank !== 0) {
      axis = rank;
    } else {
      axis = 0;
    }
  }
  if (axis === tensors[0].rank) {
    axis = -1;
  }
  return concat(tensors, axis);
}
function concatAlongFirstAxis(a, b) {
  switch (a.rank) {
    case 1:
      return concat1d([a, b]);
    case 2:
      return concat2d([a, b], 0);
    case 3:
      return concat3d([a, b], 0);
    case 4:
      return concat4d([a, b], 0);
    default:
      throw new ValueError(`concatAlongFirstAxis() received an unsupported ` + `tensor rank: ${a.rank}`);
  }
}
function tile7(x, n) {
  if (!Array.isArray(n)) {
    n = [n];
  }
  if (x.rank !== n.length) {
    throw new ValueError(`The length of input n (${n.length}) does not match ` + `the number of dimensions in input x (${x.rank})`);
  }
  return tile(x, n);
}
function randomNormal2(shape, mean6 = 0, stddev = 1, dtype, seed) {
  return randomNormal(shape, mean6, stddev, dtype, seed);
}
function dot4(a, b, activation, bias) {
  if (a.rank < 2 || b.rank < 2) {
    throw new NotImplementedError(`dot requires both inputs to be rank >= 2` + ` but got x shape = ${a.shape} and y shape = ${b.shape}`);
  }
  if (b.rank >= 3) {
    const xLastDim = a.shape.slice(-1)[0];
    const ySecondLastDim = b.shape.slice(-2)[0];
    if (xLastDim !== ySecondLastDim) {
      throw new NotImplementedError(`If rank y >= 3, then the second last dim` + ` of y must equal the last dim of x but got x shape = ${a.shape} and ` + ` y shape = ${b.shape}`);
    }
  }
  if (a.rank === 2 && b.rank === 2) {
    const transposeA = false;
    const transposeB = false;
    return exports_fused_ops.matMul({
      a,
      b,
      transposeA,
      transposeB,
      bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,
      activation
    });
  } else {
    const aFirstDims = a.shape.slice();
    const aLastDim = aFirstDims.pop();
    a = reshape(a, [-1, aLastDim]);
    const bShape = b.shape.slice();
    const bLastDim = bShape.pop();
    const ySecondLastDim = bShape.pop();
    const yOtherDims = [...bShape, bLastDim];
    const perm = Array.from({ length: b.rank }, (_, i) => {
      if (i === 0) {
        return b.rank - 2;
      } else if (i <= b.rank - 2) {
        return i - 1;
      }
      return i;
    });
    b = reshape(transpose(b, perm), [ySecondLastDim, -1]);
    const outputShape = [...aFirstDims, ...yOtherDims];
    const transposeA = false;
    const transposeB = false;
    return reshape(exports_fused_ops.matMul({
      a,
      b,
      transposeA,
      transposeB,
      bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,
      activation
    }), outputShape);
  }
}
function gather6(reference, indices, axis) {
  return tidy(() => {
    if (Array.isArray(indices)) {
      indices = tensor1d(indices, "int32");
    } else {
      indices = cast(indices, "int32");
    }
    return gather(reference, indices, axis);
  });
}
function square23(x) {
  return mul(x, x);
}
function reshapeBias(xRank, bias, dataFormat) {
  const biasShape = bias.shape;
  if (bias.rank !== 1 && bias.rank !== xRank) {
    throw new ValueError(`Unexpected bias dimensions: ${bias.rank}` + `; expected it to be 1 or ${xRank}`);
  }
  if (xRank === 5) {
    if (dataFormat === "channelsFirst") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, biasShape[0], 1, 1, 1]);
      } else {
        return reshape(bias, [1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);
      }
    } else if (dataFormat === "channelsLast") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, 1, 1, 1, biasShape[0]]);
      } else {
        return reshape(bias, [1].concat(biasShape));
      }
    }
  } else if (xRank === 4) {
    if (dataFormat === "channelsFirst") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, biasShape[0], 1, 1]);
      } else {
        return reshape(bias, [1, biasShape[2], biasShape[0], biasShape[1]]);
      }
    } else if (dataFormat === "channelsLast") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, 1, 1, biasShape[0]]);
      } else {
        return reshape(bias, [1].concat(biasShape));
      }
    }
  } else if (xRank === 3) {
    if (dataFormat === "channelsFirst") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, biasShape[0], 1]);
      } else {
        return reshape(bias, [1, biasShape[1], biasShape[0]]);
      }
    } else if (dataFormat === "channelsLast") {
      if (biasShape.length === 1) {
        return reshape(bias, [1, 1, biasShape[0]]);
      } else {
        return reshape(bias, [1].concat(biasShape));
      }
    }
  } else if (xRank < 3) {
    return bias;
  }
  throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`);
}
function biasAdd(x, bias, dataFormat) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    return add2(x, reshapeBias(x.rank, bias, dataFormat));
  });
}
function elu5(x, alpha = 1) {
  if (alpha !== 1) {
    throw new NotImplementedError(`Support for alpha values other than 1 (${alpha}) is not implemented ` + `yet.`);
  }
  return elu(x);
}
function softsign(x) {
  return tidy(() => div(x, add2(abs(x), 1)));
}
function dropout3(x, level, noiseShape, seed) {
  return tidy(() => dropout(x, level, noiseShape, seed));
}
function hardSigmoid(x) {
  return tidy(() => {
    const y = add2(0.5, mul(0.2, x));
    return clipByValue(y, 0, 1);
  });
}
function inTrainPhase(x, alt, training = false) {
  return training ? x() : alt();
}
var init_tfjs_backend = __esm(() => {
  init_dist();
  init_dist();
  init_common2();
  init_errors();
  init_math_utils();
  init_common3();
});

// node_modules/@tensorflow/tfjs-layers/dist/keras_format/initializer_config.js
var VALID_FAN_MODE_VALUES, VALID_DISTRIBUTION_VALUES;
var init_initializer_config = __esm(() => {
  VALID_FAN_MODE_VALUES = ["fanIn", "fanOut", "fanAvg"];
  VALID_DISTRIBUTION_VALUES = ["normal", "uniform", "truncatedNormal"];
});

// node_modules/@tensorflow/tfjs-layers/dist/initializers.js
function checkFanMode(value) {
  checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, "FanMode", value);
}
function checkDistribution(value) {
  checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, "Distribution", value);
}
function computeFans(shape, dataFormat = "channelsLast") {
  let fanIn;
  let fanOut;
  checkDataFormat(dataFormat);
  if (shape.length === 2) {
    fanIn = shape[0];
    fanOut = shape[1];
  } else if ([3, 4, 5].indexOf(shape.length) !== -1) {
    if (dataFormat === "channelsFirst") {
      const receptiveFieldSize = arrayProd(shape, 2);
      fanIn = shape[1] * receptiveFieldSize;
      fanOut = shape[0] * receptiveFieldSize;
    } else if (dataFormat === "channelsLast") {
      const receptiveFieldSize = arrayProd(shape, 0, shape.length - 2);
      fanIn = shape[shape.length - 2] * receptiveFieldSize;
      fanOut = shape[shape.length - 1] * receptiveFieldSize;
    }
  } else {
    const shapeProd = arrayProd(shape);
    fanIn = Math.sqrt(shapeProd);
    fanOut = Math.sqrt(shapeProd);
  }
  return [fanIn, fanOut];
}
function deserializeInitializer(config, customObjects = {}) {
  return deserializeKerasObject(config, exports_serialization.SerializationMap.getMap().classNameMap, customObjects, "initializer");
}
function serializeInitializer(initializer) {
  return serializeKerasObject(initializer);
}
function getInitializer(identifier) {
  if (typeof identifier === "string") {
    const className = identifier in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
    if (className === "GlorotNormal") {
      return new GlorotNormal;
    } else if (className === "GlorotUniform") {
      return new GlorotUniform;
    } else if (className === "HeNormal") {
      return new HeNormal;
    } else if (className === "HeUniform") {
      return new HeUniform;
    } else if (className === "LeCunNormal") {
      return new LeCunNormal;
    } else if (className === "LeCunUniform") {
      return new LeCunUniform;
    } else {
      const config = {};
      config["className"] = className;
      config["config"] = {};
      return deserializeInitializer(config);
    }
  } else if (identifier instanceof Initializer) {
    return identifier;
  } else {
    return deserializeInitializer(identifier);
  }
}
var Initializer, Zeros, Ones, Constant, RandomUniform, RandomNormal, TruncatedNormal, Identity2, VarianceScaling, GlorotUniform, GlorotNormal, HeNormal, HeUniform, LeCunNormal, LeCunUniform, Orthogonal, INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP;
var init_initializers = __esm(() => {
  init_dist();
  init_tfjs_backend();
  init_common2();
  init_errors();
  init_initializer_config();
  init_generic_utils();
  init_math_utils();
  Initializer = class Initializer extends exports_serialization.Serializable {
    fromConfigUsesCustomObjects() {
      return false;
    }
    getConfig() {
      return {};
    }
  };
  Zeros = class Zeros extends Initializer {
    apply(shape, dtype) {
      return zeros(shape, dtype);
    }
  };
  Zeros.className = "Zeros";
  exports_serialization.registerClass(Zeros);
  Ones = class Ones extends Initializer {
    apply(shape, dtype) {
      return ones2(shape, dtype);
    }
  };
  Ones.className = "Ones";
  exports_serialization.registerClass(Ones);
  Constant = class Constant extends Initializer {
    constructor(args) {
      super();
      if (typeof args !== "object") {
        throw new ValueError(`Expected argument of type ConstantConfig but got ${args}`);
      }
      if (args.value === undefined) {
        throw new ValueError(`config must have value set but got ${args}`);
      }
      this.value = args.value;
    }
    apply(shape, dtype) {
      return tidy(() => mul(scalar(this.value), ones2(shape, dtype)));
    }
    getConfig() {
      return {
        value: this.value
      };
    }
  };
  Constant.className = "Constant";
  exports_serialization.registerClass(Constant);
  RandomUniform = class RandomUniform extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_MINVAL = -0.05;
      this.DEFAULT_MAXVAL = 0.05;
      this.minval = args.minval || this.DEFAULT_MINVAL;
      this.maxval = args.maxval || this.DEFAULT_MAXVAL;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      return randomUniform(shape, this.minval, this.maxval, dtype, this.seed);
    }
    getConfig() {
      return { minval: this.minval, maxval: this.maxval, seed: this.seed };
    }
  };
  RandomUniform.className = "RandomUniform";
  exports_serialization.registerClass(RandomUniform);
  RandomNormal = class RandomNormal extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_MEAN = 0;
      this.DEFAULT_STDDEV = 0.05;
      this.mean = args.mean || this.DEFAULT_MEAN;
      this.stddev = args.stddev || this.DEFAULT_STDDEV;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);
      }
      return randomNormal2(shape, this.mean, this.stddev, dtype, this.seed);
    }
    getConfig() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }
  };
  RandomNormal.className = "RandomNormal";
  exports_serialization.registerClass(RandomNormal);
  TruncatedNormal = class TruncatedNormal extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_MEAN = 0;
      this.DEFAULT_STDDEV = 0.05;
      this.mean = args.mean || this.DEFAULT_MEAN;
      this.stddev = args.stddev || this.DEFAULT_STDDEV;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      dtype = dtype || "float32";
      if (dtype !== "float32" && dtype !== "int32") {
        throw new NotImplementedError(`truncatedNormal does not support dType ${dtype}.`);
      }
      return truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);
    }
    getConfig() {
      return { mean: this.mean, stddev: this.stddev, seed: this.seed };
    }
  };
  TruncatedNormal.className = "TruncatedNormal";
  exports_serialization.registerClass(TruncatedNormal);
  Identity2 = class Identity2 extends Initializer {
    constructor(args) {
      super();
      this.gain = args.gain != null ? args.gain : 1;
    }
    apply(shape, dtype) {
      return tidy(() => {
        if (shape.length !== 2 || shape[0] !== shape[1]) {
          throw new ValueError("Identity matrix initializer can only be used for" + " 2D square matrices.");
        } else {
          return mul(this.gain, eye(shape[0]));
        }
      });
    }
    getConfig() {
      return { gain: this.gain };
    }
  };
  Identity2.className = "Identity";
  exports_serialization.registerClass(Identity2);
  VarianceScaling = class VarianceScaling extends Initializer {
    constructor(args) {
      super();
      if (args.scale < 0) {
        throw new ValueError(`scale must be a positive float. Got: ${args.scale}`);
      }
      this.scale = args.scale == null ? 1 : args.scale;
      this.mode = args.mode == null ? "fanIn" : args.mode;
      checkFanMode(this.mode);
      this.distribution = args.distribution == null ? "normal" : args.distribution;
      checkDistribution(this.distribution);
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      const fans = computeFans(shape);
      const fanIn = fans[0];
      const fanOut = fans[1];
      let scale = this.scale;
      if (this.mode === "fanIn") {
        scale /= Math.max(1, fanIn);
      } else if (this.mode === "fanOut") {
        scale /= Math.max(1, fanOut);
      } else {
        scale /= Math.max(1, (fanIn + fanOut) / 2);
      }
      if (this.distribution === "normal") {
        const stddev = Math.sqrt(scale);
        dtype = dtype || "float32";
        if (dtype !== "float32" && dtype !== "int32") {
          throw new NotImplementedError(`${this.getClassName()} does not support dType ${dtype}.`);
        }
        return truncatedNormal(shape, 0, stddev, dtype, this.seed);
      } else {
        const limit = Math.sqrt(3 * scale);
        return randomUniform(shape, -limit, limit, dtype, this.seed);
      }
    }
    getConfig() {
      return {
        scale: this.scale,
        mode: this.mode,
        distribution: this.distribution,
        seed: this.seed
      };
    }
  };
  VarianceScaling.className = "VarianceScaling";
  exports_serialization.registerClass(VarianceScaling);
  GlorotUniform = class GlorotUniform extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "uniform",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  GlorotUniform.className = "GlorotUniform";
  exports_serialization.registerClass(GlorotUniform);
  GlorotNormal = class GlorotNormal extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanAvg",
        distribution: "normal",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  GlorotNormal.className = "GlorotNormal";
  exports_serialization.registerClass(GlorotNormal);
  HeNormal = class HeNormal extends VarianceScaling {
    constructor(args) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "normal",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  HeNormal.className = "HeNormal";
  exports_serialization.registerClass(HeNormal);
  HeUniform = class HeUniform extends VarianceScaling {
    constructor(args) {
      super({
        scale: 2,
        mode: "fanIn",
        distribution: "uniform",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  HeUniform.className = "HeUniform";
  exports_serialization.registerClass(HeUniform);
  LeCunNormal = class LeCunNormal extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "normal",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  LeCunNormal.className = "LeCunNormal";
  exports_serialization.registerClass(LeCunNormal);
  LeCunUniform = class LeCunUniform extends VarianceScaling {
    constructor(args) {
      super({
        scale: 1,
        mode: "fanIn",
        distribution: "uniform",
        seed: args == null ? null : args.seed
      });
    }
    getClassName() {
      return VarianceScaling.className;
    }
  };
  LeCunUniform.className = "LeCunUniform";
  exports_serialization.registerClass(LeCunUniform);
  Orthogonal = class Orthogonal extends Initializer {
    constructor(args) {
      super();
      this.DEFAULT_GAIN = 1;
      this.ELEMENTS_WARN_SLOW = 2000;
      this.gain = args.gain == null ? this.DEFAULT_GAIN : args.gain;
      this.seed = args.seed;
    }
    apply(shape, dtype) {
      return tidy(() => {
        if (shape.length < 2) {
          throw new NotImplementedError("Shape must be at least 2D.");
        }
        if (dtype !== "int32" && dtype !== "float32" && dtype !== undefined) {
          throw new TypeError(`Unsupported data type ${dtype}.`);
        }
        dtype = dtype;
        const numRows = exports_util.sizeFromShape(shape.slice(0, -1));
        const numCols = shape[shape.length - 1];
        const numElements = numRows * numCols;
        if (numElements > this.ELEMENTS_WARN_SLOW) {
          console.warn(`Orthogonal initializer is being called on a matrix with more ` + `than ${this.ELEMENTS_WARN_SLOW} (${numElements}) elements: ` + `Slowness may result.`);
        }
        const flatShape = [Math.max(numCols, numRows), Math.min(numCols, numRows)];
        const randNormalMat = randomNormal2(flatShape, 0, 1, dtype, this.seed);
        const qr3 = linalg.qr(randNormalMat, false);
        let qMat = qr3[0];
        const rMat = qr3[1];
        const diag2 = rMat.flatten().stridedSlice([0], [Math.min(numCols, numRows) * Math.min(numCols, numRows)], [Math.min(numCols, numRows) + 1]);
        qMat = mul(qMat, diag2.sign());
        if (numRows < numCols) {
          qMat = qMat.transpose();
        }
        return mul(scalar(this.gain), qMat.reshape(shape));
      });
    }
    getConfig() {
      return {
        gain: this.gain,
        seed: this.seed
      };
    }
  };
  Orthogonal.className = "Orthogonal";
  exports_serialization.registerClass(Orthogonal);
  INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    constant: "Constant",
    glorotNormal: "GlorotNormal",
    glorotUniform: "GlorotUniform",
    heNormal: "HeNormal",
    heUniform: "HeUniform",
    identity: "Identity",
    leCunNormal: "LeCunNormal",
    leCunUniform: "LeCunUniform",
    ones: "Ones",
    orthogonal: "Orthogonal",
    randomNormal: "RandomNormal",
    randomUniform: "RandomUniform",
    truncatedNormal: "TruncatedNormal",
    varianceScaling: "VarianceScaling",
    zeros: "Zeros"
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js
function isArrayOfShapes(x) {
  return Array.isArray(x) && Array.isArray(x[0]);
}
function normalizeShapeList(x) {
  if (x.length === 0) {
    return [];
  }
  if (!Array.isArray(x[0])) {
    return [x];
  }
  return x;
}
function getExactlyOneTensor(xs) {
  let x;
  if (Array.isArray(xs)) {
    if (xs.length !== 1) {
      throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);
    }
    x = xs[0];
  } else {
    x = xs;
  }
  return x;
}
function getExactlyOneShape(shapes) {
  if (Array.isArray(shapes) && Array.isArray(shapes[0])) {
    if (shapes.length === 1) {
      shapes = shapes;
      return shapes[0];
    } else {
      throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`);
    }
  } else {
    return shapes;
  }
}
var init_types_utils = __esm(() => {
  init_errors();
});

// node_modules/@tensorflow/tfjs-layers/dist/utils/variable_utils.js
function countParamsInWeights(weights) {
  let count2 = 0;
  for (const weight of weights) {
    if (weight.shape.length === 0) {
      count2 += 1;
    } else {
      count2 += weight.shape.reduce((a, b) => a * b);
    }
  }
  return count2;
}

// node_modules/@tensorflow/tfjs-layers/dist/variables.js
function checkShapesMatch(x, y) {
  if (x.shape.toString() !== y.shape.toString()) {
    throw new Error("Shape mismatch: " + JSON.stringify(x.shape) + " vs. " + JSON.stringify(y.shape));
  }
}
function batchGetValue(xs) {
  return xs.map((x) => x.read());
}
function batchSetValue(variablesAndValues) {
  variablesAndValues.forEach((variableAndValue) => {
    const variable2 = variableAndValue[0];
    variable2.write(variableAndValue[1]);
  });
}

class LayerVariable {
  constructor(val, dtype = "float32", name = DEFAULT_VARIABLE_NAME_PREFIX, trainable = true, constraint = null) {
    this.dtype = dtype == null ? "float32" : dtype;
    this.shape = val.shape;
    this.id = getNextUniqueTensorId();
    name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;
    this.originalName = getScopedTensorName(name);
    this.name = getUniqueTensorName(this.originalName);
    this.trainable_ = trainable;
    this.constraint = constraint;
    this.val = variable(val, this.trainable_, this.name, this.dtype);
  }
  read() {
    this.assertNotDisposed();
    return this.val;
  }
  write(newVal) {
    this.assertNotDisposed();
    checkShapesMatch(this.val, newVal);
    if (this.val.id !== newVal.id) {
      this.val.assign(newVal);
      if (this.constraint != null) {
        this.val.assign(this.constraint.apply(this.val));
      }
    }
    return this;
  }
  dispose() {
    this.assertNotDisposed();
    this.val.dispose();
  }
  assertNotDisposed() {
    if (this.val.isDisposed) {
      throw new Error(`LayersVariable ${this.name} is already disposed.`);
    }
  }
  get trainable() {
    return this.trainable_;
  }
  set trainable(trainable) {
    this.trainable_ = trainable;
    this.val.trainable = trainable;
  }
}
var DEFAULT_VARIABLE_NAME_PREFIX = "Variable";
var init_variables = __esm(() => {
  init_dist();
  init_dist();
  init_state();
  init_common2();
  init_errors();
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js
function collectInputShape(inputTensors) {
  inputTensors = toList(inputTensors);
  const shapes = [];
  for (const x of inputTensors) {
    shapes.push(x.shape);
  }
  return singletonOrArray(shapes);
}
function guessOutputDType(inputTensors) {
  return "float32";
}
function getSourceInputs(tensor153, layer, nodeIndex) {
  if (layer == null || nodeIndex != null && nodeIndex > 0) {
    layer = tensor153.sourceLayer;
    nodeIndex = tensor153.nodeIndex;
  }
  if (layer.inboundNodes.length === 0) {
    return [tensor153];
  } else {
    const node = layer.inboundNodes[nodeIndex];
    if (node.inboundLayers.length === 0) {
      return node.inputTensors;
    } else {
      const sourceTensors = [];
      for (let i = 0;i < node.inboundLayers.length; i++) {
        const x = node.inputTensors[i];
        const layer2 = node.inboundLayers[i];
        const nodeIndex2 = node.nodeIndices[i];
        const previousSources = getSourceInputs(x, layer2, nodeIndex2);
        for (const x2 of previousSources) {
          if (sourceTensors.indexOf(x2) === -1) {
            sourceTensors.push(x2);
          }
        }
      }
      return sourceTensors;
    }
  }
}
function checkAllSymbolic(tensors) {
  let allAreSymbolic = true;
  for (const tensor153 of toList(tensors)) {
    if (!(tensor153 instanceof SymbolicTensor)) {
      allAreSymbolic = false;
      break;
    }
  }
  return allAreSymbolic;
}
function checkNoneSymbolic(tensors) {
  let noneAreSymbolic = true;
  for (const tensor153 of toList(tensors)) {
    if (tensor153 instanceof SymbolicTensor) {
      noneAreSymbolic = false;
      break;
    }
  }
  return noneAreSymbolic;
}

class InputSpec {
  constructor(args) {
    this.dtype = args.dtype;
    this.shape = args.shape;
    if (args.shape != null) {
      this.ndim = args.shape.length;
    } else {
      this.ndim = args.ndim;
    }
    this.maxNDim = args.maxNDim;
    this.minNDim = args.minNDim;
    this.axes = args.axes || {};
  }
}

class SymbolicTensor {
  constructor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {
    this.dtype = dtype;
    this.shape = shape;
    this.sourceLayer = sourceLayer;
    this.inputs = inputs;
    this.callArgs = callArgs;
    this.outputTensorIndex = outputTensorIndex;
    this.id = getNextUniqueTensorId();
    if (name != null) {
      this.originalName = getScopedTensorName(name);
      this.name = getUniqueTensorName(this.originalName);
    }
    this.rank = shape.length;
  }
}

class Node {
  constructor(args, callArgs) {
    this.callArgs = callArgs;
    this.id = _nextNodeID++;
    this.outboundLayer = args.outboundLayer;
    this.inboundLayers = args.inboundLayers;
    this.nodeIndices = args.nodeIndices;
    this.tensorIndices = args.tensorIndices;
    this.inputTensors = args.inputTensors;
    this.outputTensors = args.outputTensors;
    this.inputMasks = args.inputMasks;
    this.outputMasks = args.outputMasks;
    this.inputShapes = args.inputShapes;
    this.outputShapes = args.outputShapes;
    for (const layer of args.inboundLayers) {
      if (layer != null) {
        layer.outboundNodes.push(this);
      }
    }
    args.outboundLayer.inboundNodes.push(this);
  }
  getConfig() {
    const inboundNames = [];
    for (const layer of this.inboundLayers) {
      if (layer != null) {
        inboundNames.push(layer.name);
      } else {
        inboundNames.push(null);
      }
    }
    return {
      outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
      inboundLayers: inboundNames,
      nodeIndices: this.nodeIndices,
      tensorIndices: this.tensorIndices
    };
  }
}
var _nextNodeID = 0, _nextLayerID = 0, Layer;
var init_topology = __esm(() => {
  init_dist();
  init_state();
  init_common2();
  init_errors();
  init_initializers();
  init_generic_utils();
  init_types_utils();
  init_variables();
  Layer = class Layer extends exports_serialization.Serializable {
    constructor(args = {}) {
      super();
      this._callHook = null;
      this._addedWeightNames = [];
      this._stateful = false;
      this.id = _nextLayerID++;
      this.activityRegularizer = null;
      this.inputSpec = null;
      this.supportsMasking = false;
      this._trainableWeights = [];
      this._nonTrainableWeights = [];
      this._losses = [];
      this._updates = [];
      this._built = false;
      this.inboundNodes = [];
      this.outboundNodes = [];
      let name = args.name;
      if (!name) {
        const prefix = this.getClassName();
        name = toSnakeCase(prefix) + "_" + getUid(prefix);
      }
      this.name = name;
      this.trainable_ = args.trainable == null ? true : args.trainable;
      if (args.inputShape != null || args.batchInputShape != null) {
        let batchInputShape;
        if (args.batchInputShape != null) {
          batchInputShape = args.batchInputShape;
        } else if (args.inputShape != null) {
          let batchSize = null;
          if (args.batchSize != null) {
            batchSize = args.batchSize;
          }
          batchInputShape = [batchSize].concat(args.inputShape);
        }
        this.batchInputShape = batchInputShape;
        let dtype = args.dtype;
        if (dtype == null) {
          dtype = args.inputDType;
        }
        if (dtype == null) {
          dtype = "float32";
        }
        this.dtype = dtype;
      }
      if (args.weights != null) {
        this.initialWeights = args.weights;
      } else {
        this.initialWeights = null;
      }
      this._refCount = null;
      this.fastWeightInitDuringBuild = false;
    }
    static nodeKey(layer, nodeIndex) {
      return layer.name + "_ib-" + nodeIndex.toString();
    }
    getNodeAtIndex(nodeIndex, attrName) {
      if (this.inboundNodes.length === 0) {
        throw new RuntimeError("The layer has never been called " + `and thus has no defined ${attrName}.`);
      }
      if (this.inboundNodes.length <= nodeIndex) {
        throw new ValueError(`Asked to get ${attrName} at node ${nodeIndex}, ` + `but the layer has only ${this.inboundNodes.length} inbound nodes.`);
      }
      return this.inboundNodes[nodeIndex];
    }
    getInputAt(nodeIndex) {
      return singletonOrArray(this.getNodeAtIndex(nodeIndex, "input").inputTensors);
    }
    getOutputAt(nodeIndex) {
      return singletonOrArray(this.getNodeAtIndex(nodeIndex, "output").outputTensors);
    }
    get input() {
      if (this.inboundNodes.length > 1) {
        throw new AttributeError(`Layer ${this.name}` + " has multiple inbound nodes, " + 'hence the notion of "layer input" ' + "is ill-defined. " + "Use `getInputAt(nodeIndex)` instead.");
      } else if (this.inboundNodes.length === 0) {
        throw new AttributeError(`Layer ${this.name}` + " is not connected, no input to return.");
      }
      return singletonOrArray(this.getNodeAtIndex(0, "input").inputTensors);
    }
    get output() {
      if (this.inboundNodes.length === 0) {
        throw new AttributeError(`Layer ${this.name}` + " has no inbound nodes.");
      }
      if (this.inboundNodes.length > 1) {
        throw new AttributeError(`Layer ${this.name}` + " has multiple inbound nodes, " + 'hence the notion of "layer output" ' + "is ill-defined. " + "Use `getOutputAt(nodeIndex)` instead.");
      }
      return singletonOrArray(this.getNodeAtIndex(0, "output").outputTensors);
    }
    get losses() {
      return this._losses;
    }
    calculateLosses() {
      return this.losses.map((lossFn) => lossFn());
    }
    get updates() {
      return this._updates;
    }
    get built() {
      return this._built;
    }
    set built(built) {
      this._built = built;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(trainable) {
      this._trainableWeights.forEach((w) => w.trainable = trainable);
      this.trainable_ = trainable;
    }
    get trainableWeights() {
      if (this.trainable_) {
        return this._trainableWeights.filter((w) => w.trainable);
      } else {
        return [];
      }
    }
    set trainableWeights(weights) {
      this._trainableWeights = weights;
    }
    get nonTrainableWeights() {
      if (this.trainable) {
        return this._trainableWeights.filter((w) => !w.trainable).concat(this._nonTrainableWeights);
      } else {
        return this._trainableWeights.concat(this._nonTrainableWeights);
      }
    }
    set nonTrainableWeights(weights) {
      this._nonTrainableWeights = weights;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    get stateful() {
      return this._stateful;
    }
    resetStates() {
      if (!this.stateful) {
        throw new Error("Cannot call the resetStates() method of a non-stateful Layer " + "object.");
      }
    }
    assertInputCompatibility(inputs) {
      const inputsList = toList(inputs);
      if (this.inputSpec == null || this.inputSpec.length === 0) {
        return;
      }
      const inputSpec = toList(this.inputSpec);
      if (inputsList.length !== inputSpec.length) {
        throw new ValueError(`Layer ${this.name} expects ${inputSpec.length} inputs, ` + `but it received ${inputsList.length} input tensors. ` + `Input received: ${inputs}`);
      }
      for (let inputIndex = 0;inputIndex < inputsList.length; inputIndex++) {
        const x = inputsList[inputIndex];
        const spec = inputSpec[inputIndex];
        if (spec == null) {
          continue;
        }
        const ndim = x.rank;
        if (spec.ndim != null) {
          if (ndim !== spec.ndim) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: ` + `expected ndim=${spec.ndim}, found ndim=${ndim}`);
          }
        }
        if (spec.maxNDim != null) {
          if (ndim > spec.maxNDim) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}` + `: expected max_ndim=${spec.maxNDim}, found ndim=${ndim}`);
          }
        }
        if (spec.minNDim != null) {
          if (ndim < spec.minNDim) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}` + `: expected min_ndim=${spec.minNDim}, found ndim=${ndim}.`);
          }
        }
        if (spec.dtype != null) {
          if (x.dtype !== spec.dtype) {
            throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name} ` + `: expected dtype=${spec.dtype}, found dtype=${x.dtype}.`);
          }
        }
        if (spec.axes) {
          const xShape = x.shape;
          for (const key in spec.axes) {
            const axis = Number(key);
            const value = spec.axes[key];
            const xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];
            if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {
              throw new ValueError(`Input ${inputIndex} is incompatible with layer ` + `${this.name}: expected axis ${axis} of input shape to ` + `have value ${value} but got shape ${xShape}.`);
            }
          }
        }
        if (spec.shape != null) {
          for (let i = 0;i < spec.shape.length; ++i) {
            const specDim = spec.shape[i];
            const dim = x.shape[i];
            if (specDim != null && dim != null) {
              if (specDim !== dim) {
                throw new ValueError(`Input ${inputIndex} is incompatible with layer ` + `${this.name}: expected shape=${spec.shape}, ` + `found shape=${x.shape}.`);
              }
            }
          }
        }
      }
    }
    call(inputs, kwargs) {
      return inputs;
    }
    invokeCallHook(inputs, kwargs) {
      if (this._callHook != null) {
        this._callHook(inputs, kwargs);
      }
    }
    setCallHook(callHook) {
      this._callHook = callHook;
    }
    clearCallHook() {
      this._callHook = null;
    }
    apply(inputs, kwargs) {
      kwargs = kwargs || {};
      this.assertNotDisposed();
      const inputsList = toList(inputs);
      const allAreSymbolic = checkAllSymbolic(inputs);
      const noneAreSymbolic = checkNoneSymbolic(inputs);
      if (allAreSymbolic === noneAreSymbolic) {
        throw new ValueError("Arguments to apply() must be all " + "SymbolicTensors or all Tensors");
      }
      return nameScope(this.name, () => {
        if (!this.built) {
          this.assertInputCompatibility(inputs);
          const inputShapes = [];
          for (const xElem of toList(inputs)) {
            inputShapes.push(xElem.shape);
          }
          this.build(singletonOrArray(inputShapes));
          this.built = true;
          if (this.initialWeights) {
            this.setWeights(this.initialWeights);
          }
          if (this._refCount === null && noneAreSymbolic) {
            this._refCount = 1;
          }
        }
        this.assertInputCompatibility(inputs);
        if (noneAreSymbolic) {
          let output = this.call(inputs, kwargs);
          if (this.supportsMasking) {
            this.setMaskMetadata(inputs, output);
          }
          const outputList = toList(output);
          const outputListCopy = [];
          for (let x of outputList) {
            if (inputsList.indexOf(x) !== -1) {
              x = x.clone();
            }
            outputListCopy.push(x);
          }
          output = singletonOrArray(outputListCopy);
          if (this.activityRegularizer != null) {
            throw new NotImplementedError("Layer invocation in the presence of activity " + "regularizer(s) is not supported yet.");
          }
          return output;
        } else {
          const inputShape = collectInputShape(inputs);
          const outputShape = this.computeOutputShape(inputShape);
          let output;
          const outputDType = guessOutputDType(inputs);
          this.warnOnIncompatibleInputShape(Array.isArray(inputs) ? inputShape[0] : inputShape);
          if (outputShape != null && outputShape.length > 0 && Array.isArray(outputShape[0])) {
            output = outputShape.map((shape, index) => new SymbolicTensor(outputDType, shape, this, toList(inputs), kwargs, this.name, index));
          } else {
            output = new SymbolicTensor(outputDType, outputShape, this, toList(inputs), kwargs, this.name);
          }
          this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);
          this._refCount++;
          if (this.activityRegularizer != null) {
            throw new NotImplementedError("Layer invocation in the presence of activity " + "regularizer(s) is not supported yet.");
          }
          return output;
        }
      });
    }
    warnOnIncompatibleInputShape(inputShape) {
      if (this.batchInputShape == null) {
        return;
      } else if (inputShape.length !== this.batchInputShape.length) {
        console.warn(`The rank of the input tensor provided (shape: ` + `${JSON.stringify(inputShape)}) does not match that of the ` + `batchInputShape (${JSON.stringify(this.batchInputShape)}) ` + `of the layer ${this.name}`);
      } else {
        let dimMismatch = false;
        this.batchInputShape.forEach((dimension, i) => {
          if (dimension != null && inputShape[i] != null && inputShape[i] !== dimension) {
            dimMismatch = true;
          }
        });
        if (dimMismatch) {
          console.warn(`The shape of the input tensor ` + `(${JSON.stringify(inputShape)}) does not ` + `match the expectation of layer ${this.name}: ` + `${JSON.stringify(this.batchInputShape)}`);
        }
      }
    }
    get outputShape() {
      if (this.inboundNodes == null || this.inboundNodes.length === 0) {
        throw new AttributeError(`The layer ${this.name} has never been called and thus has no ` + `defined output shape.`);
      }
      const allOutputShapes = [];
      for (const node of this.inboundNodes) {
        const shapeString = JSON.stringify(node.outputShapes);
        if (allOutputShapes.indexOf(shapeString) === -1) {
          allOutputShapes.push(shapeString);
        }
      }
      if (allOutputShapes.length === 1) {
        const outputShapes = this.inboundNodes[0].outputShapes;
        if (Array.isArray(outputShapes) && Array.isArray(outputShapes[0]) && outputShapes.length === 1) {
          return outputShapes[0];
        } else {
          return outputShapes;
        }
      } else {
        throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different ` + `output shapes. Hence the notion of "output shape" is ill-defined ` + `for the layer.`);
      }
    }
    countParams() {
      if (!this.built) {
        throw new RuntimeError(`You tried to call countParams() on ${this.name}, ` + `but the layer is not built yet. Build it first by calling ` + `build(batchInputShape).`);
      }
      return countParamsInWeights(this.weights);
    }
    build(inputShape) {
      this.built = true;
    }
    getWeights(trainableOnly = false) {
      return batchGetValue(trainableOnly ? this.trainableWeights : this.weights);
    }
    setWeights(weights) {
      tidy(() => {
        const params = this.weights;
        if (params.length !== weights.length) {
          throw new ValueError(`You called setWeights(weights) on layer "${this.name}" ` + `with a weight list of length ${weights.length}, ` + `but the layer was expecting ${params.length} weights. ` + `Provided weights: ${weights}...`);
        }
        if (params.length === 0) {
          return;
        }
        const weightValueTuples = [];
        const paramValues = batchGetValue(params);
        for (let i = 0;i < paramValues.length; ++i) {
          const pv = paramValues[i];
          const p2 = params[i];
          const w = weights[i];
          if (!exports_util.arraysEqual(pv.shape, w.shape)) {
            throw new ValueError(`Layer weight shape ${pv.shape} ` + `not compatible with provided weight shape ${w.shape}`);
          }
          weightValueTuples.push([p2, w]);
        }
        batchSetValue(weightValueTuples);
      });
    }
    addWeight(name, shape, dtype, initializer, regularizer, trainable, constraint, getInitializerFunc) {
      if (this._addedWeightNames.indexOf(name) !== -1) {
        throw new ValueError(`Duplicate weight name ${name} for layer ${this.name}`);
      }
      this._addedWeightNames.push(name);
      if (dtype == null) {
        dtype = "float32";
      }
      if (this.fastWeightInitDuringBuild) {
        initializer = getInitializerFunc != null ? getInitializerFunc() : getInitializer("zeros");
      }
      const initValue = initializer.apply(shape, dtype);
      const weight = new LayerVariable(initValue, dtype, name, trainable, constraint);
      initValue.dispose();
      if (regularizer != null) {
        this.addLoss(() => regularizer.apply(weight.read()));
      }
      if (trainable == null) {
        trainable = true;
      }
      if (trainable) {
        this._trainableWeights.push(weight);
      } else {
        this._nonTrainableWeights.push(weight);
      }
      return weight;
    }
    setFastWeightInitDuringBuild(value) {
      this.fastWeightInitDuringBuild = value;
    }
    addLoss(losses2) {
      if (losses2 == null || Array.isArray(losses2) && losses2.length === 0) {
        return;
      }
      losses2 = toList(losses2);
      if (this._losses !== undefined && this._losses !== null) {
        this.losses.push(...losses2);
      }
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    computeMask(inputs, mask) {
      if (!this.supportsMasking) {
        if (mask != null) {
          if (Array.isArray(mask)) {
            mask.forEach((maskElement) => {
              if (maskElement != null) {
                throw new TypeError(`Layer ${this.name} does not support masking, ` + "but was passed an inputMask.");
              }
            });
          } else {
            throw new TypeError(`Layer ${this.name} does not support masking, ` + "but was passed an inputMask.");
          }
        }
        return null;
      }
      return mask;
    }
    setMaskMetadata(inputs, outputs, previousMask) {
      if (!this.supportsMasking) {
        return;
      }
      const outputMasks = this.computeMask(inputs, previousMask);
      const outputsList = toList(outputs);
      const outputMasksList = toList(outputMasks);
      if (outputsList.length !== outputMasksList.length) {
        throw new Error(`${this.name} outputs ${outputsList.length} tensors ` + `but ${outputsList.length} masks for those tensors`);
      }
      for (let i = 0;i < outputsList.length; i++) {
        outputsList[i].kerasMask = outputMasksList[i];
      }
    }
    addInboundNode(inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs = null) {
      const inputTensorList = toList(inputTensors);
      outputTensors = toList(outputTensors);
      inputMasks = toList(inputMasks);
      outputMasks = toList(outputMasks);
      inputShapes = normalizeShapeList(inputShapes);
      outputShapes = normalizeShapeList(outputShapes);
      const inboundLayers = [];
      const nodeIndices = [];
      const tensorIndices = [];
      for (const x of inputTensorList) {
        inboundLayers.push(x.sourceLayer);
        nodeIndices.push(x.nodeIndex);
        tensorIndices.push(x.tensorIndex);
      }
      new Node({
        outboundLayer: this,
        inboundLayers,
        nodeIndices,
        tensorIndices,
        inputTensors: inputTensorList,
        outputTensors,
        inputMasks,
        outputMasks,
        inputShapes,
        outputShapes
      }, kwargs);
      for (let i = 0;i < outputTensors.length; i++) {
        outputTensors[i].sourceLayer = this;
        outputTensors[i].nodeIndex = this.inboundNodes.length - 1;
        outputTensors[i].tensorIndex = i;
      }
    }
    getConfig() {
      const config = { name: this.name, trainable: this.trainable };
      if (this.batchInputShape != null) {
        config["batchInputShape"] = this.batchInputShape;
      }
      if (this.dtype != null) {
        config["dtype"] = this.dtype;
      }
      return config;
    }
    disposeWeights() {
      this.weights.forEach((weight) => weight.dispose());
      return this.weights.length;
    }
    assertNotDisposed() {
      if (this._refCount === 0) {
        throw new Error(`Layer '${this.name}' is already disposed.`);
      }
    }
    dispose() {
      if (!this.built) {
        throw new Error(`Cannot dispose Layer ${this.name} because it has not been ` + `built yet.`);
      }
      if (this._refCount === null) {
        throw new Error(`Cannot dispose Layer ${this.name} because it has not been used ` + `yet.`);
      }
      this.assertNotDisposed();
      let numDisposedVariables = 0;
      if (--this._refCount === 0) {
        numDisposedVariables = this.disposeWeights();
      }
      return { refCountAfterDispose: this._refCount, numDisposedVariables };
    }
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js
function Input(config) {
  if (config.batchShape == null && config.shape == null) {
    throw new Error("Please provide to Input either a `shape`" + " or a `batchShape` argument. Note that " + "`shape` does not include the batch " + "dimension.");
  }
  if (config.batchShape != null && config.shape != null) {
    throw new ValueError("Please provide either a `shape` or `batchShape` " + "argument to Input, but not both.");
  }
  let batchShape = config.batchShape;
  if (config.shape != null && batchShape == null) {
    batchShape = [null].concat(config.shape);
  }
  let dtype = config.dtype;
  if (dtype == null) {
    dtype = "float32";
  }
  const inputLayer = new InputLayer({
    batchInputShape: batchShape,
    name: config.name,
    dtype,
    sparse: config.sparse
  });
  const outputs = inputLayer.inboundNodes[0].outputTensors;
  return outputs[0];
}
var InputLayer;
var init_input_layer = __esm(() => {
  init_dist();
  init_state();
  init_errors();
  init_topology();
  InputLayer = class InputLayer extends Layer {
    constructor(args) {
      super({
        dtype: args.dtype,
        name: args.name != null ? args.name : getUid("input").toString()
      });
      if (args.batchSize == null) {
        args.batchSize = null;
      }
      if (args.sparse == null) {
        args.sparse = false;
      }
      this.trainable = false;
      this.built = true;
      this.sparse = args.sparse;
      if (args.inputShape != null && args.batchInputShape != null) {
        throw new ValueError("Only provide the inputShape OR " + "batchInputShape argument to inputLayer, not both at the same time.");
      }
      let batchInputShape = args.batchInputShape;
      if (batchInputShape == null) {
        if (args.inputShape == null) {
          throw new ValueError("An InputLayer should be passed either a " + "`batchInputShape` or an `inputShape`.");
        } else {
          batchInputShape = [args.batchSize].concat(args.inputShape);
        }
      } else {
        if (args.batchSize != null) {
          throw new ValueError("Cannot specify batchSize if batchInputShape is " + "specified when creating an InputLayer.");
        }
      }
      const dtype = args.dtype || "float32";
      this.batchInputShape = batchInputShape;
      this.dtype = dtype;
      this.inputSpec = [{ shape: batchInputShape }];
      const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);
      inputTensor.nodeIndex = 0;
      inputTensor.tensorIndex = 0;
      new Node({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: [inputTensor],
        outputTensors: [inputTensor],
        inputMasks: [null],
        outputMasks: [null],
        inputShapes: [batchInputShape],
        outputShapes: [batchInputShape]
      });
    }
    apply(inputs, kwargs) {
      throw new ValueError("Cannot pass any input to an " + `InputLayer's apply() method. InputLayer name: ${this.name}`);
    }
    dispose() {
      return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };
    }
    getConfig() {
      return {
        batchInputShape: this.batchInputShape,
        dtype: this.dtype,
        sparse: this.sparse,
        name: this.name
      };
    }
  };
  InputLayer.className = "InputLayer";
  exports_serialization.registerClass(InputLayer);
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/executor.js
function assertFeedCompatibility(key, val) {
  if (key.dtype == null || key.dtype === val.dtype) {
    return val;
  }
  try {
    return cast(val, key.dtype);
  } catch (err) {
    throw new ValueError(`The dtype of the feed (${val.dtype}) can not be cast to the dtype ` + `of the key '${key.name}' (${key.dtype}).`);
  }
}
function updateCacheMaxEntries(maxEntries) {
  if (cachedSorted != null) {
    cachedSorted.setMaxEntries(maxEntries);
  }
  if (cachedRecipientCounts != null) {
    cachedRecipientCounts.setMaxEntries(maxEntries);
  }
}
function execute(fetches, feedDict, kwargs, probe) {
  const training = kwargs == null ? false : kwargs["training"];
  const arrayFetches = Array.isArray(fetches);
  const fetchArray = arrayFetches ? fetches : [fetches];
  const outputNames = fetchArray.map((t) => t.name);
  const finalOutputs = [];
  const feedNames = feedDict.names();
  for (const outputName of outputNames) {
    if (feedNames.indexOf(outputName) !== -1) {
      finalOutputs.push(feedDict.getValue(outputName));
    } else {
      finalOutputs.push(null);
    }
  }
  if (probe != null) {
    probe.maxNumTensors = -Infinity;
    probe.minNumTensors = Infinity;
  }
  const fetchAndFeedKey = outputNames.join(",") + "|" + feedDict.names().sort().join(",");
  let sorted = cachedSorted.get(fetchAndFeedKey);
  let recipientCounts;
  if (sorted == null) {
    const out = getTopologicalSortAndRecipientCounts(fetchArray, feedDict);
    sorted = out.sorted;
    recipientCounts = out.recipientCounts;
    cachedSorted.put(fetchAndFeedKey, sorted);
    cachedRecipientCounts.put(fetchAndFeedKey, recipientCounts);
  }
  recipientCounts = {};
  if (!training) {
    Object.assign(recipientCounts, cachedRecipientCounts.get(fetchAndFeedKey));
  }
  const internalFeedDict = new FeedDict(feedDict);
  for (let i = 0;i < sorted.length; ++i) {
    if (probe != null) {
      const numTensors = memory().numTensors;
      if (numTensors > probe.maxNumTensors) {
        probe.maxNumTensors = numTensors;
      }
      if (numTensors < probe.minNumTensors) {
        probe.minNumTensors = numTensors;
      }
    }
    const symbolic = sorted[i];
    const srcLayer = symbolic.sourceLayer;
    if (srcLayer instanceof InputLayer) {
      continue;
    }
    const inputValues = [];
    const inputMasks = [];
    const tensorsToDispose = [];
    let maskExists = false;
    for (const input of symbolic.inputs) {
      const value = internalFeedDict.getValue(input);
      const mask = internalFeedDict.getMask(input);
      inputValues.push(value);
      inputMasks.push(mask);
      if (mask != null) {
        maskExists = true;
      }
      if (!training) {
        recipientCounts[input.name]--;
        if (recipientCounts[input.name] === 0 && !feedDict.hasKey(input) && outputNames.indexOf(input.name) === -1 && !value.isDisposed && input.sourceLayer.stateful !== true) {
          tensorsToDispose.push(value);
        }
      }
    }
    if (maskExists) {
      kwargs = kwargs || {};
      kwargs["mask"] = inputMasks[0];
    }
    const outputTensors = toList(srcLayer.apply(inputValues, kwargs));
    let outputMask = null;
    if (srcLayer.supportsMasking) {
      outputMask = srcLayer.computeMask(inputValues, inputMasks);
    }
    const layerOutputs = getNodeOutputs(symbolic);
    const outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];
    for (let i3 = 0;i3 < outputSymbolicTensors.length; ++i3) {
      if (!internalFeedDict.hasKey(outputSymbolicTensors[i3])) {
        internalFeedDict.add(outputSymbolicTensors[i3], outputTensors[i3], Array.isArray(outputMask) ? outputMask[0] : outputMask);
      }
      const index = outputNames.indexOf(outputSymbolicTensors[i3].name);
      if (index !== -1) {
        finalOutputs[index] = outputTensors[i3];
      }
    }
    if (!training) {
      dispose(tensorsToDispose);
    }
  }
  internalFeedDict.disposeMasks();
  return arrayFetches ? finalOutputs : finalOutputs[0];
}
function getTopologicalSortAndRecipientCounts(fetches, feedDict) {
  exports_util.assert(fetches != null && fetches.length > 0, () => `Expected at least one fetch, got none`);
  let finalSorted = [];
  let finalRecipientMap = {};
  if (fetches.length === 1) {
    const out = getTopologicalSortAndRecipientCountsForOneFetch(fetches[0], feedDict);
    finalSorted = out.sorted;
    finalRecipientMap = out.recipientMap;
  } else {
    const visited = new Set;
    for (const fetch4 of fetches) {
      const { sorted, recipientMap } = getTopologicalSortAndRecipientCountsForOneFetch(fetch4, feedDict);
      for (const symbolicTensor of sorted) {
        if (!visited.has(symbolicTensor.name)) {
          finalSorted.push(symbolicTensor);
          visited.add(symbolicTensor.name);
        }
      }
      for (const name in recipientMap) {
        if (finalRecipientMap[name] == null) {
          finalRecipientMap[name] = new Set;
        }
        recipientMap[name].forEach((recipient) => finalRecipientMap[name].add(recipient));
      }
    }
  }
  return {
    sorted: finalSorted,
    recipientCounts: recipientMap2Counts(finalRecipientMap)
  };
}
function recipientMap2Counts(recipientMap) {
  const recipientCounts = {};
  for (const name in recipientMap) {
    recipientCounts[name] = recipientMap[name].size;
  }
  return recipientCounts;
}
function getTopologicalSortAndRecipientCountsForOneFetch(fetch4, feedDict) {
  const visited = new Set;
  const sorted = [];
  const recipientMap = {};
  for (const key of feedDict.names()) {
    visited.add(key);
  }
  const stack9 = [];
  const marks = [];
  stack9.push(fetch4);
  while (stack9.length > 0) {
    const top = stack9[stack9.length - 1];
    if (visited.has(top.name)) {
      stack9.pop();
      continue;
    }
    const topIsMarked = marks[marks.length - 1] === stack9.length - 1;
    if (top.inputs.length === 0 || topIsMarked) {
      stack9.pop();
      sorted.push(top);
      visited.add(top.name);
      if (topIsMarked) {
        marks.pop();
      }
    } else {
      marks.push(stack9.length - 1);
      for (const input of top.inputs) {
        if (recipientMap[input.name] == null) {
          recipientMap[input.name] = new Set;
        }
        recipientMap[input.name].add(top.name);
        if (visited.has(input.name)) {
          continue;
        }
        stack9.push(input);
      }
    }
  }
  return { sorted, recipientMap };
}
function getNodeOutputs(fetch4) {
  let layerOutputs;
  if (fetch4.sourceLayer.inboundNodes.length === 1) {
    layerOutputs = fetch4.sourceLayer.output;
  } else {
    let nodeIndex = null;
    for (let i = 0;i < fetch4.sourceLayer.inboundNodes.length; ++i) {
      for (const outputTensor of fetch4.sourceLayer.inboundNodes[i].outputTensors) {
        if (outputTensor.id === fetch4.id) {
          nodeIndex = i;
          break;
        }
      }
    }
    layerOutputs = fetch4.sourceLayer.getOutputAt(nodeIndex);
  }
  return layerOutputs;
}

class FeedDict {
  constructor(feeds) {
    this.id2Value = {};
    this.id2Mask = {};
    this.name2Id = {};
    if (feeds instanceof FeedDict) {
      for (const id in feeds.id2Value) {
        this.id2Value[id] = feeds.id2Value[id];
        if (id in feeds.id2Mask) {
          this.id2Mask[id] = feeds.id2Mask[id];
        }
      }
    } else {
      if (feeds == null) {
        return;
      }
      for (const feed of feeds) {
        this.add(feed.key, feed.value);
      }
    }
  }
  add(key, value, mask) {
    if (this.id2Value[key.id] == null) {
      this.id2Value[key.id] = assertFeedCompatibility(key, value);
      this.name2Id[key.name] = key.id;
      if (mask != null) {
        this.id2Mask[key.id] = mask;
      }
    } else {
      throw new ValueError(`Duplicate key: name=${key.name}, id=${key.id}`);
    }
    return this;
  }
  addFeed(feed) {
    this.add(feed.key, feed.value);
  }
  hasKey(key) {
    return this.id2Value[key.id] != null;
  }
  names() {
    return Object.keys(this.name2Id);
  }
  getValue(key) {
    if (key instanceof SymbolicTensor) {
      if (this.id2Value[key.id] == null) {
        throw new ValueError(`Nonexistent key: ${key.name}`);
      } else {
        return this.id2Value[key.id];
      }
    } else {
      const id = this.name2Id[key];
      if (id == null) {
        throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
      }
      return this.id2Value[id];
    }
  }
  getMask(key) {
    if (key instanceof SymbolicTensor) {
      if (this.id2Value[key.id] == null) {
        throw new ValueError(`Nonexistent key: ${key.name}`);
      } else {
        return this.id2Mask[key.id];
      }
    } else {
      const id = this.name2Id[key];
      if (id == null) {
        throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);
      }
      return this.id2Mask[id];
    }
  }
  disposeMasks() {
    if (this.id2Mask != null) {
      dispose(this.id2Mask);
    }
  }
}
var cachedSorted, cachedRecipientCounts;
var init_executor = __esm(() => {
  init_dist();
  init_errors();
  init_generic_utils();
  init_input_layer();
  init_topology();
  cachedSorted = new LruCache;
  cachedRecipientCounts = new LruCache;
});

// node_modules/@tensorflow/tfjs-layers/dist/flags_layers.js
var ENV3;
var init_flags_layers = __esm(() => {
  init_dist();
  init_executor();
  ENV3 = env();
  ENV3.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", () => 100, updateCacheMaxEntries);
});

// node_modules/@tensorflow/tfjs-layers/dist/constraints.js
function calcL2Norms(w, axis) {
  return tidy(() => sqrt(sum2(mul(w, w), axis, true)));
}
function serializeConstraint(constraint) {
  return serializeKerasObject(constraint);
}
function deserializeConstraint(config, customObjects = {}) {
  return deserializeKerasObject(config, exports_serialization.SerializationMap.getMap().classNameMap, customObjects, "constraint");
}
function getConstraint(identifier) {
  if (identifier == null) {
    return null;
  }
  if (typeof identifier === "string") {
    const className = identifier in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ? CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
    const config = { className, config: {} };
    return deserializeConstraint(config);
  } else if (identifier instanceof Constraint) {
    return identifier;
  } else {
    return deserializeConstraint(identifier);
  }
}
var Constraint, MaxNorm, UnitNorm, NonNeg, MinMaxNorm, CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP;
var init_constraints = __esm(() => {
  init_dist();
  init_dist();
  init_common3();
  init_generic_utils();
  Constraint = class Constraint extends exports_serialization.Serializable {
    getConfig() {
      return {};
    }
  };
  MaxNorm = class MaxNorm extends Constraint {
    constructor(args) {
      super();
      this.defaultMaxValue = 2;
      this.defaultAxis = 0;
      this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
      this.axis = args.axis != null ? args.axis : this.defaultAxis;
    }
    apply(w) {
      return tidy(() => {
        const norms = calcL2Norms(w, this.axis);
        const desired = clipByValue(norms, 0, this.maxValue);
        return mul(w, div(desired, add2(epsilon(), norms)));
      });
    }
    getConfig() {
      return { maxValue: this.maxValue, axis: this.axis };
    }
  };
  MaxNorm.className = "MaxNorm";
  exports_serialization.registerClass(MaxNorm);
  UnitNorm = class UnitNorm extends Constraint {
    constructor(args) {
      super();
      this.defaultAxis = 0;
      this.axis = args.axis != null ? args.axis : this.defaultAxis;
    }
    apply(w) {
      return tidy(() => div(w, add2(epsilon(), calcL2Norms(w, this.axis))));
    }
    getConfig() {
      return { axis: this.axis };
    }
  };
  UnitNorm.className = "UnitNorm";
  exports_serialization.registerClass(UnitNorm);
  NonNeg = class NonNeg extends Constraint {
    apply(w) {
      return relu(w);
    }
  };
  NonNeg.className = "NonNeg";
  exports_serialization.registerClass(NonNeg);
  MinMaxNorm = class MinMaxNorm extends Constraint {
    constructor(args) {
      super();
      this.defaultMinValue = 0;
      this.defaultMaxValue = 1;
      this.defaultRate = 1;
      this.defaultAxis = 0;
      this.minValue = args.minValue != null ? args.minValue : this.defaultMinValue;
      this.maxValue = args.maxValue != null ? args.maxValue : this.defaultMaxValue;
      this.rate = args.rate != null ? args.rate : this.defaultRate;
      this.axis = args.axis != null ? args.axis : this.defaultAxis;
    }
    apply(w) {
      return tidy(() => {
        const norms = calcL2Norms(w, this.axis);
        const desired = add2(mul(this.rate, clipByValue(norms, this.minValue, this.maxValue)), mul(1 - this.rate, norms));
        return mul(w, div(desired, add2(epsilon(), norms)));
      });
    }
    getConfig() {
      return {
        minValue: this.minValue,
        maxValue: this.maxValue,
        rate: this.rate,
        axis: this.axis
      };
    }
  };
  MinMaxNorm.className = "MinMaxNorm";
  exports_serialization.registerClass(MinMaxNorm);
  CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    maxNorm: "MaxNorm",
    minMaxNorm: "MinMaxNorm",
    nonNeg: "NonNeg",
    unitNorm: "UnitNorm"
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/exports_constraints.js
var exports_exports_constraints = {};
__export(exports_exports_constraints, {
  unitNorm: () => unitNorm,
  nonNeg: () => nonNeg,
  minMaxNorm: () => minMaxNorm,
  maxNorm: () => maxNorm
});
function maxNorm(args) {
  return new MaxNorm(args);
}
function unitNorm(args) {
  return new UnitNorm(args);
}
function nonNeg() {
  return new NonNeg;
}
function minMaxNorm(config) {
  return new MinMaxNorm(config);
}
var init_exports_constraints = __esm(() => {
  init_constraints();
});

// node_modules/@tensorflow/tfjs-layers/dist/exports_initializers.js
var exports_exports_initializers = {};
__export(exports_exports_initializers, {
  zeros: () => zeros6,
  varianceScaling: () => varianceScaling,
  truncatedNormal: () => truncatedNormal2,
  randomUniform: () => randomUniform2,
  randomNormal: () => randomNormal3,
  orthogonal: () => orthogonal,
  ones: () => ones8,
  leCunUniform: () => leCunUniform,
  leCunNormal: () => leCunNormal,
  identity: () => identity,
  heUniform: () => heUniform,
  heNormal: () => heNormal,
  glorotUniform: () => glorotUniform,
  glorotNormal: () => glorotNormal,
  constant: () => constant
});
function zeros6() {
  return new Zeros;
}
function ones8() {
  return new Ones;
}
function constant(args) {
  return new Constant(args);
}
function randomUniform2(args) {
  return new RandomUniform(args);
}
function randomNormal3(args) {
  return new RandomNormal(args);
}
function truncatedNormal2(args) {
  return new TruncatedNormal(args);
}
function identity(args) {
  return new Identity2(args);
}
function varianceScaling(config) {
  return new VarianceScaling(config);
}
function glorotUniform(args) {
  return new GlorotUniform(args);
}
function glorotNormal(args) {
  return new GlorotNormal(args);
}
function heNormal(args) {
  return new HeNormal(args);
}
function heUniform(args) {
  return new HeUniform(args);
}
function leCunNormal(args) {
  return new LeCunNormal(args);
}
function leCunUniform(args) {
  return new LeCunUniform(args);
}
function orthogonal(args) {
  return new Orthogonal(args);
}
var init_exports_initializers = __esm(() => {
  init_initializers();
});

// node_modules/@tensorflow/tfjs-layers/dist/logs.js
async function resolveScalarsInLogs(logs) {
  if (logs == null) {
    return;
  }
  const promises = [];
  const keys = [];
  const scalarsToDispose = [];
  for (const key in logs) {
    const value = logs[key];
    if (typeof value !== "number") {
      const valueScalar = value;
      promises.push(valueScalar.data());
      keys.push(key);
      scalarsToDispose.push(valueScalar);
    }
  }
  if (promises.length > 0) {
    const values = await Promise.all(promises);
    for (let i = 0;i < values.length; ++i) {
      logs[keys[i]] = values[i][0];
    }
    dispose(scalarsToDispose);
  }
}
function disposeTensorsInLogs(logs) {
  if (logs == null) {
    return;
  }
  for (const key in logs) {
    const value = logs[key];
    if (typeof value !== "number") {
      value.dispose();
    }
  }
}
var init_logs = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js
function standardizeCallbacks(callbacks, yieldEvery) {
  if (callbacks == null) {
    callbacks = {};
  }
  if (callbacks instanceof BaseCallback) {
    return [callbacks];
  }
  if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {
    return callbacks;
  }
  const callbackConfigs = toList(callbacks);
  return callbackConfigs.map((callbackConfig) => new CustomCallback(callbackConfig, yieldEvery));
}
function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {
  const history = new History;
  const actualCallbacks = [
    new BaseLogger,
    ...CallbackConstructorRegistry.createCallbacks(verbose)
  ];
  if (callbacks != null) {
    actualCallbacks.push(...callbacks);
  }
  actualCallbacks.push(history);
  const callbackList = new CallbackList(actualCallbacks);
  callbackList.setParams({
    epochs,
    initialEpoch,
    samples: numTrainSamples,
    steps: stepsPerEpoch,
    batchSize,
    verbose,
    doValidation,
    metrics: callbackMetrics
  });
  return { callbackList, history };
}

class BaseCallback {
  constructor() {
    this.validationData = null;
  }
  setParams(params) {
    this.params = params;
  }
  async onEpochBegin(epoch, logs2) {
  }
  async onEpochEnd(epoch, logs2) {
  }
  async onBatchBegin(batch, logs2) {
  }
  async onBatchEnd(batch, logs2) {
  }
  async onTrainBegin(logs2) {
  }
  async onTrainEnd(logs2) {
  }
  setModel(model) {
  }
}

class CallbackList {
  constructor(callbacks, queueLength = 10) {
    if (callbacks == null) {
      callbacks = [];
    }
    this.callbacks = callbacks;
    this.queueLength = queueLength;
  }
  append(callback) {
    this.callbacks.push(callback);
  }
  setParams(params) {
    for (const callback of this.callbacks) {
      callback.setParams(params);
    }
  }
  setModel(model) {
    for (const callback of this.callbacks) {
      callback.setModel(model);
    }
  }
  async onEpochBegin(epoch, logs2) {
    if (logs2 == null) {
      logs2 = {};
    }
    for (const callback of this.callbacks) {
      await callback.onEpochBegin(epoch, logs2);
    }
  }
  async onEpochEnd(epoch, logs2) {
    if (logs2 == null) {
      logs2 = {};
    }
    for (const callback of this.callbacks) {
      await callback.onEpochEnd(epoch, logs2);
    }
  }
  async onBatchBegin(batch, logs2) {
    if (logs2 == null) {
      logs2 = {};
    }
    for (const callback of this.callbacks) {
      await callback.onBatchBegin(batch, logs2);
    }
  }
  async onBatchEnd(batch, logs2) {
    if (logs2 == null) {
      logs2 = {};
    }
    for (const callback of this.callbacks) {
      await callback.onBatchEnd(batch, logs2);
    }
  }
  async onTrainBegin(logs2) {
    if (logs2 == null) {
      logs2 = {};
    }
    for (const callback of this.callbacks) {
      await callback.onTrainBegin(logs2);
    }
  }
  async onTrainEnd(logs2) {
    if (logs2 == null) {
      logs2 = {};
    }
    for (const callback of this.callbacks) {
      await callback.onTrainEnd(logs2);
    }
  }
}

class CallbackConstructorRegistry {
  constructor() {
  }
  static registerCallbackConstructor(verbosityLevel, callbackConstructor) {
    exports_util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` + `but got ${verbosityLevel}`);
    CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);
    if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {
      CallbackConstructorRegistry.constructors[verbosityLevel] = [];
    }
    CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);
  }
  static checkForDuplicate(callbackConstructor) {
    for (const levelName in CallbackConstructorRegistry.constructors) {
      const constructors = CallbackConstructorRegistry.constructors[+levelName];
      constructors.forEach((ctor) => {
        if (ctor === callbackConstructor) {
          throw new ValueError("Duplicate callback constructor.");
        }
      });
    }
  }
  static clear() {
    CallbackConstructorRegistry.constructors = {};
  }
  static createCallbacks(verbosityLevel) {
    const constructors = [];
    for (const levelName in CallbackConstructorRegistry.constructors) {
      const level = +levelName;
      if (verbosityLevel >= level) {
        constructors.push(...CallbackConstructorRegistry.constructors[level]);
      }
    }
    return constructors.map((ctor) => new ctor);
  }
}
var ModelLoggingVerbosity, DEFAULT_YIELD_EVERY_MS = 125, BaseLogger, History, CustomCallback;
var init_base_callbacks = __esm(() => {
  init_dist();
  init_errors();
  init_logs();
  init_generic_utils();
  (function(ModelLoggingVerbosity2) {
    ModelLoggingVerbosity2[ModelLoggingVerbosity2["SILENT"] = 0] = "SILENT";
    ModelLoggingVerbosity2[ModelLoggingVerbosity2["VERBOSE"] = 1] = "VERBOSE";
  })(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));
  BaseLogger = class BaseLogger extends BaseCallback {
    constructor() {
      super();
    }
    async onEpochBegin(epoch) {
      this.seen = 0;
      this.totals = {};
    }
    async onBatchEnd(batch, logs2) {
      if (logs2 == null) {
        logs2 = {};
      }
      const batchSize = logs2["size"] == null ? 0 : logs2["size"];
      this.seen += batchSize;
      for (const key in logs2) {
        const value = logs2[key];
        if (typeof value === "number") {
          if (!this.totals.hasOwnProperty(key)) {
            this.totals[key] = 0;
          }
          this.totals[key] = this.totals[key] + value * batchSize;
        } else {
          let oldTotalsToDispose;
          if (key in this.totals) {
            oldTotalsToDispose = this.totals[key];
          } else {
            this.totals[key] = 0;
          }
          const total = tidy(() => add2(this.totals[key], mul(value, batchSize)));
          this.totals[key] = total;
          if (oldTotalsToDispose != null) {
            oldTotalsToDispose.dispose();
          }
        }
      }
    }
    async onEpochEnd(epoch, logs2) {
      if (logs2 != null) {
        for (const key of this.params["metrics"]) {
          if (this.totals[key] == null) {
            continue;
          }
          if (typeof this.totals[key] === "number") {
            logs2[key] = this.totals[key] / this.seen;
          } else {
            tidy(() => {
              const log9 = mul(div(1, this.seen), this.totals[key]);
              logs2[key] = log9;
              this.totals[key].dispose();
              keep(logs2[key]);
            });
          }
        }
      }
    }
  };
  History = class History extends BaseCallback {
    async onTrainBegin(logs2) {
      this.epoch = [];
      this.history = {};
    }
    async onEpochEnd(epoch, logs2) {
      if (logs2 == null) {
        logs2 = {};
      }
      this.epoch.push(epoch);
      for (const key in logs2) {
        if (this.history[key] == null) {
          this.history[key] = [];
        }
        this.history[key].push(logs2[key]);
      }
    }
    async syncData() {
      const promises = [];
      const keys = [];
      const indices = [];
      for (const key in this.history) {
        const valueArray = this.history[key];
        for (let i = 0;i < valueArray.length; ++i) {
          if (typeof valueArray[i] !== "number") {
            const valueScalar = valueArray[i];
            promises.push(valueScalar.data());
            keys.push(key);
            indices.push(i);
          }
        }
      }
      const values = await Promise.all(promises);
      for (let n = 0;n < values.length; ++n) {
        const tensorToDispose = this.history[keys[n]][indices[n]];
        tensorToDispose.dispose();
        this.history[keys[n]][indices[n]] = values[n][0];
      }
    }
  };
  CustomCallback = class CustomCallback extends BaseCallback {
    constructor(args, yieldEvery) {
      super();
      this.currentEpoch = 0;
      this.nowFunc = args.nowFunc;
      this.nextFrameFunc = args.nextFrameFunc || nextFrame;
      this.yieldEvery = yieldEvery || "auto";
      if (this.yieldEvery === "auto") {
        this.yieldEvery = DEFAULT_YIELD_EVERY_MS;
      }
      if (this.yieldEvery === "never" && args.onYield != null) {
        throw new Error("yieldEvery is `never` but you provided an `onYield` callback. " + "Either change `yieldEvery` or remove the callback");
      }
      if (exports_util.isNumber(this.yieldEvery)) {
        this.maybeWait = debounce(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);
      }
      this.trainBegin = args.onTrainBegin;
      this.trainEnd = args.onTrainEnd;
      this.epochBegin = args.onEpochBegin;
      this.epochEnd = args.onEpochEnd;
      this.batchBegin = args.onBatchBegin;
      this.batchEnd = args.onBatchEnd;
      this.yield = args.onYield;
    }
    async maybeWait(epoch, batch, logs2) {
      const ps = [];
      if (this.yield != null) {
        await resolveScalarsInLogs(logs2);
        ps.push(this.yield(epoch, batch, logs2));
      }
      ps.push(this.nextFrameFunc());
      await Promise.all(ps);
    }
    async onEpochBegin(epoch, logs2) {
      this.currentEpoch = epoch;
      if (this.epochBegin != null) {
        await resolveScalarsInLogs(logs2);
        await this.epochBegin(epoch, logs2);
      }
    }
    async onEpochEnd(epoch, logs2) {
      const ps = [];
      if (this.epochEnd != null) {
        await resolveScalarsInLogs(logs2);
        ps.push(this.epochEnd(epoch, logs2));
      }
      if (this.yieldEvery === "epoch") {
        ps.push(this.nextFrameFunc());
      }
      await Promise.all(ps);
    }
    async onBatchBegin(batch, logs2) {
      if (this.batchBegin != null) {
        await resolveScalarsInLogs(logs2);
        await this.batchBegin(batch, logs2);
      }
    }
    async onBatchEnd(batch, logs2) {
      const ps = [];
      if (this.batchEnd != null) {
        await resolveScalarsInLogs(logs2);
        ps.push(this.batchEnd(batch, logs2));
      }
      if (this.yieldEvery === "batch") {
        ps.push(this.nextFrameFunc());
      } else if (exports_util.isNumber(this.yieldEvery)) {
        ps.push(this.maybeWait(this.currentEpoch, batch, logs2));
      }
      await Promise.all(ps);
    }
    async onTrainBegin(logs2) {
      if (this.trainBegin != null) {
        await resolveScalarsInLogs(logs2);
        await this.trainBegin(logs2);
      }
    }
    async onTrainEnd(logs2) {
      if (this.trainEnd != null) {
        await resolveScalarsInLogs(logs2);
        await this.trainEnd(logs2);
      }
    }
  };
  CallbackConstructorRegistry.constructors = {};
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/serialization.js
function deserialize(config, customObjects = {}, fastWeightInit = false) {
  return deserializeKerasObject(config, exports_serialization.SerializationMap.getMap().classNameMap, customObjects, "layer", fastWeightInit);
}
var init_serialization2 = __esm(() => {
  init_dist();
  init_generic_utils();
});

// node_modules/@tensorflow/tfjs-layers/dist/losses.js
function l2Normalize(x, axis) {
  return tidy(() => {
    if (x.dtype !== "float32") {
      x = cast(x, "float32");
    }
    const squareSum = sum2(square23(x), axis, true);
    const epsilonTensor = fill(squareSum.shape, epsilon());
    const norm7 = sqrt(maximum(squareSum, epsilonTensor));
    return div(x, norm7);
  });
}
function meanSquaredError2(yTrue, yPred) {
  return tidy(() => mean(square23(sub(yPred, yTrue)), -1));
}
function meanAbsoluteError(yTrue, yPred) {
  return tidy(() => mean(abs(sub(yPred, yTrue)), -1));
}
function meanAbsolutePercentageError(yTrue, yPred) {
  return tidy(() => {
    const diff = sub(yTrue, yPred);
    const clippedTrue = clipByValue(abs(yTrue), epsilon(), Number.MAX_VALUE);
    const absResult = abs(div(diff, clippedTrue));
    return mul(100, mean(absResult, -1));
  });
}
function meanSquaredLogarithmicError(yTrue, yPred) {
  return tidy(() => {
    const clippedPred = clipByValue(yPred, epsilon(), Number.MAX_VALUE);
    const firstLog = log2(add2(1, clippedPred));
    const clippedTrue = clipByValue(yTrue, epsilon(), Number.MAX_VALUE);
    const secondLog = log2(add2(1, clippedTrue));
    return mean(square23(sub(firstLog, secondLog)), -1);
  });
}
function squaredHinge(yTrue, yPred) {
  return tidy(() => {
    const maxResult = maximum(0, sub(1, mul(yTrue, yPred)));
    return mean(square23(maxResult), -1);
  });
}
function hinge(yTrue, yPred) {
  return tidy(() => {
    const maxResult = maximum(0, sub(1, mul(yTrue, yPred)));
    return mean(maxResult, -1);
  });
}
function categoricalHinge(yTrue, yPred) {
  return tidy(() => {
    const pos = sum2(mul(yTrue, yPred), -1);
    const neg21 = max(mul(sub(1, yTrue), yPred), -1);
    return maximum(0, add2(1, sub(neg21, pos)));
  });
}
function logcosh(yTrue, yPred) {
  return tidy(() => {
    const log22 = Math.log(2);
    const predictionDiff = sub(yPred, yTrue);
    const logcoshResult = sub(add2(predictionDiff, softplus(mul(-2, predictionDiff))), log22);
    return mean(logcoshResult, -1);
  });
}
function categoricalCrossentropy(target, output, fromLogits = false) {
  return tidy(() => {
    if (fromLogits) {
      output = softmax(output);
    } else {
      const outputSum = sum2(output, output.shape.length - 1, true);
      output = div(output, outputSum);
    }
    output = clipByValue(output, epsilon(), 1 - epsilon());
    return neg(sum2(mul(cast(target, "float32"), log2(output)), output.shape.length - 1));
  });
}
function sparseCategoricalCrossentropy(target, output, fromLogits = false) {
  return tidy(() => {
    const flatTarget = cast(floor(flatten3(target)), "int32");
    output = clipByValue(output, epsilon(), 1 - epsilon());
    const outputShape = output.shape;
    const oneHotTarget = reshape(oneHot(flatTarget, outputShape[outputShape.length - 1]), outputShape);
    return categoricalCrossentropy(oneHotTarget, output, fromLogits);
  });
}
function sigmoidCrossEntropyWithLogits(labels, logits) {
  if (!exports_util.arraysEqual(labels.shape, logits.shape)) {
    throw new ValueError(`logits and labels must have the same shape, but got shapes ` + `${JSON.stringify(labels.shape)} and ${JSON.stringify(logits.shape)}`);
  }
  return tidy(() => {
    const reluLogits = relu(logits);
    const negAbsLogits = neg(abs(logits));
    return add2(sub(reluLogits, mul(logits, labels)), log1p(exp(negAbsLogits)));
  });
}
function binaryCrossentropy(yTrue, yPred) {
  return tidy(() => {
    let y;
    y = clipByValue(yPred, epsilon(), 1 - epsilon());
    y = log2(div(y, sub(1, y)));
    return mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);
  });
}
function kullbackLeiblerDivergence(yTrue, yPred) {
  return tidy(() => {
    const clippedTrue = clipByValue(yTrue, epsilon(), 1);
    const clippedPred = clipByValue(yPred, epsilon(), 1);
    return sum2(mul(yTrue, log2(div(clippedTrue, clippedPred))), -1);
  });
}
function poisson(yTrue, yPred) {
  return tidy(() => {
    const logPred = log2(add2(epsilon(), yPred));
    return mean(sub(yPred, mul(yTrue, logPred)), -1);
  });
}
function cosineProximity(yTrue, yPred) {
  return tidy(() => {
    const trueNormalized = l2Normalize(yTrue, -1);
    const predNormalized = l2Normalize(yPred, -1);
    const trueXPred = mul(trueNormalized, predNormalized);
    return neg(sum2(trueXPred, -1));
  });
}
function get(identifierOrFn) {
  if (typeof identifierOrFn === "string") {
    if (identifierOrFn in lossesMap) {
      return lossesMap[identifierOrFn];
    }
    let errMsg = `Unknown loss ${identifierOrFn}`;
    if (identifierOrFn.toLowerCase().includes("softmaxcrossentropy")) {
      errMsg = `Unknown loss ${identifierOrFn}. ` + 'Use "categoricalCrossentropy" as the string name for ' + "tf.losses.softmaxCrossEntropy";
    }
    throw new ValueError(errMsg);
  } else {
    return identifierOrFn;
  }
}
var lossesMap;
var init_losses = __esm(() => {
  init_dist();
  init_dist();
  init_common3();
  init_tfjs_backend();
  init_errors();
  lossesMap = {
    meanSquaredError: meanSquaredError2,
    meanAbsoluteError,
    meanAbsolutePercentageError,
    meanSquaredLogarithmicError,
    squaredHinge,
    hinge,
    categoricalHinge,
    logcosh,
    categoricalCrossentropy,
    sparseCategoricalCrossentropy,
    binaryCrossentropy,
    kullbackLeiblerDivergence,
    poisson,
    cosineProximity
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/metrics.js
function binaryAccuracy(yTrue, yPred) {
  return tidy(() => {
    const threshold3 = mul(0.5, onesLike(yPred));
    const yPredThresholded = cast45(greater(yPred, threshold3), yTrue.dtype);
    return mean(equal(yTrue, yPredThresholded), -1);
  });
}
function categoricalAccuracy(yTrue, yPred) {
  return tidy(() => cast45(equal(argMax(yTrue, -1), argMax(yPred, -1)), "float32"));
}
function truePositives(yTrue, yPred) {
  return tidy(() => {
    return cast(sum2(logicalAnd(equal(yTrue, 1), equal(yPred, 1))), "float32");
  });
}
function falseNegatives(yTrue, yPred) {
  return tidy(() => {
    return cast(sum2(logicalAnd(equal(yTrue, 1), equal(yPred, 0))), "float32");
  });
}
function falsePositives(yTrue, yPred) {
  return tidy(() => {
    return cast(sum2(logicalAnd(equal(yTrue, 0), equal(yPred, 1))), "float32");
  });
}
function precision(yTrue, yPred) {
  return tidy(() => {
    const tp = truePositives(yTrue, yPred);
    const fp = falsePositives(yTrue, yPred);
    const denominator = add2(tp, fp);
    return cast(where(greater(denominator, 0), div(tp, denominator), 0), "float32");
  });
}
function recall(yTrue, yPred) {
  return tidy(() => {
    const tp = truePositives(yTrue, yPred);
    const fn = falseNegatives(yTrue, yPred);
    const denominator = add2(tp, fn);
    return cast(where(greater(denominator, 0), div(tp, denominator), 0), "float32");
  });
}
function binaryCrossentropy2(yTrue, yPred) {
  return binaryCrossentropy(yTrue, yPred);
}
function sparseCategoricalAccuracy(yTrue, yPred) {
  if (yTrue.rank === yPred.rank) {
    yTrue = squeeze(yTrue, [yTrue.rank - 1]);
  }
  yPred = argMax(yPred, -1);
  if (yPred.dtype !== yTrue.dtype) {
    yPred = cast(yPred, yTrue.dtype);
  }
  return cast(equal(yTrue, yPred), "float32");
}
function r2Score(yTrue, yPred) {
  return tidy(() => {
    const sumSquaresResiduals = yTrue.sub(yPred).square().sum();
    const sumSquares = yTrue.sub(yTrue.mean()).square().sum();
    return scalar(1).sub(sumSquaresResiduals.div(sumSquares));
  });
}
function get2(identifier) {
  if (typeof identifier === "string" && identifier in metricsMap) {
    return metricsMap[identifier];
  } else if (typeof identifier !== "string" && identifier != null) {
    return identifier;
  } else {
    throw new ValueError(`Unknown metric ${identifier}`);
  }
}
function getLossOrMetricName(fn) {
  assert2(fn !== null, `Unknown LossOrMetricFn ${fn}`);
  if (typeof fn === "string") {
    return fn;
  } else {
    let fnName;
    for (const key of Object.keys(lossesMap)) {
      if (lossesMap[key] === fn) {
        fnName = key;
        break;
      }
    }
    if (fnName !== undefined) {
      return fnName;
    }
    for (const key of Object.keys(metricsMap)) {
      if (metricsMap[key] === fn) {
        fnName = key;
        break;
      }
    }
    if (fnName !== undefined) {
      return fnName;
    }
    return fn.name;
  }
}
var mse, MSE, mae, MAE, mape, MAPE, categoricalCrossentropy2, cosine, sparseCategoricalCrossentropy2, metricsMap;
var init_metrics = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_errors();
  init_losses();
  init_generic_utils();
  mse = meanSquaredError2;
  MSE = meanSquaredError2;
  mae = meanAbsoluteError;
  MAE = meanAbsoluteError;
  mape = meanAbsolutePercentageError;
  MAPE = meanAbsolutePercentageError;
  categoricalCrossentropy2 = categoricalCrossentropy;
  cosine = cosineProximity;
  sparseCategoricalCrossentropy2 = sparseCategoricalCrossentropy;
  metricsMap = {
    binaryAccuracy,
    categoricalAccuracy,
    precision,
    categoricalCrossentropy: categoricalCrossentropy2,
    sparseCategoricalCrossentropy: sparseCategoricalCrossentropy2,
    mse,
    MSE,
    mae,
    MAE,
    mape,
    MAPE,
    cosine
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/optimizers.js
function getOptimizer(identifier) {
  const optimizerMap = {
    Adagrad: () => train.adagrad(0.01),
    Adadelta: () => train.adadelta(1, 0.95, epsilon()),
    Adam: () => train.adam(0.001, 0.9, 0.999, epsilon()),
    Adamax: () => train.adamax(0.002, 0.9, 0.999, epsilon(), 0),
    RMSProp: () => train.rmsprop(0.001, 0.9, 0, epsilon()),
    SGD: () => train.sgd(0.01)
  };
  optimizerMap["adagrad"] = optimizerMap["Adagrad"];
  optimizerMap["adadelta"] = optimizerMap["Adadelta"];
  optimizerMap["adam"] = optimizerMap["Adam"];
  optimizerMap["adamax"] = optimizerMap["Adamax"];
  optimizerMap["rmsprop"] = optimizerMap["RMSProp"];
  optimizerMap["sgd"] = optimizerMap["SGD"];
  if (identifier in optimizerMap) {
    return optimizerMap[identifier]();
  }
  throw new ValueError(`Unknown Optimizer ${identifier}`);
}
var init_optimizers = __esm(() => {
  init_dist();
  init_common3();
  init_errors();
});

// node_modules/@tensorflow/tfjs-layers/dist/user_defined_metadata.js
function checkUserDefinedMetadata(userDefinedMetadata, modelName, checkSize = false) {
  if (userDefinedMetadata == null || typeof userDefinedMetadata !== "object" || Object.getPrototypeOf(userDefinedMetadata) !== Object.prototype || !plainObjectCheck(userDefinedMetadata)) {
    throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
  }
  if (checkSize) {
    const out = JSON.stringify(userDefinedMetadata);
    if (out.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH) {
      console.warn(`User-defined metadata of model "${modelName}" is too large in ` + `size (length=${out.length} when serialized). It is not ` + `recommended to store such large objects in user-defined metadata. ` + `Please make sure its serialized length is <= ` + `${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`);
    }
  }
}
function plainObjectCheck(x) {
  if (x === null) {
    return true;
  } else if (typeof x === "object") {
    if (Object.getPrototypeOf(x) === Object.prototype) {
      const keys = Object.keys(x);
      for (const key of keys) {
        if (typeof key !== "string") {
          return false;
        }
        if (!plainObjectCheck(x[key])) {
          return false;
        }
      }
      return true;
    } else {
      if (Array.isArray(x)) {
        for (const item of x) {
          if (!plainObjectCheck(item)) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    }
  } else {
    const xType = typeof x;
    return xType === "string" || xType === "number" || xType === "boolean";
  }
}
var MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH;
var init_user_defined_metadata = __esm(() => {
  MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1 * 1024 * 1024;
});

// node_modules/@tensorflow/tfjs-layers/dist/utils/layer_utils.js
function printSummary(model, lineLength, positions, printFn = console.log) {
  const sequentialLike = isModelSequentialLike(model);
  const toDisplay = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
  if (sequentialLike) {
    lineLength = lineLength || 90;
    positions = positions || [0.32, 0.61, 0.89, 1];
  } else {
    lineLength = lineLength || 115;
    positions = positions || [0.24, 0.48, 0.7, 0.8, 1];
  }
  if (positions[positions.length - 1] <= 1) {
    positions = positions.map((p2) => Math.floor(lineLength * p2));
  }
  let relevantNodes;
  if (!sequentialLike) {
    toDisplay.push("Receives inputs");
    relevantNodes = [];
    for (const depth in model.nodesByDepth) {
      relevantNodes.push(...model.nodesByDepth[depth]);
    }
  }
  printFn("_".repeat(lineLength));
  printRow(toDisplay, positions, printFn);
  printFn("=".repeat(lineLength));
  const layers = model.layers;
  for (let i = 0;i < layers.length; ++i) {
    if (sequentialLike) {
      printLayerSummary(layers[i], positions, printFn);
    } else {
      printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);
    }
    printFn((i === layers.length - 1 ? "=" : "_").repeat(lineLength));
  }
  model.checkTrainableWeightsConsistency();
  const trainableCount = countTrainableParams(model);
  const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);
  printFn(`Total params: ${trainableCount + nonTrainableCount}`);
  printFn(`Trainable params: ${trainableCount}`);
  printFn(`Non-trainable params: ${nonTrainableCount}`);
  printFn("_".repeat(lineLength));
}
function countTrainableParams(model) {
  let trainableCount;
  if (model.collectedTrainableWeights != null) {
    trainableCount = countParamsInWeights(model.collectedTrainableWeights);
  } else {
    trainableCount = countParamsInWeights(model.trainableWeights);
  }
  return trainableCount;
}
function isModelSequentialLike(model) {
  let sequentialLike = true;
  const nodesByDepth = [];
  const nodes = [];
  for (const depth in model.nodesByDepth) {
    nodesByDepth.push(model.nodesByDepth[depth]);
  }
  for (const depthNodes of nodesByDepth) {
    if (depthNodes.length > 1 || depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {
      sequentialLike = false;
      break;
    }
    nodes.push(...depthNodes);
  }
  if (sequentialLike) {
    for (const layer of model.layers) {
      let flag = false;
      for (const node of layer.inboundNodes) {
        if (nodes.indexOf(node) !== -1) {
          if (flag) {
            sequentialLike = false;
            break;
          } else {
            flag = true;
          }
        }
      }
      if (!sequentialLike) {
        break;
      }
    }
  }
  return sequentialLike;
}
function printRow(fields, positions, printFn = console.log) {
  let line = "";
  for (let i = 0;i < fields.length; ++i) {
    if (i > 0) {
      line = line.slice(0, line.length - 1) + " ";
    }
    line += fields[i];
    line = line.slice(0, positions[i]);
    line += " ".repeat(positions[i] - line.length);
  }
  printFn(line);
}
function printLayerSummary(layer, positions, printFn) {
  let outputShape;
  let inputShape;
  try {
    inputShape = layer.inboundNodes.map((x) => JSON.stringify(x.inputShapes)).join(",");
  } catch (err) {
    inputShape = "multiple";
  }
  try {
    outputShape = JSON.stringify(layer.outputShape);
  } catch (err) {
    outputShape = "multiple";
  }
  const name = layer.name;
  const className = layer.getClassName();
  const fields = [
    `${name} (${className})`,
    inputShape,
    outputShape,
    layer.countParams().toString()
  ];
  printRow(fields, positions, printFn);
}
function printLayerSummaryWithConnections(layer, positions, relevantNodes, printFn) {
  let outputShape;
  let inputShape;
  try {
    inputShape = layer.inboundNodes.map((x) => JSON.stringify(x.inputShapes)).join(",");
  } catch (err) {
    inputShape = "multiple";
  }
  try {
    outputShape = JSON.stringify(layer.outputShape);
  } catch (err) {
    outputShape = "multiple";
  }
  const connections = [];
  for (const node of layer.inboundNodes) {
    if (relevantNodes != null && relevantNodes.length > 0 && relevantNodes.indexOf(node) === -1) {
      continue;
    }
    for (let i = 0;i < node.inboundLayers.length; ++i) {
      const inboundLayer = node.inboundLayers[i].name;
      const inboundLayerIndex = node.nodeIndices[i];
      const inboundTensorIndex = node.tensorIndices[i];
      connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);
    }
  }
  const name = layer.name;
  const className = layer.getClassName();
  const firstConnection = connections.length === 0 ? "" : connections[0];
  const fields = [
    `${name} (${className})`,
    inputShape,
    outputShape,
    layer.countParams().toString(),
    firstConnection
  ];
  printRow(fields, positions, printFn);
  for (let i = 1;i < connections.length; ++i) {
    printRow(["", "", "", "", connections[i]], positions, printFn);
  }
}
var init_layer_utils = () => {
};

// node_modules/@tensorflow/tfjs-layers/dist/utils/serialization_utils.js
function isArrayItemInputOrOutputName(key, index, value) {
  return (key === "inboundNodes" || key === "outputLayers" || key === "inputLayers") && index === 0 && typeof value === "string";
}
function convertPythonicToTs(pythonicConfig, key) {
  if (pythonicConfig === null) {
    return null;
  } else if (typeof pythonicConfig === "string") {
    return toCamelCase(pythonicConfig);
  } else if (typeof pythonicConfig === "number" || typeof pythonicConfig === "boolean") {
    return pythonicConfig;
  } else if (pythonicConfig instanceof Array) {
    const tsArray = [];
    const arrayLength = pythonicConfig.length;
    for (let i = 0;i < arrayLength; ++i) {
      const item = pythonicConfig[i];
      if (isArrayItemInputOrOutputName(key, i, item)) {
        tsArray.push(item);
      } else {
        tsArray.push(convertPythonicToTs(item, key));
      }
    }
    return tsArray;
  } else {
    const tsDict = {};
    for (const pythonicKey of Object.keys(pythonicConfig)) {
      const pythonicValue = pythonicConfig[pythonicKey];
      if (pythonicKey === "name" && typeof pythonicValue === "string") {
        tsDict[pythonicKey] = pythonicValue;
      } else {
        const tsKey = toCamelCase(pythonicKey);
        tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);
      }
    }
    return tsDict;
  }
}
function convertTsToPythonic(tsConfig, key) {
  if (tsConfig === null || tsConfig === undefined) {
    return null;
  } else if (typeof tsConfig === "string") {
    return toSnakeCase(tsConfig);
  } else if (typeof tsConfig === "number" || typeof tsConfig === "boolean") {
    return tsConfig;
  } else if (tsConfig instanceof Array) {
    const pyArray = [];
    const arrayLength = tsConfig.length;
    for (let i = 0;i < arrayLength; ++i) {
      const item = tsConfig[i];
      if (isArrayItemInputOrOutputName(key, i, item)) {
        pyArray.push(item);
      } else {
        pyArray.push(convertTsToPythonic(item, key));
      }
    }
    return pyArray;
  } else {
    const pyDict = {};
    for (const tsKey of Object.keys(tsConfig)) {
      const tsValue = tsConfig[tsKey];
      const pyKey = toSnakeCase(tsKey);
      if ((tsKey === "name" || tsKey === "className") && typeof tsValue === "string") {
        pyDict[pyKey] = tsValue;
      } else {
        pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);
      }
    }
    return pyDict;
  }
}
var init_serialization_utils = __esm(() => {
  init_generic_utils();
});

// node_modules/@tensorflow/tfjs-layers/dist/version.js
var version3 = "4.22.0";
var init_version2 = () => {
};

// node_modules/@tensorflow/tfjs-layers/dist/engine/container.js
var isKerasSavedModelFormat = (weights) => {
  const keys = Object.keys(weights);
  if (keys.length === 0) {
    return false;
  }
  const key = keys[0].split("/");
  return !isNaN(parseInt(key[key.length - 1], 10));
}, Container;
var init_container = __esm(() => {
  init_dist();
  init_state();
  init_errors();
  init_serialization2();
  init_generic_utils();
  init_serialization_utils();
  init_types_utils();
  init_variables();
  init_version2();
  init_executor();
  init_input_layer();
  init_topology();
  Container = class Container extends Layer {
    constructor(args) {
      super({});
      this.containerNodes = new Set;
      this.name = args.name;
      if (this.name == null) {
        const prefix = this.getClassName().toLowerCase();
        this.name = getUid(prefix);
      }
      this.supportsMasking = false;
      this.trainable_ = true;
      if (Array.isArray(args.inputs)) {
        this.inputs = args.inputs.slice();
      } else {
        this.inputs = [args.inputs];
      }
      if (Array.isArray(args.outputs)) {
        this.outputs = args.outputs.slice();
      } else {
        this.outputs = [args.outputs];
      }
      if (unique4(this.inputs).length !== this.inputs.length) {
        throw new ValueError("The list of inputs passed to the model is " + "redundant. All inputs should only appear once. Found: " + `${this.inputs.map((x) => x.name)}`);
      }
      if (unique4(this.outputs).length !== this.outputs.length) {
        console.warn("The list of outputs passed to the model is redundant. " + "All outputs should only appear once. Found: " + `${this.outputs.map((x) => x.name)}`);
      }
      this.inputLayers = [];
      this.inputLayersNodeIndices = [];
      this.inputLayersTensorIndices = [];
      this.outputLayers = [];
      this.outputLayersNodeIndices = [];
      this.outputLayersTensorIndices = [];
      this.layers = [];
      this.internalContainerRefs = [];
      for (const x of this.outputs) {
        const layer = x.sourceLayer;
        const nodeIndex = x.nodeIndex;
        const tensorIndex = x.tensorIndex;
        this.outputLayers.push(layer);
        this.outputLayersNodeIndices.push(nodeIndex);
        this.outputLayersTensorIndices.push(tensorIndex);
      }
      for (const x of this.inputs) {
        const layer = x.sourceLayer;
        const nodeIndex = x.nodeIndex;
        const tensorIndex = x.tensorIndex;
        assert2(nodeIndex === 0, "input layer has >1 nodes");
        assert2(tensorIndex === 0, "input layer has >1 tensors");
        this.inputLayers.push(layer);
        this.inputLayersNodeIndices.push(nodeIndex);
        this.inputLayersTensorIndices.push(tensorIndex);
      }
      this.inputNames = [];
      this.outputNames = [];
      this.feedInputShapes = [];
      this.feedInputNames = [];
      this.feedOutputNames = [];
      for (let i = 0;i < this.inputLayers.length; i++) {
        const layer = this.inputLayers[i];
        if (!(layer instanceof InputLayer)) {
          throw new TypeError("Input layers to a LayersModel must be InputLayer objects. " + `Received inputs: ${args.inputs}. ` + `Input ${i} (0-based) originates ` + `from layer type ${layer.getClassName()}.`);
        }
        this.inputNames.push(layer.name);
        this.feedInputShapes.push(layer.batchInputShape);
        this.feedInputNames.push(layer.name);
      }
      for (const layer of this.outputLayers) {
        this.outputNames.push(layer.name);
      }
      this.internalInputShapes = this.inputs.map((x) => x.shape);
      this.internalOutputShapes = this.outputs.map((x) => x.shape);
      const nodesDepths = {};
      const nodeIDToNode = {};
      const layersDepths = {};
      const layerIDToLayer = {};
      const layerIndices = {};
      const nodesInDecreasingDepth = [];
      const buildMapOfGraph = (tensor153, finishedNodes2, nodesInProgress2, layer, nodeIndex, tensorIndex) => {
        if (layer == null || nodeIndex == null || tensorIndex == null) {
          layer = tensor153.sourceLayer;
          nodeIndex = tensor153.nodeIndex;
          tensorIndex = tensor153.tensorIndex;
        }
        const node = layer.inboundNodes[nodeIndex];
        if (nodesInProgress2.indexOf(node) !== -1) {
          throw new RuntimeError(`The tensor ${tensor153.name} at layer "${layer.name}" ` + "is part of a cycle.");
        }
        if (finishedNodes2.indexOf(node) !== -1) {
          return;
        }
        this.containerNodes.add(Container.nodeKey(layer, nodeIndex));
        if (!(layer.id in layerIndices)) {
          layerIndices[layer.id] = Object.keys(layerIndices).length;
        }
        if (nodesInProgress2.indexOf(node) === -1) {
          nodesInProgress2.push(node);
        }
        const numInboundLayers = node.inboundLayers.length;
        for (let i = 0;i < numInboundLayers; i++) {
          const x = node.inputTensors[i];
          const layer2 = node.inboundLayers[i];
          const nodeIndex2 = node.nodeIndices[i];
          const tensorIndex2 = node.tensorIndices[i];
          buildMapOfGraph(x, finishedNodes2, nodesInProgress2, layer2, nodeIndex2, tensorIndex2);
        }
        finishedNodes2.push(node);
        while (nodesInProgress2.indexOf(node) >= 0) {
          nodesInProgress2.splice(nodesInProgress2.indexOf(node), 1);
        }
        nodesInDecreasingDepth.push(node);
      };
      const finishedNodes = [];
      const nodesInProgress = [];
      for (const x of this.outputs) {
        buildMapOfGraph(x, finishedNodes, nodesInProgress);
      }
      const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();
      for (const node of reversedNodesInDecreasingDepth) {
        nodeIDToNode[node.id] = node;
        if (!(node.id in nodesDepths)) {
          nodesDepths[node.id] = 0;
        }
        let depth = nodesDepths[node.id];
        const previousDepth = layersDepths[node.outboundLayer.id] == null ? 0 : layersDepths[node.outboundLayer.id];
        depth = Math.max(depth, previousDepth);
        layersDepths[node.outboundLayer.id] = depth;
        layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;
        nodesDepths[node.id] = depth;
        for (let i = 0;i < node.inboundLayers.length; i++) {
          const inboundLayer = node.inboundLayers[i];
          const nodeIndex = node.nodeIndices[i];
          const inboundNode = inboundLayer.inboundNodes[nodeIndex];
          const previousDepth2 = nodesDepths[inboundNode.id] == null ? 0 : nodesDepths[inboundNode.id];
          nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth2);
          nodeIDToNode[inboundNode.id] = inboundNode;
        }
      }
      const nodesByDepth = {};
      for (const nodeID in nodesDepths) {
        const depth = nodesDepths[nodeID];
        if (!(depth in nodesByDepth)) {
          nodesByDepth[depth] = [];
        }
        nodesByDepth[depth].push(nodeIDToNode[nodeID]);
      }
      const layersByDepth = {};
      for (const layerID in layersDepths) {
        const depth = layersDepths[layerID];
        if (!(depth in layersByDepth)) {
          layersByDepth[depth] = [];
        }
        layersByDepth[depth].push(layerIDToLayer[layerID]);
      }
      let depthKeys = Object.keys(layersByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      this.layers = [];
      for (const depth of depthKeys) {
        const layersForDepth = layersByDepth[depth];
        layersForDepth.sort((a, b) => {
          const aIndex = layerIndices[a.id];
          const bIndex = layerIndices[b.id];
          if (aIndex < bIndex) {
            return -1;
          }
          if (aIndex > bIndex) {
            return 1;
          }
          return 0;
        });
        for (const layer of layersForDepth) {
          if (layer instanceof Container) {
            this.internalContainerRefs.push(layer);
          }
          this.layers.push(layer);
        }
      }
      this.layersByDepth = layersByDepth;
      depthKeys = Object.keys(nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      const computableTensors = this.inputs.slice();
      const layersWithCompleteInput = [];
      for (const depth of depthKeys) {
        for (const node of nodesByDepth[depth]) {
          const layer = node.outboundLayer;
          if (layer != null) {
            for (const x of node.inputTensors) {
              if (computableTensors.indexOf(x) === -1) {
                throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x}` + ` at layer "${layer.name}". ` + "The following previous layers were accessed without " + `issue: ${layersWithCompleteInput}`);
              }
            }
            for (const x of node.outputTensors) {
              computableTensors.push(x);
            }
            layersWithCompleteInput.push(layer.name);
          }
        }
      }
      this.nodesByDepth = nodesByDepth;
      const allNames = this.layers.map((x) => x.name);
      for (const name of allNames) {
        const numOccurrences = allNames.filter((x) => x === name).length;
        if (numOccurrences !== 1) {
          throw new RuntimeError(`The name "${name}" is used ${numOccurrences} times ` + "in the model. All layer names should be unique. Layer names: " + JSON.stringify(allNames));
        }
      }
      this.outboundNodes = [];
      this.inboundNodes = [];
      new Node({
        outboundLayer: this,
        inboundLayers: [],
        nodeIndices: [],
        tensorIndices: [],
        inputTensors: this.inputs,
        outputTensors: this.outputs,
        inputMasks: this.inputs.map((x) => null),
        outputMasks: this.outputs.map((x) => null),
        inputShapes: this.inputs.map((x) => x.shape),
        outputShapes: this.outputs.map((x) => x.shape)
      });
      this.built = true;
      this._refCount = 1;
    }
    assertNotDisposed() {
      if (this._refCount === 0) {
        throw new Error(`Container '${this.name}' is already disposed.`);
      }
    }
    dispose() {
      this.assertNotDisposed();
      const result = { refCountAfterDispose: null, numDisposedVariables: 0 };
      if (--this._refCount === 0) {
        for (const layer of this.layers) {
          result.numDisposedVariables += layer.dispose().numDisposedVariables;
        }
        for (const container of this.internalContainerRefs) {
          result.numDisposedVariables += container.dispose().numDisposedVariables;
        }
      }
      result.refCountAfterDispose = this._refCount;
      return result;
    }
    get trainable() {
      return this.trainable_;
    }
    set trainable(trainable) {
      this.layers.forEach((layer) => {
        layer._trainableWeights.forEach((w) => w.trainable = trainable);
      });
      this.trainable_ = trainable;
    }
    get trainableWeights() {
      if (this._trainableWeights.length > 0) {
        throw new ValueError("Container instance unexpectedly contains _trainableWeights." + "The trainable weights of a Container are a union of the " + "trainable weights of its consituent Layers. Its own " + "_trainableWeights must remain an empty Array.");
      }
      if (!this.trainable) {
        return [];
      }
      let weights = [];
      for (const layer of this.layers) {
        weights = weights.concat(layer.trainableWeights);
      }
      return weights;
    }
    get nonTrainableWeights() {
      const weights = [];
      for (const layer of this.layers) {
        weights.push(...layer.nonTrainableWeights);
      }
      if (!this.trainable) {
        const trainableWeights = [];
        for (const layer of this.layers) {
          trainableWeights.push(...layer.trainableWeights);
        }
        return trainableWeights.concat(weights);
      }
      return weights;
    }
    get weights() {
      return this.trainableWeights.concat(this.nonTrainableWeights);
    }
    loadWeights(weights, strict = true) {
      const nameToWeight = {};
      let totalWeightsCount = 0;
      const modelIsKerasSavedModelFormat = isKerasSavedModelFormat(weights);
      if (modelIsKerasSavedModelFormat) {
        this.parseWeights(weights);
      }
      for (const layer of this.layers) {
        for (const [index, weight] of layer.weights.entries()) {
          const parsedName = modelIsKerasSavedModelFormat ? `${weight.name.split("/").slice(0, -1).join("/") + "/"}${index}` : weight.originalName;
          if (nameToWeight[parsedName] != null) {
            throw new ValueError(`Duplicate weight name: ${parsedName}`);
          }
          nameToWeight[parsedName] = weight;
          totalWeightsCount++;
        }
      }
      const weightValueTuples = [];
      for (const name in weights) {
        let validatedName = name;
        if (nameToWeight[name] == null) {
          const tokens = name.split("/");
          const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);
          validatedName = shortenNameArray.join("/");
        }
        if (nameToWeight[validatedName] != null) {
          weightValueTuples.push([nameToWeight[validatedName], weights[name]]);
        } else if (strict) {
          throw new ValueError(`Provided weight data has no target variable: ${name}`);
        }
        delete nameToWeight[validatedName];
      }
      if (strict) {
        const unsetNames = [];
        for (const name in nameToWeight) {
          unsetNames.push(name);
        }
        if (unsetNames.length > 0) {
          throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ` + `${unsetNames}`);
        }
      }
      batchSetValue(weightValueTuples);
    }
    parseWeights(weights) {
      for (const key in Object.keys(weights)) {
        const listParts = key.split("/");
        const list = ["vars", "layer_checkpoint_dependencies"];
        const newKey = listParts.map((str) => {
          if (str.startsWith("_")) {
            return str.slice(1);
          }
          return str;
        }).filter((str) => !list.includes(str)).join("/");
        if (newKey !== key) {
          weights[newKey] = weights[key];
          delete weights[key];
        }
      }
    }
    updatedConfig() {
      const theConfig = this.getConfig();
      const modelConfig = {};
      modelConfig["className"] = this.getClassName();
      modelConfig["config"] = theConfig;
      modelConfig["kerasVersion"] = `tfjs-layers ${version3}`;
      modelConfig["backend"] = "TensorFlow.js";
      return modelConfig;
    }
    toJSON(unused, returnString = true) {
      const modelConfig = convertTsToPythonic(this.updatedConfig());
      return returnString ? JSON.stringify(modelConfig) : modelConfig;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = toList(inputs);
        const feedDict = new FeedDict;
        for (let i = 0;i < this.inputs.length; ++i) {
          feedDict.add(this.inputs[i], inputs[i]);
        }
        return execute(this.outputs, feedDict, kwargs);
      });
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        inputs = toList(inputs);
        let masks;
        if (mask == null) {
          masks = pyListRepeat(null, inputs.length);
        } else {
          masks = toList(mask);
        }
        return this.runInternalGraph(inputs, masks)[1];
      });
    }
    computeOutputShape(inputShape) {
      const inputShapes = normalizeShapeList(inputShape);
      if (inputShapes.length !== this.inputLayers.length) {
        throw new ValueError(`Invalid inputShape argument ${inputShape}: ` + `model has ${this.inputLayers.length} tensor inputs.`);
      }
      const layersToOutputShapes = {};
      for (let i = 0;i < inputShapes.length; i++) {
        const layer = this.inputLayers[i];
        const inputShape2 = inputShapes[i];
        const shapeKey = layer.name + "_0_0";
        layersToOutputShapes[shapeKey] = inputShape2;
      }
      const depthKeys = Object.keys(this.nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      if (depthKeys.length > 1) {
        for (const depth of depthKeys) {
          const nodes = this.nodesByDepth[depth];
          for (const node of nodes) {
            const layer = node.outboundLayer;
            if (this.inputLayers.map((x) => x.id).indexOf(layer.id) !== -1) {
              continue;
            }
            const inputShapes2 = [];
            for (let j = 0;j < node.inboundLayers.length; j++) {
              const inboundLayer = node.inboundLayers[j];
              const nodeIndex2 = node.nodeIndices[j];
              const tensorIndex = node.tensorIndices[j];
              const shapeKey = `${inboundLayer.name}_${nodeIndex2}_${tensorIndex}`;
              const inputShape2 = layersToOutputShapes[shapeKey];
              inputShapes2.push(inputShape2);
            }
            const outputShape = layer.computeOutputShape(singletonOrArray(inputShapes2));
            const outputShapes2 = normalizeShapeList(outputShape);
            const nodeIndex = layer.inboundNodes.indexOf(node);
            for (let j = 0;j < outputShapes2.length; j++) {
              const shapeKey = `${layer.name}_${nodeIndex}_${j}`;
              layersToOutputShapes[shapeKey] = outputShapes2[j];
            }
          }
        }
      }
      const outputShapes = [];
      const outputShapeKeys = [];
      for (let i = 0;i < this.outputLayers.length; i++) {
        const layer = this.outputLayers[i];
        const nodeIndex = this.outputLayersNodeIndices[i];
        const tensorIndex = this.outputLayersTensorIndices[i];
        const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;
        outputShapeKeys.push(shapeKey);
      }
      for (let i = 0;i < outputShapeKeys.length; i++) {
        const key = outputShapeKeys[i];
        assert2(key in layersToOutputShapes);
        outputShapes.push(layersToOutputShapes[key]);
      }
      return singletonOrArray(outputShapes);
    }
    runInternalGraph(inputs, masks) {
      if (masks == null) {
        masks = pyListRepeat(null, inputs.length);
      }
      const tensorMap = {};
      for (let i = 0;i < this.inputs.length; ++i) {
        const x = this.inputs[i];
        const y = inputs[i];
        const mask = masks[i];
        tensorMap[x.id] = [y, mask];
      }
      const depthKeys = Object.keys(this.nodesByDepth).map((x) => parseInt(x, 10)).sort(reverseNumberCompare);
      for (const depth of depthKeys) {
        const nodes = this.nodesByDepth[depth];
        for (const node of nodes) {
          const layer = node.outboundLayer;
          const referenceInputTensors = node.inputTensors;
          const referenceOutputTensors = node.outputTensors;
          const computedData = new Array;
          for (const x of referenceInputTensors) {
            if (x.id in tensorMap) {
              computedData.push(tensorMap[x.id]);
            }
          }
          if (computedData.length === referenceInputTensors.length) {
            let kwargs = {};
            let computedTensors;
            let computedMasks;
            let outputTensors2;
            let outputMasks2;
            if (node.callArgs != null) {
              kwargs = node.callArgs;
            }
            if (computedData.length === 1) {
              const [computedTensor, computedMask] = computedData[0];
              if (kwargs["mask"] == null) {
                kwargs["mask"] = computedMask;
              }
              outputTensors2 = toList(layer.call(computedTensor, kwargs));
              outputMasks2 = toList(layer.computeMask(computedTensor, computedMask));
              computedTensors = [computedTensor];
              computedMasks = [computedMask];
            } else {
              computedTensors = computedData.map((x) => x[0]);
              computedMasks = computedData.map((x) => x[1]);
              if (kwargs["mask"] == null) {
                kwargs["mask"] = computedMasks;
              }
              outputTensors2 = toList(layer.call(computedTensors, kwargs));
              outputMasks2 = toList(layer.computeMask(computedTensors, computedMasks));
            }
            if (layer.activityRegularizer) {
              throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the " + "presence of activity regularizer(s) is not supported yet.");
            }
            for (let i = 0;i < referenceOutputTensors.length; ++i) {
              const x = referenceOutputTensors[i];
              const y = outputTensors2[i];
              const mask = outputMasks2[i];
              tensorMap[x.id] = [y, mask];
            }
          }
        }
      }
      const outputTensors = [];
      const outputMasks = [];
      const outputShapes = [];
      for (const x of this.outputs) {
        assert2(x.id in tensorMap, `Could not compute output ${x.name} : ${x.id}`);
        const [tensor153, mask] = tensorMap[x.id];
        outputShapes.push(tensor153.shape);
        outputTensors.push(tensor153);
        outputMasks.push(mask);
      }
      return [outputTensors, outputMasks, outputShapes];
    }
    buildNodeConversionMap(layers) {
      const nodeConversionMap = {};
      let keptNodes;
      for (const layer of this.layers) {
        keptNodes = layer instanceof Container ? 1 : 0;
        for (let originalNodeIndex = 0;originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
          const nodeKey = Container.nodeKey(layer, originalNodeIndex);
          if (this.containerNodes.has(nodeKey)) {
            nodeConversionMap[nodeKey] = keptNodes;
            keptNodes += 1;
          }
        }
      }
      return nodeConversionMap;
    }
    getLayer(nameOrIndex, index) {
      if (index != null) {
        return this.findLayer(index);
      } else {
        if (nameOrIndex == null) {
          throw new ValueError("Provide either a layer name or layer index");
        }
        if (typeof nameOrIndex === "number") {
          return this.findLayer(nameOrIndex);
        }
      }
      for (const layer of this.layers) {
        if (layer.name === nameOrIndex) {
          return layer;
        }
      }
      throw new ValueError(`No such layer: ${nameOrIndex}`);
    }
    findLayer(index) {
      if (this.layers.length <= index) {
        throw new ValueError(`Was asked to retrieve layer at index ${index}, but model only ` + `has ${this.layers.length} layer(s).`);
      } else {
        return this.layers[index];
      }
    }
    calculateLosses() {
      return tidy(() => {
        const losses3 = [];
        for (const layer of this.layers) {
          for (let nodeIndex = 0;nodeIndex < layer.inboundNodes.length; ++nodeIndex) {
            const nodeKey = Container.nodeKey(layer, nodeIndex);
            if (this.containerNodes.has(nodeKey)) {
              losses3.push(...layer.calculateLosses());
            }
          }
        }
        return losses3;
      });
    }
    getConfig() {
      const config = { name: this.name };
      const nodeConversionMap = this.buildNodeConversionMap(this.layers);
      const layerConfigs = [];
      for (const layer of this.layers) {
        const layerClassName = layer.getClassName();
        const layerConfig = layer.getConfig();
        const filteredInboundNodes = [];
        for (let originalNodeIndex = 0;originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {
          const node = layer.inboundNodes[originalNodeIndex];
          const nodeKey = Container.nodeKey(layer, originalNodeIndex);
          let kwargs = {};
          if (this.containerNodes.has(nodeKey)) {
            if (node.callArgs) {
              try {
                JSON.stringify(node.callArgs);
                kwargs = node.callArgs;
              } catch (err) {
                console.warn(`Layer ${layer.name} was passed ` + `non-serializable keyword arguments: ` + `${node.callArgs}. They will not be included ` + `in the serialized model (and thus will be ` + `missing at deserialization time).`);
                kwargs = {};
              }
            }
            if (node.inboundLayers.length > 0) {
              const nodeData = [];
              for (let i = 0;i < node.inboundLayers.length; i++) {
                const inboundLayer = node.inboundLayers[i];
                const nodeIndex = node.nodeIndices[i];
                const tensorIndex = node.tensorIndices[i];
                const nodeKey2 = Container.nodeKey(inboundLayer, nodeIndex);
                let newNodeIndex = nodeConversionMap[nodeKey2];
                if (newNodeIndex == null) {
                  newNodeIndex = 0;
                }
                nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);
              }
              filteredInboundNodes.push(nodeData);
            }
          }
        }
        const dict = {};
        dict["name"] = layer.name;
        dict["className"] = layerClassName;
        dict["config"] = layerConfig;
        dict["inboundNodes"] = filteredInboundNodes;
        layerConfigs.push(dict);
      }
      config["layers"] = layerConfigs;
      const modelInputs = [];
      for (let i = 0;i < this.inputLayers.length; i++) {
        const layer = this.inputLayers[i];
        const nodeIndex = this.inputLayersNodeIndices[i];
        const nodeKey = Container.nodeKey(layer, nodeIndex);
        if (!this.containerNodes.has(nodeKey)) {
          continue;
        }
        let newNodeIndex = nodeConversionMap[nodeKey];
        if (newNodeIndex === null || newNodeIndex === undefined) {
          newNodeIndex = 0;
        }
        const tensorIndex = this.inputLayersTensorIndices[i];
        modelInputs.push([layer.name, newNodeIndex, tensorIndex]);
      }
      config["inputLayers"] = modelInputs;
      const modelOutputs = [];
      for (let i = 0;i < this.outputLayers.length; i++) {
        const layer = this.outputLayers[i];
        const nodeIndex = this.outputLayersNodeIndices[i];
        const nodeKey = Container.nodeKey(layer, nodeIndex);
        if (!this.containerNodes.has(nodeKey)) {
          continue;
        }
        let newNodeIndex = nodeConversionMap[nodeKey];
        if (newNodeIndex === null || newNodeIndex === undefined) {
          newNodeIndex = 0;
        }
        const tensorIndex = this.outputLayersTensorIndices[i];
        modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);
      }
      config["outputLayers"] = modelOutputs;
      return config;
    }
    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {
      const createdLayers = {};
      const unprocessedNodes = {};
      function addUnprocessedNode(layer, nodeData) {
        if (!(layer.name in unprocessedNodes)) {
          unprocessedNodes[layer.name] = [nodeData];
        } else {
          unprocessedNodes[layer.name].push(nodeData);
        }
      }
      function processNode(layer, nodeData) {
        const inputTensors2 = [];
        let kwargs;
        for (const inputData of nodeData) {
          const inboundLayerName = inputData[0];
          const inboundNodeIndex = inputData[1];
          const inboundTensorIndex = inputData[2];
          kwargs = inputData[3] == null ? {} : inputData[3];
          if (!(inboundLayerName in createdLayers)) {
            addUnprocessedNode(layer, nodeData);
            return;
          }
          const inboundLayer = createdLayers[inboundLayerName];
          if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {
            addUnprocessedNode(layer, nodeData);
            return;
          }
          const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];
          inputTensors2.push(inboundNode.outputTensors[inboundTensorIndex]);
        }
        if (inputTensors2.length > 0) {
          layer.apply(singletonOrArray(inputTensors2), kwargs);
        }
      }
      function processLayer(layerData) {
        const layerName = layerData["name"];
        const layer = deserialize(layerData, config["customObjects"] != null ? config["customObjects"] : {});
        layer.setFastWeightInitDuringBuild(fastWeightInit);
        createdLayers[layerName] = layer;
        const inboundNodesData = layerData["inboundNodes"];
        inboundNodesData.forEach((nodeData) => {
          if (!(nodeData instanceof Array)) {
            throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);
          }
          addUnprocessedNode(layer, nodeData);
        });
      }
      const name = config["name"];
      const layersFromConfig = config["layers"];
      for (const layerData of layersFromConfig) {
        processLayer(layerData);
      }
      while (!isObjectEmpty(unprocessedNodes)) {
        for (const layerData of layersFromConfig) {
          const layer = createdLayers[layerData["name"]];
          if (layer.name in unprocessedNodes) {
            const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];
            delete unprocessedNodes[layer.name];
            for (const nodeData of currentUnprocessedNodesForLayer) {
              processNode(layer, nodeData);
            }
          }
        }
      }
      const inputTensors = [];
      const outputTensors = [];
      const inputLayersFromConfig = config["inputLayers"];
      for (const layerData of inputLayersFromConfig) {
        const layerName = layerData[0];
        const nodeIndex = layerData[1];
        const tensorIndex = layerData[2];
        assert2(layerName in createdLayers);
        const layer = createdLayers[layerName];
        const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
        inputTensors.push(layerOutputTensors[tensorIndex]);
      }
      const outputLayersFromConfig = config["outputLayers"];
      for (const layerData of outputLayersFromConfig) {
        const layerName = layerData[0];
        const nodeIndex = layerData[1];
        const tensorIndex = layerData[2];
        assert2(layerName in createdLayers);
        const layer = createdLayers[layerName];
        const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;
        outputTensors.push(layerOutputTensors[tensorIndex]);
      }
      return new cls({ inputs: inputTensors, outputs: outputTensors, name });
    }
    get stateful() {
      if (this._stateful) {
        throw new ValueError("Container instance unexpectedly has _stateful = true. The " + "statefulness of a Container is determined by the Layers it " + "contains. Its _stateful property must remain the default false.");
      }
      for (const layer of this.layers) {
        if (layer.stateful) {
          return true;
        }
      }
      return false;
    }
    resetStates() {
      tidy(() => {
        this.layers.forEach((layer) => {
          if (layer.stateful) {
            layer.resetStates();
          }
        });
      });
    }
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/training_utils.js
function standardizeSampleOrClassWeights(xWeight, outputNames, weightType) {
  const numOutputs = outputNames.length;
  if (xWeight == null || Array.isArray(xWeight) && xWeight.length === 0) {
    return outputNames.map((name) => null);
  }
  if (numOutputs === 1) {
    if (Array.isArray(xWeight) && xWeight.length === 1) {
      return xWeight;
    } else if (typeof xWeight === "object" && outputNames[0] in xWeight) {
      return [xWeight[outputNames[0]]];
    } else {
      return [xWeight];
    }
  }
  if (Array.isArray(xWeight)) {
    if (xWeight.length !== numOutputs) {
      throw new Error(`Provided ${weightType} is an array of ${xWeight.length} ` + `element(s), but the model has ${numOutputs} outputs. ` + `Make sure a set of weights is provided for each model output.`);
    }
    return xWeight;
  } else if (typeof xWeight === "object" && Object.keys(xWeight).length > 0 && typeof xWeight[Object.keys(xWeight)[0]] === "object") {
    const output = [];
    outputNames.forEach((outputName) => {
      if (outputName in xWeight) {
        output.push(xWeight[outputName]);
      } else {
        output.push(null);
      }
    });
    return output;
  } else {
    throw new Error(`The model has multiple (${numOutputs}) outputs, ` + `so ${weightType} must be either an array with ` + `${numOutputs} elements or an object with ${outputNames} keys. ` + `Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`);
  }
}
function standardizeClassWeights(classWeight, outputNames) {
  return standardizeSampleOrClassWeights(classWeight, outputNames, "classWeight");
}
async function standardizeWeights(y, sampleWeight, classWeight, sampleWeightMode) {
  if (sampleWeight != null || sampleWeightMode != null) {
    throw new Error("Support sampleWeight is not implemented yet");
  }
  if (classWeight != null) {
    const yClasses = tidy(() => {
      if (y.shape.length === 1) {
        return clone(y);
      } else if (y.shape.length === 2) {
        if (y.shape[1] > 1) {
          const axis = 1;
          return argMax(y, axis);
        } else if (y.shape[1] === 1) {
          return reshape(y, [y.shape[0]]);
        } else {
          throw new Error(`Encountered unexpected last-dimension size (${y.shape[1]}) ` + `during handling of class weights. The size is expected to be ` + `>= 1.`);
        }
      } else {
        throw new Error(`Unexpected rank of target (y) tensor (${y.rank}) during ` + `handling of class weights. The rank is expected to be 1 or 2.`);
      }
    });
    const yClassIndices = Array.from(await yClasses.data());
    dispose(yClasses);
    const classSampleWeight = [];
    yClassIndices.forEach((classIndex) => {
      if (classWeight[classIndex] == null) {
        throw new Error(`classWeight must contain all classes in the training data. ` + `The class ${classIndex} exists in the data but not in ` + `classWeight`);
      } else {
        classSampleWeight.push(classWeight[classIndex]);
      }
    });
    return tensor1d(classSampleWeight, "float32");
  } else {
    return null;
  }
}
function computeWeightedLoss2(losses3, sampleWeights) {
  return mul(losses3, sampleWeights);
}
var init_training_utils = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/training_dataset.js
function standardizeDataIteratorOutput(model, iteratorOut) {
  let xs;
  let ys;
  const iteratorOutObj = iteratorOut;
  xs = iteratorOutObj["xs"];
  ys = iteratorOutObj["ys"];
  exports_util.assert(xs != null && ys != null, () => "A Dataset iterator for fitDataset() is expected to generate " + "objects of the form `{xs: xVal, ys: yVal}`, where the two " + "values may be `tf.Tensor`, an array of Tensors, or a map of " + "string to Tensor.  The provided Dataset instead generates " + `${iteratorOut}`);
  const flattenedXs = flattenTensorOrArrayOrMap("input", model.inputNames, xs);
  const flattenedYs = flattenTensorOrArrayOrMap("output", model.outputNames, ys);
  const batchSize = flattenedXs[0].shape[0];
  exports_util.assert(flattenedXs.length === model.inputs.length, () => `LayersModel has ${model.inputs.length} inputs, but the dataset ` + `provides ${flattenedXs.length} inputs.  (Expected input keys: ` + `${JSON.stringify(model.inputNames)})`);
  exports_util.assert(flattenedYs.length === model.outputs.length, () => `LayersModel has ${model.outputs.length} outputs, but the dataset ` + `provides ${flattenedYs.length} outputs.  (Expected output keys: ` + `${JSON.stringify(model.outputNames)})`);
  for (let xIndex = 0;xIndex < flattenedXs.length; xIndex++) {
    exports_util.assert(flattenedXs[xIndex].shape[0] === batchSize, () => `Batch size mismatch: input ` + `${model.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; ` + `expected  ${batchSize} based on input ${model.inputNames[0]}.`);
  }
  for (let yIndex = 0;yIndex < flattenedYs.length; yIndex++) {
    exports_util.assert(flattenedYs[yIndex].shape[0] === batchSize, () => `Batch size mismatch: output ` + `${model.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; ` + `expected  ${batchSize} based on input ${model.inputNames[0]}.`);
  }
  return { xs: flattenedXs, ys: flattenedYs };
}
function flattenTensorOrArrayOrMap(inputOrOutput, names, values) {
  if (values instanceof Tensor) {
    return [values];
  } else if (Array.isArray(values)) {
    exports_util.assert(values.length === names.length, () => `Received an array of ${values.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`);
    return values;
  } else {
    const result = [];
    for (const name of names) {
      if (values[name] == null) {
        throw new ValueError(`The feature data generated by the dataset lacks the required ` + `${inputOrOutput} key '${name}'.`);
      }
      result.push(values[name]);
    }
    return result;
  }
}
function standardizeTensorValidationData(data) {
  if (data.length === 3) {
    throw new NotImplementedError("Validation with sample weights is not implemented yet.");
  }
  return { xs: data[0], ys: data[1] };
}
async function fitDataset(model, dataset, args) {
  const hasBatchesPerEpoch = args.batchesPerEpoch != null;
  exports_util.assert(model.optimizer != null, () => "You must compile a model before training/testing. Use " + "LayersModel.compile(modelCompileConfig).");
  exports_util.assert(args != null, () => `For fitDataset(), the 2nd argument (config) is required, ` + `but it is not provided in this call.`);
  exports_util.assert(args.epochs != null && args.epochs > 0 && Number.isInteger(args.epochs), () => `For fitDataset(), config.epochs is expected to be a positive ` + `integer, but got ${args.epochs}`);
  exports_util.assert(!hasBatchesPerEpoch || args.batchesPerEpoch > 0 && Number.isInteger(args.batchesPerEpoch), () => `For fitDataset(), config.batchesPerEpoch is expected to be a ` + `positive integer if specified, but got ${args.batchesPerEpoch}`);
  exports_util.assert(args["validationSplit"] == null, () => "`validationSplit` is not supported by `fitDataset()`. " + "Use validationData instead.");
  if (model.isTraining) {
    throw new Error("Cannot start training because another fit() call is ongoing.");
  }
  model.isTraining = true;
  try {
    const doValidation = args.validationData != null;
    let valXs;
    let valYs;
    if (doValidation) {
      if (isDatasetObject(args.validationData)) {
        exports_util.assert(args.validationBatches == null || args.validationBatches > 0 && Number.isInteger(args.validationBatches), () => `For fitDataset() with dataset-based validation, ` + `config.validationBatches is expected not to be provided, ` + `or to be a positive integer, ` + `but got ${args.validationBatches}`);
      } else {
        const validationData = standardizeTensorValidationData(args.validationData);
        valXs = validationData.xs;
        valYs = validationData.ys;
      }
    }
    const trainFunction = model.makeTrainFunction();
    const outLabels = model.getDedupedMetricsNames();
    let callbackMetrics;
    if (doValidation) {
      callbackMetrics = outLabels.slice().concat(outLabels.map((n) => "val_" + n));
    } else {
      callbackMetrics = outLabels.slice();
    }
    const callbacks = standardizeCallbacks(args.callbacks, args.yieldEvery);
    const verbose = args.verbose == null ? 1 : args.verbose;
    const { callbackList, history } = configureCallbacks(callbacks, verbose, args.epochs, null, null, getStepsPerEpoch(dataset, args), null, doValidation, callbackMetrics);
    callbackList.setModel(model);
    model.history = history;
    await callbackList.onTrainBegin();
    model.stopTraining_ = false;
    let epoch = args.initialEpoch == null ? 0 : args.initialEpoch;
    let dataIterator = await dataset.iterator();
    while (epoch < args.epochs) {
      const epochLogs = {};
      await callbackList.onEpochBegin(epoch);
      let stepsDone = 0;
      let batchIndex = 0;
      if (!hasBatchesPerEpoch) {
        dataIterator = await dataset.iterator();
      }
      while (hasBatchesPerEpoch ? stepsDone < args.batchesPerEpoch : true) {
        const iteratorOut = await dataIterator.next();
        if (hasBatchesPerEpoch && iteratorOut.done) {
          console.warn("You provided `batchesPerEpoch` as " + `${args.batchesPerEpoch}, ` + "but your dataset iterator ran out of data after " + `${stepsDone} batches; ` + "interrupting training. Make sure that your " + "dataset can generate at least `batchesPerEpoch * epochs` " + "batches (in this case, " + `${args.batchesPerEpoch * args.epochs} batches). ` + "You may need to use the repeat() function when building " + "your dataset.");
          break;
        }
        if (iteratorOut.value != null) {
          const { xs, ys } = standardizeDataIteratorOutput(model, iteratorOut.value);
          const batchLogs = {};
          batchLogs["batch"] = batchIndex;
          batchLogs["size"] = xs[0].shape[0];
          await callbackList.onBatchBegin(batchIndex, batchLogs);
          const sampleWeights = [];
          if (args.classWeight != null) {
            const standardClassWeights = standardizeClassWeights(args.classWeight, model.outputNames);
            for (let i = 0;i < standardClassWeights.length; ++i) {
              sampleWeights.push(await standardizeWeights(ys[i], null, standardClassWeights[i]));
            }
          }
          const ins = xs.concat(ys).concat(sampleWeights);
          const outs = trainFunction(ins);
          dispose(ins);
          for (let i = 0;i < outLabels.length; ++i) {
            const label = outLabels[i];
            const out = outs[i];
            batchLogs[label] = out;
            keep(out);
          }
          await callbackList.onBatchEnd(batchIndex, batchLogs);
          disposeTensorsInLogs(batchLogs);
          batchIndex++;
          stepsDone++;
        }
        if (hasBatchesPerEpoch ? stepsDone >= args.batchesPerEpoch : iteratorOut.done) {
          if (doValidation) {
            let valOuts;
            if (isDatasetObject(args.validationData)) {
              valOuts = toList(await model.evaluateDataset(args.validationData, { batches: args.validationBatches }));
            } else {
              valOuts = toList(model.evaluate(valXs, valYs, {
                batchSize: args.validationBatchSize == null ? DEFAULT_VALIDATION_BATCH_SIZE : args.validationBatchSize,
                verbose: 0
              }));
            }
            for (let i = 0;i < model.metricsNames.length; ++i) {
              epochLogs[`val_${model.metricsNames[i]}`] = valOuts[i];
            }
          }
          break;
        }
        if (model.stopTraining_) {
          break;
        }
      }
      await callbackList.onEpochEnd(epoch, epochLogs);
      epoch++;
      if (model.stopTraining_) {
        break;
      }
    }
    await callbackList.onTrainEnd();
    await model.history.syncData();
    return model.history;
  } finally {
    model.isTraining = false;
  }
}
function getStepsPerEpoch(dataset, args) {
  let stepsPerEpoch = null;
  if (args.batchesPerEpoch != null) {
    stepsPerEpoch = args.batchesPerEpoch;
  } else if (Number.isFinite(dataset.size)) {
    stepsPerEpoch = dataset.size;
  }
  return stepsPerEpoch;
}
function isDatasetObject(dataset) {
  return typeof dataset.iterator === "function";
}
function isLazyIteratorObject(iterator) {
  return typeof iterator.next === "function";
}
async function evaluateDataset(model, dataset, args) {
  args = args || {};
  const hasBatches = args.batches != null;
  const f = model.testFunction;
  let outs = [];
  if (args.verbose > 0) {
    throw new NotImplementedError("Verbose mode is not implemented yet.");
  }
  exports_util.assert(!hasBatches || args.batches > 0 && Number.isInteger(args.batches), () => "Test loop expects `batches` to be a positive integer, but " + `received ${JSON.stringify(args.batches)}`);
  const dataIterator = isLazyIteratorObject(dataset) ? dataset : await dataset.iterator();
  let numExamples = 0;
  let batch = 0;
  while (hasBatches ? batch < args.batches : true) {
    const iteratorOut = await dataIterator.next();
    outs = tidy(() => {
      if (iteratorOut.value) {
        const { xs, ys } = standardizeDataIteratorOutput(model, iteratorOut.value);
        const xsAndYs = xs.concat(ys);
        const batchOuts = tidy(() => f(xsAndYs));
        dispose(xsAndYs);
        if (batch === 0) {
          for (let i = 0;i < batchOuts.length; ++i) {
            outs.push(scalar(0));
          }
        }
        const batchSize = xsAndYs[0].shape[0];
        for (let i = 0;i < batchOuts.length; ++i) {
          const batchOut = batchOuts[i];
          const oldScalar = outs[i];
          outs[i] = tidy(() => add2(outs[i], mul(batchSize, batchOut)));
          if (batch > 0) {
            dispose(oldScalar);
          }
        }
        dispose(batchOuts);
        numExamples += batchSize;
        ++batch;
      }
      return outs;
    });
    if (iteratorOut.done) {
      if (hasBatches) {
        console.warn("Your dataset iterator ran out of data during evaluateDataset(). " + "Interrupting evalution. Make sure that your " + "dataset can generate at least `batches` " + `batches (in this case, ${args.batches} batches). ` + "You may need to use the repeat() function when building " + "your dataset.");
      }
      break;
    }
  }
  for (let i = 0;i < outs.length; ++i) {
    const oldScalar = outs[i];
    outs[i] = div(outs[i], numExamples);
    dispose(oldScalar);
  }
  return singletonOrArray(outs);
}
var DEFAULT_VALIDATION_BATCH_SIZE = 32;
var init_training_dataset = __esm(() => {
  init_dist();
  init_dist();
  init_base_callbacks();
  init_errors();
  init_logs();
  init_generic_utils();
  init_training_utils();
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/training_tensors.js
function checkBatchSize(batchSize) {
  exports_util.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);
}
function sliceArrays(arrays, start, stop) {
  if (arrays == null) {
    return [null];
  } else if (Array.isArray(arrays)) {
    return arrays.map((array) => sliceAlongFirstAxis(array, start, stop - start));
  } else {
    return sliceAlongFirstAxis(arrays, start, stop - start);
  }
}
function sliceArraysByIndices(arrays, indices) {
  return tidy(() => {
    if (arrays == null) {
      return null;
    } else if (Array.isArray(arrays)) {
      return arrays.map((array) => sliceArraysByIndices(array, indices));
    } else {
      return gather6(arrays, indices.dtype === "int32" ? indices : cast(indices, "int32"));
    }
  });
}
function makeBatches(size, batchSize) {
  const output = [];
  let batchStart = 0;
  let batchEnd = null;
  while (batchStart < size) {
    batchEnd = batchStart + batchSize;
    if (batchEnd >= size) {
      batchEnd = size;
    }
    output.push([batchStart, batchEnd]);
    batchStart = batchEnd;
  }
  return output;
}
function ensureTensorsRank2OrHigher(tensors) {
  const outs = [];
  if (tensors instanceof Tensor) {
    tensors = [tensors];
  }
  for (let i = 0;i < tensors.length; ++i) {
    const tensor153 = tensors[i];
    if (tensor153.rank === 1) {
      outs.push(expandDims2(tensor153, 1));
    } else if (tensor153.rank === 0) {
      throw new Error("Expected tensor to be at least 1D, but received a 0D tensor " + "(scalar).");
    } else {
      outs.push(tensor153);
    }
  }
  return outs;
}
function disposeNewTensors(tensors, refTensors) {
  if (tensors == null) {
    return;
  }
  const oldTensorIds = [];
  if (refTensors instanceof Tensor) {
    oldTensorIds.push(refTensors.id);
  } else if (Array.isArray(refTensors)) {
    refTensors.forEach((t) => oldTensorIds.push(t.id));
  } else if (refTensors != null) {
    for (const name in refTensors) {
      const oldTensor = refTensors[name];
      oldTensorIds.push(oldTensor.id);
    }
  }
  const tensorsToDispose = [];
  if (tensors instanceof Tensor) {
    if (oldTensorIds.indexOf(tensors.id) === -1) {
      tensorsToDispose.push(tensors);
    }
  } else if (Array.isArray(tensors)) {
    tensors.forEach((t) => {
      if (oldTensorIds.indexOf(t.id) === -1) {
        tensorsToDispose.push(t);
      }
    });
  } else if (tensors != null) {
    for (const name in tensors) {
      const tensor153 = tensors[name];
      if (oldTensorIds.indexOf(tensor153.id) === -1) {
        tensorsToDispose.push(tensor153);
      }
    }
  }
  tensorsToDispose.forEach((t) => {
    if (!t.isDisposed) {
      t.dispose();
    }
  });
}
var init_training_tensors = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/training.js
function isDataTensor(x) {
  return x instanceof Tensor;
}
function isDataArray(x) {
  return Array.isArray(x);
}
function isDataDict(x) {
  return !isDataTensor(x) && !isDataArray(x);
}
function standardizeInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
  if (names == null || names.length === 0) {
    if (data != null) {
      let gotUnexpectedData = false;
      if (isDataArray(data) && data.length > 0) {
        gotUnexpectedData = true;
      } else if (isDataDict(data)) {
        for (const key in data) {
          if (data.hasOwnProperty(key)) {
            gotUnexpectedData = true;
            break;
          }
        }
      } else {
        gotUnexpectedData = true;
      }
      if (gotUnexpectedData) {
        throw new ValueError(`Error when checking model ${exceptionPrefix} expected no data, ` + `but got ${data}`);
      }
    }
    return [];
  }
  if (data == null) {
    return names.map((name) => null);
  }
  let arrays;
  if (isDataDict(data)) {
    data = data;
    arrays = [];
    for (const name of names) {
      if (data[name] == null) {
        throw new ValueError(`No data provided for "${name}". Need data for each key in: ` + `${names}`);
      }
      arrays.push(data[name]);
    }
  } else if (isDataArray(data)) {
    data = data;
    if (data.length !== names.length) {
      throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of ` + `Tensors that you are passing to your model is not the size the ` + `model expected. Expected to see ${names.length} Tensor(s), but ` + `instead got the following list of Tensor(s): ${data}`);
    }
    arrays = data;
  } else {
    data = data;
    if (names.length > 1) {
      throw new ValueError(`The model ${exceptionPrefix} expects ${names.length} Tensor(s), ` + `but only received one Tensor. Found: Tensor with shape ${data.shape}`);
    }
    arrays = [data];
  }
  arrays = ensureTensorsRank2OrHigher(arrays);
  if (shapes != null) {
    for (let i = 0;i < names.length; ++i) {
      if (shapes[i] == null) {
        continue;
      }
      const array = arrays[i];
      if (array.shape.length !== shapes[i].length) {
        throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} ` + `to have ${shapes[i].length} dimension(s). but got array with ` + `shape ${array.shape}`);
      }
      for (let j = 0;j < shapes[i].length; ++j) {
        if (j === 0 && !checkBatchAxis) {
          continue;
        }
        const dim = array.shape[j];
        const refDim = shapes[i][j];
        if (refDim != null && refDim >= 0 && dim !== refDim) {
          throw new ValueError(`${exceptionPrefix} expected a batch of elements where each ` + `example has shape [${shapes[i].slice(1, shapes[i].length)}] ` + `(i.e.,tensor shape [*,${shapes[i].slice(1, shapes[i].length)}])` + ` but the ${exceptionPrefix} received an input with ${array.shape[0]}` + ` examples, each with shape [${array.shape.slice(1, array.shape.length)}]` + ` (tensor shape [${array.shape}])`);
        }
      }
    }
  }
  return arrays;
}
function checkArrayLengths(inputs, targets, weights) {
  const setX = unique4(inputs.map((input) => input.shape[0]));
  setX.sort();
  const setY = unique4(targets.map((target) => target.shape[0]));
  setY.sort();
  if (setX.length > 1) {
    throw new ValueError(`All input Tensors (x) should have the same number of samples. ` + `Got array shapes: ` + `${JSON.stringify(inputs.map((input) => input.shape))}`);
  }
  if (setY.length > 1) {
    throw new ValueError(`All target Tensors (y) should have the same number of samples. ` + `Got array shapes: ` + `${JSON.stringify(targets.map((target) => target.shape))}`);
  }
  if (setX.length > 0 && setY.length > 0 && !exports_util.arraysEqual(setX, setY)) {
    throw new ValueError(`Input Tensors should have the same number of samples as target ` + `Tensors. Found ${setX[0]} input sample(s) and ${setY[0]} target ` + `sample(s).`);
  }
}
function checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {
  const keyLosses = [
    meanSquaredError2,
    binaryCrossentropy,
    categoricalCrossentropy
  ];
  for (let i = 0;i < targets.length; ++i) {
    const y = targets[i];
    const loss = lossFns[i];
    const shape = outputShapes[i];
    if (loss == null) {
      continue;
    }
    if (loss === categoricalCrossentropy) {
      if (y.shape[y.shape.length - 1] === 1) {
        throw new ValueError(`You are passing a target array of shape ${y.shape} while using ` + `a loss 'categorical_crossentropy'. 'categorical_crossentropy'` + `expects targets to be binary matrices (1s and 0s) of shape ` + `[samples, classes].`);
      }
    }
    if (keyLosses.indexOf(loss) !== -1) {
      const slicedYShape = y.shape.slice(1);
      const slicedShape = shape.slice(1);
      for (let j = 0;j < slicedYShape.length; ++j) {
        const targetDim = slicedYShape[j];
        const outDim = slicedShape[j];
        if (outDim != null && targetDim !== outDim) {
          throw new ValueError(`A target Tensor with shape ${y.shape} was passed for an ` + `output of shape ${shape}, while using a loss function that ` + `expects targets to have the same shape as the output.`);
        }
      }
    }
  }
}
function checkInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = "") {
  let arrays;
  if (Array.isArray(data)) {
    if (data.length !== names.length) {
      throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of ` + `Tensors that you are passing to your model is not the size the ` + `the model expected. Expected to see ${names.length} Tensor(s),` + ` but instead got ${data.length} Tensors(s).`);
    }
    arrays = data;
  } else {
    if (names.length > 1) {
      throw new ValueError(`The model expects ${names.length} ${exceptionPrefix} Tensors, ` + `but only received one Tensor. Found: array with shape ` + `${JSON.stringify(data.shape)}.`);
    }
    arrays = [data];
  }
  if (shapes != null) {
    for (let i = 0;i < names.length; ++i) {
      if (shapes[i] == null) {
        continue;
      }
      const array = arrays[i];
      if (array.shape.length !== shapes[i].length) {
        throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} ` + `to have ${shapes[i].length} dimension(s), but got array with ` + `shape ${JSON.stringify(array.shape)}`);
      }
      for (let j = 0;j < shapes[i].length; ++j) {
        if (j === 0 && !checkBatchAxis) {
          continue;
        }
        const dim = array.shape[j];
        const refDim = shapes[i][j];
        if (refDim != null) {
          if (refDim !== dim) {
            throw new ValueError(`Error when checking ${exceptionPrefix}: expected ` + `${names[i]} to have shape ${JSON.stringify(shapes[i])} but ` + `got array with shape ${JSON.stringify(array.shape)}.`);
          }
        }
      }
    }
  }
}
function collectMetrics(metrics, outputNames) {
  if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {
    return outputNames.map((name) => []);
  }
  let wrappedMetrics;
  if (typeof metrics === "string" || typeof metrics === "function") {
    wrappedMetrics = [metrics];
  } else if (Array.isArray(metrics) || typeof metrics === "object") {
    wrappedMetrics = metrics;
  } else {
    throw new TypeError("Type of metrics argument not understood. Expected an string," + `function, Array, or Object, found: ${metrics}`);
  }
  if (Array.isArray(wrappedMetrics)) {
    return outputNames.map((name) => wrappedMetrics);
  } else {
    const nestedMetrics = [];
    for (const name of outputNames) {
      let outputMetrics = wrappedMetrics.hasOwnProperty(name) ? wrappedMetrics[name] : [];
      if (!Array.isArray(outputMetrics)) {
        outputMetrics = [outputMetrics];
      }
      nestedMetrics.push(outputMetrics);
    }
    return nestedMetrics;
  }
}
var LAYERS_MODEL_FORMAT_NAME = "layers-model", LayersModel, Functional;
var init_training = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_base_callbacks();
  init_common2();
  init_errors();
  init_serialization2();
  init_logs();
  init_losses();
  init_metrics();
  init_optimizers();
  init_user_defined_metadata();
  init_generic_utils();
  init_layer_utils();
  init_math_utils();
  init_serialization_utils();
  init_version2();
  init_container();
  init_executor();
  init_training_dataset();
  init_training_tensors();
  init_training_utils();
  LayersModel = class LayersModel extends Container {
    constructor(args) {
      super(args);
      this.isTraining = false;
    }
    summary(lineLength, positions, printFn = console.log) {
      if (!this.built) {
        throw new ValueError(`This model has never been called, thus its weights have not been ` + `created yet. So no summary can be displayed. Build the model ` + `first (e.g., by calling it on some test data).`);
      }
      printSummary(this, lineLength, positions, printFn);
    }
    compile(args) {
      if (args.loss == null) {
        args.loss = [];
      }
      this.loss = args.loss;
      if (typeof args.optimizer === "string") {
        this.optimizer_ = getOptimizer(args.optimizer);
        this.isOptimizerOwned = true;
      } else {
        if (!(args.optimizer instanceof Optimizer)) {
          throw new ValueError(`User-defined optimizer must be an instance of tf.Optimizer.`);
        }
        this.optimizer_ = args.optimizer;
        this.isOptimizerOwned = false;
      }
      let lossFunctions = [];
      if (!Array.isArray(args.loss) && typeof args.loss !== "string" && typeof args.loss !== "function") {
        args.loss = args.loss;
        for (const name in args.loss) {
          if (this.outputNames.indexOf(name) === -1) {
            throw new ValueError(`Unknown entry in loss dictionary: "${name}". ` + `Only expected the following keys: ${this.outputNames}`);
          }
        }
        for (const name of this.outputNames) {
          if (args.loss[name] == null) {
            console.warn(`Output "${name}" is missing from loss dictionary. We assume ` + `this was done on purpose, and we will not be expecting data ` + `to be passed to ${name} during training`);
          }
          lossFunctions.push(get(args.loss[name]));
        }
      } else if (Array.isArray(args.loss)) {
        if (args.loss.length !== this.outputs.length) {
          throw new ValueError(`When passing an Array as loss, it should have one entry per ` + `model output. The model has ${this.outputs.length} output(s), ` + `but you passed loss=${args.loss}.`);
        }
        const theLosses = args.loss;
        lossFunctions = theLosses.map((l) => get(l));
      } else {
        const lossFunction = get(args.loss);
        this.outputs.forEach((_) => {
          lossFunctions.push(lossFunction);
        });
      }
      this.lossFunctions = lossFunctions;
      this.feedOutputNames = [];
      this.feedOutputShapes = [];
      this.feedLossFns = [];
      for (let i = 0;i < this.outputs.length; ++i) {
        const shape = this.internalOutputShapes[i];
        const name = this.outputNames[i];
        this.feedOutputNames.push(name);
        this.feedOutputShapes.push(shape);
        this.feedLossFns.push(this.lossFunctions[i]);
      }
      const skipTargetIndices = [];
      this.metrics = args.metrics;
      this.metricsNames = ["loss"];
      this.metricsTensors = [];
      nameScope("loss", () => {
        for (let i = 0;i < this.outputs.length; ++i) {
          if (skipTargetIndices.indexOf(i) !== -1) {
            continue;
          }
          const weightedLoss = this.lossFunctions[i];
          if (this.outputs.length > 1) {
            this.metricsTensors.push([weightedLoss, i]);
            this.metricsNames.push(this.outputNames[i] + "_loss");
          }
        }
      });
      const nestedMetrics = collectMetrics(args.metrics, this.outputNames);
      const appendMetric = (outputIndex, metricName, metricTensor) => {
        if (this.outputNames.length > 1) {
          metricName = this.outputNames[outputIndex] + "_" + metricName;
        }
        this.metricsNames.push(metricName);
        this.metricsTensors.push([metricTensor, outputIndex]);
      };
      nameScope("metric", () => {
        for (let i = 0;i < this.outputs.length; ++i) {
          if (skipTargetIndices.indexOf(i) !== -1) {
            continue;
          }
          const outputMetrics = nestedMetrics[i];
          const handleMetrics = (metrics) => {
            const metricNamePrefix = "";
            let metricName;
            let accFn;
            let weightedMetricFn;
            for (const metric of metrics) {
              if (typeof metric === "string" && ["accuracy", "acc", "crossentropy", "ce"].indexOf(metric) !== -1) {
                const outputShape = this.internalOutputShapes[i];
                if (outputShape[outputShape.length - 1] === 1 || this.lossFunctions[i] === binaryCrossentropy) {
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    accFn = binaryAccuracy;
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    accFn = binaryCrossentropy2;
                  }
                } else if (this.lossFunctions[i] === sparseCategoricalCrossentropy) {
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    accFn = sparseCategoricalAccuracy;
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    accFn = sparseCategoricalCrossentropy2;
                  }
                } else {
                  if (["accuracy", "acc"].indexOf(metric) !== -1) {
                    accFn = categoricalAccuracy;
                  } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                    accFn = categoricalCrossentropy2;
                  }
                }
                let suffix;
                if (["accuracy", "acc"].indexOf(metric) !== -1) {
                  suffix = "acc";
                } else if (["crossentropy", "ce"].indexOf(metric) !== -1) {
                  suffix = "ce";
                }
                weightedMetricFn = accFn;
                metricName = metricNamePrefix + suffix;
              } else {
                const metricFn = get2(metric);
                weightedMetricFn = metricFn;
                metricName = metricNamePrefix + getLossOrMetricName(metric);
              }
              let metricResult;
              nameScope(metricName, () => {
                metricResult = weightedMetricFn;
              });
              appendMetric(i, metricName, metricResult);
            }
          };
          handleMetrics(outputMetrics);
        }
      });
      this.collectedTrainableWeights = this.trainableWeights;
    }
    checkTrainableWeightsConsistency() {
      if (this.collectedTrainableWeights == null) {
        return;
      }
      if (this.trainableWeights.length !== this.collectedTrainableWeights.length) {
        console.warn("Discrepancy between trainableweights and collected trainable " + "weights. Did you set `model.trainable` without calling " + "`model.compile()` afterwards?");
      }
    }
    evaluate(x, y, args = {}) {
      const batchSize = args.batchSize == null ? 32 : args.batchSize;
      checkBatchSize(batchSize);
      const checkBatchAxis = true;
      const standardizedOuts = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);
      try {
        const ins = standardizedOuts[0].concat(standardizedOuts[1]);
        this.makeTestFunction();
        const f = this.testFunction;
        const testOuts = this.testLoop(f, ins, batchSize, args.verbose, args.steps);
        return singletonOrArray(testOuts);
      } finally {
        disposeNewTensors(standardizedOuts[0], x);
        disposeNewTensors(standardizedOuts[1], y);
      }
    }
    async evaluateDataset(dataset, args) {
      this.makeTestFunction();
      return evaluateDataset(this, dataset, args);
    }
    checkNumSamples(ins, batchSize, steps, stepsName = "steps") {
      let numSamples;
      if (steps != null) {
        numSamples = null;
        if (batchSize != null) {
          throw new ValueError(`If ${stepsName} is set, batchSize must be null or undefined.` + `Got batchSize = ${batchSize}`);
        }
      } else if (ins != null) {
        if (Array.isArray(ins)) {
          numSamples = ins[0].shape[0];
        } else {
          numSamples = ins.shape[0];
        }
      } else {
        throw new ValueError(`Either the input data should have a defined shape, or ` + `${stepsName} shoud be specified.`);
      }
      return numSamples;
    }
    execute(inputs, outputs) {
      if (Array.isArray(outputs) && outputs.length === 0) {
        throw new ValueError("`outputs` is an empty Array, which is not allowed.");
      }
      const outputsIsArray = Array.isArray(outputs);
      const outputNames = outputsIsArray ? outputs : [outputs];
      const outputSymbolicTensors = this.retrieveSymbolicTensors(outputNames);
      const feedDict = new FeedDict;
      if (inputs instanceof Tensor) {
        inputs = [inputs];
      }
      if (Array.isArray(inputs)) {
        if (inputs.length !== this.inputs.length) {
          throw new ValueError(`The number of inputs provided (${inputs.length}) ` + `does not match the number of inputs of this model ` + `(${this.inputs.length}).`);
        }
        for (let i = 0;i < this.inputs.length; ++i) {
          feedDict.add(this.inputs[i], inputs[i]);
        }
      } else {
        for (const input of this.inputs) {
          const tensorValue = inputs[input.name];
          if (tensorValue == null) {
            throw new ValueError(`No value is provided for the model's input ${input.name}`);
          }
          feedDict.add(input, tensorValue);
        }
      }
      const executeOutputs = execute(outputSymbolicTensors, feedDict);
      return outputsIsArray ? executeOutputs : executeOutputs[0];
    }
    retrieveSymbolicTensors(symbolicTensorNames) {
      const outputSymbolicTensors = pyListRepeat(null, symbolicTensorNames.length);
      let outputsRemaining = symbolicTensorNames.length;
      for (const layer of this.layers) {
        const layerOutputs = Array.isArray(layer.output) ? layer.output : [layer.output];
        const layerOutputNames = layerOutputs.map((output) => output.name);
        for (let i = 0;i < symbolicTensorNames.length; ++i) {
          const index = layerOutputNames.indexOf(symbolicTensorNames[i]);
          if (index !== -1) {
            outputSymbolicTensors[i] = layerOutputs[index];
            outputsRemaining--;
          }
          if (outputsRemaining === 0) {
            break;
          }
        }
        if (outputsRemaining === 0) {
          break;
        }
      }
      if (outputsRemaining > 0) {
        const remainingNames = [];
        outputSymbolicTensors.forEach((tensor153, i) => {
          if (tensor153 == null) {
            remainingNames.push(symbolicTensorNames[i]);
          }
        });
        throw new ValueError(`Cannot find SymbolicTensors for output name(s): ` + `${JSON.stringify(remainingNames)}`);
      }
      return outputSymbolicTensors;
    }
    predictLoop(ins, batchSize = 32, verbose = false) {
      return tidy(() => {
        const numSamples = this.checkNumSamples(ins);
        if (verbose) {
          throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");
        }
        const batches = makeBatches(numSamples, batchSize);
        const outsBatches = this.outputs.map((output) => []);
        for (let batchIndex = 0;batchIndex < batches.length; ++batchIndex) {
          const batchOuts = tidy(() => {
            const batchStart = batches[batchIndex][0];
            const batchEnd = batches[batchIndex][1];
            const insBatch = sliceArrays(ins, batchStart, batchEnd);
            const feeds = [];
            if (Array.isArray(insBatch)) {
              for (let i = 0;i < insBatch.length; ++i) {
                feeds.push({ key: this.inputs[i], value: insBatch[i] });
              }
            } else {
              feeds.push({ key: this.inputs[0], value: insBatch });
            }
            const feedDict = new FeedDict(feeds);
            return execute(this.outputs, feedDict);
          });
          batchOuts.forEach((batchOut, i) => outsBatches[i].push(batchOut));
        }
        return singletonOrArray(outsBatches.map((batches2) => concat(batches2, 0)));
      });
    }
    predict(x, args = {}) {
      const xsRank2OrHigher = ensureTensorsRank2OrHigher(x);
      checkInputData(xsRank2OrHigher, this.inputNames, this.feedInputShapes, false);
      try {
        const batchSize = args.batchSize == null ? 32 : args.batchSize;
        checkBatchSize(batchSize);
        return this.predictLoop(xsRank2OrHigher, batchSize);
      } finally {
        disposeNewTensors(xsRank2OrHigher, x);
      }
    }
    predictOnBatch(x) {
      checkInputData(x, this.inputNames, this.feedInputShapes, true);
      const batchSize = (Array.isArray(x) ? x[0] : x).shape[0];
      return this.predictLoop(x, batchSize);
    }
    standardizeUserDataXY(x, y, checkBatchAxis = true, batchSize) {
      if (this.optimizer_ == null) {
        throw new RuntimeError("You must compile a model before training/testing. Use " + "LayersModel.compile(modelCompileArgs).");
      }
      const outputShapes = [];
      for (let i = 0;i < this.feedOutputShapes.length; ++i) {
        const outputShape = this.feedOutputShapes[i];
        const lossFn = this.feedLossFns[i];
        if (lossFn === sparseCategoricalCrossentropy) {
          outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));
        } else {
          outputShapes.push(outputShape);
        }
      }
      x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, "input");
      y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, "target");
      checkArrayLengths(x, y, null);
      checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);
      if (this.stateful && batchSize != null && batchSize > 0) {
        if (x[0].shape[0] % batchSize !== 0) {
          throw new ValueError(`In a stateful network, you should only pass inputs with a ` + `number of samples that is divisible by the batch size ` + `${batchSize}. Found: ${x[0].shape[0]} sample(s).`);
        }
      }
      return [x, y];
    }
    async standardizeUserData(x, y, sampleWeight, classWeight, checkBatchAxis = true, batchSize) {
      const [standardXs, standardYs] = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);
      if (sampleWeight != null) {
        throw new Error("sample weight is not supported yet.");
      }
      let standardSampleWeights = null;
      if (classWeight != null) {
        const classWeights = standardizeClassWeights(classWeight, this.outputNames);
        standardSampleWeights = [];
        for (let i = 0;i < classWeights.length; ++i) {
          standardSampleWeights.push(await standardizeWeights(standardYs[i], null, classWeights[i]));
        }
      }
      return [standardXs, standardYs, standardSampleWeights];
    }
    testLoop(f, ins, batchSize, verbose = 0, steps) {
      return tidy(() => {
        const numSamples = this.checkNumSamples(ins, batchSize, steps, "steps");
        const outs = [];
        if (verbose > 0) {
          throw new NotImplementedError("Verbose mode is not implemented yet.");
        }
        if (steps != null) {
          throw new NotImplementedError("steps mode in testLoop() is not implemented yet");
        } else {
          const batches = makeBatches(numSamples, batchSize);
          const indexArray = tensor1d(range4(0, numSamples));
          for (let batchIndex = 0;batchIndex < batches.length; ++batchIndex) {
            const batchStart = batches[batchIndex][0];
            const batchEnd = batches[batchIndex][1];
            const batchIds = sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);
            const insBatch = sliceArraysByIndices(ins, batchIds);
            const batchOuts = f(insBatch);
            if (batchIndex === 0) {
              for (let i = 0;i < batchOuts.length; ++i) {
                outs.push(scalar(0));
              }
            }
            for (let i = 0;i < batchOuts.length; ++i) {
              const batchOut = batchOuts[i];
              outs[i] = add2(outs[i], mul(batchEnd - batchStart, batchOut));
            }
          }
          for (let i = 0;i < outs.length; ++i) {
            outs[i] = div(outs[i], numSamples);
          }
        }
        return outs;
      });
    }
    getDedupedMetricsNames() {
      const outLabels = this.metricsNames;
      const dedupedOutLabels = [];
      for (let i = 0;i < outLabels.length; ++i) {
        const label = outLabels[i];
        let newLabel = label;
        if (count(outLabels, label) > 1) {
          const dupIndex = count(outLabels.slice(0, i), label);
          newLabel += `_${dupIndex}`;
        }
        dedupedOutLabels.push(newLabel);
      }
      return dedupedOutLabels;
    }
    makeTrainFunction() {
      return (data) => {
        const lossValues = [];
        const inputs = data.slice(0, this.inputs.length);
        const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);
        const sampleWeights = data.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2);
        const metricsValues = [];
        const totalLossFunction = () => {
          const feeds = [];
          for (let i = 0;i < this.inputs.length; ++i) {
            feeds.push({ key: this.inputs[i], value: inputs[i] });
          }
          const feedDict = new FeedDict(feeds);
          const outputs = execute(this.outputs, feedDict, { training: true });
          let totalLoss;
          for (let i = 0;i < this.lossFunctions.length; ++i) {
            const lossFunction = this.lossFunctions[i];
            let loss = lossFunction(targets[i], outputs[i]);
            if (sampleWeights[i] != null) {
              loss = computeWeightedLoss2(loss, sampleWeights[i]);
            }
            const meanLoss = mean(loss);
            lossValues.push(meanLoss);
            if (i === 0) {
              totalLoss = loss;
            } else {
              totalLoss = add2(totalLoss, loss);
            }
          }
          for (let i = 0;i < this.metricsTensors.length; ++i) {
            let weightedMetric;
            if (this.outputs.length > 1 && i < this.outputs.length) {
              weightedMetric = lossValues[i];
            } else {
              const metric = this.metricsTensors[i][0];
              const outputIndex = this.metricsTensors[i][1];
              weightedMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
            }
            keep(weightedMetric);
            metricsValues.push(weightedMetric);
          }
          totalLoss = mean(totalLoss);
          this.calculateLosses().forEach((regularizerLoss) => {
            totalLoss = add2(totalLoss, regularizerLoss);
          });
          return totalLoss;
        };
        const variables3 = this.collectedTrainableWeights.map((param) => param.read());
        const returnCost = true;
        const totalLossValue = this.optimizer_.minimize(totalLossFunction, returnCost, variables3);
        return [totalLossValue].concat(metricsValues);
      };
    }
    makeTestFunction() {
      this.testFunction = (data) => {
        return tidy(() => {
          const valOutputs = [];
          let totalLoss;
          const inputs = data.slice(0, this.inputs.length);
          const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);
          const feeds = [];
          for (let i = 0;i < this.inputs.length; ++i) {
            feeds.push({ key: this.inputs[i], value: inputs[i] });
          }
          const feedDict = new FeedDict(feeds);
          const outputs = execute(this.outputs, feedDict);
          for (let i = 0;i < this.lossFunctions.length; ++i) {
            const lossFunction = this.lossFunctions[i];
            const loss = mean(lossFunction(targets[i], outputs[i]));
            if (i === 0) {
              totalLoss = loss;
            } else {
              totalLoss = add2(totalLoss, loss);
            }
            valOutputs.push(totalLoss);
          }
          for (let i = 0;i < this.metricsTensors.length; ++i) {
            const metric = this.metricsTensors[i][0];
            const outputIndex = this.metricsTensors[i][1];
            const meanMetric = mean(metric(targets[outputIndex], outputs[outputIndex]));
            valOutputs.push(meanMetric);
          }
          return valOutputs;
        });
      };
    }
    async fit(x, y, args = {}) {
      if (this.isTraining) {
        throw new Error("Cannot start training because another fit() call is ongoing.");
      }
      this.isTraining = true;
      let inputs;
      let targets;
      let originalInputs;
      let originalTargets;
      let inputValX;
      let inputValY;
      let valX;
      let valY;
      let sampleWeights;
      try {
        const batchSize = args.batchSize == null ? 32 : args.batchSize;
        checkBatchSize(batchSize);
        const checkBatchAxis = false;
        const standardizedOuts = await this.standardizeUserData(x, y, args.sampleWeight, args.classWeight, checkBatchAxis, batchSize);
        inputs = standardizedOuts[0];
        targets = standardizedOuts[1];
        sampleWeights = standardizedOuts[2];
        let doValidation = false;
        let valIns;
        if (args.validationData != null && args.validationData.length > 0) {
          doValidation = true;
          if (args.validationData.length === 2) {
            inputValX = args.validationData[0];
            inputValY = args.validationData[1];
          } else if (args.validationData.length === 3) {
            throw new NotImplementedError("validationData including sample weights is not supported yet.");
          } else {
            throw new ValueError(`When passing validation data, it must contain 2 (valX, valY) ` + `or 3 (valX, valY, valSampleWeight) items; ` + `${args.validationData} is invalid.`);
          }
          const checkBatchAxis2 = true;
          const valStandardized = await this.standardizeUserData(inputValX, inputValY, null, null, checkBatchAxis2, batchSize);
          valX = valStandardized[0];
          valY = valStandardized[1];
          valIns = valX.concat(valY);
        } else if (args.validationSplit != null && args.validationSplit > 0 && args.validationSplit < 1) {
          doValidation = true;
          const splitAt = Math.floor(inputs[0].shape[0] * (1 - args.validationSplit));
          const originalBatchSize = inputs[0].shape[0];
          valX = sliceArrays(inputs, splitAt, originalBatchSize);
          originalInputs = inputs;
          inputs = sliceArrays(inputs, 0, splitAt);
          valY = sliceArrays(targets, splitAt, originalBatchSize);
          originalTargets = targets;
          targets = sliceArrays(targets, 0, splitAt);
          valIns = valX.concat(valY);
        } else if (args.validationSteps != null) {
          doValidation = true;
        }
        const ins = inputs.concat(targets).concat(sampleWeights);
        this.checkTrainableWeightsConsistency();
        const trainFunction = this.makeTrainFunction();
        const outLabels = this.getDedupedMetricsNames();
        let valFunction;
        let callbackMetrics;
        if (doValidation) {
          this.makeTestFunction();
          valFunction = this.testFunction;
          callbackMetrics = outLabels.slice().concat(outLabels.map((n) => "val_" + n));
        } else {
          valFunction = null;
          valIns = [];
          callbackMetrics = outLabels.slice();
        }
        const callbacks = standardizeCallbacks(args.callbacks, args.yieldEvery);
        const out = await this.fitLoop(trainFunction, ins, outLabels, batchSize, args.epochs, args.verbose, callbacks, valFunction, valIns, args.shuffle, callbackMetrics, args.initialEpoch, null, null);
        return out;
      } finally {
        this.isTraining = false;
        disposeNewTensors(inputs, x);
        disposeNewTensors(targets, y);
        disposeNewTensors(originalInputs, x);
        disposeNewTensors(originalTargets, y);
        disposeNewTensors(valX, inputValX);
        disposeNewTensors(valY, inputValY);
        if (sampleWeights != null) {
          dispose(sampleWeights);
        }
      }
    }
    async fitLoop(f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle2, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {
      if (batchSize == null) {
        batchSize = 32;
      }
      if (epochs == null) {
        epochs = 1;
      }
      if (shuffle2 == null) {
        shuffle2 = true;
      }
      if (initialEpoch == null) {
        initialEpoch = 0;
      }
      let doValidation = false;
      if (valF != null && valIns != null) {
        doValidation = true;
      }
      if (validationSteps != null) {
        doValidation = true;
        if (stepsPerEpoch == null) {
          throw new ValueError("Can only use `validationSteps` when doing step-wise training, " + "i.e., `stepsPerEpoch` must be set.");
        }
      }
      const numTrainSamples = this.checkNumSamples(ins, batchSize, stepsPerEpoch, "steps_per_epoch");
      let indexArray;
      if (numTrainSamples != null) {
        indexArray = range4(0, numTrainSamples);
      }
      if (verbose == null) {
        verbose = 1;
      }
      const { callbackList, history } = configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics);
      callbackList.setModel(this);
      this.history = history;
      await callbackList.onTrainBegin();
      this.stopTraining_ = false;
      for (let epoch = initialEpoch;epoch < epochs; ++epoch) {
        await callbackList.onEpochBegin(epoch);
        const epochLogs = {};
        if (stepsPerEpoch != null) {
          throw new NotImplementedError("stepsPerEpoch mode is not implemented yet.");
        } else {
          if (shuffle2 === "batch") {
            throw new NotImplementedError("batch shuffling is not implemneted" + " yet");
          } else if (shuffle2) {
            exports_util.shuffle(indexArray);
          }
          const epochIndexArray1D = tensor1d(indexArray);
          const batches = makeBatches(numTrainSamples, batchSize);
          for (let batchIndex = 0;batchIndex < batches.length; ++batchIndex) {
            const batchLogs = {};
            await callbackList.onBatchBegin(batchIndex, batchLogs);
            tidy(() => {
              const batchStart = batches[batchIndex][0];
              const batchEnd = batches[batchIndex][1];
              const batchIds = sliceAlongFirstAxis(epochIndexArray1D, batchStart, batchEnd - batchStart);
              batchLogs["batch"] = batchIndex;
              batchLogs["size"] = batchEnd - batchStart;
              const insBatch = sliceArraysByIndices(ins, batchIds);
              const outs = f(insBatch);
              for (let i = 0;i < outLabels.length; ++i) {
                const label = outLabels[i];
                const out = outs[i];
                batchLogs[label] = out;
                keep(out);
              }
              if (batchIndex === batches.length - 1) {
                if (doValidation) {
                  const valOuts = this.testLoop(valF, valIns, batchSize);
                  for (let i = 0;i < outLabels.length; ++i) {
                    const label = outLabels[i];
                    const out = valOuts[i];
                    keep(out);
                    epochLogs["val_" + label] = out;
                  }
                }
              }
            });
            await callbackList.onBatchEnd(batchIndex, batchLogs);
            disposeTensorsInLogs(batchLogs);
            if (this.stopTraining_) {
              break;
            }
          }
          epochIndexArray1D.dispose();
        }
        await callbackList.onEpochEnd(epoch, epochLogs);
        if (this.stopTraining_) {
          break;
        }
      }
      await callbackList.onTrainEnd();
      await this.history.syncData();
      return this.history;
    }
    async fitDataset(dataset, args) {
      return fitDataset(this, dataset, args);
    }
    async trainOnBatch(x, y) {
      const standardizeOut = await this.standardizeUserData(x, y);
      const inputs = standardizeOut[0];
      const targets = standardizeOut[1];
      const trainFunction = this.makeTrainFunction();
      const losses3 = trainFunction(inputs.concat(targets));
      const lossValues = [];
      for (const loss of losses3) {
        const v = await loss.data();
        lossValues.push(v[0]);
      }
      dispose(losses3);
      disposeNewTensors(standardizeOut[0], x);
      disposeNewTensors(standardizeOut[1], y);
      return singletonOrArray(lossValues);
    }
    getNamedWeights(config) {
      const namedWeights = [];
      const trainableOnly = config != null && config.trainableOnly;
      const weights = trainableOnly ? this.trainableWeights : this.weights;
      const weightValues = this.getWeights(trainableOnly);
      for (let i = 0;i < weights.length; ++i) {
        if (trainableOnly && !weights[i].trainable) {
          continue;
        }
        namedWeights.push({ name: weights[i].originalName, tensor: weightValues[i] });
      }
      return namedWeights;
    }
    set stopTraining(stop) {
      this.stopTraining_ = stop;
    }
    get stopTraining() {
      return this.stopTraining_;
    }
    get optimizer() {
      return this.optimizer_;
    }
    set optimizer(optimizer7) {
      if (this.optimizer_ !== optimizer7) {
        this.optimizer_ = optimizer7;
        this.isOptimizerOwned = false;
      }
    }
    dispose() {
      const result = super.dispose();
      if (result.refCountAfterDispose === 0 && this.optimizer != null && this.isOptimizerOwned) {
        const numTensorsBeforeOptmizerDisposal = memory().numTensors;
        this.optimizer_.dispose();
        result.numDisposedVariables += numTensorsBeforeOptmizerDisposal - memory().numTensors;
      }
      return result;
    }
    getLossIdentifiers() {
      let lossNames;
      if (typeof this.loss === "string") {
        lossNames = toSnakeCase(this.loss);
      } else if (Array.isArray(this.loss)) {
        for (const loss of this.loss) {
          if (typeof loss !== "string") {
            throw new Error("Serialization of non-string loss is not supported.");
          }
        }
        lossNames = this.loss.map((name) => toSnakeCase(name));
      } else {
        const outputNames = Object.keys(this.loss);
        lossNames = {};
        const losses3 = this.loss;
        for (const outputName of outputNames) {
          if (typeof losses3[outputName] === "string") {
            lossNames[outputName] = toSnakeCase(losses3[outputName]);
          } else {
            throw new Error("Serialization of non-string loss is not supported.");
          }
        }
      }
      return lossNames;
    }
    getMetricIdentifiers() {
      if (typeof this.metrics === "string" || typeof this.metrics === "function") {
        return [toSnakeCase(getLossOrMetricName(this.metrics))];
      } else if (Array.isArray(this.metrics)) {
        return this.metrics.map((metric) => toSnakeCase(getLossOrMetricName(metric)));
      } else {
        const metricsIdentifiers = {};
        for (const key in this.metrics) {
          metricsIdentifiers[key] = toSnakeCase(getLossOrMetricName(this.metrics[key]));
        }
        return metricsIdentifiers;
      }
    }
    getTrainingConfig() {
      return {
        loss: this.getLossIdentifiers(),
        metrics: this.getMetricIdentifiers(),
        optimizer_config: {
          class_name: this.optimizer.getClassName(),
          config: this.optimizer.getConfig()
        }
      };
    }
    loadTrainingConfig(trainingConfig) {
      if (trainingConfig.weighted_metrics != null) {
        throw new Error("Loading weight_metrics is not supported yet.");
      }
      if (trainingConfig.loss_weights != null) {
        throw new Error("Loading loss_weights is not supported yet.");
      }
      if (trainingConfig.sample_weight_mode != null) {
        throw new Error("Loading sample_weight_mode is not supported yet.");
      }
      const tsConfig = convertPythonicToTs(trainingConfig.optimizer_config);
      const optimizer7 = deserialize(tsConfig);
      let loss;
      if (typeof trainingConfig.loss === "string") {
        loss = toCamelCase(trainingConfig.loss);
      } else if (Array.isArray(trainingConfig.loss)) {
        loss = trainingConfig.loss.map((lossEntry) => toCamelCase(lossEntry));
      } else if (trainingConfig.loss != null) {
        loss = {};
        for (const key in trainingConfig.loss) {
          loss[key] = toCamelCase(trainingConfig.loss[key]);
        }
      }
      let metrics;
      if (Array.isArray(trainingConfig.metrics)) {
        metrics = trainingConfig.metrics.map((metric) => toCamelCase(metric));
      } else if (trainingConfig.metrics != null) {
        metrics = {};
        for (const key in trainingConfig.metrics) {
          metrics[key] = toCamelCase(trainingConfig.metrics[key]);
        }
      }
      this.compile({ loss, metrics, optimizer: optimizer7 });
    }
    async save(handlerOrURL, config) {
      if (typeof handlerOrURL === "string") {
        const handlers = exports_io.getSaveHandlers(handlerOrURL);
        if (handlers.length === 0) {
          throw new ValueError(`Cannot find any save handlers for URL '${handlerOrURL}'`);
        } else if (handlers.length > 1) {
          throw new ValueError(`Found more than one (${handlers.length}) save handlers for ` + `URL '${handlerOrURL}'`);
        }
        handlerOrURL = handlers[0];
      }
      if (handlerOrURL.save == null) {
        throw new ValueError("LayersModel.save() cannot proceed because the IOHandler " + "provided does not have the `save` attribute defined.");
      }
      const weightDataAndSpecs = await exports_io.encodeWeights(this.getNamedWeights(config));
      const returnString = false;
      const unusedArg = null;
      const modelConfig = this.toJSON(unusedArg, returnString);
      const modelArtifacts = {
        modelTopology: modelConfig,
        format: LAYERS_MODEL_FORMAT_NAME,
        generatedBy: `TensorFlow.js tfjs-layers v${version3}`,
        convertedBy: null
      };
      const includeOptimizer = config == null ? false : config.includeOptimizer;
      if (includeOptimizer && this.optimizer != null) {
        modelArtifacts.trainingConfig = this.getTrainingConfig();
        const weightType = "optimizer";
        const { data: optimizerWeightData, specs: optimizerWeightSpecs } = await exports_io.encodeWeights(await this.optimizer.getWeights(), weightType);
        weightDataAndSpecs.specs.push(...optimizerWeightSpecs);
        weightDataAndSpecs.data = exports_io.concatenateArrayBuffers([weightDataAndSpecs.data, optimizerWeightData]);
      }
      if (this.userDefinedMetadata != null) {
        const checkSize = true;
        checkUserDefinedMetadata(this.userDefinedMetadata, this.name, checkSize);
        modelArtifacts.userDefinedMetadata = this.userDefinedMetadata;
      }
      modelArtifacts.weightData = weightDataAndSpecs.data;
      modelArtifacts.weightSpecs = weightDataAndSpecs.specs;
      return handlerOrURL.save(modelArtifacts);
    }
    setUserDefinedMetadata(userDefinedMetadata) {
      checkUserDefinedMetadata(userDefinedMetadata, this.name);
      this.userDefinedMetadata = userDefinedMetadata;
    }
    getUserDefinedMetadata() {
      return this.userDefinedMetadata;
    }
  };
  LayersModel.className = "Model";
  exports_serialization.registerClass(LayersModel);
  Functional = class Functional extends LayersModel {
  };
  Functional.className = "Functional";
  exports_serialization.registerClass(Functional);
});

// node_modules/@tensorflow/tfjs-layers/dist/models.js
async function modelFromJSON(modelAndWeightsConfig, customObjects) {
  if (!("modelTopology" in modelAndWeightsConfig)) {
    modelAndWeightsConfig = { modelTopology: modelAndWeightsConfig };
  }
  modelAndWeightsConfig = modelAndWeightsConfig;
  let modelTopology = modelAndWeightsConfig.modelTopology;
  if (modelTopology["model_config"] != null) {
    modelTopology = modelTopology["model_config"];
  }
  const tsConfig = convertPythonicToTs(modelTopology);
  const model = deserialize(tsConfig, customObjects);
  if (modelAndWeightsConfig.weightsManifest != null) {
    const weightValues = await exports_io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map((weight) => weight.originalName));
    const uniqueWeightValues = {};
    for (const weight of model.weights) {
      uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];
    }
    model.loadWeights(uniqueWeightValues);
    dispose(weightValues);
  }
  return model;
}
async function loadLayersModel(pathOrIOHandler, options) {
  if (options == null) {
    options = {};
  }
  if (typeof pathOrIOHandler === "string") {
    const handlers = exports_io.getLoadHandlers(pathOrIOHandler, options);
    if (handlers.length === 0) {
      handlers.push(exports_io.browserHTTPRequest(pathOrIOHandler, options));
    } else if (handlers.length > 1) {
      throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` + `URL '${pathOrIOHandler}'`);
    }
    pathOrIOHandler = handlers[0];
  }
  return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);
}
async function loadLayersModelFromIOHandler(handler, customObjects, options) {
  if (options == null) {
    options = {};
  }
  if (handler.load == null) {
    throw new ValueError("Cannot proceed with model loading because the IOHandler provided " + "does not have the `load` method implemented.");
  }
  const artifacts = await handler.load();
  let modelTopology = artifacts.modelTopology;
  if (modelTopology["model_config"] != null) {
    modelTopology = modelTopology["model_config"];
  }
  const strict = options.strict == null ? true : options.strict;
  const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;
  const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);
  const trainingConfig = artifacts.trainingConfig;
  if (trainingConfig != null) {
    model.loadTrainingConfig(trainingConfig);
  }
  if (artifacts.userDefinedMetadata != null) {
    model.setUserDefinedMetadata(artifacts.userDefinedMetadata);
  }
  if (artifacts.weightData != null) {
    if (artifacts.weightSpecs == null) {
      throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. " + "Therefore loading of weights cannot proceed.");
    }
    const { modelWeights, optimizerWeights } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);
    model.loadWeights(modelWeights, strict);
    if (model.optimizer != null && optimizerWeights.length > 0) {
      await model.optimizer.setWeights(optimizerWeights);
    }
    dispose(modelWeights);
    dispose(optimizerWeights.map((w) => w.tensor));
  }
  return model;
}
function decodeModelAndOptimizerWeights(weightData, specs) {
  const name2Tensor = exports_io.decodeWeights(weightData, specs);
  const modelWeights = {};
  const optimizerWeights = [];
  specs.forEach((spec) => {
    if (spec.group === "optimizer") {
      optimizerWeights.push({ name: spec.name, tensor: name2Tensor[spec.name] });
    } else {
      modelWeights[spec.name] = name2Tensor[spec.name];
    }
  });
  return { modelWeights, optimizerWeights };
}
var Sequential;
var init_models = __esm(() => {
  init_dist();
  init_state();
  init_input_layer();
  init_topology();
  init_training();
  init_errors();
  init_serialization2();
  init_generic_utils();
  init_serialization_utils();
  init_types_utils();
  Sequential = class Sequential extends LayersModel {
    constructor(args) {
      super({ inputs: [], outputs: [] });
      args = args || {};
      this.trainable = true;
      this.built = false;
      this.name = args.name != null ? args.name : getUid("sequential_");
      if (args.layers != null) {
        for (const layer of args.layers) {
          this.add(layer);
        }
      }
    }
    checkShape(layer) {
      const shape = layer.inboundNodes[0].outputTensors[0].shape;
      if (shape.some((x) => x < 0)) {
        throw new ValueError("Negative dimension size caused by adding layer " + `${layer.name} with input shape [` + `${layer.inboundNodes[0].inputTensors[0].shape}]`);
      }
    }
    add(layer) {
      const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;
      let modelLayer;
      if (isLayerModelInstance) {
        modelLayer = layer;
        if (modelLayer.outputs.length !== 1) {
          throw new ValueError("All layers in a Sequential model " + "should have a single output tensor. " + "For multi-output layers, " + "use the functional API.");
        }
        if (modelLayer.inputs.length !== 1) {
          throw new ValueError("All layers in a Sequential model " + "should have a single input tensor. " + "For multi-input layers, " + "use the functional API.");
        }
      }
      if (this.outputs.length === 0) {
        if (layer.inboundNodes.length === 0) {
          if (layer.batchInputShape == null) {
            throw new ValueError("The first layer in a Sequential model must " + "get an `inputShape` or `batchInputShape` argument.");
          }
          const x = Input({
            batchShape: layer.batchInputShape,
            dtype: layer.dtype,
            name: layer.name + "_input"
          });
          layer.apply(x);
        }
        if (isLayerModelInstance) {
          this.outputs = modelLayer.outputs;
          this.inputs = modelLayer.inputs;
        } else {
          if (layer.inboundNodes.length !== 1) {
            throw new ValueError("A layer added to a Sequential model must not already be " + `connected somewhere else. LayersModel received layer ${layer.name} ` + `which has ${layer.inboundNodes.length} pre-existing inbound ` + "connections.");
          }
          if (layer.inboundNodes[0].outputTensors.length !== 1) {
            throw new ValueError("All layers in a Sequential model " + "should have a single output tensor. " + "For multi-output layers, " + "use the functional API.");
          }
          this.checkShape(layer);
          this.outputs = [layer.inboundNodes[0].outputTensors[0]];
          this.inputs = getSourceInputs(this.outputs[0]);
        }
        this.inboundNodes = [];
        new Node({
          outboundLayer: this,
          inboundLayers: [],
          nodeIndices: [],
          tensorIndices: [],
          inputTensors: this.inputs,
          outputTensors: this.outputs,
          inputMasks: pyListRepeat(null, this.inputs.length),
          outputMasks: [null],
          inputShapes: this.inputs.map((x) => x.shape),
          outputShapes: this.outputs[0].shape
        });
      } else {
        const outputTensor = layer.apply(this.outputs[0]);
        if (Array.isArray(outputTensor)) {
          throw new TypeError("All layers in a Sequential model " + "should have a single output tensor. " + "For multi-output layers, " + "use the functional API.");
        }
        this.checkShape(layer);
        this.outputs = [outputTensor];
        this.inboundNodes[0].outputTensors = this.outputs;
        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
      this.layers.push(layer);
      this.built = false;
    }
    pop() {
      if (this.layers.length === 0) {
        throw new TypeError("There are no layers in the model.");
      }
      this.layers.pop();
      if (this.layers.length === 0) {
        this.outputs = [];
        this.inboundNodes = [];
        this.outboundNodes = [];
      } else {
        const lastLayerIndex = this.layers.length - 1;
        this.layers[lastLayerIndex].outboundNodes = [];
        this.outputs = [this.layers[lastLayerIndex].output];
        this.inboundNodes[0].outputTensors = this.outputs;
        this.inboundNodes[0].outputShapes = [this.outputs[0].shape];
      }
    }
    call(inputs, kwargs) {
      if (this.model == null) {
        this.build();
      }
      return this.model.call(inputs, kwargs);
    }
    build(inputShape) {
      getExactlyOneShape(inputShape);
      if (this.inputs.length === 0 || this.outputs.length === 0) {
        throw new TypeError("Sequential model cannot be built: model is empty." + " Add some layers first.");
      }
      this.model = new LayersModel({
        inputs: this.inputs,
        outputs: this.outputs[0],
        name: this.name + "_model"
      });
      this.model.trainable = this.trainable;
      this.supportsMasking = this.model.supportsMasking;
      this.inputLayers = this.model.inputLayers;
      this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;
      this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;
      this.outputLayers = this.model.outputLayers;
      this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;
      this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;
      this.nodesByDepth = this.model.nodesByDepth;
      this.containerNodes = this.model.containerNodes;
      this.outputNames = this.model.outputNames;
      this.inputNames = this.model.inputNames;
      this.built = true;
    }
    countParams() {
      if (!this.built) {
        this.build();
      }
      return super.countParams();
    }
    summary(lineLength, positions, printFn = console.log) {
      if (!this.built) {
        this.build();
      }
      super.summary(lineLength, positions, printFn);
    }
    setWeights(weights) {
      if (this.model == null) {
        this.build();
      }
      this.model.setWeights(weights);
    }
    evaluate(x, y, args = {}) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before being used.");
      }
      return this.model.evaluate(x, y, args);
    }
    async evaluateDataset(dataset, args) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before being used.");
      }
      return this.model.evaluateDataset(dataset, args);
    }
    predict(x, args = {}) {
      if (this.model == null) {
        this.build();
      }
      return this.model.predict(x, args);
    }
    predictOnBatch(x) {
      if (this.model == null) {
        this.build();
      }
      return this.model.predictOnBatch(x);
    }
    compile(args) {
      this.build();
      this.model.compile(args);
      this.optimizer_ = this.model.optimizer;
      this.isOptimizerOwned = this.model.isOptimizerOwned;
      this.loss = this.model.loss;
      this.metrics = this.model.metrics;
      this.metricsTensors = this.model.metricsTensors;
      this.metricsNames = this.model.metricsNames;
    }
    get optimizer() {
      return this.model == null ? undefined : this.model.optimizer;
    }
    set optimizer(optimizer7) {
      this.model.optimizer = optimizer7;
    }
    async fit(x, y, args = {}) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before " + "being used.");
      }
      return this.model.fit(x, y, args);
    }
    async fitDataset(dataset, args) {
      if (!this.built) {
        throw new RuntimeError("The model needs to be compiled before " + "being used.");
      }
      return this.model.fitDataset(dataset, args);
    }
    async trainOnBatch(x, y) {
      return this.model.trainOnBatch(x, y);
    }
    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {
      let configArray;
      let extraModelConfig = {};
      if (config instanceof Array) {
        if (!(config[0].className != null) || config[0]["className"] === "Merge") {
          throw new ValueError("Legacy serialization format not supported yet.");
        }
        configArray = config;
      } else {
        exports_util.assert(config["layers"] != null, () => `When the config data for a Sequential model is not an Array, ` + `it must be an Object that contains the 'layers' field.`);
        configArray = config["layers"];
        delete config["layers"];
        extraModelConfig = config;
      }
      const model = new cls(extraModelConfig);
      if (!(model instanceof Sequential)) {
        throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);
      }
      for (const conf of configArray) {
        const customObjects2 = undefined;
        const layer = deserialize(conf, customObjects2, fastWeightInit);
        if (fastWeightInit) {
          layer.setFastWeightInitDuringBuild(true);
        }
        model.add(layer);
      }
      return model;
    }
    set stopTraining(stop) {
      if (this.model == null) {
        throw new ValueError("Cannot set the stopTraining property of a sequential model before " + "it is compiled.");
      }
      this.model.stopTraining = stop;
    }
    get stopTraining() {
      if (this.model == null) {
        throw new ValueError("Cannot get the stopTraining property of a sequential model before " + "it is compiled.");
      }
      return this.model.stopTraining;
    }
    getConfig() {
      const layers = [];
      for (const layer of this.layers) {
        const dict = {};
        dict["className"] = layer.getClassName();
        dict["config"] = layer.getConfig();
        layers.push(dict);
      }
      return { name: this.name, layers };
    }
  };
  Sequential.className = "Sequential";
  exports_serialization.registerClass(Sequential);
});

// node_modules/@tensorflow/tfjs-layers/dist/exports.js
function model(args) {
  return new LayersModel(args);
}
function sequential(config) {
  return new Sequential(config);
}
function input(config) {
  return Input(config);
}
function registerCallbackConstructor(verbosityLevel, callbackConstructor) {
  CallbackConstructorRegistry.registerCallbackConstructor(verbosityLevel, callbackConstructor);
}
var init_exports = __esm(() => {
  init_base_callbacks();
  init_input_layer();
  init_training();
  init_models();
  init_models();
});

// node_modules/@tensorflow/tfjs-layers/dist/activations.js
function serializeActivation(activation) {
  return activation.getClassName();
}
function deserializeActivation(config, customObjects = {}) {
  return deserializeKerasObject(config, exports_serialization.SerializationMap.getMap().classNameMap, customObjects, "activation");
}
function getActivation(identifier) {
  if (identifier == null) {
    const config = {};
    config["className"] = "linear";
    config["config"] = {};
    return deserializeActivation(config);
  }
  if (typeof identifier === "string") {
    const config = {};
    config["className"] = identifier;
    config["config"] = {};
    return deserializeActivation(config);
  } else if (identifier instanceof Activation) {
    return identifier;
  } else {
    return deserializeActivation(identifier);
  }
}
var Activation, Elu2, Selu2, Relu2, Relu62, Linear, Sigmoid2, HardSigmoid, Softplus2, Softsign, Tanh2, Softmax2, LogSoftmax2, Gelu, GeluNew, Mish, Swish;
var init_activations = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_generic_utils();
  Activation = class Activation extends exports_serialization.Serializable {
    getConfig() {
      return {};
    }
  };
  Elu2 = class Elu2 extends Activation {
    apply(x, alpha = 1) {
      return elu5(x, alpha);
    }
  };
  Elu2.className = "elu";
  exports_serialization.registerClass(Elu2);
  Selu2 = class Selu2 extends Activation {
    apply(x) {
      return selu(x);
    }
  };
  Selu2.className = "selu";
  exports_serialization.registerClass(Selu2);
  Relu2 = class Relu2 extends Activation {
    apply(x) {
      return relu(x);
    }
  };
  Relu2.className = "relu";
  exports_serialization.registerClass(Relu2);
  Relu62 = class Relu62 extends Activation {
    apply(x) {
      return tidy(() => minimum(6, relu(x)));
    }
  };
  Relu62.className = "relu6";
  exports_serialization.registerClass(Relu62);
  Linear = class Linear extends Activation {
    apply(x) {
      return x;
    }
  };
  Linear.className = "linear";
  exports_serialization.registerClass(Linear);
  Sigmoid2 = class Sigmoid2 extends Activation {
    apply(x) {
      return sigmoid(x);
    }
  };
  Sigmoid2.className = "sigmoid";
  exports_serialization.registerClass(Sigmoid2);
  HardSigmoid = class HardSigmoid extends Activation {
    apply(x) {
      return hardSigmoid(x);
    }
  };
  HardSigmoid.className = "hardSigmoid";
  exports_serialization.registerClass(HardSigmoid);
  Softplus2 = class Softplus2 extends Activation {
    apply(x) {
      return softplus(x);
    }
  };
  Softplus2.className = "softplus";
  exports_serialization.registerClass(Softplus2);
  Softsign = class Softsign extends Activation {
    apply(x) {
      return softsign(x);
    }
  };
  Softsign.className = "softsign";
  exports_serialization.registerClass(Softsign);
  Tanh2 = class Tanh2 extends Activation {
    apply(x) {
      return tanh2(x);
    }
  };
  Tanh2.className = "tanh";
  exports_serialization.registerClass(Tanh2);
  Softmax2 = class Softmax2 extends Activation {
    apply(x, axis = -1) {
      return softmax(x, axis);
    }
  };
  Softmax2.className = "softmax";
  exports_serialization.registerClass(Softmax2);
  LogSoftmax2 = class LogSoftmax2 extends Activation {
    apply(x, axis = -1) {
      return logSoftmax(x, axis);
    }
  };
  LogSoftmax2.className = "logSoftmax";
  exports_serialization.registerClass(LogSoftmax2);
  Gelu = class Gelu extends Activation {
    apply(x) {
      return tidy(() => {
        return tidy(() => {
          const sqrtTwo = Math.sqrt(2);
          const cdf = mul(0.5, add2(1, erf(div(x, sqrtTwo))));
          return mul(x, cdf);
        });
      });
    }
  };
  Gelu.className = "gelu";
  exports_serialization.registerClass(Gelu);
  GeluNew = class GeluNew extends Activation {
    apply(x) {
      return tidy(() => {
        return mul(0.5, mul(x, add2(1, tanh2(mul(sqrt(div(2, Math.PI)), add2(x, mul(0.044715, pow(x, 3))))))));
      });
    }
  };
  GeluNew.className = "gelu_new";
  exports_serialization.registerClass(GeluNew);
  Mish = class Mish extends Activation {
    apply(x) {
      return tidy(() => mul(x, tanh2(softplus(x))));
    }
  };
  Mish.className = "mish";
  exports_serialization.registerClass(Mish);
  Swish = class Swish extends Activation {
    apply(x, alpha = 1) {
      return tidy(() => mul(sigmoid(mul(x, alpha)), x));
    }
  };
  Swish.className = "swish";
  exports_serialization.registerClass(Swish);
});

// node_modules/@tensorflow/tfjs-layers/dist/regularizers.js
function assertObjectArgs(args) {
  if (args != null && typeof args !== "object") {
    throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an ` + `object, but received: ${args}`);
  }
}
function l1(args) {
  assertObjectArgs(args);
  return new L1L2({ l1: args != null ? args.l1 : null, l2: 0 });
}
function l2(args) {
  assertObjectArgs(args);
  return new L1L2({ l2: args != null ? args.l2 : null, l1: 0 });
}
function serializeRegularizer(constraint) {
  return serializeKerasObject(constraint);
}
function deserializeRegularizer(config, customObjects = {}) {
  return deserializeKerasObject(config, exports_serialization.SerializationMap.getMap().classNameMap, customObjects, "regularizer");
}
function getRegularizer(identifier) {
  if (identifier == null) {
    return null;
  }
  if (typeof identifier === "string") {
    const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ? REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] : identifier;
    const config = { className, config: {} };
    return deserializeRegularizer(config);
  } else if (identifier instanceof Regularizer) {
    return identifier;
  } else {
    return deserializeRegularizer(identifier);
  }
}
var Regularizer, L1L2, REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP;
var init_regularizers = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_generic_utils();
  Regularizer = class Regularizer extends exports_serialization.Serializable {
  };
  L1L2 = class L1L2 extends Regularizer {
    constructor(args) {
      super();
      assertObjectArgs(args);
      this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;
      this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;
      this.hasL1 = this.l1 !== 0;
      this.hasL2 = this.l2 !== 0;
    }
    apply(x) {
      return tidy(() => {
        let regularization = zeros([1]);
        if (this.hasL1) {
          regularization = add2(regularization, sum2(mul(this.l1, abs(x))));
        }
        if (this.hasL2) {
          regularization = add2(regularization, sum2(mul(this.l2, square23(x))));
        }
        return reshape(regularization, []);
      });
    }
    getConfig() {
      return { l1: this.l1, l2: this.l2 };
    }
    static fromConfig(cls, config) {
      return new cls({ l1: config["l1"], l2: config["l2"] });
    }
  };
  L1L2.className = "L1L2";
  exports_serialization.registerClass(L1L2);
  REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {
    l1l2: "L1L2"
  };
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/advanced_activations.js
var ReLU, LeakyReLU, PReLU, ELU, ThresholdedReLU, Softmax3;
var init_advanced_activations = __esm(() => {
  init_dist();
  init_activations();
  init_constraints();
  init_topology();
  init_errors();
  init_initializers();
  init_regularizers();
  init_types_utils();
  ReLU = class ReLU extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.supportsMasking = true;
      if (args != null) {
        this.maxValue = args.maxValue;
      }
    }
    call(inputs, kwargs) {
      inputs = getExactlyOneTensor(inputs);
      let output = relu(inputs);
      if (this.maxValue != null) {
        output = clipByValue(output, 0, this.maxValue);
      }
      return output;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { maxValue: this.maxValue };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ReLU.className = "ReLU";
  exports_serialization.registerClass(ReLU);
  LeakyReLU = class LeakyReLU extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_ALPHA = 0.3;
      if (args == null) {
        args = {};
      }
      this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return leakyRelu(x, this.alpha);
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { alpha: this.alpha };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  LeakyReLU.className = "LeakyReLU";
  exports_serialization.registerClass(LeakyReLU);
  PReLU = class PReLU extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_ALPHA_INITIALIZER = "zeros";
      if (args == null) {
        args = {};
      }
      this.supportsMasking = true;
      this.alphaInitializer = getInitializer(args.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER);
      this.alphaRegularizer = getRegularizer(args.alphaRegularizer);
      this.alphaConstraint = getConstraint(args.alphaConstraint);
      if (args.sharedAxes == null) {
        this.sharedAxes = null;
      } else if (Array.isArray(args.sharedAxes)) {
        this.sharedAxes = args.sharedAxes;
      } else if (typeof args.sharedAxes === "number") {
        this.sharedAxes = [args.sharedAxes];
      } else {
        throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, ` + `but got ${args.sharedAxes}`);
      }
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const paramShape = inputShape.slice(1);
      if (this.sharedAxes != null) {
        for (const i of this.sharedAxes) {
          paramShape[i - 1] = 1;
        }
      }
      this.alpha = this.addWeight("alpha", paramShape, "float32", this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);
      const axes = {};
      if (this.sharedAxes != null) {
        for (let i = 1;i < inputShape.length; ++i) {
          axes[i] = inputShape[i];
        }
      }
      this.inputSpec = [new InputSpec({
        ndim: inputShape.length,
        axes
      })];
      this.built = true;
    }
    call(inputs, kwargs) {
      inputs = getExactlyOneTensor(inputs);
      return prelu(inputs, this.alpha.read());
    }
    getConfig() {
      const config = {
        alphaInitializer: serializeInitializer(this.alphaInitializer),
        alphaRegularizer: serializeRegularizer(this.alphaRegularizer),
        alphaConstraint: serializeConstraint(this.alphaConstraint),
        sharedAxes: this.sharedAxes
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  PReLU.className = "PReLU";
  exports_serialization.registerClass(PReLU);
  ELU = class ELU extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_ALPHA = 1;
      if (args == null) {
        args = {};
      }
      if (args.alpha != null && args.alpha !== this.DEFAULT_ALPHA) {
        throw new NotImplementedError(`Non-default alpha value (${args.alpha}) is not supported by the ` + `ELU layer yet.`);
      }
      this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return elu(x);
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { alpha: this.alpha };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ELU.className = "ELU";
  exports_serialization.registerClass(ELU);
  ThresholdedReLU = class ThresholdedReLU extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_THETA = 1;
      if (args == null) {
        args = {};
      }
      this.theta = args.theta == null ? this.DEFAULT_THETA : args.theta;
    }
    call(inputs, kwargs) {
      const x = getExactlyOneTensor(inputs);
      return mul(x, cast(greater(x, this.theta), "float32"));
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { theta: this.theta };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ThresholdedReLU.className = "ThresholdedReLU";
  exports_serialization.registerClass(ThresholdedReLU);
  Softmax3 = class Softmax3 extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.DEFAULT_AXIS = 1;
      if (args == null) {
        args = {};
      }
      this.softmax = new Softmax2().apply;
      this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let x = getExactlyOneTensor(inputs);
        const mask = kwargs["mask"];
        if (mask != null) {
          const adder = mul(sub(ones2(x.shape), cast(mask, x.dtype)), scalar(-1e9));
          x = add2(x, adder);
        }
        if (this.axis instanceof Array) {
          if (this.axis.length > 1) {
            return exp(sub(x, logSumExp(x, this.axis, true)));
          } else {
            return this.softmax(x, this.axis[0]);
          }
        }
        return this.softmax(x, this.axis);
      });
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const config = { axis: this.axis };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Softmax3.className = "Softmax";
  exports_serialization.registerClass(Softmax3);
});

// node_modules/@tensorflow/tfjs-layers/dist/utils/conv_utils.js
function normalizeArray(value, n, name) {
  if (typeof value === "number") {
    return pyListRepeat(value, n);
  } else {
    if (value.length !== n) {
      throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers.` + ` Received: ${value.length} elements.`);
    }
    for (let i = 0;i < n; ++i) {
      const singleValue = value[i];
      if (!isInteger(singleValue)) {
        throw new ValueError(`The ${name} argument must be an integer or tuple of ${n}` + ` integers. Received: ${JSON.stringify(value)} including a` + ` non-integer number ${singleValue}`);
      }
    }
    return value;
  }
}
function convOutputLength(inputLength, filterSize, padding, stride, dilation = 1) {
  if (inputLength == null) {
    return inputLength;
  }
  const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);
  let outputLength;
  if (padding === "same") {
    outputLength = inputLength;
  } else {
    outputLength = inputLength - dilatedFilterSize + 1;
  }
  return Math.floor((outputLength + stride - 1) / stride);
}
function deconvLength(dimSize, strideSize, kernelSize, padding) {
  if (dimSize == null) {
    return null;
  }
  if (padding === "valid") {
    dimSize = dimSize * strideSize + max7([kernelSize - strideSize, 0]);
  } else if (padding === "same") {
    dimSize = dimSize * strideSize;
  } else {
    throw new ValueError(`Unsupport padding mode: ${padding}.`);
  }
  return dimSize;
}
var init_conv_utils = __esm(() => {
  init_errors();
  init_generic_utils();
  init_math_utils();
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional.js
function preprocessConv2DInput(x, dataFormat) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    if (dataFormat === "channelsFirst") {
      return transpose(x, [0, 2, 3, 1]);
    } else {
      return x;
    }
  });
}
function preprocessConv3DInput(x, dataFormat) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    if (dataFormat === "channelsFirst") {
      return transpose(x, [0, 2, 3, 4, 1]);
    } else {
      return x;
    }
  });
}
function conv1dWithBias(x, kernel, bias, strides = 1, padding = "valid", dataFormat, dilationRate = 1) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    if (x.shape.length !== 3) {
      throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ` + `${x.shape.length} instead.`);
    }
    if (kernel.shape.length !== 3) {
      throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ` + `${kernel.shape.length} instead`);
    }
    if (bias != null && bias.shape.length !== 1) {
      throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ` + `${bias.shape.length} instead`);
    }
    if (dataFormat === "channelsFirst") {
      x = transpose(x, [0, 2, 1]);
    }
    if (padding === "causal") {
      throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not " + "implemented yet.");
    }
    let y = conv1d(x, kernel, strides, padding === "same" ? "same" : "valid", "NWC", dilationRate);
    if (bias != null) {
      y = biasAdd(y, bias);
    }
    return y;
  });
}
function conv2dWithBiasActivation(x, kernel, bias, strides = [1, 1], padding = "valid", dataFormat, dilationRate, activation = null) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    if (x.rank !== 3 && x.rank !== 4) {
      throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, ` + `but received ${x.rank}.`);
    }
    if (kernel.rank !== 3 && kernel.rank !== 4) {
      throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, ` + `but received ${x.rank}.`);
    }
    let y = preprocessConv2DInput(x, dataFormat);
    if (padding === "causal") {
      throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not " + "implemented yet.");
    }
    y = exports_fused_ops.conv2d({
      x: y,
      filter: kernel,
      strides,
      pad: padding === "same" ? "same" : "valid",
      dilations: dilationRate,
      dataFormat: "NHWC",
      bias,
      activation
    });
    if (dataFormat === "channelsFirst") {
      y = transpose(y, [0, 3, 1, 2]);
    }
    return y;
  });
}
function conv3dWithBias(x, kernel, bias, strides = [1, 1, 1], padding = "valid", dataFormat, dilationRate) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    if (x.rank !== 4 && x.rank !== 5) {
      throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ` + `${x.rank}.`);
    }
    if (kernel.rank !== 4 && kernel.rank !== 5) {
      throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ` + `${x.rank}.`);
    }
    let y = preprocessConv3DInput(x, dataFormat);
    if (padding === "causal") {
      throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not " + "implemented yet.");
    }
    y = conv3d(y, kernel, strides, padding === "same" ? "same" : "valid", "NDHWC", dilationRate);
    if (bias != null) {
      y = biasAdd(y, bias);
    }
    if (dataFormat === "channelsFirst") {
      y = transpose(y, [0, 4, 1, 2, 3]);
    }
    return y;
  });
}
var BaseConv, Conv, Conv2D2, Conv3D2, Conv2DTranspose, Conv3DTranspose, SeparableConv, SeparableConv2D, Conv1D, Cropping2D, UpSampling2D;
var init_convolutional = __esm(() => {
  init_dist();
  init_dist();
  init_activations();
  init_common3();
  init_tfjs_backend();
  init_common2();
  init_constraints();
  init_topology();
  init_errors();
  init_initializers();
  init_regularizers();
  init_conv_utils();
  init_generic_utils();
  init_types_utils();
  BaseConv = class BaseConv extends Layer {
    constructor(rank, args) {
      super(args);
      this.bias = null;
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      BaseConv.verifyArgs(args);
      this.rank = rank;
      assertPositiveInteger(this.rank, "rank");
      if (this.rank !== 1 && this.rank !== 2 && this.rank !== 3) {
        throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is ` + `not implemented yet.`);
      }
      this.kernelSize = normalizeArray(args.kernelSize, rank, "kernelSize");
      this.strides = normalizeArray(args.strides == null ? 1 : args.strides, rank, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      checkPaddingMode(this.padding);
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      this.activation = getActivation(args.activation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.biasConstraint = getConstraint(args.biasConstraint);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.activityRegularizer = getRegularizer(args.activityRegularizer);
      this.dilationRate = normalizeArray(args.dilationRate == null ? 1 : args.dilationRate, rank, "dilationRate");
      if (this.rank === 1 && (Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)) {
        throw new ValueError(`dilationRate must be a number or an array of a single number ` + `for 1D convolution, but received ` + `${JSON.stringify(this.dilationRate)}`);
      } else if (this.rank === 2) {
        if (typeof this.dilationRate === "number") {
          this.dilationRate = [this.dilationRate, this.dilationRate];
        } else if (this.dilationRate.length !== 2) {
          throw new ValueError(`dilationRate must be a number or array of two numbers for 2D ` + `convolution, but received ${JSON.stringify(this.dilationRate)}`);
        }
      } else if (this.rank === 3) {
        if (typeof this.dilationRate === "number") {
          this.dilationRate = [this.dilationRate, this.dilationRate, this.dilationRate];
        } else if (this.dilationRate.length !== 3) {
          throw new ValueError(`dilationRate must be a number or array of three numbers for 3D ` + `convolution, but received ${JSON.stringify(this.dilationRate)}`);
        }
      }
    }
    static verifyArgs(args) {
      assert2("kernelSize" in args, `required key 'kernelSize' not in config`);
      if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 3)) {
        throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with ` + `length 1, 2, or 3, but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
    getConfig() {
      const config = {
        kernelSize: this.kernelSize,
        strides: this.strides,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        activation: serializeActivation(this.activation),
        useBias: this.useBias,
        biasInitializer: serializeInitializer(this.biasInitializer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        biasConstraint: serializeConstraint(this.biasConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Conv = class Conv extends BaseConv {
    constructor(rank, args) {
      super(rank, args);
      this.kernel = null;
      Conv.verifyArgs(args);
      this.filters = args.filters;
      assertPositiveInteger(this.filters, "filters");
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.kernelConstraint = getConstraint(args.kernelConstraint);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError(`The channel dimension of the input should be defined. ` + `Found ${inputShape[channelAxis]}`);
      }
      const inputDim = inputShape[channelAxis];
      const kernelShape = this.kernelSize.concat([inputDim, this.filters]);
      this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.inputSpec = [{ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } }];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        let outputs;
        const biasValue = this.bias == null ? null : this.bias.read();
        const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
        if (fusedActivationName != null && this.rank === 2) {
          outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate, fusedActivationName);
        } else {
          if (this.rank === 1) {
            outputs = conv1dWithBias(inputs, this.kernel.read(), biasValue, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);
          } else if (this.rank === 2) {
            outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
          } else if (this.rank === 3) {
            outputs = conv3dWithBias(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);
          } else {
            throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");
          }
          if (this.activation != null) {
            outputs = this.activation.apply(outputs);
          }
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const newSpace = [];
      const space = this.dataFormat === "channelsLast" ? inputShape.slice(1, inputShape.length - 1) : inputShape.slice(2);
      for (let i = 0;i < space.length; ++i) {
        const newDim = convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === "number" ? this.dilationRate : this.dilationRate[i]);
        newSpace.push(newDim);
      }
      let outputShape = [inputShape[0]];
      if (this.dataFormat === "channelsLast") {
        outputShape = outputShape.concat(newSpace);
        outputShape.push(this.filters);
      } else {
        outputShape.push(this.filters);
        outputShape = outputShape.concat(newSpace);
      }
      return outputShape;
    }
    getConfig() {
      const config = {
        filters: this.filters,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    static verifyArgs(args) {
      if (!("filters" in args) || typeof args.filters !== "number" || args.filters < 1) {
        throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 ` + `but got ${JSON.stringify(args.filters)}`);
      }
    }
  };
  Conv2D2 = class Conv2D2 extends Conv {
    constructor(args) {
      super(2, args);
      Conv2D2.verifyArgs(args);
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      return config;
    }
    static verifyArgs(args) {
      if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 2)) {
        throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with ` + `length 1 or 2, but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
  };
  Conv2D2.className = "Conv2D";
  exports_serialization.registerClass(Conv2D2);
  Conv3D2 = class Conv3D2 extends Conv {
    constructor(args) {
      super(3, args);
      Conv3D2.verifyArgs(args);
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      return config;
    }
    static verifyArgs(args) {
      if (typeof args.kernelSize !== "number") {
        if (!(Array.isArray(args.kernelSize) && (args.kernelSize.length === 1 || args.kernelSize.length === 3))) {
          throw new ValueError(`Conv3D expects config.kernelSize to be number or` + ` [number, number, number], but received ${JSON.stringify(args.kernelSize)}.`);
        }
      }
    }
  };
  Conv3D2.className = "Conv3D";
  exports_serialization.registerClass(Conv3D2);
  Conv2DTranspose = class Conv2DTranspose extends Conv2D2 {
    constructor(args) {
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 4 })];
      if (this.padding !== "same" && this.padding !== "valid") {
        throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' ` + `and 'valid', but received padding mode ${this.padding}`);
      }
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length !== 4) {
        throw new ValueError("Input should have rank 4; Received input shape: " + JSON.stringify(inputShape));
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError("The channel dimension of the inputs should be defined. " + "Found `None`.");
      }
      const inputDim = inputShape[channelAxis];
      const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
      this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.inputSpec = [new InputSpec({ ndim: 4, axes: { [channelAxis]: inputDim } })];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let input2 = getExactlyOneTensor(inputs);
        if (input2.shape.length !== 4) {
          throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but ` + `received a tensor of rank-${input2.shape.length}`);
        }
        const inputShape = input2.shape;
        const batchSize = inputShape[0];
        let hAxis;
        let wAxis;
        if (this.dataFormat === "channelsFirst") {
          hAxis = 2;
          wAxis = 3;
        } else {
          hAxis = 1;
          wAxis = 2;
        }
        const height = inputShape[hAxis];
        const width = inputShape[wAxis];
        const kernelH = this.kernelSize[0];
        const kernelW = this.kernelSize[1];
        const strideH = this.strides[0];
        const strideW = this.strides[1];
        const outHeight = deconvLength(height, strideH, kernelH, this.padding);
        const outWidth = deconvLength(width, strideW, kernelW, this.padding);
        const outputShape = [batchSize, outHeight, outWidth, this.filters];
        if (this.dataFormat !== "channelsLast") {
          input2 = transpose(input2, [0, 2, 3, 1]);
        }
        let outputs = conv2dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
        if (this.dataFormat !== "channelsLast") {
          outputs = transpose(outputs, [0, 3, 1, 2]);
        }
        if (this.bias != null) {
          outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
        }
        if (this.activation != null) {
          outputs = this.activation.apply(outputs);
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      let channelAxis;
      let heightAxis;
      let widthAxis;
      if (this.dataFormat === "channelsFirst") {
        channelAxis = 1;
        heightAxis = 2;
        widthAxis = 3;
      } else {
        channelAxis = 3;
        heightAxis = 1;
        widthAxis = 2;
      }
      const kernelH = this.kernelSize[0];
      const kernelW = this.kernelSize[1];
      const strideH = this.strides[0];
      const strideW = this.strides[1];
      outputShape[channelAxis] = this.filters;
      outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
      outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
      return outputShape;
    }
    getConfig() {
      const config = super.getConfig();
      delete config["dilationRate"];
      return config;
    }
  };
  Conv2DTranspose.className = "Conv2DTranspose";
  exports_serialization.registerClass(Conv2DTranspose);
  Conv3DTranspose = class Conv3DTranspose extends Conv3D2 {
    constructor(args) {
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 5 })];
      if (this.padding !== "same" && this.padding !== "valid") {
        throw new ValueError(`Conv3DTranspose currently supports only padding modes 'same' ` + `and 'valid', but received padding mode ${this.padding}`);
      }
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length !== 5) {
        throw new ValueError("Input should have rank 5; Received input shape: " + JSON.stringify(inputShape));
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError("The channel dimension of the inputs should be defined. " + "Found `None`.");
      }
      const inputDim = inputShape[channelAxis];
      const kernelShape = this.kernelSize.concat([this.filters, inputDim]);
      this.kernel = this.addWeight("kernel", kernelShape, "float32", this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.inputSpec = [new InputSpec({ ndim: 5, axes: { [channelAxis]: inputDim } })];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let input2 = getExactlyOneTensor(inputs);
        if (input2.shape.length !== 5) {
          throw new ValueError(`Conv3DTranspose.call() expects input tensor to be rank-4, but ` + `received a tensor of rank-${input2.shape.length}`);
        }
        const inputShape = input2.shape;
        const batchSize = inputShape[0];
        let hAxis;
        let wAxis;
        let dAxis;
        if (this.dataFormat === "channelsFirst") {
          dAxis = 2;
          hAxis = 3;
          wAxis = 4;
        } else {
          dAxis = 1;
          hAxis = 2;
          wAxis = 3;
        }
        const depth = inputShape[dAxis];
        const height = inputShape[hAxis];
        const width = inputShape[wAxis];
        const kernelD = this.kernelSize[0];
        const kernelH = this.kernelSize[1];
        const kernelW = this.kernelSize[2];
        const strideD = this.strides[0];
        const strideH = this.strides[1];
        const strideW = this.strides[2];
        const outDepth = deconvLength(depth, strideD, kernelD, this.padding);
        const outHeight = deconvLength(height, strideH, kernelH, this.padding);
        const outWidth = deconvLength(width, strideW, kernelW, this.padding);
        const outputShape = [batchSize, outDepth, outHeight, outWidth, this.filters];
        if (this.dataFormat !== "channelsLast") {
          input2 = transpose(input2, [0, 2, 3, 4, 1]);
        }
        let outputs = conv3dTranspose(input2, this.kernel.read(), outputShape, this.strides, this.padding);
        if (this.dataFormat !== "channelsLast") {
          outputs = transpose(outputs, [0, 4, 1, 2, 3]);
        }
        if (this.bias !== null) {
          outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
        }
        if (this.activation !== null) {
          outputs = this.activation.apply(outputs);
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      let channelAxis;
      let depthAxis;
      let heightAxis;
      let widthAxis;
      if (this.dataFormat === "channelsFirst") {
        channelAxis = 1;
        depthAxis = 2;
        heightAxis = 3;
        widthAxis = 4;
      } else {
        channelAxis = 4;
        depthAxis = 1;
        heightAxis = 2;
        widthAxis = 3;
      }
      const kernelD = this.kernelSize[0];
      const kernelH = this.kernelSize[1];
      const kernelW = this.kernelSize[2];
      const strideD = this.strides[0];
      const strideH = this.strides[1];
      const strideW = this.strides[2];
      outputShape[channelAxis] = this.filters;
      outputShape[depthAxis] = deconvLength(outputShape[depthAxis], strideD, kernelD, this.padding);
      outputShape[heightAxis] = deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);
      outputShape[widthAxis] = deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);
      return outputShape;
    }
    getConfig() {
      const config = super.getConfig();
      delete config["dilationRate"];
      return config;
    }
  };
  Conv3DTranspose.className = "Conv3DTranspose";
  exports_serialization.registerClass(Conv3DTranspose);
  SeparableConv = class SeparableConv extends Conv {
    constructor(rank, config) {
      super(rank, config);
      this.DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform";
      this.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform";
      this.depthwiseKernel = null;
      this.pointwiseKernel = null;
      if (config.filters == null) {
        throw new ValueError("The `filters` configuration field is required by SeparableConv, " + "but is unspecified.");
      }
      if (config.kernelInitializer != null || config.kernelRegularizer != null || config.kernelConstraint != null) {
        throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint " + "are invalid for SeparableConv2D. Use depthwiseInitializer, " + "depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, " + "pointwiseRegularizer and pointwiseConstraint instead.");
      }
      if (config.padding != null && config.padding !== "same" && config.padding !== "valid") {
        throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: ` + `'same' and 'valid', but received ${JSON.stringify(config.padding)}`);
      }
      this.depthMultiplier = config.depthMultiplier == null ? 1 : config.depthMultiplier;
      this.depthwiseInitializer = getInitializer(config.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER);
      this.depthwiseRegularizer = getRegularizer(config.depthwiseRegularizer);
      this.depthwiseConstraint = getConstraint(config.depthwiseConstraint);
      this.pointwiseInitializer = getInitializer(config.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER);
      this.pointwiseRegularizer = getRegularizer(config.pointwiseRegularizer);
      this.pointwiseConstraint = getConstraint(config.pointwiseConstraint);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length < this.rank + 2) {
        throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ` + `${this.rank + 2}, but received input shape: ` + `${JSON.stringify(inputShape)}`);
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
        throw new ValueError(`The channel dimension of the inputs should be defined, ` + `but found ${JSON.stringify(inputShape[channelAxis])}`);
      }
      const inputDim = inputShape[channelAxis];
      const depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);
      const pointwiseKernelShape = [];
      for (let i = 0;i < this.rank; ++i) {
        pointwiseKernelShape.push(1);
      }
      pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);
      const trainable = true;
      this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);
      this.pointwiseKernel = this.addWeight("pointwise_kernel", pointwiseKernelShape, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.inputSpec = [new InputSpec({ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } })];
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        let output;
        if (this.rank === 1) {
          throw new NotImplementedError("1D separable convolution is not implemented yet.");
        } else if (this.rank === 2) {
          if (this.dataFormat === "channelsFirst") {
            inputs = transpose(inputs, [0, 2, 3, 1]);
          }
          output = separableConv2d(inputs, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, "NHWC");
        }
        if (this.useBias) {
          output = biasAdd(output, this.bias.read(), this.dataFormat);
        }
        if (this.activation != null) {
          output = this.activation.apply(output);
        }
        if (this.dataFormat === "channelsFirst") {
          output = transpose(output, [0, 3, 1, 2]);
        }
        return output;
      });
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      delete config["kernelInitializer"];
      delete config["kernelRegularizer"];
      delete config["kernelConstraint"];
      config["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
      config["pointwiseInitializer"] = serializeInitializer(this.pointwiseInitializer);
      config["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
      config["pointwiseRegularizer"] = serializeRegularizer(this.pointwiseRegularizer);
      config["depthwiseConstraint"] = serializeConstraint(this.depthwiseConstraint);
      config["pointwiseConstraint"] = serializeConstraint(this.pointwiseConstraint);
      return config;
    }
  };
  SeparableConv.className = "SeparableConv";
  SeparableConv2D = class SeparableConv2D extends SeparableConv {
    constructor(args) {
      super(2, args);
    }
  };
  SeparableConv2D.className = "SeparableConv2D";
  exports_serialization.registerClass(SeparableConv2D);
  Conv1D = class Conv1D extends Conv {
    constructor(args) {
      super(1, args);
      Conv1D.verifyArgs(args);
      this.inputSpec = [{ ndim: 3 }];
    }
    getConfig() {
      const config = super.getConfig();
      delete config["rank"];
      delete config["dataFormat"];
      return config;
    }
    static verifyArgs(args) {
      if (typeof args.kernelSize !== "number" && !checkArrayTypeAndLength(args.kernelSize, "number", 1, 1)) {
        throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with ` + `length 1, but received ${JSON.stringify(args.kernelSize)}.`);
      }
    }
  };
  Conv1D.className = "Conv1D";
  exports_serialization.registerClass(Conv1D);
  Cropping2D = class Cropping2D extends Layer {
    constructor(args) {
      super(args);
      if (typeof args.cropping === "number") {
        this.cropping = [[args.cropping, args.cropping], [args.cropping, args.cropping]];
      } else if (typeof args.cropping[0] === "number") {
        this.cropping = [
          [args.cropping[0], args.cropping[0]],
          [args.cropping[1], args.cropping[1]]
        ];
      } else {
        this.cropping = args.cropping;
      }
      this.dataFormat = args.dataFormat === undefined ? "channelsLast" : args.dataFormat;
      this.inputSpec = [{ ndim: 4 }];
    }
    computeOutputShape(inputShape) {
      if (this.dataFormat === "channelsFirst") {
        return [
          inputShape[0],
          inputShape[1],
          inputShape[2] - this.cropping[0][0] - this.cropping[0][1],
          inputShape[3] - this.cropping[1][0] - this.cropping[1][1]
        ];
      } else {
        return [
          inputShape[0],
          inputShape[1] - this.cropping[0][0] - this.cropping[0][1],
          inputShape[2] - this.cropping[1][0] - this.cropping[1][1],
          inputShape[3]
        ];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsLast") {
          const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);
          return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);
        } else {
          const hSliced = sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);
          return sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);
        }
      });
    }
    getConfig() {
      const config = { cropping: this.cropping, dataFormat: this.dataFormat };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Cropping2D.className = "Cropping2D";
  exports_serialization.registerClass(Cropping2D);
  UpSampling2D = class UpSampling2D extends Layer {
    constructor(args) {
      super(args);
      this.DEFAULT_SIZE = [2, 2];
      this.inputSpec = [{ ndim: 4 }];
      this.size = args.size == null ? this.DEFAULT_SIZE : args.size;
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      this.interpolation = args.interpolation == null ? "nearest" : args.interpolation;
      checkInterpolationFormat(this.interpolation);
    }
    computeOutputShape(inputShape) {
      if (this.dataFormat === "channelsFirst") {
        const height = inputShape[2] == null ? null : this.size[0] * inputShape[2];
        const width = inputShape[3] == null ? null : this.size[1] * inputShape[3];
        return [inputShape[0], inputShape[1], height, width];
      } else {
        const height = inputShape[1] == null ? null : this.size[0] * inputShape[1];
        const width = inputShape[2] == null ? null : this.size[1] * inputShape[2];
        return [inputShape[0], height, width, inputShape[3]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        let input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        if (this.dataFormat === "channelsFirst") {
          input2 = transpose(input2, [0, 2, 3, 1]);
          const height = this.size[0] * inputShape[2];
          const width = this.size[1] * inputShape[3];
          const resized = this.interpolation === "nearest" ? image.resizeNearestNeighbor(input2, [height, width]) : image.resizeBilinear(input2, [height, width]);
          return transpose(resized, [0, 3, 1, 2]);
        } else {
          const height = this.size[0] * inputShape[1];
          const width = this.size[1] * inputShape[2];
          return this.interpolation === "nearest" ? image.resizeNearestNeighbor(input2, [height, width]) : image.resizeBilinear(input2, [height, width]);
        }
      });
    }
    getConfig() {
      const config = {
        size: this.size,
        dataFormat: this.dataFormat,
        interpolation: this.interpolation
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  UpSampling2D.className = "UpSampling2D";
  exports_serialization.registerClass(UpSampling2D);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_depthwise.js
function depthwiseConv2d3(x, depthwiseKernel, strides = [1, 1], padding = "valid", dataFormat, dilationRate) {
  return tidy(() => {
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    checkDataFormat(dataFormat);
    let y = preprocessConv2DInput(x, dataFormat);
    if (x.rank !== 4) {
      throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ` + `${x.rank}-D`);
    }
    if (depthwiseKernel.rank !== 4) {
      throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ` + `${depthwiseKernel.rank}-D`);
    }
    y = depthwiseConv2d(y, depthwiseKernel, strides, padding === "same" ? "same" : "valid", "NHWC", dilationRate);
    if (dataFormat === "channelsFirst") {
      y = transpose(y, [0, 3, 1, 2]);
    }
    return y;
  });
}
var DepthwiseConv2D;
var init_convolutional_depthwise = __esm(() => {
  init_dist();
  init_dist();
  init_common3();
  init_tfjs_backend();
  init_common2();
  init_constraints();
  init_errors();
  init_initializers();
  init_regularizers();
  init_conv_utils();
  init_types_utils();
  init_convolutional();
  DepthwiseConv2D = class DepthwiseConv2D extends BaseConv {
    constructor(args) {
      super(2, args);
      this.depthwiseKernel = null;
      this.depthMultiplier = args.depthMultiplier == null ? 1 : args.depthMultiplier;
      this.depthwiseInitializer = getInitializer(args.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.depthwiseConstraint = getConstraint(args.depthwiseConstraint);
      this.depthwiseRegularizer = getRegularizer(args.depthwiseRegularizer);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length < 4) {
        throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. ` + `Received input shape: ${JSON.stringify(inputShape)}.`);
      }
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : 3;
      if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {
        throw new ValueError("The channel dimension of the inputs to DepthwiseConv2D should " + `be defined, but is not (${inputShape[channelAxis]}).`);
      }
      const inputDim = inputShape[channelAxis];
      const depthwiseKernelShape = [
        this.kernelSize[0],
        this.kernelSize[1],
        inputDim,
        this.depthMultiplier
      ];
      this.depthwiseKernel = this.addWeight("depthwise_kernel", depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        let outputs = depthwiseConv2d3(inputs, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);
        if (this.useBias) {
          outputs = biasAdd(outputs, this.bias.read(), this.dataFormat);
        }
        if (this.activation != null) {
          outputs = this.activation.apply(outputs);
        }
        return outputs;
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
      const cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
      const outFilters = this.dataFormat === "channelsFirst" ? inputShape[1] * this.depthMultiplier : inputShape[3] * this.depthMultiplier;
      const outRows = convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);
      const outCols = convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);
      if (this.dataFormat === "channelsFirst") {
        return [inputShape[0], outFilters, outRows, outCols];
      } else {
        return [inputShape[0], outRows, outCols, outFilters];
      }
    }
    getConfig() {
      const config = super.getConfig();
      config["depthMultiplier"] = this.depthMultiplier;
      config["depthwiseInitializer"] = serializeInitializer(this.depthwiseInitializer);
      config["depthwiseRegularizer"] = serializeRegularizer(this.depthwiseRegularizer);
      config["depthwiseConstraint"] = serializeConstraint(this.depthwiseRegularizer);
      return config;
    }
  };
  DepthwiseConv2D.className = "DepthwiseConv2D";
  exports_serialization.registerClass(DepthwiseConv2D);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/recurrent.js
function standardizeArgs(inputs, initialState, constants, numConstants) {
  if (Array.isArray(inputs)) {
    if (initialState != null || constants != null) {
      throw new ValueError("When inputs is an array, neither initialState or constants " + "should be provided");
    }
    if (numConstants != null) {
      constants = inputs.slice(inputs.length - numConstants, inputs.length);
      inputs = inputs.slice(0, inputs.length - numConstants);
    }
    if (inputs.length > 1) {
      initialState = inputs.slice(1, inputs.length);
    }
    inputs = inputs[0];
  }
  function toListOrNull(x) {
    if (x == null || Array.isArray(x)) {
      return x;
    } else {
      return [x];
    }
  }
  initialState = toListOrNull(initialState);
  constants = toListOrNull(constants);
  return { inputs, initialState, constants };
}
function rnn(stepFunction, inputs, initialStates, goBackwards = false, mask, constants, unroll = false, needPerStepOutputs = false) {
  return tidy(() => {
    const ndim = inputs.shape.length;
    if (ndim < 3) {
      throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);
    }
    const axes = [1, 0].concat(range4(2, ndim));
    inputs = transpose(inputs, axes);
    if (constants != null) {
      throw new NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support " + "constants yet.");
    }
    if (unroll) {
      console.warn("Backend rnn(): the unroll = true option is not applicable to the " + "imperative deeplearn.js backend.");
    }
    if (mask != null) {
      mask = cast(cast(mask, "bool"), "float32");
      if (mask.rank === ndim - 1) {
        mask = expandDims(mask, -1);
      }
      mask = transpose(mask, axes);
    }
    if (goBackwards) {
      inputs = reverse(inputs, 0);
      if (mask != null) {
        mask = reverse(mask, 0);
      }
    }
    const perStepOutputs = [];
    let lastOutput;
    let states = initialStates;
    const timeSteps = inputs.shape[0];
    const perStepInputs = unstack(inputs);
    let perStepMasks;
    if (mask != null) {
      perStepMasks = unstack(mask);
    }
    for (let t = 0;t < timeSteps; ++t) {
      const currentInput = perStepInputs[t];
      const stepOutputs = tidy(() => stepFunction(currentInput, states));
      if (mask == null) {
        lastOutput = stepOutputs[0];
        states = stepOutputs[1];
      } else {
        const maskedOutputs = tidy(() => {
          const stepMask = perStepMasks[t];
          const negStepMask = sub(onesLike(stepMask), stepMask);
          const output = add2(mul(stepOutputs[0], stepMask), mul(states[0], negStepMask));
          const newStates = states.map((state6, i) => {
            return add2(mul(stepOutputs[1][i], stepMask), mul(state6, negStepMask));
          });
          return { output, newStates };
        });
        lastOutput = maskedOutputs.output;
        states = maskedOutputs.newStates;
      }
      if (needPerStepOutputs) {
        perStepOutputs.push(lastOutput);
      }
    }
    let outputs;
    if (needPerStepOutputs) {
      const axis = 1;
      outputs = stack(perStepOutputs, axis);
    }
    return [lastOutput, outputs, states];
  });
}
function generateDropoutMask(args) {
  const { ones: ones9, rate, training: training3 = false, count: count2 = 1, dropoutFunc } = args;
  const droppedInputs = () => dropoutFunc != null ? dropoutFunc(ones9(), rate) : dropout3(ones9(), rate);
  const createMask = () => inTrainPhase(droppedInputs, ones9, training3);
  if (!count2 || count2 <= 1) {
    return keep(createMask().clone());
  }
  const masks = Array(count2).fill(undefined).map(createMask);
  return masks.map((m) => keep(m.clone()));
}
var RNN, RNNCell, SimpleRNNCell, SimpleRNN, GRUCell, GRU, LSTMCell, LSTM, StackedRNNCells;
var init_recurrent = __esm(() => {
  init_dist();
  init_dist();
  init_activations();
  init_tfjs_backend();
  init_common2();
  init_constraints();
  init_topology();
  init_topology();
  init_errors();
  init_initializers();
  init_regularizers();
  init_generic_utils();
  init_math_utils();
  init_types_utils();
  init_variables();
  init_serialization2();
  RNN = class RNN extends Layer {
    constructor(args) {
      super(args);
      let cell;
      if (args.cell == null) {
        throw new ValueError("cell property is missing for the constructor of RNN.");
      } else if (Array.isArray(args.cell)) {
        cell = new StackedRNNCells({ cells: args.cell });
      } else {
        cell = args.cell;
      }
      if (cell.stateSize == null) {
        throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of " + "integers, one integer per RNN state).");
      }
      this.cell = cell;
      this.returnSequences = args.returnSequences == null ? false : args.returnSequences;
      this.returnState = args.returnState == null ? false : args.returnState;
      this.goBackwards = args.goBackwards == null ? false : args.goBackwards;
      this._stateful = args.stateful == null ? false : args.stateful;
      this.unroll = args.unroll == null ? false : args.unroll;
      this.supportsMasking = true;
      this.inputSpec = [new InputSpec({ ndim: 3 })];
      this.stateSpec = null;
      this.states_ = null;
      this.numConstants = null;
      this.keptStates = [];
    }
    getStates() {
      if (this.states_ == null) {
        const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        return range4(0, numStates).map((x) => null);
      } else {
        return this.states_;
      }
    }
    setStates(states) {
      this.states_ = states;
    }
    computeOutputShape(inputShape) {
      if (isArrayOfShapes(inputShape)) {
        inputShape = inputShape[0];
      }
      inputShape = inputShape;
      let stateSize = this.cell.stateSize;
      if (!Array.isArray(stateSize)) {
        stateSize = [stateSize];
      }
      const outputDim = stateSize[0];
      let outputShape;
      if (this.returnSequences) {
        outputShape = [inputShape[0], inputShape[1], outputDim];
      } else {
        outputShape = [inputShape[0], outputDim];
      }
      if (this.returnState) {
        const stateShape = [];
        for (const dim of stateSize) {
          stateShape.push([inputShape[0], dim]);
        }
        return [outputShape].concat(stateShape);
      } else {
        return outputShape;
      }
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        if (Array.isArray(mask)) {
          mask = mask[0];
        }
        const outputMask = this.returnSequences ? mask : null;
        if (this.returnState) {
          const stateMask = this.states.map((s) => null);
          return [outputMask].concat(stateMask);
        } else {
          return outputMask;
        }
      });
    }
    get states() {
      if (this.states_ == null) {
        const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        const output = [];
        for (let i = 0;i < numStates; ++i) {
          output.push(null);
        }
        return output;
      } else {
        return this.states_;
      }
    }
    set states(s) {
      this.states_ = s;
    }
    build(inputShape) {
      const constantShape = null;
      if (this.numConstants != null) {
        throw new NotImplementedError("Constants support is not implemented in RNN yet.");
      }
      if (isArrayOfShapes(inputShape)) {
        inputShape = inputShape[0];
      }
      inputShape = inputShape;
      const batchSize = this.stateful ? inputShape[0] : null;
      const inputDim = inputShape.slice(2);
      this.inputSpec[0] = new InputSpec({ shape: [batchSize, null, ...inputDim] });
      const stepInputShape = [inputShape[0]].concat(inputShape.slice(2));
      if (constantShape != null) {
        throw new NotImplementedError("Constants support is not implemented in RNN yet.");
      } else {
        this.cell.build(stepInputShape);
      }
      let stateSize;
      if (Array.isArray(this.cell.stateSize)) {
        stateSize = this.cell.stateSize;
      } else {
        stateSize = [this.cell.stateSize];
      }
      if (this.stateSpec != null) {
        if (!exports_util.arraysEqual(this.stateSpec.map((spec) => spec.shape[spec.shape.length - 1]), stateSize)) {
          throw new ValueError(`An initialState was passed that is not compatible with ` + `cell.stateSize. Received stateSpec=${this.stateSpec}; ` + `However cell.stateSize is ${this.cell.stateSize}`);
        }
      } else {
        this.stateSpec = stateSize.map((dim) => new InputSpec({ shape: [null, dim] }));
      }
      if (this.stateful) {
        this.resetStates();
      }
    }
    resetStates(states, training3 = false) {
      tidy(() => {
        if (!this.stateful) {
          throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
        }
        const batchSize = this.inputSpec[0].shape[0];
        if (batchSize == null) {
          throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify " + "the batch size of your input tensors: \n" + "- If using a Sequential model, specify the batch size by " + "passing a `batchInputShape` option to your first layer.\n" + "- If using the functional API, specify the batch size by " + "passing a `batchShape` option to your Input layer.");
        }
        if (this.states_ == null) {
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map((dim) => zeros([batchSize, dim]));
          } else {
            this.states_ = [zeros([batchSize, this.cell.stateSize])];
          }
        } else if (states == null) {
          dispose(this.states_);
          if (this.keptStates != null) {
            dispose(this.keptStates);
            this.keptStates = [];
          }
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map((dim) => zeros([batchSize, dim]));
          } else {
            this.states_[0] = zeros([batchSize, this.cell.stateSize]);
          }
        } else {
          if (!Array.isArray(states)) {
            states = [states];
          }
          if (states.length !== this.states_.length) {
            throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), ` + `but it received ${states.length} state value(s). Input ` + `received: ${states}`);
          }
          if (training3 === true) {
            this.keptStates.push(this.states_.slice());
          } else {
            dispose(this.states_);
          }
          for (let index = 0;index < this.states_.length; ++index) {
            const value = states[index];
            const dim = Array.isArray(this.cell.stateSize) ? this.cell.stateSize[index] : this.cell.stateSize;
            const expectedShape = [batchSize, dim];
            if (!exports_util.arraysEqual(value.shape, expectedShape)) {
              throw new ValueError(`State ${index} is incompatible with layer ${this.name}: ` + `expected shape=${expectedShape}, received shape=${value.shape}`);
            }
            this.states_[index] = value;
          }
        }
        this.states_ = this.states_.map((state6) => keep(state6.clone()));
      });
    }
    apply(inputs, kwargs) {
      let initialState = kwargs == null ? null : kwargs["initialState"];
      let constants = kwargs == null ? null : kwargs["constants"];
      if (kwargs == null) {
        kwargs = {};
      }
      const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
      inputs = standardized.inputs;
      initialState = standardized.initialState;
      constants = standardized.constants;
      let additionalInputs = [];
      let additionalSpecs = [];
      if (initialState != null) {
        kwargs["initialState"] = initialState;
        additionalInputs = additionalInputs.concat(initialState);
        this.stateSpec = [];
        for (const state6 of initialState) {
          this.stateSpec.push(new InputSpec({ shape: state6.shape }));
        }
        additionalSpecs = additionalSpecs.concat(this.stateSpec);
      }
      if (constants != null) {
        kwargs["constants"] = constants;
        additionalInputs = additionalInputs.concat(constants);
        this.numConstants = constants.length;
      }
      const isTensor = additionalInputs[0] instanceof SymbolicTensor;
      if (isTensor) {
        const fullInput = [inputs].concat(additionalInputs);
        const fullInputSpec = this.inputSpec.concat(additionalSpecs);
        const originalInputSpec = this.inputSpec;
        this.inputSpec = fullInputSpec;
        const output = super.apply(fullInput, kwargs);
        this.inputSpec = originalInputSpec;
        return output;
      } else {
        return super.apply(inputs, kwargs);
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const mask = kwargs == null ? null : kwargs["mask"];
        const training3 = kwargs == null ? null : kwargs["training"];
        let initialState = kwargs == null ? null : kwargs["initialState"];
        inputs = getExactlyOneTensor(inputs);
        if (initialState == null) {
          if (this.stateful) {
            initialState = this.states_;
          } else {
            initialState = this.getInitialState(inputs);
          }
        }
        const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;
        if (initialState.length !== numStates) {
          throw new ValueError(`RNN Layer has ${numStates} state(s) but was passed ` + `${initialState.length} initial state(s).`);
        }
        if (this.unroll) {
          console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
        }
        const cellCallKwargs = { training: training3 };
        const step7 = (inputs2, states2) => {
          const outputs2 = this.cell.call([inputs2].concat(states2), cellCallKwargs);
          return [outputs2[0], outputs2.slice(1)];
        };
        const rnnOutputs = rnn(step7, inputs, initialState, this.goBackwards, mask, null, this.unroll, this.returnSequences);
        const lastOutput = rnnOutputs[0];
        const outputs = rnnOutputs[1];
        const states = rnnOutputs[2];
        if (this.stateful) {
          this.resetStates(states, training3);
        }
        const output = this.returnSequences ? outputs : lastOutput;
        if (this.returnState) {
          return [output].concat(states);
        } else {
          return output;
        }
      });
    }
    getInitialState(inputs) {
      return tidy(() => {
        let initialState = zeros(inputs.shape);
        initialState = sum2(initialState, [1, 2]);
        initialState = expandDims2(initialState);
        if (Array.isArray(this.cell.stateSize)) {
          return this.cell.stateSize.map((dim) => dim > 1 ? tile7(initialState, [1, dim]) : initialState);
        } else {
          return this.cell.stateSize > 1 ? [tile7(initialState, [1, this.cell.stateSize])] : [initialState];
        }
      });
    }
    get trainableWeights() {
      if (!this.trainable) {
        return [];
      }
      return this.cell.trainableWeights;
    }
    get nonTrainableWeights() {
      if (!this.trainable) {
        return this.cell.weights;
      }
      return this.cell.nonTrainableWeights;
    }
    setFastWeightInitDuringBuild(value) {
      super.setFastWeightInitDuringBuild(value);
      if (this.cell != null) {
        this.cell.setFastWeightInitDuringBuild(value);
      }
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        returnSequences: this.returnSequences,
        returnState: this.returnState,
        goBackwards: this.goBackwards,
        stateful: this.stateful,
        unroll: this.unroll
      };
      if (this.numConstants != null) {
        config["numConstants"] = this.numConstants;
      }
      const cellConfig = this.cell.getConfig();
      if (this.getClassName() === RNN.className) {
        config["cell"] = {
          className: this.cell.getClassName(),
          config: cellConfig
        };
      }
      return Object.assign(Object.assign(Object.assign({}, cellConfig), baseConfig), config);
    }
    static fromConfig(cls, config, customObjects = {}) {
      const cellConfig = config["cell"];
      const cell = deserialize(cellConfig, customObjects);
      return new cls(Object.assign(config, { cell }));
    }
  };
  RNN.className = "RNN";
  exports_serialization.registerClass(RNN);
  RNNCell = class RNNCell extends Layer {
  };
  SimpleRNNCell = class SimpleRNNCell extends RNNCell {
    constructor(args) {
      super(args);
      this.DEFAULT_ACTIVATION = "tanh";
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      this.units = args.units;
      assertPositiveInteger(this.units, `units`);
      this.activation = getActivation(args.activation == null ? this.DEFAULT_ACTIVATION : args.activation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.kernelConstraint = getConstraint(args.kernelConstraint);
      this.recurrentConstraint = getConstraint(args.recurrentConstraint);
      this.biasConstraint = getConstraint(args.biasConstraint);
      this.dropout = min5([1, max7([0, args.dropout == null ? 0 : args.dropout])]);
      this.recurrentDropout = min5([
        1,
        max7([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
      ]);
      this.dropoutFunc = args.dropoutFunc;
      this.stateSize = this.units;
      this.dropoutMask = null;
      this.recurrentDropoutMask = null;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      this.kernel = this.addWeight("kernel", [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        if (inputs.length !== 2) {
          throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);
        }
        let prevOutput = inputs[1];
        inputs = inputs[0];
        const training3 = kwargs["training"] == null ? false : kwargs["training"];
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(inputs),
            rate: this.dropout,
            training: training3,
            dropoutFunc: this.dropoutFunc
          });
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(prevOutput),
            rate: this.recurrentDropout,
            training: training3,
            dropoutFunc: this.dropoutFunc
          });
        }
        let h;
        const dpMask = this.dropoutMask;
        const recDpMask = this.recurrentDropoutMask;
        if (dpMask != null) {
          h = dot4(mul(inputs, dpMask), this.kernel.read());
        } else {
          h = dot4(inputs, this.kernel.read());
        }
        if (this.bias != null) {
          h = biasAdd(h, this.bias.read());
        }
        if (recDpMask != null) {
          prevOutput = mul(prevOutput, recDpMask);
        }
        let output = add2(h, dot4(prevOutput, this.recurrentKernel.read()));
        if (this.activation != null) {
          output = this.activation.apply(output);
        }
        return [output, output];
      });
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        recurrentInitializer: serializeInitializer(this.recurrentInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        recurrentConstraint: serializeConstraint(this.recurrentConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout
      };
      return Object.assign(Object.assign({}, baseConfig), config);
    }
  };
  SimpleRNNCell.className = "SimpleRNNCell";
  exports_serialization.registerClass(SimpleRNNCell);
  SimpleRNN = class SimpleRNN extends RNN {
    constructor(args) {
      args.cell = new SimpleRNNCell(args);
      super(args);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training3 = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training: training3, initialState });
      });
    }
    static fromConfig(cls, config) {
      return new cls(config);
    }
  };
  SimpleRNN.className = "SimpleRNN";
  exports_serialization.registerClass(SimpleRNN);
  GRUCell = class GRUCell extends RNNCell {
    constructor(args) {
      super(args);
      this.DEFAULT_ACTIVATION = "tanh";
      this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      if (args.resetAfter) {
        throw new ValueError(`GRUCell does not support reset_after parameter set to true.`);
      }
      this.units = args.units;
      assertPositiveInteger(this.units, "units");
      this.activation = getActivation(args.activation === undefined ? this.DEFAULT_ACTIVATION : args.activation);
      this.recurrentActivation = getActivation(args.recurrentActivation === undefined ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.kernelConstraint = getConstraint(args.kernelConstraint);
      this.recurrentConstraint = getConstraint(args.recurrentConstraint);
      this.biasConstraint = getConstraint(args.biasConstraint);
      this.dropout = min5([1, max7([0, args.dropout == null ? 0 : args.dropout])]);
      this.recurrentDropout = min5([
        1,
        max7([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
      ]);
      this.dropoutFunc = args.dropoutFunc;
      this.implementation = args.implementation;
      this.stateSize = this.units;
      this.dropoutMask = null;
      this.recurrentDropoutMask = null;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const inputDim = inputShape[inputShape.length - 1];
      this.kernel = this.addWeight("kernel", [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      if (this.useBias) {
        this.bias = this.addWeight("bias", [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        if (inputs.length !== 2) {
          throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ` + `${inputs.length}.`);
        }
        const training3 = kwargs["training"] == null ? false : kwargs["training"];
        let hTMinus1 = inputs[1];
        inputs = inputs[0];
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(inputs),
            rate: this.dropout,
            training: training3,
            count: 3,
            dropoutFunc: this.dropoutFunc
          });
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(hTMinus1),
            rate: this.recurrentDropout,
            training: training3,
            count: 3,
            dropoutFunc: this.dropoutFunc
          });
        }
        const dpMask = this.dropoutMask;
        const recDpMask = this.recurrentDropoutMask;
        let z;
        let r;
        let hh;
        if (0 < this.dropout && this.dropout < 1) {
          inputs = mul(inputs, dpMask[0]);
        }
        let matrixX = dot4(inputs, this.kernel.read());
        if (this.useBias) {
          matrixX = biasAdd(matrixX, this.bias.read());
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
          hTMinus1 = mul(hTMinus1, recDpMask[0]);
        }
        const recurrentKernelValue = this.recurrentKernel.read();
        const [rk1, rk2] = split(recurrentKernelValue, [2 * this.units, this.units], recurrentKernelValue.rank - 1);
        const matrixInner = dot4(hTMinus1, rk1);
        const [xZ, xR, xH] = split(matrixX, 3, matrixX.rank - 1);
        const [recurrentZ, recurrentR] = split(matrixInner, 2, matrixInner.rank - 1);
        z = this.recurrentActivation.apply(add2(xZ, recurrentZ));
        r = this.recurrentActivation.apply(add2(xR, recurrentR));
        const recurrentH = dot4(mul(r, hTMinus1), rk2);
        hh = this.activation.apply(add2(xH, recurrentH));
        const h = add2(mul(z, hTMinus1), mul(add2(1, neg(z)), hh));
        return [h, h];
      });
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        recurrentActivation: serializeActivation(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        recurrentInitializer: serializeInitializer(this.recurrentInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        recurrentConstraint: serializeConstraint(this.recurrentConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation,
        resetAfter: false
      };
      return Object.assign(Object.assign({}, baseConfig), config);
    }
  };
  GRUCell.className = "GRUCell";
  exports_serialization.registerClass(GRUCell);
  GRU = class GRU extends RNN {
    constructor(args) {
      if (args.implementation === 0) {
        console.warn("`implementation=0` has been deprecated, and now defaults to " + "`implementation=1`. Please update your layer call.");
      }
      args.cell = new GRUCell(args);
      super(args);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training3 = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training: training3, initialState });
      });
    }
    static fromConfig(cls, config) {
      if (config["implmentation"] === 0) {
        config["implementation"] = 1;
      }
      return new cls(config);
    }
  };
  GRU.className = "GRU";
  exports_serialization.registerClass(GRU);
  LSTMCell = class LSTMCell extends RNNCell {
    constructor(args) {
      super(args);
      this.DEFAULT_ACTIVATION = "tanh";
      this.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid";
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_RECURRENT_INITIALIZER = "orthogonal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      this.units = args.units;
      assertPositiveInteger(this.units, "units");
      this.activation = getActivation(args.activation === undefined ? this.DEFAULT_ACTIVATION : args.activation);
      this.recurrentActivation = getActivation(args.recurrentActivation === undefined ? this.DEFAULT_RECURRENT_ACTIVATION : args.recurrentActivation);
      this.useBias = args.useBias == null ? true : args.useBias;
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.unitForgetBias = args.unitForgetBias;
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.kernelConstraint = getConstraint(args.kernelConstraint);
      this.recurrentConstraint = getConstraint(args.recurrentConstraint);
      this.biasConstraint = getConstraint(args.biasConstraint);
      this.dropout = min5([1, max7([0, args.dropout == null ? 0 : args.dropout])]);
      this.recurrentDropout = min5([
        1,
        max7([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])
      ]);
      this.dropoutFunc = args.dropoutFunc;
      this.implementation = args.implementation;
      this.stateSize = [this.units, this.units];
      this.dropoutMask = null;
      this.recurrentDropoutMask = null;
    }
    build(inputShape) {
      var _a;
      inputShape = getExactlyOneShape(inputShape);
      const inputDim = inputShape[inputShape.length - 1];
      this.kernel = this.addWeight("kernel", [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      let biasInitializer;
      if (this.useBias) {
        if (this.unitForgetBias) {
          const capturedBiasInit = this.biasInitializer;
          const capturedUnits = this.units;
          biasInitializer = new (_a = class CustomInit extends Initializer {
            apply(shape, dtype) {
              const bI = capturedBiasInit.apply([capturedUnits]);
              const bF = new Ones().apply([capturedUnits]);
              const bCAndH = capturedBiasInit.apply([capturedUnits * 2]);
              return concatAlongFirstAxis(concatAlongFirstAxis(bI, bF), bCAndH);
            }
          }, _a.className = "CustomInit", _a);
        } else {
          biasInitializer = this.biasInitializer;
        }
        this.bias = this.addWeight("bias", [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      } else {
        this.bias = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const training3 = kwargs["training"] == null ? false : kwargs["training"];
        inputs = inputs;
        if (inputs.length !== 3) {
          throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ` + `${inputs.length}.`);
        }
        let hTMinus1 = inputs[1];
        const cTMinus1 = inputs[2];
        inputs = inputs[0];
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(inputs),
            rate: this.dropout,
            training: training3,
            count: 4,
            dropoutFunc: this.dropoutFunc
          });
        }
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(hTMinus1),
            rate: this.recurrentDropout,
            training: training3,
            count: 4,
            dropoutFunc: this.dropoutFunc
          });
        }
        const dpMask = this.dropoutMask;
        const recDpMask = this.recurrentDropoutMask;
        let i;
        let f;
        let c;
        let o;
        if (0 < this.dropout && this.dropout < 1) {
          inputs = mul(inputs, dpMask[0]);
        }
        let z = dot4(inputs, this.kernel.read());
        if (0 < this.recurrentDropout && this.recurrentDropout < 1) {
          hTMinus1 = mul(hTMinus1, recDpMask[0]);
        }
        z = add2(z, dot4(hTMinus1, this.recurrentKernel.read()));
        if (this.useBias) {
          z = biasAdd(z, this.bias.read());
        }
        const [z0, z1, z2, z3] = split(z, 4, z.rank - 1);
        i = this.recurrentActivation.apply(z0);
        f = this.recurrentActivation.apply(z1);
        c = add2(mul(f, cTMinus1), mul(i, this.activation.apply(z2)));
        o = this.recurrentActivation.apply(z3);
        const h = mul(o, this.activation.apply(c));
        return [h, h, c];
      });
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        recurrentActivation: serializeActivation(this.recurrentActivation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        recurrentInitializer: serializeInitializer(this.recurrentInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        unitForgetBias: this.unitForgetBias,
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        recurrentConstraint: serializeConstraint(this.recurrentConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint),
        dropout: this.dropout,
        recurrentDropout: this.recurrentDropout,
        implementation: this.implementation
      };
      return Object.assign(Object.assign({}, baseConfig), config);
    }
  };
  LSTMCell.className = "LSTMCell";
  exports_serialization.registerClass(LSTMCell);
  LSTM = class LSTM extends RNN {
    constructor(args) {
      if (args.implementation === 0) {
        console.warn("`implementation=0` has been deprecated, and now defaults to " + "`implementation=1`. Please update your layer call.");
      }
      args.cell = new LSTMCell(args);
      super(args);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training3 = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training: training3, initialState });
      });
    }
    static fromConfig(cls, config) {
      if (config["implmentation"] === 0) {
        config["implementation"] = 1;
      }
      return new cls(config);
    }
  };
  LSTM.className = "LSTM";
  exports_serialization.registerClass(LSTM);
  StackedRNNCells = class StackedRNNCells extends RNNCell {
    constructor(args) {
      super(args);
      this.cells = args.cells;
    }
    get stateSize() {
      const stateSize = [];
      for (const cell of this.cells.slice().reverse()) {
        if (Array.isArray(cell.stateSize)) {
          stateSize.push(...cell.stateSize);
        } else {
          stateSize.push(cell.stateSize);
        }
      }
      return stateSize;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        let states = inputs.slice(1);
        const nestedStates = [];
        for (const cell of this.cells.slice().reverse()) {
          if (Array.isArray(cell.stateSize)) {
            nestedStates.push(states.splice(0, cell.stateSize.length));
          } else {
            nestedStates.push(states.splice(0, 1));
          }
        }
        nestedStates.reverse();
        const newNestedStates = [];
        let callInputs;
        for (let i = 0;i < this.cells.length; ++i) {
          const cell = this.cells[i];
          states = nestedStates[i];
          if (i === 0) {
            callInputs = [inputs[0]].concat(states);
          } else {
            callInputs = [callInputs[0]].concat(states);
          }
          callInputs = cell.call(callInputs, kwargs);
          newNestedStates.push(callInputs.slice(1));
        }
        states = [];
        for (const cellStates of newNestedStates.slice().reverse()) {
          states.push(...cellStates);
        }
        return [callInputs[0]].concat(states);
      });
    }
    build(inputShape) {
      if (isArrayOfShapes(inputShape)) {
        inputShape = inputShape[0];
      }
      inputShape = inputShape;
      let outputDim;
      this.cells.forEach((cell, i) => {
        nameScope(`RNNCell_${i}`, () => {
          cell.build(inputShape);
          if (Array.isArray(cell.stateSize)) {
            outputDim = cell.stateSize[0];
          } else {
            outputDim = cell.stateSize;
          }
          inputShape = [inputShape[0], outputDim];
        });
      });
      this.built = true;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const getCellConfig = (cell) => {
        return {
          className: cell.getClassName(),
          config: cell.getConfig()
        };
      };
      const cellConfigs = this.cells.map(getCellConfig);
      const config = { cells: cellConfigs };
      return Object.assign(Object.assign({}, baseConfig), config);
    }
    static fromConfig(cls, config, customObjects = {}) {
      const cells = [];
      for (const cellConfig of config["cells"]) {
        cells.push(deserialize(cellConfig, customObjects));
      }
      return new cls({ cells });
    }
    get trainableWeights() {
      if (!this.trainable) {
        return [];
      }
      const weights = [];
      for (const cell of this.cells) {
        weights.push(...cell.trainableWeights);
      }
      return weights;
    }
    get nonTrainableWeights() {
      const weights = [];
      for (const cell of this.cells) {
        weights.push(...cell.nonTrainableWeights);
      }
      if (!this.trainable) {
        const trainableWeights = [];
        for (const cell of this.cells) {
          trainableWeights.push(...cell.trainableWeights);
        }
        return trainableWeights.concat(weights);
      }
      return weights;
    }
    getWeights() {
      const weights = [];
      for (const cell of this.cells) {
        weights.push(...cell.weights);
      }
      return batchGetValue(weights);
    }
    setWeights(weights) {
      const tuples = [];
      for (const cell of this.cells) {
        const numParams = cell.weights.length;
        const inputWeights = weights.splice(numParams);
        for (let i = 0;i < cell.weights.length; ++i) {
          tuples.push([cell.weights[i], inputWeights[i]]);
        }
      }
      batchSetValue(tuples);
    }
  };
  StackedRNNCells.className = "StackedRNNCells";
  exports_serialization.registerClass(StackedRNNCells);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s);i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
}, ConvRNN2D, ConvLSTM2DCell, ConvLSTM2D;
var init_convolutional_recurrent = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_common2();
  init_topology();
  init_errors();
  init_initializers();
  init_conv_utils();
  init_generic_utils();
  init_types_utils();
  init_recurrent();
  ConvRNN2D = class ConvRNN2D extends RNN {
    constructor(args) {
      if (args.unroll) {
        throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");
      }
      if (Array.isArray(args.cell)) {
        throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");
      }
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 5 })];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.cell.dropoutMask != null) {
          dispose(this.cell.dropoutMask);
          this.cell.dropoutMask = null;
        }
        if (this.cell.recurrentDropoutMask != null) {
          dispose(this.cell.recurrentDropoutMask);
          this.cell.recurrentDropoutMask = null;
        }
        if (kwargs && kwargs["constants"]) {
          throw new ValueError("ConvRNN2D cell does not support constants");
        }
        const mask = kwargs == null ? null : kwargs["mask"];
        const training3 = kwargs == null ? null : kwargs["training"];
        const initialState = kwargs == null ? null : kwargs["initialState"];
        return super.call(inputs, { mask, training: training3, initialState });
      });
    }
    computeOutputShape(inputShape) {
      let outShape = this.computeSingleOutputShape(inputShape);
      if (!this.returnSequences) {
        outShape = [outShape[0], ...outShape.slice(2)];
      }
      if (this.returnState) {
        outShape = [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];
      }
      return outShape;
    }
    getInitialState(inputs) {
      return tidy(() => {
        const { stateSize } = this.cell;
        const inputShape = inputs.shape;
        const outputShape = this.computeSingleOutputShape(inputShape);
        const stateShape = [outputShape[0], ...outputShape.slice(2)];
        const initialState = zeros(stateShape);
        if (Array.isArray(stateSize)) {
          return Array(stateSize.length).fill(initialState);
        }
        return [initialState];
      });
    }
    resetStates(states, training3 = false) {
      tidy(() => {
        if (!this.stateful) {
          throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");
        }
        const inputShape = this.inputSpec[0].shape;
        const outputShape = this.computeSingleOutputShape(inputShape);
        const stateShape = [outputShape[0], ...outputShape.slice(2)];
        const batchSize = inputShape[0];
        if (batchSize == null) {
          throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify " + "the batch size of your input tensors: \n" + "- If using a Sequential model, specify the batch size by " + "passing a `batchInputShape` option to your first layer.\n" + "- If using the functional API, specify the batch size by " + "passing a `batchShape` option to your Input layer.");
        }
        if (this.getStates() == null) {
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map(() => zeros(stateShape));
          } else {
            this.states_ = [zeros(stateShape)];
          }
        } else if (states == null) {
          dispose(this.states_);
          if (this.keptStates != null) {
            dispose(this.keptStates);
            this.keptStates = [];
          }
          if (Array.isArray(this.cell.stateSize)) {
            this.states_ = this.cell.stateSize.map(() => zeros(stateShape));
          } else {
            this.states_[0] = zeros(stateShape);
          }
        } else {
          if (!Array.isArray(states)) {
            states = [states];
          }
          if (states.length !== this.states_.length) {
            throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), ` + `but it received ${states.length} state value(s). Input ` + `received: ${states}`);
          }
          if (training3) {
            this.keptStates.push(this.states_.slice());
          } else {
            dispose(this.states_);
          }
          for (let index = 0;index < this.states_.length; ++index) {
            const value = states[index];
            const expectedShape = stateShape;
            if (!exports_util.arraysEqual(value.shape, expectedShape)) {
              throw new ValueError(`State ${index} is incompatible with layer ${this.name}: ` + `expected shape=${expectedShape}, received shape=${value.shape}`);
            }
            this.states_[index] = value;
          }
        }
        this.states_ = this.states_.map((state6) => keep(state6.clone()));
      });
    }
    computeSingleOutputShape(inputShape) {
      const { dataFormat, filters, kernelSize, padding, strides, dilationRate } = this.cell;
      const isChannelsFirst = dataFormat === "channelsFirst";
      const h = inputShape[isChannelsFirst ? 3 : 2];
      const w = inputShape[isChannelsFirst ? 4 : 3];
      const hOut = convOutputLength(h, kernelSize[0], padding, strides[0], dilationRate[0]);
      const wOut = convOutputLength(w, kernelSize[1], padding, strides[1], dilationRate[1]);
      const outShape = [
        ...inputShape.slice(0, 2),
        ...isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters]
      ];
      return outShape;
    }
  };
  ConvRNN2D.className = "ConvRNN2D";
  ConvLSTM2DCell = class ConvLSTM2DCell extends LSTMCell {
    constructor(args) {
      const { filters, kernelSize, strides, padding, dataFormat, dilationRate } = args;
      super(Object.assign(Object.assign({}, args), { units: filters }));
      this.filters = filters;
      assertPositiveInteger(this.filters, "filters");
      this.kernelSize = normalizeArray(kernelSize, 2, "kernelSize");
      this.kernelSize.forEach((size) => assertPositiveInteger(size, "kernelSize"));
      this.strides = normalizeArray(strides || 1, 2, "strides");
      this.strides.forEach((stride) => assertPositiveInteger(stride, "strides"));
      this.padding = padding || "valid";
      checkPaddingMode(this.padding);
      this.dataFormat = dataFormat || "channelsLast";
      checkDataFormat(this.dataFormat);
      this.dilationRate = normalizeArray(dilationRate || 1, 2, "dilationRate");
      this.dilationRate.forEach((rate) => assertPositiveInteger(rate, "dilationRate"));
    }
    build(inputShape) {
      var _a;
      inputShape = getExactlyOneShape(inputShape);
      const channelAxis = this.dataFormat === "channelsFirst" ? 1 : inputShape.length - 1;
      if (inputShape[channelAxis] == null) {
        throw new ValueError(`The channel dimension of the input should be defined. ` + `Found ${inputShape[channelAxis]}`);
      }
      const inputDim = inputShape[channelAxis];
      const numOfKernels = 4;
      const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);
      this.kernel = this.addWeight("kernel", kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
      const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);
      this.recurrentKernel = this.addWeight("recurrent_kernel", recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);
      if (this.useBias) {
        let biasInitializer;
        if (this.unitForgetBias) {
          const init = this.biasInitializer;
          const filters = this.filters;
          biasInitializer = new (_a = class CustomInit extends Initializer {
            apply(shape, dtype) {
              const biasI = init.apply([filters]);
              const biasF = ones2([filters]);
              const biasCAndO = init.apply([filters * 2]);
              return concatenate([biasI, biasF, biasCAndO]);
            }
          }, _a.className = "CustomInit", _a);
        } else {
          biasInitializer = this.biasInitializer;
        }
        this.bias = this.addWeight("bias", [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (inputs.length !== 3) {
          throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ` + `${inputs.length}.`);
        }
        const training3 = kwargs["training"] || false;
        const x = inputs[0];
        const hTMinus1 = inputs[1];
        const cTMinus1 = inputs[2];
        const numOfKernels = 4;
        if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {
          this.dropoutMask = generateDropoutMask({
            ones: () => onesLike(x),
            rate: this.dropout,
            training: training3,
            count: numOfKernels,
            dropoutFunc: this.dropoutFunc
          });
        }
        const dropoutMask = this.dropoutMask;
        const applyDropout = (x2, mask, index) => {
          if (!mask || !mask[index]) {
            return x2;
          }
          return mul(mask[index], x2);
        };
        let xI = applyDropout(x, dropoutMask, 0);
        let xF = applyDropout(x, dropoutMask, 1);
        let xC = applyDropout(x, dropoutMask, 2);
        let xO = applyDropout(x, dropoutMask, 3);
        if (0 < this.recurrentDropout && this.recurrentDropout < 1 && this.recurrentDropoutMask == null) {
          this.recurrentDropoutMask = generateDropoutMask({
            ones: () => onesLike(hTMinus1),
            rate: this.recurrentDropout,
            training: training3,
            count: numOfKernels,
            dropoutFunc: this.dropoutFunc
          });
        }
        const recDropoutMask = this.recurrentDropoutMask;
        let hI = applyDropout(hTMinus1, recDropoutMask, 0);
        let hF = applyDropout(hTMinus1, recDropoutMask, 1);
        let hC = applyDropout(hTMinus1, recDropoutMask, 2);
        let hO = applyDropout(hTMinus1, recDropoutMask, 3);
        const kernelChannelAxis = 3;
        const [kernelI, kernelF, kernelC, kernelO] = split(this.kernel.read(), numOfKernels, kernelChannelAxis);
        const [biasI, biasF, biasC, biasO] = this.useBias ? split(this.bias.read(), numOfKernels) : [null, null, null, null];
        xI = this.inputConv(xI, kernelI, biasI, this.padding);
        xF = this.inputConv(xF, kernelF, biasF, this.padding);
        xC = this.inputConv(xC, kernelC, biasC, this.padding);
        xO = this.inputConv(xO, kernelO, biasO, this.padding);
        const [recKernelI, recKernelF, recKernelC, recKernelO] = split(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);
        hI = this.recurrentConv(hI, recKernelI);
        hF = this.recurrentConv(hF, recKernelF);
        hC = this.recurrentConv(hC, recKernelC);
        hO = this.recurrentConv(hO, recKernelO);
        const i = this.recurrentActivation.apply(add2(xI, hI));
        const f = this.recurrentActivation.apply(add2(xF, hF));
        const c = add2(mul(f, cTMinus1), mul(i, this.activation.apply(add2(xC, hC))));
        const h = mul(this.recurrentActivation.apply(add2(xO, hO)), this.activation.apply(c));
        return [h, h, c];
      });
    }
    getConfig() {
      const _a = super.getConfig(), { units: _ } = _a, baseConfig = __rest(_a, ["units"]);
      const config = {
        filters: this.filters,
        kernelSize: this.kernelSize,
        padding: this.padding,
        dataFormat: this.dataFormat,
        dilationRate: this.dilationRate,
        strides: this.strides
      };
      return Object.assign(Object.assign({}, baseConfig), config);
    }
    inputConv(x, w, b, padding) {
      const out = conv2d(x, w, this.strides, padding || "valid", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC", this.dilationRate);
      if (b) {
        return biasAdd(out, b, this.dataFormat);
      }
      return out;
    }
    recurrentConv(x, w) {
      const strides = 1;
      return conv2d(x, w, strides, "same", this.dataFormat === "channelsFirst" ? "NCHW" : "NHWC");
    }
  };
  ConvLSTM2DCell.className = "ConvLSTM2DCell";
  exports_serialization.registerClass(ConvLSTM2DCell);
  ConvLSTM2D = class ConvLSTM2D extends ConvRNN2D {
    constructor(args) {
      const cell = new ConvLSTM2DCell(args);
      super(Object.assign(Object.assign({}, args), { cell }));
    }
    static fromConfig(cls, config) {
      return new cls(config);
    }
  };
  ConvLSTM2D.className = "ConvLSTM2D";
  exports_serialization.registerClass(ConvLSTM2D);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/core.js
var Dropout, SpatialDropout1D, Dense, Flatten, Activation2, RepeatVector, Reshape2, Permute, Masking;
var init_core = __esm(() => {
  init_dist();
  init_activations();
  init_tfjs_backend();
  init_constraints();
  init_topology();
  init_errors();
  init_initializers();
  init_regularizers();
  init_generic_utils();
  init_math_utils();
  init_types_utils();
  Dropout = class Dropout extends Layer {
    constructor(args) {
      super(args);
      this.rate = Math.max(Math.min(args.rate, 1), 0);
      this.noiseShape = args.noiseShape;
      this.seed = args.seed;
      this.supportsMasking = true;
    }
    getNoiseShape(input2) {
      if (this.noiseShape == null) {
        return this.noiseShape;
      }
      const inputShape = input2.shape;
      const noiseShape = [];
      for (let i = 0;i < this.noiseShape.length; ++i) {
        noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);
      }
      return noiseShape;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        if (0 < this.rate && this.rate < 1) {
          const training3 = kwargs["training"] == null ? false : kwargs["training"];
          const noiseShape = this.getNoiseShape(input2);
          const output = inTrainPhase(() => dropout3(input2, this.rate, noiseShape, this.seed), () => input2, training3);
          return output;
        }
        return inputs;
      });
    }
    getConfig() {
      const config = {
        rate: this.rate,
        noiseShape: this.noiseShape,
        seed: this.seed
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    dispose() {
      return super.dispose();
    }
  };
  Dropout.className = "Dropout";
  exports_serialization.registerClass(Dropout);
  SpatialDropout1D = class SpatialDropout1D extends Dropout {
    constructor(args) {
      super(args);
      this.inputSpec = [{ ndim: 3 }];
    }
    getNoiseShape(input2) {
      const inputShape = input2.shape;
      return [inputShape[0], 1, inputShape[2]];
    }
  };
  SpatialDropout1D.className = "SpatialDropout1D";
  exports_serialization.registerClass(SpatialDropout1D);
  Dense = class Dense extends Layer {
    constructor(args) {
      super(args);
      this.activation = null;
      this.useBias = true;
      this.kernel = null;
      this.bias = null;
      this.DEFAULT_KERNEL_INITIALIZER = "glorotNormal";
      this.DEFAULT_BIAS_INITIALIZER = "zeros";
      if (args.batchInputShape == null && args.inputShape == null && args.inputDim != null) {
        let batchSize = null;
        if (args.batchSize != null) {
          batchSize = args.batchSize;
        }
        this.batchInputShape = [batchSize, args.inputDim];
      }
      this.units = args.units;
      assertPositiveInteger(this.units, "units");
      this.activation = getActivation(args.activation);
      if (args.useBias != null) {
        this.useBias = args.useBias;
      }
      this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);
      this.biasInitializer = getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);
      this.kernelConstraint = getConstraint(args.kernelConstraint);
      this.biasConstraint = getConstraint(args.biasConstraint);
      this.kernelRegularizer = getRegularizer(args.kernelRegularizer);
      this.biasRegularizer = getRegularizer(args.biasRegularizer);
      this.activityRegularizer = getRegularizer(args.activityRegularizer);
      this.supportsMasking = true;
      this.inputSpec = [{ minNDim: 2 }];
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const inputLastDim = inputShape[inputShape.length - 1];
      if (this.kernel == null) {
        this.kernel = this.addWeight("kernel", [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);
        if (this.useBias) {
          this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);
        }
      }
      this.inputSpec = [{ minNDim: 2, axes: { [-1]: inputLastDim } }];
      this.built = true;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      outputShape[outputShape.length - 1] = this.units;
      return outputShape;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());
        let output;
        if (fusedActivationName != null) {
          output = dot4(input2, this.kernel.read(), fusedActivationName, this.bias ? this.bias.read() : null);
        } else {
          output = dot4(input2, this.kernel.read());
          if (this.bias != null) {
            output = biasAdd(output, this.bias.read());
          }
          if (this.activation != null) {
            output = this.activation.apply(output);
          }
        }
        return output;
      });
    }
    getConfig() {
      const config = {
        units: this.units,
        activation: serializeActivation(this.activation),
        useBias: this.useBias,
        kernelInitializer: serializeInitializer(this.kernelInitializer),
        biasInitializer: serializeInitializer(this.biasInitializer),
        kernelRegularizer: serializeRegularizer(this.kernelRegularizer),
        biasRegularizer: serializeRegularizer(this.biasRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        kernelConstraint: serializeConstraint(this.kernelConstraint),
        biasConstraint: serializeConstraint(this.biasConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Dense.className = "Dense";
  exports_serialization.registerClass(Dense);
  Flatten = class Flatten extends Layer {
    constructor(args) {
      args = args || {};
      super(args);
      this.inputSpec = [{ minNDim: 3 }];
      this.dataFormat = args.dataFormat;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      for (const dim of inputShape.slice(1)) {
        if (dim == null) {
          throw new ValueError(`The shape of the input to "Flatten" is not fully defined ` + `(got ${inputShape.slice(1)}). Make sure to pass a complete ` + `"input_shape" or "batch_input_shape" argument to the first ` + `layer in your model.`);
        }
      }
      return [inputShape[0], arrayProd(inputShape, 1)];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        let input2 = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsFirst" && input2.rank > 1) {
          const permutation = [0];
          for (let i = 2;i < input2.rank; ++i) {
            permutation.push(i);
          }
          permutation.push(1);
          input2 = transpose(input2, permutation);
        }
        return batchFlatten(input2);
      });
    }
    getConfig() {
      const config = {};
      if (this.dataFormat != null) {
        config["dataFormat"] = this.dataFormat;
      }
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Flatten.className = "Flatten";
  exports_serialization.registerClass(Flatten);
  Activation2 = class Activation2 extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.activation = getActivation(args.activation);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        return this.activation.apply(input2);
      });
    }
    getConfig() {
      const config = { activation: serializeActivation(this.activation) };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Activation2.className = "Activation";
  exports_serialization.registerClass(Activation2);
  RepeatVector = class RepeatVector extends Layer {
    constructor(args) {
      super(args);
      this.n = args.n;
      this.inputSpec = [{ ndim: 2 }];
    }
    computeOutputShape(inputShape) {
      return [inputShape[0], this.n, inputShape[1]];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        return repeat(inputs, this.n);
      });
    }
    getConfig() {
      const config = {
        n: this.n
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  RepeatVector.className = "RepeatVector";
  exports_serialization.registerClass(RepeatVector);
  Reshape2 = class Reshape2 extends Layer {
    constructor(args) {
      super(args);
      this.targetShape = args.targetShape;
      for (let i = 0;i < this.targetShape.length; ++i) {
        if (this.isUnknown(this.targetShape[i])) {
          this.targetShape[i] = null;
        }
      }
    }
    isUnknown(dim) {
      return dim < 0 || dim == null;
    }
    fixUnknownDimension(inputShape, outputShape) {
      const errorMsg = "Total size of new array must be unchanged.";
      const finalShape = outputShape.slice();
      let known = 1;
      let unknown = null;
      for (let i = 0;i < finalShape.length; ++i) {
        const dim = finalShape[i];
        if (this.isUnknown(dim)) {
          if (unknown === null) {
            unknown = i;
          } else {
            throw new ValueError("Can only specifiy one unknown dimension.");
          }
        } else {
          known *= dim;
        }
      }
      const originalSize = arrayProd(inputShape);
      if (unknown !== null) {
        if (known === 0 || originalSize % known !== 0) {
          throw new ValueError(errorMsg);
        }
        finalShape[unknown] = originalSize / known;
      } else if (originalSize !== known) {
        throw new ValueError(errorMsg);
      }
      return finalShape;
    }
    computeOutputShape(inputShape) {
      let anyUnknownDims = false;
      for (let i = 0;i < inputShape.length; ++i) {
        if (this.isUnknown(inputShape[i])) {
          anyUnknownDims = true;
          break;
        }
      }
      if (anyUnknownDims) {
        return inputShape.slice(0, 1).concat(this.targetShape);
      } else {
        return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        const outputShape = inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));
        return reshape(input2, outputShape);
      });
    }
    getConfig() {
      const config = {
        targetShape: this.targetShape
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Reshape2.className = "Reshape";
  exports_serialization.registerClass(Reshape2);
  Permute = class Permute extends Layer {
    constructor(args) {
      super(args);
      if (args.dims == null) {
        throw new Error("Required configuration field `dims` is missing during Permute " + "constructor call.");
      }
      if (!Array.isArray(args.dims)) {
        throw new Error("Permute constructor requires `dims` to be an Array, but received " + `${args.dims} instead.`);
      }
      const expectedSortedIndices = range4(1, args.dims.length + 1);
      if (!exports_util.arraysEqual(args.dims.slice().sort(), expectedSortedIndices)) {
        throw new Error("Invalid permutation `dims`: " + JSON.stringify(args.dims) + " `dims` must contain consecutive integers starting from 1.");
      }
      this.dims = args.dims;
      this.dimsIncludingBatch = [0].concat(this.dims);
      this.inputSpec = [new InputSpec({ ndim: this.dims.length + 1 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const outputShape = inputShape.slice();
      this.dims.forEach((dim, i) => {
        outputShape[i + 1] = inputShape[dim];
      });
      return outputShape;
    }
    call(inputs, kwargs) {
      return transpose(getExactlyOneTensor(inputs), this.dimsIncludingBatch);
    }
    getConfig() {
      const config = {
        dims: this.dims
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Permute.className = "Permute";
  exports_serialization.registerClass(Permute);
  Masking = class Masking extends Layer {
    constructor(args) {
      super(args == null ? {} : args);
      this.supportsMasking = true;
      if (args != null) {
        this.maskValue = args.maskValue == null ? 0 : args.maskValue;
      } else {
        this.maskValue = 0;
      }
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { maskValue: this.maskValue };
      Object.assign(config, baseConfig);
      return config;
    }
    computeMask(inputs, mask) {
      const input2 = getExactlyOneTensor(inputs);
      const axis = -1;
      return any(notEqual(input2, this.maskValue), axis);
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const axis = -1;
        const keepDims = true;
        const booleanMask = any(notEqual(input2, this.maskValue), axis, keepDims);
        const output = mul(input2, cast(booleanMask, input2.dtype));
        return output;
      });
    }
  };
  Masking.className = "Masking";
  exports_serialization.registerClass(Masking);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/embeddings.js
var Embedding;
var init_embeddings = __esm(() => {
  init_dist();
  init_tfjs_backend();
  init_constraints();
  init_topology();
  init_errors();
  init_initializers();
  init_regularizers();
  init_generic_utils();
  init_types_utils();
  Embedding = class Embedding extends Layer {
    constructor(args) {
      super(args);
      this.embeddings = null;
      this.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform";
      if (args.batchInputShape == null && args.inputShape == null) {
        let batchSize = null;
        if (args.batchSize != null) {
          batchSize = args.batchSize;
        }
        if (args.inputLength == null) {
          this.batchInputShape = [batchSize, null];
        } else {
          this.batchInputShape = [batchSize].concat(toList(args.inputLength));
        }
      }
      this.inputDim = args.inputDim;
      assertPositiveInteger(this.inputDim, "inputDim");
      this.outputDim = args.outputDim;
      assertPositiveInteger(this.outputDim, "outputDim");
      this.embeddingsInitializer = getInitializer(args.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER);
      this.embeddingsRegularizer = getRegularizer(args.embeddingsRegularizer);
      this.activityRegularizer = getRegularizer(args.activityRegularizer);
      this.embeddingsConstraint = getConstraint(args.embeddingsConstraint);
      this.maskZero = args.maskZero;
      this.supportsMasking = args.maskZero;
      this.inputLength = args.inputLength;
    }
    build(inputShape) {
      this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);
      this.built = true;
    }
    warnOnIncompatibleInputShape(inputShape) {
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        if (!this.maskZero) {
          return null;
        } else {
          inputs = getExactlyOneTensor(inputs);
          return notEqual(inputs, zerosLike(inputs));
        }
      });
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (this.inputLength == null) {
        return [...inputShape, this.outputDim];
      }
      const inLens = toList(this.inputLength);
      if (inLens.length !== inputShape.length - 1) {
        throw new ValueError(`"inputLength" is ${this.inputLength}, but received ` + `input shape has shape ${inputShape}`);
      } else {
        let i = 0;
        for (let k = 0;k < inLens.length; ++k) {
          const s1 = inLens[k];
          const s22 = inputShape[k + 1];
          if (s1 != null && s22 != null && s1 !== s22) {
            throw new ValueError(`"inputLength" is ${this.inputLength}, but received ` + `input shape has shape ${inputShape}`);
          } else if (s1 == null) {
            inLens[i] = s22;
          }
          i++;
        }
      }
      return [inputShape[0], ...inLens, this.outputDim];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        let input2 = getExactlyOneTensor(inputs);
        if (input2.dtype !== "int32") {
          input2 = cast45(input2, "int32");
        }
        const output = gather6(this.embeddings.read(), reshape(input2, [input2.size]));
        return reshape(output, getExactlyOneShape(this.computeOutputShape(input2.shape)));
      });
    }
    getConfig() {
      const config = {
        inputDim: this.inputDim,
        outputDim: this.outputDim,
        embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),
        embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),
        activityRegularizer: serializeRegularizer(this.activityRegularizer),
        embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),
        maskZero: this.maskZero,
        inputLength: this.inputLength
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Embedding.className = "Embedding";
  exports_serialization.registerClass(Embedding);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/merge.js
function interpretAxis(axis, dim) {
  while (axis < 0) {
    axis += dim;
  }
  return axis;
}
function batchDot(x, y, axes) {
  if (x.shape.length > 3 || y.shape.length > 3) {
    throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");
  }
  exports_util.assert(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, ` + `but got ${x.shape.length}`);
  exports_util.assert(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, ` + `but got ${y.shape.length}`);
  if (typeof axes === "number") {
    axes = [axes, axes];
  }
  if (x.dtype === "complex64" || y.dtype === "complex64") {
    throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");
  }
  const xNDim = x.shape.length;
  const yNDim = y.shape.length;
  if (axes == null) {
    axes = [xNDim - 1, yNDim - 2];
  }
  const axesArray = axes;
  return tidy(() => {
    let diff;
    if (xNDim > yNDim) {
      diff = xNDim - yNDim;
      const diffShape = [];
      for (let i = 0;i < diff; ++i) {
        diffShape.push(1);
      }
      y = reshape(y, y.shape.concat(diffShape));
    } else if (yNDim > xNDim) {
      diff = yNDim - xNDim;
      const diffShape = [];
      for (let i = 0;i < diff; ++i) {
        diffShape.push(1);
      }
      x = reshape(x, x.shape.concat(diffShape));
    } else {
      diff = 0;
    }
    let out;
    if (x.shape.length === 2 && y.shape.length === 2) {
      if (axesArray[0] === axesArray[1]) {
        out = sum2(mul(x, y), axesArray[0]);
      } else {
        out = sum2(mul(transpose(x, [1, 0]), y), axesArray[1]);
      }
    } else {
      const adjX = axesArray[0] !== x.shape.length - 1;
      const adjY = axesArray[1] === y.shape.length - 1;
      out = matMul(x, y, adjX, adjY);
    }
    if (diff > 0) {
      let idx;
      if (xNDim > yNDim) {
        idx = xNDim + yNDim - 3;
      } else {
        idx = xNDim - 1;
      }
      const squeezeAxes = [];
      for (let i = idx;i < idx + diff; ++i) {
        squeezeAxes.push(i);
      }
      out = squeeze(out, squeezeAxes);
    }
    if (out.shape.length === 1) {
      out = expandDims(out, 1);
    }
    return out;
  });
}
var Merge, Add2, Multiply2, Average, Maximum2, Minimum2, Concatenate, Dot;
var init_merge = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_topology();
  init_errors();
  init_losses();
  init_generic_utils();
  init_math_utils();
  init_types_utils();
  Merge = class Merge extends Layer {
    constructor(args) {
      super(args || {});
      this.supportsMasking = true;
    }
    mergeFunction(inputs) {
      throw new NotImplementedError;
    }
    computeElementwiseOpOutputShape(shape1, shape2) {
      if (shape1 == null || shape2 == null) {
        return null;
      } else if (shape1.length < shape2.length) {
        return this.computeElementwiseOpOutputShape(shape2, shape1);
      } else if (shape2.length === 0) {
        return shape1;
      }
      const outputShape = shape1.slice(0, shape1.length - shape2.length);
      for (let k = 0;k < shape2.length; ++k) {
        const i = shape1[shape1.length - shape2.length + k];
        const j = shape2[k];
        if (i == null || j == null || i < 0 || j < 0) {
          outputShape.push(null);
        } else if (i === 1) {
          outputShape.push(j);
        } else if (j === 1) {
          outputShape.push(i);
        } else {
          if (i !== j) {
            throw new ValueError("Operands could not be broadcast together with shapes " + JSON.stringify(shape1) + " " + JSON.stringify(shape2));
          }
          outputShape.push(i);
        }
      }
      return outputShape;
    }
    build(inputShape) {
      if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {
        inputShape = [getExactlyOneShape(inputShape)];
      }
      inputShape = inputShape;
      if (inputShape.length < 2) {
        throw new ValueError("A merge layer should be called on an Array of at least 2 inputs." + ` Got ${inputShape.length} input(s).`);
      }
      let batchSizes = [];
      for (const shape of inputShape) {
        if (shape != null && shape[0] !== null) {
          batchSizes.push(shape[0]);
        }
      }
      batchSizes = unique4(batchSizes);
      if (batchSizes.length > 1) {
        throw new ValueError(`Can not merge tensors with different batch sizes. ` + `Got tensors with shapes: ${JSON.stringify(inputShape)}.`);
      }
      let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);
      for (let i = 1;i < inputShape.length; ++i) {
        const shape = inputShape[i] == null ? null : inputShape[i].slice(1);
        outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
      }
      const allRanks = inputShape.map((shape) => shape.length);
      if (inputShape.indexOf(null) === -1 && unique4(allRanks).length === 1) {
        this.reshapeRequired = false;
      } else {
        this.reshapeRequired = true;
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = inputs;
        if (this.reshapeRequired) {
          const reshapedInputs = [];
          const inputDims = inputs.map((input2) => input2.rank);
          if (inputDims.indexOf(null) === -1) {
            const maxNDim = max7(inputDims);
            for (let x of inputs) {
              const xNDim = x.rank;
              for (let k = 0;k < maxNDim - xNDim; ++k) {
                x = expandDims2(x, 1);
              }
              reshapedInputs.push(x);
            }
            return this.mergeFunction(reshapedInputs);
          } else {
            let transposed = false;
            for (const x of inputs) {
              const xNDim = x.rank;
              if (xNDim == null) {
                const xShape = x.shape;
                const batchSize = xShape[0];
                const newShape = xShape.slice(1).concat([batchSize]);
                let xTransposed = reshape(x, [batchSize].concat(arrayProd(xShape.slice(1))));
                xTransposed = transpose(xTransposed, [1, 0]);
                xTransposed = reshape(xTransposed, newShape);
                reshapedInputs.push(xTransposed);
                transposed = true;
              } else if (xNDim > 1) {
                const dims = range4(1, xNDim).concat([0]);
                reshapedInputs.push(transpose(x, dims));
                transposed = true;
              } else {
                reshapedInputs.push(x);
              }
            }
            let y = this.mergeFunction(reshapedInputs);
            const yNDim = y.rank;
            if (transposed) {
              if (yNDim == null) {
                const yShape = y.shape;
                const yNDim2 = yShape.length;
                const batchSize = yShape[yNDim2 - 1];
                const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));
                y = reshape(transpose(reshape(y, [-1, batchSize]), [1, 0]), newShape);
              } else if (yNDim > 1) {
                const dims = [yNDim - 1].concat(range4(0, yNDim - 1));
                y = transpose(y, dims);
              }
            }
            return y;
          }
        } else {
          return this.mergeFunction(inputs);
        }
      });
    }
    computeOutputShape(inputShape) {
      inputShape = inputShape;
      let outputShape;
      if (inputShape[0] == null) {
        outputShape = null;
      } else {
        outputShape = inputShape[0].slice(1);
      }
      for (let i = 1;i < inputShape.length; ++i) {
        const shape = inputShape[i] == null ? null : inputShape[i].slice(1);
        outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);
      }
      let batchSizes = [];
      for (const shape of inputShape) {
        if (shape != null && shape[0] !== null) {
          batchSizes.push(shape[0]);
        }
      }
      batchSizes = unique4(batchSizes);
      if (batchSizes.length === 1) {
        outputShape = batchSizes.concat(outputShape);
      } else {
        outputShape = [null].concat(outputShape);
      }
      return outputShape;
    }
    computeMask(inputs, mask) {
      return tidy(() => {
        if (mask == null) {
          return null;
        }
        if (!Array.isArray(mask)) {
          throw new ValueError("`mask` should be an Array");
        }
        if (!Array.isArray(inputs)) {
          throw new ValueError("`inputs` should be an Array");
        }
        if (mask.length !== inputs.length) {
          throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same ` + `length, but have different lengths ` + `(${inputs.length} vs ${mask.length})`);
        }
        if (mask.every((m) => m == null)) {
          return null;
        }
        mask = mask.map((m) => m == null ? m : expandDims(m, 0));
        let output = mask[0];
        for (let i = 1;i < mask.length - 1; ++i) {
          output = logicalAnd(output, mask[i]);
        }
        return output;
      });
    }
  };
  Add2 = class Add2 extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0].clone();
        for (let i = 1;i < inputs.length; ++i) {
          output = add2(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Add2.className = "Add";
  exports_serialization.registerClass(Add2);
  Multiply2 = class Multiply2 extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0].clone();
        for (let i = 1;i < inputs.length; ++i) {
          output = mul(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Multiply2.className = "Multiply";
  exports_serialization.registerClass(Multiply2);
  Average = class Average extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0].clone();
        for (let i = 1;i < inputs.length; ++i) {
          output = add2(output, inputs[i]);
        }
        return mul(1 / inputs.length, output);
      });
    }
  };
  Average.className = "Average";
  exports_serialization.registerClass(Average);
  Maximum2 = class Maximum2 extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0];
        for (let i = 1;i < inputs.length; ++i) {
          output = maximum(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Maximum2.className = "Maximum";
  exports_serialization.registerClass(Maximum2);
  Minimum2 = class Minimum2 extends Merge {
    constructor(args) {
      super(args);
    }
    mergeFunction(inputs) {
      return tidy(() => {
        let output = inputs[0];
        for (let i = 1;i < inputs.length; ++i) {
          output = minimum(output, inputs[i]);
        }
        return output;
      });
    }
  };
  Minimum2.className = "Minimum";
  exports_serialization.registerClass(Minimum2);
  Concatenate = class Concatenate extends Merge {
    constructor(args) {
      super(args);
      this.DEFAULT_AXIS = -1;
      if (args == null) {
        args = {};
      }
      this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;
      this.supportsMasking = true;
      this.reshapeRequired = false;
    }
    build(inputShape) {
      if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) || inputShape.length === 1) {
        throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 " + "inputs");
      }
      inputShape = inputShape;
      let allNoneShape = true;
      for (const shape of inputShape) {
        if (shape != null) {
          allNoneShape = false;
          break;
        }
      }
      if (allNoneShape) {
        return;
      }
      const shapeSet = [];
      for (let i = 0;i < inputShape.length; ++i) {
        const shapeWithoutConcatAxis = inputShape[i].slice();
        shapeWithoutConcatAxis.splice(this.axis, 1);
        let exists = false;
        for (const shape of shapeSet) {
          if (exports_util.arraysEqual(shape, shapeWithoutConcatAxis)) {
            exists = true;
            break;
          }
        }
        if (!exists) {
          shapeSet.push(shapeWithoutConcatAxis);
        }
      }
      if (shapeSet.length > 1) {
        throw new ValueError("A `Concatenate` layer requires inputs with matching shapes " + "except for the concat axis. Got input shapes: " + JSON.stringify(inputShape));
      }
    }
    mergeFunction(inputs) {
      return tidy(() => {
        return concatenate(inputs, this.axis);
      });
    }
    computeOutputShape(inputShape) {
      if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {
        throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");
      }
      const inputShapes = inputShape;
      const outputShape = inputShapes[0].slice();
      const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;
      for (const shape of inputShapes.slice(1)) {
        if (outputShape[axis] == null || shape[axis] == null) {
          outputShape[axis] = null;
          break;
        }
        outputShape[axis] += shape[axis];
      }
      return outputShape;
    }
    computeMask(inputs, mask) {
      if (mask == null) {
        return null;
      }
      if (!Array.isArray(mask)) {
        throw new ValueError("`mask` should be an array for Concatenate");
      }
      if (!Array.isArray(inputs)) {
        throw new ValueError("`inputs` should be an array for Concatenate");
      }
      if (mask.length !== inputs.length) {
        throw new ValueError(`Mismatch in the length of mask (${mask.length}) ` + `and the legnth of inputs (${inputs.length})`);
      }
      return tidy(() => {
        let allNullMasks = true;
        mask.forEach((m) => {
          if (m != null) {
            allNullMasks = false;
            return;
          }
        });
        if (allNullMasks) {
          return null;
        }
        const outputMasks = [];
        for (let i = 0;i < inputs.length; ++i) {
          if (mask[i] == null) {
            outputMasks.push(cast(onesLike(inputs[i]), "bool"));
          } else if (mask[i].rank < inputs[i].rank) {
            outputMasks.push(expandDims(mask[i], -1));
          } else {
            outputMasks.push(mask[i]);
          }
        }
        const concatenatedMasks = concat(outputMasks, this.axis);
        return all(concatenatedMasks, -1, false);
      });
    }
    getConfig() {
      const config = {
        axis: this.axis
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Concatenate.className = "Concatenate";
  exports_serialization.registerClass(Concatenate);
  Dot = class Dot extends Merge {
    constructor(args) {
      super(args);
      this.axes = args.axes;
      this.normalize = args.normalize == null ? false : args.normalize;
      this.supportsMasking = true;
      this.reshapeRequired = false;
    }
    build(inputShape) {
      exports_util.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const shape1 = inputShape[0];
      const shape2 = inputShape[1];
      if (shape1.length > 3 || shape2.length > 3) {
        throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
      }
      const axes = this.interpretAxes(shape1, shape2);
      if (shape1[axes[0]] !== shape2[axes[1]]) {
        throw new ValueError(`Dimension incompatibility: ` + `${shape1[axes[0]]} !== ${shape2[axes[1]]}`);
      }
    }
    mergeFunction(inputs) {
      if (inputs.length !== 2) {
        throw new ValueError("A `Dot` layer must be called on exactly 2 inputs, " + `but received ${inputs.length} input(s).`);
      }
      let x1 = inputs[0];
      let x2 = inputs[1];
      let axes;
      if (!Array.isArray(this.axes)) {
        axes = [
          interpretAxis(this.axes, x1.shape.length),
          interpretAxis(this.axes, x2.shape.length)
        ];
      } else {
        axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));
      }
      if (this.normalize) {
        x1 = l2Normalize(x1, axes[0]);
        x2 = l2Normalize(x2, axes[1]);
      }
      return batchDot(x1, x2, axes);
    }
    interpretAxes(shape1, shape2) {
      let axes;
      if (!Array.isArray(this.axes)) {
        axes = [
          interpretAxis(this.axes, shape1.length),
          interpretAxis(this.axes, shape2.length)
        ];
      } else {
        axes = this.axes;
      }
      return axes;
    }
    computeOutputShape(inputShape) {
      exports_util.assert(Array.isArray(inputShape) && inputShape.length === 2 && Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => "A `Dot` layer should be called on a list of exactly 2 inputs.");
      const shape1 = inputShape[0].slice();
      const shape2 = inputShape[1].slice();
      if (shape1.length > 3 || shape2.length > 3) {
        throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");
      }
      const axes = this.interpretAxes(shape1, shape2);
      shape1.splice(axes[0], 1);
      shape2.splice(axes[1], 1);
      shape2.splice(0, 1);
      const outputShape = shape1.concat(shape2);
      if (outputShape.length === 1) {
        outputShape.push(1);
      }
      return outputShape;
    }
    computeMask(inputs, mask) {
      return null;
    }
    getConfig() {
      const config = {
        axes: this.axes,
        normalize: this.normalize
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  Dot.className = "Dot";
  exports_serialization.registerClass(Dot);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/noise.js
var GaussianNoise, GaussianDropout, AlphaDropout;
var init_noise = __esm(() => {
  init_dist();
  init_tfjs_backend();
  init_topology();
  init_types_utils();
  GaussianNoise = class GaussianNoise extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.stddev = args.stddev;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { stddev: this.stddev };
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        const noised = () => add2(randomNormal2(input2.shape, 0, this.stddev), input2);
        const output = inTrainPhase(noised, () => input2, kwargs["training"] || false);
        return output;
      });
    }
  };
  GaussianNoise.className = "GaussianNoise";
  exports_serialization.registerClass(GaussianNoise);
  GaussianDropout = class GaussianDropout extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.rate = args.rate;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { rate: this.rate };
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        const input2 = getExactlyOneTensor(inputs);
        if (this.rate > 0 && this.rate < 1) {
          const noised = () => {
            const stddev = Math.sqrt(this.rate / (1 - this.rate));
            return mul(input2, randomNormal2(input2.shape, 1, stddev));
          };
          return inTrainPhase(noised, () => input2, kwargs["training"] || false);
        }
        return input2;
      });
    }
  };
  GaussianDropout.className = "GaussianDropout";
  exports_serialization.registerClass(GaussianDropout);
  AlphaDropout = class AlphaDropout extends Layer {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
      this.rate = args.rate;
      this.noiseShape = args.noiseShape;
    }
    _getNoiseShape(inputs) {
      return this.noiseShape || getExactlyOneTensor(inputs).shape;
    }
    computeOutputShape(inputShape) {
      return inputShape;
    }
    getConfig() {
      const baseConfig = super.getConfig();
      const config = { rate: this.rate };
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        if (this.rate < 1 && this.rate > 0) {
          const noiseShape = this._getNoiseShape(inputs);
          const droppedInputs = () => {
            const input2 = getExactlyOneTensor(inputs);
            const alpha = 1.6732632423543772;
            const scale = 1.0507009873554805;
            const alphaP = -alpha * scale;
            let keptIdx = greaterEqual(randomUniform(noiseShape), this.rate);
            keptIdx = cast45(keptIdx, "float32");
            const a = ((1 - this.rate) * (1 + this.rate * alphaP ** 2)) ** -0.5;
            const b = -a * alphaP * this.rate;
            const x = add2(mul(input2, keptIdx), mul(add2(keptIdx, -1), alphaP));
            return add2(mul(x, a), b);
          };
          return inTrainPhase(droppedInputs, () => getExactlyOneTensor(inputs), kwargs["training"] || false);
        }
        return inputs;
      });
    }
  };
  AlphaDropout.className = "AlphaDropout";
  exports_serialization.registerClass(AlphaDropout);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/normalization.js
function batchNormalization(x, mean6, variance, beta, gamma, epsilon2 = 0.001) {
  let out;
  if (x.rank === 2) {
    out = batchNorm2d(x, mean6, variance, beta, gamma, epsilon2);
  } else if (x.rank === 3) {
    out = batchNorm3d(x, mean6, variance, beta, gamma, epsilon2);
  } else if (x.rank === 4) {
    out = batchNorm4d(x, mean6, variance, beta, gamma, epsilon2);
  } else {
    throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${x.rank} ` + `yet`);
  }
  return out;
}
function regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2 = 0.001) {
  return tidy(() => {
    const meanAndVariance = moments(x, reductionAxes);
    const mean6 = meanAndVariance.mean;
    const variance = meanAndVariance.variance;
    const normed = batchNormalization(x, mean6, variance, beta, gamma, epsilon2);
    return [normed, mean6, variance];
  });
}
function broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2 = 0.001) {
  return tidy(() => {
    const meanAndVariance = moments(x, reductionAxes);
    const mean6 = meanAndVariance.mean;
    const variance = meanAndVariance.variance;
    const targetShape = [];
    for (const axis of range4(0, x.rank)) {
      if (reductionAxes.indexOf(axis) !== -1) {
        targetShape.push(1);
      } else {
        targetShape.push(x.shape[axis]);
      }
    }
    const broadcastMean = reshape(mean6, targetShape);
    const broadcastVariance = reshape(variance, targetShape);
    const broadcastGamma = gamma == null ? null : reshape(gamma, targetShape);
    const broadcastBeta = beta == null ? null : reshape(beta, targetShape);
    const normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon2);
    return [normed, mean6, variance];
  });
}
function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2 = 0.001) {
  if (exports_util.arraysEqual(reductionAxes.slice().sort(), range4(0, x.rank - 1))) {
    return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2);
  } else {
    return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon2);
  }
}
var BatchNormalization, LayerNormalization;
var init_normalization = __esm(() => {
  init_dist();
  init_dist();
  init_constraints();
  init_topology();
  init_errors();
  init_initializers();
  init_regularizers();
  init_generic_utils();
  init_math_utils();
  init_types_utils();
  BatchNormalization = class BatchNormalization extends Layer {
    constructor(args) {
      if (args == null) {
        args = {};
      }
      super(args);
      this.supportsMasking = true;
      this.axis = args.axis == null ? -1 : args.axis;
      this.momentum = args.momentum == null ? 0.99 : args.momentum;
      this.epsilon = args.epsilon == null ? 0.001 : args.epsilon;
      this.center = args.center == null ? true : args.center;
      this.scale = args.scale == null ? true : args.scale;
      this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
      this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
      this.movingMeanInitializer = getInitializer(args.movingMeanInitializer || "zeros");
      this.movingVarianceInitializer = getInitializer(args.movingVarianceInitializer || "ones");
      this.betaConstraint = getConstraint(args.betaConstraint);
      this.gammaConstraint = getConstraint(args.gammaConstraint);
      this.betaRegularizer = getRegularizer(args.betaRegularizer);
      this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const axis = this.axis >= 0 ? this.axis : this.axis + inputShape.length;
      const dim = inputShape[axis];
      if (dim == null) {
        throw new ValueError(`Axis ${axis} of input tensor should have a defined dimension but ` + `the layer received an input with shape ` + `${JSON.stringify(inputShape)}.`);
      }
      this.inputSpec = [new InputSpec({ ndim: inputShape.length, axes: { [axis]: dim } })];
      const shape = [dim];
      if (this.scale) {
        this.gamma = this.addWeight("gamma", shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);
      }
      if (this.center) {
        this.beta = this.addWeight("beta", shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);
      }
      this.movingMean = this.addWeight("moving_mean", shape, null, this.movingMeanInitializer, null, false);
      this.movingVariance = this.addWeight("moving_variance", shape, null, this.movingVarianceInitializer, null, false);
      this.built = true;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const training3 = kwargs["training"] == null ? false : kwargs["training"];
        const input2 = getExactlyOneTensor(inputs);
        const inputShape = input2.shape;
        const ndim = inputShape.length;
        const reductionAxes = range4(0, ndim);
        const axis = this.axis >= 0 ? this.axis : this.axis + ndim;
        reductionAxes.splice(axis, 1);
        const broadcastShape = pyListRepeat(1, ndim);
        broadcastShape[axis] = inputShape[axis];
        const sortedReductionAxes = reductionAxes.slice();
        sortedReductionAxes.sort();
        const needsBroadcasting = !exports_util.arraysEqual(sortedReductionAxes, range4(0, ndim).slice(0, ndim - 1));
        const normalizeInference = () => {
          if (needsBroadcasting) {
            const broadcastMovingMean = reshape(this.movingMean.read(), broadcastShape);
            const broadcastMovingVariance = reshape(this.movingVariance.read(), broadcastShape);
            const broadcastBeta = this.center ? reshape(this.beta.read(), broadcastShape) : null;
            const broadcastGamma = this.scale ? reshape(this.gamma.read(), broadcastShape) : null;
            return batchNormalization(input2, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, this.epsilon);
          } else {
            return batchNormalization(input2, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);
          }
        };
        if (!training3) {
          return normalizeInference();
        }
        const [normedTraining, mean6, variance] = normalizeBatchInTraining(input2, this.gamma.read(), this.beta.read(), reductionAxes, this.epsilon);
        const doMovingAverage = (variable2, value, momentum) => {
          tidy(() => {
            const decay = 1 - momentum;
            const origValue = variable2.read();
            const updateDelta = mul(sub(origValue, value), decay);
            variable2.write(sub(origValue, updateDelta));
          });
        };
        const updateMovingMeanAndVariance = () => {
          doMovingAverage(this.movingMean, mean6, this.momentum);
          doMovingAverage(this.movingVariance, variance, this.momentum);
        };
        updateMovingMeanAndVariance();
        return normedTraining;
      });
    }
    getConfig() {
      const config = {
        axis: this.axis,
        momentum: this.momentum,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: serializeInitializer(this.betaInitializer),
        gammaInitializer: serializeInitializer(this.gammaInitializer),
        movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),
        movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),
        betaRegularizer: serializeRegularizer(this.betaRegularizer),
        gammaRegularizer: serializeRegularizer(this.gammaRegularizer),
        betaConstraint: serializeConstraint(this.betaConstraint),
        gammaConstraint: serializeConstraint(this.gammaConstraint)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  BatchNormalization.className = "BatchNormalization";
  exports_serialization.registerClass(BatchNormalization);
  LayerNormalization = class LayerNormalization extends Layer {
    constructor(args) {
      if (args == null) {
        args = {};
      }
      super(args);
      this.axis = args.axis == null ? -1 : args.axis;
      if (typeof this.axis === "number") {
        if (!Number.isInteger(this.axis)) {
          throw new Error(`Expected axis to be an integer, but received ${this.axis}`);
        }
      } else if (Array.isArray(this.axis)) {
        for (const axis of this.axis) {
          if (!Number.isInteger(axis)) {
            throw new Error(`Expected axis to be an array of integers, ` + `but received ${JSON.stringify(this.axis)}`);
          }
        }
      } else {
        throw new Error(`Expected axis to be an integer or an array of integers, ` + `but received ${JSON.stringify(this.axis)}`);
      }
      this.epsilon = args.epsilon == null ? 0.001 : args.epsilon;
      this.center = args.center == null ? true : args.center;
      this.scale = args.scale == null ? true : args.scale;
      this.betaInitializer = getInitializer(args.betaInitializer || "zeros");
      this.gammaInitializer = getInitializer(args.gammaInitializer || "ones");
      this.betaRegularizer = getRegularizer(args.betaRegularizer);
      this.gammaRegularizer = getRegularizer(args.gammaRegularizer);
      this.supportsMasking = true;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const nDims = inputShape.length;
      if (typeof this.axis === "number") {
        this.axis = [this.axis];
      }
      for (let i = 0;i < this.axis.length; ++i) {
        if (this.axis[i] < 0) {
          this.axis[i] += nDims;
        }
      }
      for (const axis of this.axis) {
        if (axis < 0 || axis >= nDims) {
          throw new Error(`Invalid axis: ${axis}`);
        }
      }
      if (this.axis.length !== unique4(this.axis).length) {
        throw new Error(`Found duplicate axes in: ${this.axis}`);
      }
      const paramShape = this.axis.map((axis) => inputShape[axis]);
      const trainable = true;
      if (this.scale) {
        this.gamma = this.addWeight("gamma", paramShape, "float32", this.gammaInitializer, this.gammaRegularizer, trainable);
      } else {
        this.gamma = null;
      }
      if (this.center) {
        this.beta = this.addWeight("beta", paramShape, "float32", this.betaInitializer, this.betaRegularizer, trainable);
      } else {
        this.beta = null;
      }
      this.built = true;
    }
    call(inputs, kwargs) {
      const input2 = getExactlyOneTensor(inputs);
      const inputShape = input2.shape;
      const nDims = inputShape.length;
      return tidy(() => {
        const keepDims = true;
        let { mean: mean6, variance } = moments(input2, this.axis, keepDims);
        const broadcastShape = pyListRepeat(1, nDims);
        for (const dim of this.axis) {
          broadcastShape[dim] = inputShape[dim];
        }
        const broadcast = (v) => {
          if (v != null && v.shape.length !== nDims) {
            return reshape(v, broadcastShape);
          } else {
            return v;
          }
        };
        let scale = this.scale ? broadcast(this.gamma.read()) : null;
        let offset = this.center ? broadcast(this.beta.read()) : null;
        const momentsTiling = [];
        const scaleOffsetTiling = [];
        for (let i = 0;i < nDims; ++i) {
          if (this.axis.indexOf(i) !== -1) {
            momentsTiling.push(inputShape[i]);
            scaleOffsetTiling.push(1);
          } else {
            momentsTiling.push(1);
            scaleOffsetTiling.push(inputShape[i]);
          }
        }
        mean6 = tile(mean6, momentsTiling);
        variance = tile(variance, momentsTiling);
        if (scale != null) {
          scale = tile(scale, scaleOffsetTiling);
        }
        if (offset != null) {
          offset = tile(offset, scaleOffsetTiling);
        }
        return batchNormalization(input2, mean6, variance, offset, scale, this.epsilon);
      });
    }
    getConfig() {
      const config = {
        axis: this.axis,
        epsilon: this.epsilon,
        center: this.center,
        scale: this.scale,
        betaInitializer: serializeInitializer(this.betaInitializer),
        gammaInitializer: serializeInitializer(this.gammaInitializer),
        betaRegularizer: serializeRegularizer(this.betaRegularizer),
        gammaRegularizer: serializeRegularizer(this.gammaRegularizer)
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  LayerNormalization.className = "LayerNormalization";
  exports_serialization.registerClass(LayerNormalization);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/padding.js
function spatial2dPadding(x, padding, dataFormat) {
  return tidy(() => {
    if (x.rank !== 4) {
      throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ` + `${x.rank}-D tensor.`);
    }
    if (padding == null) {
      padding = [[1, 1], [1, 1]];
    }
    if (padding.length !== 2 || padding[0].length !== 2 || padding[1].length !== 2) {
      throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, " + "each of which is an Array of two integers.");
    }
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    if (dataFormat !== "channelsLast" && dataFormat !== "channelsFirst") {
      throw new ValueError(`Unknown data format: ${dataFormat}. ` + `Supported data formats are 'channelsLast' and 'channelsFirst.`);
    }
    let pattern;
    if (dataFormat === "channelsFirst") {
      pattern = [[0, 0], [0, 0], padding[0], padding[1]];
    } else {
      pattern = [[0, 0], padding[0], padding[1], [0, 0]];
    }
    return pad(x, pattern);
  });
}
var ZeroPadding2D;
var init_padding = __esm(() => {
  init_dist();
  init_dist();
  init_common3();
  init_topology();
  init_errors();
  init_types_utils();
  ZeroPadding2D = class ZeroPadding2D extends Layer {
    constructor(args) {
      if (args == null) {
        args = {};
      }
      super(args);
      this.dataFormat = args.dataFormat == null ? imageDataFormat() : args.dataFormat;
      if (args.padding == null) {
        this.padding = [[1, 1], [1, 1]];
      } else if (typeof args.padding === "number") {
        this.padding = [[args.padding, args.padding], [args.padding, args.padding]];
      } else {
        args.padding = args.padding;
        if (args.padding.length !== 2) {
          throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but ` + `received a length-${args.padding.length} array.`);
        }
        let heightPadding;
        let widthPadding;
        if (typeof args.padding[0] === "number") {
          heightPadding = [args.padding[0], args.padding[0]];
          widthPadding = [args.padding[1], args.padding[1]];
        } else {
          args.padding = args.padding;
          if (args.padding[0].length !== 2) {
            throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, ` + `but received a length-${args.padding[0].length} array.`);
          }
          heightPadding = args.padding[0];
          if (args.padding[1].length !== 2) {
            throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, ` + `but received a length-${args.padding[1].length} array.`);
          }
          widthPadding = args.padding[1];
        }
        this.padding = [heightPadding, widthPadding];
      }
      this.inputSpec = [new InputSpec({ ndim: 4 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      let rows;
      let cols;
      if (this.dataFormat === "channelsFirst") {
        if (inputShape[2] != null && inputShape[2] >= 0) {
          rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];
        } else {
          rows = null;
        }
        if (inputShape[3] != null && inputShape[3] >= 0) {
          cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];
        } else {
          cols = null;
        }
        return [inputShape[0], inputShape[1], rows, cols];
      } else {
        if (inputShape[1] != null && inputShape[1] >= 0) {
          rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];
        } else {
          rows = null;
        }
        if (inputShape[2] != null && inputShape[2] >= 0) {
          cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];
        } else {
          cols = null;
        }
        return [inputShape[0], rows, cols, inputShape[3]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));
    }
    getConfig() {
      const config = {
        padding: this.padding,
        dataFormat: this.dataFormat
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  ZeroPadding2D.className = "ZeroPadding2D";
  exports_serialization.registerClass(ZeroPadding2D);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/pooling.js
function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    checkPoolMode(poolMode);
    checkPaddingMode(padding);
    if (strides == null) {
      strides = [1, 1];
    }
    if (padding == null) {
      padding = "valid";
    }
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    if (poolMode == null) {
      poolMode = "max";
    }
    x = preprocessConv2DInput(x, dataFormat);
    let y;
    const paddingString = padding === "same" ? "same" : "valid";
    if (poolMode === "max") {
      y = maxPool(x, poolSize, strides, paddingString);
    } else {
      y = avgPool(x, poolSize, strides, paddingString);
    }
    if (dataFormat === "channelsFirst") {
      y = transpose(y, [0, 3, 1, 2]);
    }
    return y;
  });
}
function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {
  return tidy(() => {
    checkDataFormat(dataFormat);
    checkPoolMode(poolMode);
    checkPaddingMode(padding);
    if (strides == null) {
      strides = [1, 1, 1];
    }
    if (padding == null) {
      padding = "valid";
    }
    if (dataFormat == null) {
      dataFormat = imageDataFormat();
    }
    if (poolMode == null) {
      poolMode = "max";
    }
    x = preprocessConv3DInput(x, dataFormat);
    let y;
    const paddingString = padding === "same" ? "same" : "valid";
    if (poolMode === "max") {
      y = maxPool3d(x, poolSize, strides, paddingString);
    } else {
      y = avgPool3d(x, poolSize, strides, paddingString);
    }
    if (dataFormat === "channelsFirst") {
      y = transpose(y, [0, 4, 1, 2, 3]);
    }
    return y;
  });
}
var Pooling1D, MaxPooling1D, AveragePooling1D, Pooling2D, MaxPooling2D, AveragePooling2D, Pooling3D, MaxPooling3D, AveragePooling3D, GlobalPooling1D, GlobalAveragePooling1D, GlobalMaxPooling1D, GlobalPooling2D, GlobalAveragePooling2D, GlobalMaxPooling2D;
var init_pooling = __esm(() => {
  init_dist();
  init_dist();
  init_common3();
  init_tfjs_backend();
  init_common2();
  init_topology();
  init_topology();
  init_errors();
  init_conv_utils();
  init_generic_utils();
  init_types_utils();
  init_convolutional();
  Pooling1D = class Pooling1D extends Layer {
    constructor(args) {
      if (args.poolSize == null) {
        args.poolSize = 2;
      }
      super(args);
      if (typeof args.poolSize === "number") {
        this.poolSize = [args.poolSize];
      } else if (Array.isArray(args.poolSize) && args.poolSize.length === 1 && typeof args.poolSize[0] === "number") {
        this.poolSize = args.poolSize;
      } else {
        throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.poolSize)}`);
      }
      assertPositiveInteger(this.poolSize, "poolSize");
      if (args.strides == null) {
        this.strides = this.poolSize;
      } else {
        if (typeof args.strides === "number") {
          this.strides = [args.strides];
        } else if (Array.isArray(args.strides) && args.strides.length === 1 && typeof args.strides[0] === "number") {
          this.strides = args.strides;
        } else {
          throw new ValueError(`strides for 1D convolutional layer must be a number or an ` + `Array of a single number, but received ` + `${JSON.stringify(args.strides)}`);
        }
      }
      assertPositiveInteger(this.strides, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      checkPaddingMode(this.padding);
      this.inputSpec = [new InputSpec({ ndim: 3 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);
      return [inputShape[0], length, inputShape[2]];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        inputs = expandDims2(getExactlyOneTensor(inputs), 2);
        const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, "channelsLast");
        return squeeze(output, [2]);
      });
    }
    getConfig() {
      const config = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  MaxPooling1D = class MaxPooling1D extends Pooling1D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "max");
    }
  };
  MaxPooling1D.className = "MaxPooling1D";
  exports_serialization.registerClass(MaxPooling1D);
  AveragePooling1D = class AveragePooling1D extends Pooling1D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg");
    }
  };
  AveragePooling1D.className = "AveragePooling1D";
  exports_serialization.registerClass(AveragePooling1D);
  Pooling2D = class Pooling2D extends Layer {
    constructor(args) {
      if (args.poolSize == null) {
        args.poolSize = [2, 2];
      }
      super(args);
      this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize];
      if (args.strides == null) {
        this.strides = this.poolSize;
      } else if (Array.isArray(args.strides)) {
        if (args.strides.length !== 2) {
          throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` + `it is expected to have a length of 2, but received length ` + `${args.strides.length}.`);
        }
        this.strides = args.strides;
      } else {
        this.strides = [args.strides, args.strides];
      }
      assertPositiveInteger(this.poolSize, "poolSize");
      assertPositiveInteger(this.strides, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      checkPaddingMode(this.padding);
      this.inputSpec = [new InputSpec({ ndim: 4 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      let rows = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
      let cols = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
      rows = convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);
      cols = convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);
      if (this.dataFormat === "channelsFirst") {
        return [inputShape[0], inputShape[1], rows, cols];
      } else {
        return [inputShape[0], rows, cols, inputShape[3]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
      });
    }
    getConfig() {
      const config = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  MaxPooling2D = class MaxPooling2D extends Pooling2D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "max");
    }
  };
  MaxPooling2D.className = "MaxPooling2D";
  exports_serialization.registerClass(MaxPooling2D);
  AveragePooling2D = class AveragePooling2D extends Pooling2D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool2d(inputs, poolSize, strides, padding, dataFormat, "avg");
    }
  };
  AveragePooling2D.className = "AveragePooling2D";
  exports_serialization.registerClass(AveragePooling2D);
  Pooling3D = class Pooling3D extends Layer {
    constructor(args) {
      if (args.poolSize == null) {
        args.poolSize = [2, 2, 2];
      }
      super(args);
      this.poolSize = Array.isArray(args.poolSize) ? args.poolSize : [args.poolSize, args.poolSize, args.poolSize];
      if (args.strides == null) {
        this.strides = this.poolSize;
      } else if (Array.isArray(args.strides)) {
        if (args.strides.length !== 3) {
          throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` + `it is expected to have a length of 3, but received length ` + `${args.strides.length}.`);
        }
        this.strides = args.strides;
      } else {
        this.strides = [args.strides, args.strides, args.strides];
      }
      assertPositiveInteger(this.poolSize, "poolSize");
      assertPositiveInteger(this.strides, "strides");
      this.padding = args.padding == null ? "valid" : args.padding;
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      checkPaddingMode(this.padding);
      this.inputSpec = [new InputSpec({ ndim: 5 })];
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      let depths = this.dataFormat === "channelsFirst" ? inputShape[2] : inputShape[1];
      let rows = this.dataFormat === "channelsFirst" ? inputShape[3] : inputShape[2];
      let cols = this.dataFormat === "channelsFirst" ? inputShape[4] : inputShape[3];
      depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);
      rows = convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);
      cols = convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);
      if (this.dataFormat === "channelsFirst") {
        return [inputShape[0], inputShape[1], depths, rows, cols];
      } else {
        return [inputShape[0], depths, rows, cols, inputShape[4]];
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        this.invokeCallHook(inputs, kwargs);
        return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);
      });
    }
    getConfig() {
      const config = {
        poolSize: this.poolSize,
        padding: this.padding,
        strides: this.strides,
        dataFormat: this.dataFormat
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  MaxPooling3D = class MaxPooling3D extends Pooling3D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool3d(inputs, poolSize, strides, padding, dataFormat, "max");
    }
  };
  MaxPooling3D.className = "MaxPooling3D";
  exports_serialization.registerClass(MaxPooling3D);
  AveragePooling3D = class AveragePooling3D extends Pooling3D {
    constructor(args) {
      super(args);
    }
    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {
      checkDataFormat(dataFormat);
      checkPaddingMode(padding);
      return pool3d(inputs, poolSize, strides, padding, dataFormat, "avg");
    }
  };
  AveragePooling3D.className = "AveragePooling3D";
  exports_serialization.registerClass(AveragePooling3D);
  GlobalPooling1D = class GlobalPooling1D extends Layer {
    constructor(args) {
      super(args);
      this.inputSpec = [new InputSpec({ ndim: 3 })];
    }
    computeOutputShape(inputShape) {
      return [inputShape[0], inputShape[2]];
    }
    call(inputs, kwargs) {
      throw new NotImplementedError;
    }
  };
  GlobalAveragePooling1D = class GlobalAveragePooling1D extends GlobalPooling1D {
    constructor(args) {
      super(args || {});
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        return mean(input2, 1);
      });
    }
  };
  GlobalAveragePooling1D.className = "GlobalAveragePooling1D";
  exports_serialization.registerClass(GlobalAveragePooling1D);
  GlobalMaxPooling1D = class GlobalMaxPooling1D extends GlobalPooling1D {
    constructor(args) {
      super(args || {});
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        return max(input2, 1);
      });
    }
  };
  GlobalMaxPooling1D.className = "GlobalMaxPooling1D";
  exports_serialization.registerClass(GlobalMaxPooling1D);
  GlobalPooling2D = class GlobalPooling2D extends Layer {
    constructor(args) {
      super(args);
      this.dataFormat = args.dataFormat == null ? "channelsLast" : args.dataFormat;
      checkDataFormat(this.dataFormat);
      this.inputSpec = [new InputSpec({ ndim: 4 })];
    }
    computeOutputShape(inputShape) {
      inputShape = inputShape;
      if (this.dataFormat === "channelsLast") {
        return [inputShape[0], inputShape[3]];
      } else {
        return [inputShape[0], inputShape[1]];
      }
    }
    call(inputs, kwargs) {
      throw new NotImplementedError;
    }
    getConfig() {
      const config = { dataFormat: this.dataFormat };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  GlobalAveragePooling2D = class GlobalAveragePooling2D extends GlobalPooling2D {
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsLast") {
          return mean(input2, [1, 2]);
        } else {
          return mean(input2, [2, 3]);
        }
      });
    }
  };
  GlobalAveragePooling2D.className = "GlobalAveragePooling2D";
  exports_serialization.registerClass(GlobalAveragePooling2D);
  GlobalMaxPooling2D = class GlobalMaxPooling2D extends GlobalPooling2D {
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        if (this.dataFormat === "channelsLast") {
          return max(input2, [1, 2]);
        } else {
          return max(input2, [2, 3]);
        }
      });
    }
  };
  GlobalMaxPooling2D.className = "GlobalMaxPooling2D";
  exports_serialization.registerClass(GlobalMaxPooling2D);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js
function checkBidirectionalMergeMode(value) {
  checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, "BidirectionalMergeMode", value);
}
var Wrapper, TimeDistributed, DEFAULT_BIDIRECTIONAL_MERGE_MODE = "concat", Bidirectional;
var init_wrappers = __esm(() => {
  init_dist();
  init_dist();
  init_tfjs_backend();
  init_common2();
  init_topology();
  init_errors();
  init_common();
  init_generic_utils();
  init_types_utils();
  init_recurrent();
  init_serialization2();
  Wrapper = class Wrapper extends Layer {
    constructor(args) {
      super(args);
      this.layer = args.layer;
    }
    build(inputShape) {
      this.built = true;
    }
    get trainable() {
      if (this.layer != null) {
        return this.layer.trainable;
      } else {
        return false;
      }
    }
    set trainable(value) {
      if (this.layer != null) {
        this.layer.trainable = value;
      }
    }
    get trainableWeights() {
      return this.layer.trainableWeights;
    }
    get nonTrainableWeights() {
      return this.layer.nonTrainableWeights;
    }
    get updates() {
      return this.layer._updates;
    }
    get losses() {
      return this.layer.losses;
    }
    getWeights() {
      return this.layer.getWeights();
    }
    setWeights(weights) {
      this.layer.setWeights(weights);
    }
    getConfig() {
      const config = {
        layer: {
          className: this.layer.getClassName(),
          config: this.layer.getConfig()
        }
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    setFastWeightInitDuringBuild(value) {
      super.setFastWeightInitDuringBuild(value);
      if (this.layer != null) {
        this.layer.setFastWeightInitDuringBuild(value);
      }
    }
    static fromConfig(cls, config, customObjects = {}) {
      const layerConfig = config["layer"];
      const layer = deserialize(layerConfig, customObjects);
      delete config["layer"];
      const newConfig = { layer };
      Object.assign(newConfig, config);
      return new cls(newConfig);
    }
  };
  TimeDistributed = class TimeDistributed extends Wrapper {
    constructor(args) {
      super(args);
      this.supportsMasking = true;
    }
    build(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape.length < 3) {
        throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received ` + `input shape ${JSON.stringify(inputShape)}`);
      }
      this.inputSpec = [{ shape: inputShape }];
      const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
      if (!this.layer.built) {
        this.layer.build(childInputShape);
        this.layer.built = true;
      }
      super.build(inputShape);
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const childInputShape = [inputShape[0]].concat(inputShape.slice(2));
      const childOutputShape = this.layer.computeOutputShape(childInputShape);
      const timesteps = inputShape[1];
      return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        const step7 = (inputs2, states) => {
          const output = getExactlyOneTensor(this.layer.call(inputs2, kwargs));
          return [output, []];
        };
        const rnnOutputs = rnn(step7, inputs, [], false, null, null, false, true);
        const y = rnnOutputs[1];
        return y;
      });
    }
  };
  TimeDistributed.className = "TimeDistributed";
  exports_serialization.registerClass(TimeDistributed);
  Bidirectional = class Bidirectional extends Wrapper {
    constructor(args) {
      super(args);
      const layerConfig = args.layer.getConfig();
      const forwDict = {};
      forwDict["className"] = args.layer.getClassName();
      forwDict["config"] = layerConfig;
      this.forwardLayer = deserialize(forwDict);
      layerConfig["goBackwards"] = layerConfig["goBackwards"] === true ? false : true;
      const backDict = {};
      backDict["className"] = args.layer.getClassName();
      backDict["config"] = layerConfig;
      this.backwardLayer = deserialize(backDict);
      this.forwardLayer.name = "forward_" + this.forwardLayer.name;
      this.backwardLayer.name = "backward_" + this.backwardLayer.name;
      this.mergeMode = args.mergeMode === undefined ? DEFAULT_BIDIRECTIONAL_MERGE_MODE : args.mergeMode;
      checkBidirectionalMergeMode(this.mergeMode);
      if (args.weights) {
        throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");
      }
      this._stateful = args.layer.stateful;
      this.returnSequences = args.layer.returnSequences;
      this.returnState = args.layer.returnState;
      this.supportsMasking = true;
      this._trainable = true;
      this.inputSpec = args.layer.inputSpec;
      this.numConstants = null;
    }
    get trainable() {
      return this._trainable;
    }
    set trainable(value) {
      this._trainable = value;
      if (this.forwardLayer != null) {
        this.forwardLayer.trainable = value;
      }
      if (this.backwardLayer != null) {
        this.backwardLayer.trainable = value;
      }
    }
    getWeights() {
      return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());
    }
    setWeights(weights) {
      const numWeights = weights.length;
      const numeightsOver2 = Math.floor(numWeights / 2);
      this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));
      this.backwardLayer.setWeights(weights.slice(numeightsOver2));
    }
    computeOutputShape(inputShape) {
      let layerShapes = this.forwardLayer.computeOutputShape(inputShape);
      if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {
        layerShapes = [layerShapes];
      }
      layerShapes = layerShapes;
      let outputShape;
      let outputShapes;
      let stateShape;
      if (this.returnState) {
        stateShape = layerShapes.slice(1);
        outputShape = layerShapes[0];
      } else {
        outputShape = layerShapes[0];
      }
      outputShape = outputShape;
      if (this.mergeMode === "concat") {
        outputShape[outputShape.length - 1] *= 2;
        outputShapes = [outputShape];
      } else if (this.mergeMode == null) {
        outputShapes = [outputShape, outputShape.slice()];
      } else {
        outputShapes = [outputShape];
      }
      if (this.returnState) {
        if (this.mergeMode == null) {
          return outputShapes.concat(stateShape).concat(stateShape.slice());
        }
        return [outputShape].concat(stateShape).concat(stateShape.slice());
      }
      return singletonOrArray(outputShapes);
    }
    apply(inputs, kwargs) {
      let initialState = kwargs == null ? null : kwargs["initialState"];
      let constants = kwargs == null ? null : kwargs["constants"];
      if (kwargs == null) {
        kwargs = {};
      }
      const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);
      inputs = standardized.inputs;
      initialState = standardized.initialState;
      constants = standardized.constants;
      if (Array.isArray(inputs)) {
        initialState = inputs.slice(1);
        inputs = inputs[0];
      }
      if ((initialState == null || initialState.length === 0) && constants == null) {
        return super.apply(inputs, kwargs);
      }
      const additionalInputs = [];
      const additionalSpecs = [];
      if (initialState != null) {
        const numStates = initialState.length;
        if (numStates % 2 > 0) {
          throw new ValueError("When passing `initialState` to a Bidrectional RNN, " + "the state should be an Array containing the states of " + "the underlying RNNs.");
        }
        kwargs["initialState"] = initialState;
        additionalInputs.push(...initialState);
        const stateSpecs = initialState.map((state6) => new InputSpec({ shape: state6.shape }));
        this.forwardLayer.stateSpec = stateSpecs.slice(0, numStates / 2);
        this.backwardLayer.stateSpec = stateSpecs.slice(numStates / 2);
        additionalSpecs.push(...stateSpecs);
      }
      if (constants != null) {
        throw new NotImplementedError("Support for constants in Bidirectional layers is not " + "implemented yet.");
      }
      const isSymbolicTensor = additionalInputs[0] instanceof SymbolicTensor;
      for (const tensor153 of additionalInputs) {
        if (tensor153 instanceof SymbolicTensor !== isSymbolicTensor) {
          throw new ValueError("The initial state of a Bidirectional layer cannot be " + "specified as a mix of symbolic and non-symbolic tensors");
        }
      }
      if (isSymbolicTensor) {
        const fullInput = [inputs].concat(additionalInputs);
        const fullInputSpec = this.inputSpec.concat(additionalSpecs);
        const originalInputSpec = this.inputSpec;
        this.inputSpec = fullInputSpec;
        const output = super.apply(fullInput, kwargs);
        this.inputSpec = originalInputSpec;
        return output;
      } else {
        return super.apply(inputs, kwargs);
      }
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const initialState = kwargs["initialState"];
        let y;
        let yRev;
        if (initialState == null) {
          y = this.forwardLayer.call(inputs, kwargs);
          yRev = this.backwardLayer.call(inputs, kwargs);
        } else {
          const forwardState = initialState.slice(0, initialState.length / 2);
          const backwardState = initialState.slice(initialState.length / 2);
          y = this.forwardLayer.call(inputs, Object.assign(kwargs, { initialState: forwardState }));
          yRev = this.backwardLayer.call(inputs, Object.assign(kwargs, { initialState: backwardState }));
        }
        let states;
        if (this.returnState) {
          if (Array.isArray(y)) {
            states = y.slice(1).concat(yRev.slice(1));
          } else {
          }
          y = y[0];
          yRev = yRev[0];
        }
        if (this.returnSequences) {
          yRev = reverse(yRev, 1);
        }
        let output;
        if (this.mergeMode === "concat") {
          output = concatenate([y, yRev]);
        } else if (this.mergeMode === "sum") {
          output = add2(y, yRev);
        } else if (this.mergeMode === "ave") {
          output = mul(0.5, add2(y, yRev));
        } else if (this.mergeMode === "mul") {
          output = mul(y, yRev);
        } else if (this.mergeMode == null) {
          output = [y, yRev];
        }
        if (this.returnState) {
          if (this.mergeMode == null) {
            return output.concat(states);
          }
          return [output].concat(states);
        }
        return output;
      });
    }
    resetStates(states) {
      this.forwardLayer.resetStates();
      this.backwardLayer.resetStates();
    }
    build(inputShape) {
      nameScope(this.forwardLayer.name, () => {
        this.forwardLayer.build(inputShape);
      });
      nameScope(this.backwardLayer.name, () => {
        this.backwardLayer.build(inputShape);
      });
      this.built = true;
    }
    computeMask(inputs, mask) {
      if (Array.isArray(mask)) {
        mask = mask[0];
      }
      let outputMask;
      if (this.returnSequences) {
        if (this.mergeMode == null) {
          outputMask = [mask, mask];
        } else {
          outputMask = mask;
        }
      } else {
        if (this.mergeMode == null) {
          outputMask = [null, null];
        } else {
          outputMask = null;
        }
      }
      if (this.returnState) {
        const states = this.forwardLayer.states;
        const stateMask = states.map((state6) => null);
        if (Array.isArray(outputMask)) {
          return outputMask.concat(stateMask).concat(stateMask);
        } else {
          return [outputMask].concat(stateMask).concat(stateMask);
        }
      } else {
        return outputMask;
      }
    }
    get trainableWeights() {
      return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);
    }
    get nonTrainableWeights() {
      return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);
    }
    setFastWeightInitDuringBuild(value) {
      super.setFastWeightInitDuringBuild(value);
      if (this.forwardLayer != null) {
        this.forwardLayer.setFastWeightInitDuringBuild(value);
      }
      if (this.backwardLayer != null) {
        this.backwardLayer.setFastWeightInitDuringBuild(value);
      }
    }
    getConfig() {
      const config = {
        mergeMode: this.mergeMode
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    static fromConfig(cls, config) {
      const rnnLayer = deserialize(config["layer"]);
      delete config["layer"];
      if (config["numConstants"] != null) {
        throw new NotImplementedError(`Deserialization of a Bidirectional layer with numConstants ` + `present is not supported yet.`);
      }
      const newConfig = config;
      newConfig["layer"] = rnnLayer;
      return new cls(newConfig);
    }
  };
  Bidirectional.className = "Bidirectional";
  exports_serialization.registerClass(Bidirectional);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/preprocessing/image_preprocessing.js
var Rescaling;
var init_image_preprocessing = __esm(() => {
  init_topology();
  init_dist();
  init_types_utils();
  init_tfjs_backend();
  Rescaling = class Rescaling extends Layer {
    constructor(args) {
      super(args);
      this.scale = args.scale;
      if (args.offset) {
        this.offset = args.offset;
      } else {
        this.offset = 0;
      }
    }
    getConfig() {
      const config = {
        scale: this.scale,
        offset: this.offset
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        if (inputs.dtype !== "float32") {
          inputs = cast45(inputs, "float32");
        }
        return add2(mul(inputs, this.scale), this.offset);
      });
    }
  };
  Rescaling.className = "Rescaling";
  exports_serialization.registerClass(Rescaling);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/preprocessing/center_crop.js
var resizeBilinear2, cropAndResize2, CenterCrop;
var init_center_crop = __esm(() => {
  init_dist();
  init_types_utils();
  init_topology();
  init_tfjs_backend();
  ({ resizeBilinear: resizeBilinear2, cropAndResize: cropAndResize2 } = image);
  CenterCrop = class CenterCrop extends Layer {
    constructor(args) {
      super(args);
      this.height = args.height;
      this.width = args.width;
    }
    centerCrop(inputs, hBuffer, wBuffer, height, width, inputHeight, inputWidth, dtype) {
      return tidy(() => {
        let input2;
        let isRank3 = false;
        const top = hBuffer / inputHeight;
        const left = wBuffer / inputWidth;
        const bottom = (height + hBuffer) / inputHeight;
        const right = (width + wBuffer) / inputWidth;
        const bound = [top, left, bottom, right];
        const boxesArr = [];
        if (inputs.rank === 3) {
          isRank3 = true;
          input2 = stack([inputs]);
        } else {
          input2 = inputs;
        }
        for (let i = 0;i < input2.shape[0]; i++) {
          boxesArr.push(bound);
        }
        const boxes = tensor4(boxesArr, [boxesArr.length, 4]);
        const boxInd = range(0, boxesArr.length, 1, "int32");
        const cropSize = [height, width];
        const cropped = cropAndResize2(input2, boxes, boxInd, cropSize, "nearest");
        if (isRank3) {
          return cast45(getExactlyOneTensor(unstack(cropped)), dtype);
        }
        return cast45(cropped, dtype);
      });
    }
    upsize(inputs, height, width, dtype) {
      return tidy(() => {
        const outputs = resizeBilinear2(inputs, [height, width]);
        return cast45(outputs, dtype);
      });
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const rankedInputs = getExactlyOneTensor(inputs);
        const dtype = rankedInputs.dtype;
        const inputShape = rankedInputs.shape;
        const inputHeight = inputShape[inputShape.length - 3];
        const inputWidth = inputShape[inputShape.length - 2];
        let hBuffer = 0;
        if (inputHeight !== this.height) {
          hBuffer = Math.floor((inputHeight - this.height) / 2);
        }
        let wBuffer = 0;
        if (inputWidth !== this.width) {
          wBuffer = Math.floor((inputWidth - this.width) / 2);
          if (wBuffer === 0) {
            wBuffer = 1;
          }
        }
        if (hBuffer >= 0 && wBuffer >= 0) {
          return this.centerCrop(rankedInputs, hBuffer, wBuffer, this.height, this.width, inputHeight, inputWidth, dtype);
        } else {
          return this.upsize(inputs, this.height, this.width, dtype);
        }
      });
    }
    getConfig() {
      const config = {
        height: this.height,
        width: this.width
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const hAxis = inputShape.length - 3;
      const wAxis = inputShape.length - 2;
      inputShape[hAxis] = this.height;
      inputShape[wAxis] = this.width;
      return inputShape;
    }
  };
  CenterCrop.className = "CenterCrop";
  exports_serialization.registerClass(CenterCrop);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/preprocessing/preprocessing_utils.js
function encodeCategoricalInputs(inputs, outputMode, depth, weights) {
  let input2 = getExactlyOneTensor(inputs);
  if (input2.dtype !== "int32") {
    input2 = cast45(input2, "int32");
  }
  if (outputMode === "int") {
    return input2;
  }
  const originalShape = input2.shape;
  if (input2.rank === 0) {
    input2 = expandDims(input2, -1);
  }
  if (outputMode === "oneHot") {
    if (input2.shape[input2.shape.length - 1] !== 1) {
      input2 = expandDims(input2, -1);
    }
  }
  if (input2.rank > 2) {
    throw new ValueError(`When outputMode is not int, maximum output rank is 2` + ` Received outputMode ${outputMode} and input shape ${originalShape}` + ` which would result in output rank ${input2.rank}.`);
  }
  const binaryOutput = ["multiHot", "oneHot"].includes(outputMode);
  const denseBincountInput = input2;
  let binCounts;
  if (typeof weights !== "undefined" && outputMode === "count") {
    binCounts = denseBincount(denseBincountInput, weights, depth, binaryOutput);
  } else {
    binCounts = denseBincount(denseBincountInput, [], depth, binaryOutput);
  }
  if (outputMode !== "tfIdf") {
    return binCounts;
  }
  if (weights) {
    return mul(binCounts, weights);
  } else {
    throw new ValueError(`When outputMode is 'tfIdf', weights must be provided.`);
  }
}
var init_preprocessing_utils = __esm(() => {
  init_dist();
  init_types_utils();
  init_dist();
  init_errors();
  init_tfjs_backend();
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/preprocessing/category_encoding.js
var CategoryEncoding;
var init_category_encoding = __esm(() => {
  init_topology();
  init_dist();
  init_dist();
  init_types_utils();
  init_errors();
  init_tfjs_backend();
  init_preprocessing_utils();
  CategoryEncoding = class CategoryEncoding extends Layer {
    constructor(args) {
      super(args);
      this.numTokens = args.numTokens;
      if (args.outputMode) {
        this.outputMode = args.outputMode;
      } else {
        this.outputMode = "multiHot";
      }
    }
    getConfig() {
      const config = {
        numTokens: this.numTokens,
        outputMode: this.outputMode
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      if (inputShape == null) {
        return [this.numTokens];
      }
      if (this.outputMode === "oneHot" && inputShape[inputShape.length - 1] !== 1) {
        inputShape.push(this.numTokens);
        return inputShape;
      }
      inputShape[inputShape.length - 1] = this.numTokens;
      return inputShape;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        inputs = getExactlyOneTensor(inputs);
        if (inputs.dtype !== "int32") {
          inputs = cast45(inputs, "int32");
        }
        let countWeights;
        if (typeof kwargs["countWeights"] !== "undefined") {
          if (this.outputMode !== "count") {
            throw new ValueError(`countWeights is not used when outputMode !== count.
              Received countWeights=${kwargs["countWeights"]}`);
          }
          countWeights = getExactlyOneTensor(kwargs["countWeights"]);
        }
        const maxValue = max(inputs);
        const minValue = min(inputs);
        const greaterEqualMax = greater(this.numTokens, maxValue).bufferSync().get(0);
        const greaterMin = greaterEqual(minValue, 0).bufferSync().get(0);
        if (!(greaterEqualMax && greaterMin)) {
          throw new ValueError("Input values must be between 0 < values <=" + ` numTokens with numTokens=${this.numTokens}`);
        }
        return encodeCategoricalInputs(inputs, this.outputMode, this.numTokens, countWeights);
      });
    }
  };
  CategoryEncoding.className = "CategoryEncoding";
  exports_serialization.registerClass(CategoryEncoding);
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/preprocessing/image_resizing.js
var INTERPOLATION_KEYS, INTERPOLATION_METHODS, Resizing;
var init_image_resizing = __esm(() => {
  init_dist();
  init_topology();
  init_errors();
  init_types_utils();
  INTERPOLATION_KEYS = ["bilinear", "nearest"];
  INTERPOLATION_METHODS = new Set(INTERPOLATION_KEYS);
  Resizing = class Resizing extends Layer {
    constructor(args) {
      super(args);
      this.height = args.height;
      this.width = args.width;
      if (args.interpolation) {
        if (INTERPOLATION_METHODS.has(args.interpolation)) {
          this.interpolation = args.interpolation;
        } else {
          throw new ValueError(`Invalid interpolation parameter: ${args.interpolation} is not implemented`);
        }
      } else {
        this.interpolation = "bilinear";
      }
      this.cropToAspectRatio = Boolean(args.cropToAspectRatio);
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const numChannels = inputShape[2];
      return [this.height, this.width, numChannels];
    }
    getConfig() {
      const config = {
        height: this.height,
        width: this.width,
        interpolation: this.interpolation,
        cropToAspectRatio: this.cropToAspectRatio
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const size = [this.height, this.width];
        if (this.interpolation === "bilinear") {
          return image.resizeBilinear(inputs, size, !this.cropToAspectRatio);
        } else if (this.interpolation === "nearest") {
          return image.resizeNearestNeighbor(inputs, size, !this.cropToAspectRatio);
        } else {
          throw new Error(`Interpolation is ${this.interpolation} but only ${[...INTERPOLATION_METHODS]} are supported`);
        }
      });
    }
  };
  Resizing.className = "Resizing";
  exports_serialization.registerClass(Resizing);
});

// node_modules/@tensorflow/tfjs-layers/dist/backend/random_seed.js
class RandomSeed {
  constructor(seed) {
    this.seed = seed;
  }
  next() {
    if (this.seed === undefined) {
      return;
    }
    return this.seed++;
  }
}
var init_random_seed = __esm(() => {
  RandomSeed.className = "RandomSeed";
});

// node_modules/@tensorflow/tfjs-layers/dist/engine/base_random_layer.js
var BaseRandomLayer;
var init_base_random_layer = __esm(() => {
  init_topology();
  init_random_seed();
  BaseRandomLayer = class BaseRandomLayer extends Layer {
    constructor(args) {
      super(args);
      this.randomGenerator = new RandomSeed(args.seed);
    }
    getConfig() {
      const config = {
        seed: this.randomGenerator.seed
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
  };
  BaseRandomLayer.className = "BaseRandomLayer";
});

// node_modules/@tensorflow/tfjs-layers/dist/layers/preprocessing/random_width.js
var INTERPOLATION_KEYS2, INTERPOLATION_METHODS2, RandomWidth;
var init_random_width = __esm(() => {
  init_dist();
  init_types_utils();
  init_errors();
  init_base_random_layer();
  init_dist();
  INTERPOLATION_KEYS2 = ["bilinear", "nearest"];
  INTERPOLATION_METHODS2 = new Set(INTERPOLATION_KEYS2);
  RandomWidth = class RandomWidth extends BaseRandomLayer {
    constructor(args) {
      super(args);
      const { factor, interpolation = "bilinear" } = args;
      this.factor = factor;
      if (Array.isArray(this.factor) && this.factor.length === 2) {
        this.widthLower = this.factor[0];
        this.widthUpper = this.factor[1];
      } else if (!Array.isArray(this.factor) && this.factor > 0) {
        this.widthLower = -this.factor;
        this.widthUpper = this.factor;
      } else {
        throw new ValueError(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);
      }
      if (this.widthLower < -1 || this.widthUpper < -1) {
        throw new ValueError(`factor must have values larger than -1. Got: ${this.factor}`);
      }
      if (this.widthUpper < this.widthLower) {
        throw new ValueError(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);
      }
      if (interpolation) {
        if (INTERPOLATION_METHODS2.has(interpolation)) {
          this.interpolation = interpolation;
        } else {
          throw new ValueError(`Invalid interpolation parameter: ${interpolation} is not implemented`);
        }
      }
    }
    getConfig() {
      const config = {
        factor: this.factor,
        interpolation: this.interpolation
      };
      const baseConfig = super.getConfig();
      Object.assign(config, baseConfig);
      return config;
    }
    computeOutputShape(inputShape) {
      inputShape = getExactlyOneShape(inputShape);
      const numChannels = inputShape[2];
      return [this.imgHeight, -1, numChannels];
    }
    call(inputs, kwargs) {
      return tidy(() => {
        const input2 = getExactlyOneTensor(inputs);
        this.imgHeight = input2.shape[input2.shape.length - 3];
        const imgWidth = input2.shape[input2.shape.length - 2];
        this.widthFactor = randomUniform([1], 1 + this.widthLower, 1 + this.widthUpper, "float32", this.randomGenerator.next());
        let adjustedWidth = this.widthFactor.dataSync()[0] * imgWidth;
        adjustedWidth = Math.round(adjustedWidth);
        const size = [this.imgHeight, adjustedWidth];
        switch (this.interpolation) {
          case "bilinear":
            return image.resizeBilinear(inputs, size);
          case "nearest":
            return image.resizeNearestNeighbor(inputs, size);
          default:
            throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...INTERPOLATION_METHODS2]} are supported`);
        }
      });
    }
  };
  RandomWidth.className = "RandomWidth";
  exports_serialization.registerClass(RandomWidth);
});

// node_modules/@tensorflow/tfjs-layers/dist/exports_layers.js
var exports_exports_layers = {};
__export(exports_exports_layers, {
  zeroPadding2d: () => zeroPadding2d,
  upSampling2d: () => upSampling2d,
  timeDistributed: () => timeDistributed,
  thresholdedReLU: () => thresholdedReLU,
  stackedRNNCells: () => stackedRNNCells,
  spatialDropout1d: () => spatialDropout1d,
  softmax: () => softmax3,
  simpleRNNCell: () => simpleRNNCell,
  simpleRNN: () => simpleRNN,
  separableConv2d: () => separableConv2d2,
  rnn: () => rnn2,
  resizing: () => resizing,
  reshape: () => reshape76,
  rescaling: () => rescaling,
  repeatVector: () => repeatVector,
  reLU: () => reLU,
  randomWidth: () => randomWidth,
  prelu: () => prelu5,
  permute: () => permute,
  multiply: () => multiply,
  minimum: () => minimum6,
  maximum: () => maximum6,
  maxPooling3d: () => maxPooling3d,
  maxPooling2d: () => maxPooling2d,
  maxPooling1d: () => maxPooling1d,
  maxPool2d: () => maxPool2d,
  maxPool1d: () => maxPool1d,
  masking: () => masking,
  lstmCell: () => lstmCell,
  lstm: () => lstm,
  leakyReLU: () => leakyReLU,
  layerNormalization: () => layerNormalization,
  inputLayer: () => inputLayer,
  input: () => input,
  gruCell: () => gruCell,
  gru: () => gru,
  globalMaxPooling2d: () => globalMaxPooling2d,
  globalMaxPooling1d: () => globalMaxPooling1d,
  globalMaxPool2d: () => globalMaxPool2d,
  globalMaxPool1d: () => globalMaxPool1d,
  globalAveragePooling2d: () => globalAveragePooling2d,
  globalAveragePooling1d: () => globalAveragePooling1d,
  gaussianNoise: () => gaussianNoise,
  gaussianDropout: () => gaussianDropout,
  flatten: () => flatten4,
  embedding: () => embedding,
  elu: () => elu6,
  dropout: () => dropout4,
  dot: () => dot5,
  depthwiseConv2d: () => depthwiseConv2d4,
  dense: () => dense,
  cropping2D: () => cropping2D,
  convLstm2dCell: () => convLstm2dCell,
  convLstm2d: () => convLstm2d,
  conv3dTranspose: () => conv3dTranspose2,
  conv3d: () => conv3d2,
  conv2dTranspose: () => conv2dTranspose2,
  conv2d: () => conv2d10,
  conv1d: () => conv1d4,
  concatenate: () => concatenate2,
  centerCrop: () => centerCrop,
  categoryEncoding: () => categoryEncoding,
  bidirectional: () => bidirectional,
  batchNormalization: () => batchNormalization2,
  avgPooling3d: () => avgPooling3d,
  avgPooling2d: () => avgPooling2d,
  avgPooling1d: () => avgPooling1d,
  avgPool3d: () => avgPool3d2,
  avgPool2d: () => avgPool2d,
  avgPool1d: () => avgPool1d,
  averagePooling3d: () => averagePooling3d,
  averagePooling2d: () => averagePooling2d,
  averagePooling1d: () => averagePooling1d,
  average: () => average,
  alphaDropout: () => alphaDropout,
  add: () => add30,
  activation: () => activation,
  RNNCell: () => RNNCell,
  RNN: () => RNN,
  Layer: () => Layer
});
function inputLayer(args) {
  return new InputLayer(args);
}
function elu6(args) {
  return new ELU(args);
}
function reLU(args) {
  return new ReLU(args);
}
function leakyReLU(args) {
  return new LeakyReLU(args);
}
function prelu5(args) {
  return new PReLU(args);
}
function softmax3(args) {
  return new Softmax3(args);
}
function thresholdedReLU(args) {
  return new ThresholdedReLU(args);
}
function conv1d4(args) {
  return new Conv1D(args);
}
function conv2d10(args) {
  return new Conv2D2(args);
}
function conv2dTranspose2(args) {
  return new Conv2DTranspose(args);
}
function conv3d2(args) {
  return new Conv3D2(args);
}
function conv3dTranspose2(args) {
  return new Conv3DTranspose(args);
}
function separableConv2d2(args) {
  return new SeparableConv2D(args);
}
function cropping2D(args) {
  return new Cropping2D(args);
}
function upSampling2d(args) {
  return new UpSampling2D(args);
}
function depthwiseConv2d4(args) {
  return new DepthwiseConv2D(args);
}
function activation(args) {
  return new Activation2(args);
}
function dense(args) {
  return new Dense(args);
}
function dropout4(args) {
  return new Dropout(args);
}
function spatialDropout1d(args) {
  return new SpatialDropout1D(args);
}
function flatten4(args) {
  return new Flatten(args);
}
function repeatVector(args) {
  return new RepeatVector(args);
}
function reshape76(args) {
  return new Reshape2(args);
}
function permute(args) {
  return new Permute(args);
}
function embedding(args) {
  return new Embedding(args);
}
function add30(args) {
  return new Add2(args);
}
function average(args) {
  return new Average(args);
}
function concatenate2(args) {
  return new Concatenate(args);
}
function maximum6(args) {
  return new Maximum2(args);
}
function minimum6(args) {
  return new Minimum2(args);
}
function multiply(args) {
  return new Multiply2(args);
}
function dot5(args) {
  return new Dot(args);
}
function batchNormalization2(args) {
  return new BatchNormalization(args);
}
function layerNormalization(args) {
  return new LayerNormalization(args);
}
function zeroPadding2d(args) {
  return new ZeroPadding2D(args);
}
function averagePooling1d(args) {
  return new AveragePooling1D(args);
}
function avgPool1d(args) {
  return averagePooling1d(args);
}
function avgPooling1d(args) {
  return averagePooling1d(args);
}
function averagePooling2d(args) {
  return new AveragePooling2D(args);
}
function avgPool2d(args) {
  return averagePooling2d(args);
}
function avgPooling2d(args) {
  return averagePooling2d(args);
}
function averagePooling3d(args) {
  return new AveragePooling3D(args);
}
function avgPool3d2(args) {
  return averagePooling3d(args);
}
function avgPooling3d(args) {
  return averagePooling3d(args);
}
function globalAveragePooling1d(args) {
  return new GlobalAveragePooling1D(args);
}
function globalAveragePooling2d(args) {
  return new GlobalAveragePooling2D(args);
}
function globalMaxPooling1d(args) {
  return new GlobalMaxPooling1D(args);
}
function globalMaxPooling2d(args) {
  return new GlobalMaxPooling2D(args);
}
function maxPooling1d(args) {
  return new MaxPooling1D(args);
}
function maxPooling2d(args) {
  return new MaxPooling2D(args);
}
function maxPooling3d(args) {
  return new MaxPooling3D(args);
}
function gru(args) {
  return new GRU(args);
}
function gruCell(args) {
  return new GRUCell(args);
}
function lstm(args) {
  return new LSTM(args);
}
function lstmCell(args) {
  return new LSTMCell(args);
}
function simpleRNN(args) {
  return new SimpleRNN(args);
}
function simpleRNNCell(args) {
  return new SimpleRNNCell(args);
}
function convLstm2d(args) {
  return new ConvLSTM2D(args);
}
function convLstm2dCell(args) {
  return new ConvLSTM2DCell(args);
}
function rnn2(args) {
  return new RNN(args);
}
function stackedRNNCells(args) {
  return new StackedRNNCells(args);
}
function bidirectional(args) {
  return new Bidirectional(args);
}
function timeDistributed(args) {
  return new TimeDistributed(args);
}
function gaussianNoise(args) {
  return new GaussianNoise(args);
}
function gaussianDropout(args) {
  return new GaussianDropout(args);
}
function alphaDropout(args) {
  return new AlphaDropout(args);
}
function masking(args) {
  return new Masking(args);
}
function rescaling(args) {
  return new Rescaling(args);
}
function centerCrop(args) {
  return new CenterCrop(args);
}
function resizing(args) {
  return new Resizing(args);
}
function categoryEncoding(args) {
  return new CategoryEncoding(args);
}
function randomWidth(args) {
  return new RandomWidth(args);
}
var globalMaxPool1d, globalMaxPool2d, maxPool1d, maxPool2d;
var init_exports_layers = __esm(() => {
  init_input_layer();
  init_topology();
  init_exports();
  init_advanced_activations();
  init_convolutional();
  init_convolutional_depthwise();
  init_convolutional_recurrent();
  init_core();
  init_embeddings();
  init_merge();
  init_noise();
  init_normalization();
  init_padding();
  init_pooling();
  init_recurrent();
  init_wrappers();
  init_image_preprocessing();
  init_center_crop();
  init_category_encoding();
  init_image_resizing();
  init_random_width();
  globalMaxPool1d = globalMaxPooling1d;
  globalMaxPool2d = globalMaxPooling2d;
  maxPool1d = maxPooling1d;
  maxPool2d = maxPooling2d;
});

// node_modules/@tensorflow/tfjs-layers/dist/exports_metrics.js
var exports_exports_metrics = {};
__export(exports_exports_metrics, {
  sparseCategoricalAccuracy: () => sparseCategoricalAccuracy2,
  recall: () => recall2,
  r2Score: () => r2Score2,
  precision: () => precision2,
  mse: () => mse2,
  meanSquaredError: () => meanSquaredError3,
  meanAbsolutePercentageError: () => meanAbsolutePercentageError2,
  meanAbsoluteError: () => meanAbsoluteError2,
  mape: () => mape2,
  cosineProximity: () => cosineProximity2,
  categoricalCrossentropy: () => categoricalCrossentropy3,
  categoricalAccuracy: () => categoricalAccuracy2,
  binaryCrossentropy: () => binaryCrossentropy3,
  binaryAccuracy: () => binaryAccuracy2,
  MSE: () => MSE2,
  MAPE: () => MAPE2
});
function binaryAccuracy2(yTrue, yPred) {
  return binaryAccuracy(yTrue, yPred);
}
function binaryCrossentropy3(yTrue, yPred) {
  return binaryCrossentropy2(yTrue, yPred);
}
function sparseCategoricalAccuracy2(yTrue, yPred) {
  return sparseCategoricalAccuracy(yTrue, yPred);
}
function categoricalAccuracy2(yTrue, yPred) {
  return categoricalAccuracy(yTrue, yPred);
}
function categoricalCrossentropy3(yTrue, yPred) {
  return categoricalCrossentropy2(yTrue, yPred);
}
function precision2(yTrue, yPred) {
  return precision(yTrue, yPred);
}
function recall2(yTrue, yPred) {
  return recall(yTrue, yPred);
}
function cosineProximity2(yTrue, yPred) {
  return cosineProximity(yTrue, yPred);
}
function meanAbsoluteError2(yTrue, yPred) {
  return meanAbsoluteError(yTrue, yPred);
}
function meanAbsolutePercentageError2(yTrue, yPred) {
  return meanAbsolutePercentageError(yTrue, yPred);
}
function MAPE2(yTrue, yPred) {
  return meanAbsolutePercentageError(yTrue, yPred);
}
function mape2(yTrue, yPred) {
  return meanAbsolutePercentageError(yTrue, yPred);
}
function meanSquaredError3(yTrue, yPred) {
  return meanSquaredError2(yTrue, yPred);
}
function MSE2(yTrue, yPred) {
  return meanSquaredError2(yTrue, yPred);
}
function mse2(yTrue, yPred) {
  return meanSquaredError2(yTrue, yPred);
}
function r2Score2(yTrue, yPred) {
  return r2Score(yTrue, yPred);
}
var init_exports_metrics = __esm(() => {
  init_losses();
  init_metrics();
});

// node_modules/@tensorflow/tfjs-layers/dist/exports_models.js
var exports_exports_models = {};
__export(exports_exports_models, {
  modelFromJSON: () => modelFromJSON
});
var init_exports_models = __esm(() => {
  init_models();
});

// node_modules/@tensorflow/tfjs-layers/dist/exports_regularizers.js
var exports_exports_regularizers = {};
__export(exports_exports_regularizers, {
  l2: () => l22,
  l1l2: () => l1l2,
  l1: () => l12
});
function l1l2(config) {
  return new L1L2(config);
}
function l12(config) {
  return l1(config);
}
function l22(config) {
  return l2(config);
}
var init_exports_regularizers = __esm(() => {
  init_regularizers();
  init_regularizers();
});

// node_modules/@tensorflow/tfjs-layers/dist/callbacks.js
function less6(currVal, prevVal) {
  return currVal < prevVal;
}
function greater11(currVal, prevVal) {
  return currVal > prevVal;
}
function earlyStopping(args) {
  return new EarlyStopping(args);
}
var Callback, EarlyStopping, callbacks;
var init_callbacks = __esm(() => {
  init_base_callbacks();
  init_training();
  init_errors();
  init_logs();
  Callback = class Callback extends BaseCallback {
    constructor() {
      super(...arguments);
      this.model = null;
    }
    setModel(model2) {
      if (!(model2 instanceof LayersModel)) {
        throw new Error("model must be a LayersModel, not some other Container");
      }
      this.model = model2;
    }
  };
  EarlyStopping = class EarlyStopping extends Callback {
    constructor(args) {
      super();
      if (args == null) {
        args = {};
      }
      if (args.restoreBestWeights) {
        throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");
      }
      this.monitor = args.monitor || "val_loss";
      this.minDelta = Math.abs(args.minDelta || 0);
      this.patience = args.patience || 0;
      this.verbose = args.verbose || 0;
      this.mode = args.mode || "auto";
      this.baseline = args.baseline;
      if (["auto", "min", "max"].indexOf(this.mode) === -1) {
        console.warn(`EarlyStopping mode '${this.mode}' is invalid. ` + `Falling back to mode 'auto'.`);
        this.mode = "auto";
      }
      if (this.mode === "min") {
        this.monitorFunc = less6;
      } else if (this.mode === "max") {
        this.monitorFunc = greater11;
      } else {
        if (this.monitor.indexOf("acc") !== -1) {
          this.monitorFunc = greater11;
        } else {
          this.monitorFunc = less6;
        }
      }
      if (this.monitorFunc === less6) {
        this.minDelta *= -1;
      }
    }
    async onTrainBegin(logs5) {
      this.wait = 0;
      this.stoppedEpoch = 0;
      if (this.baseline != null) {
        this.best = this.baseline;
      } else {
        this.best = this.monitorFunc === less6 ? Infinity : -Infinity;
      }
    }
    async onEpochEnd(epoch, logs5) {
      await resolveScalarsInLogs(logs5);
      const current = this.getMonitorValue(logs5);
      if (current == null) {
        return;
      }
      if (this.monitorFunc(current - this.minDelta, this.best)) {
        this.best = current;
        this.wait = 0;
      } else {
        this.wait++;
        if (this.wait >= this.patience) {
          this.stoppedEpoch = epoch;
          this.model.stopTraining = true;
        }
      }
    }
    async onTrainEnd(logs5) {
      if (this.stoppedEpoch > 0 && this.verbose) {
        console.log(`Epoch ${this.stoppedEpoch}: early stopping.`);
      }
    }
    getMonitorValue(logs5) {
      if (logs5 == null) {
        logs5 = {};
      }
      const monitorValue = logs5[this.monitor];
      if (monitorValue == null) {
        console.warn(`Metric for EarlyStopping ${this.monitor} is not available. ` + `Available metrics are: ${Object.keys(logs5)}`);
      }
      return monitorValue;
    }
  };
  callbacks = { earlyStopping };
});

// node_modules/@tensorflow/tfjs-layers/dist/index.js
var init_dist2 = __esm(() => {
  init_flags_layers();
  init_dist();
  init_register_all_gradients();
  init_exports_constraints();
  init_exports_initializers();
  init_exports_layers();
  init_exports_metrics();
  init_exports_models();
  init_exports_regularizers();
  init_base_callbacks();
  init_callbacks();
  init_topology();
  init_training();
  init_exports();
  init_recurrent();
  init_models();
  init_variables();
  init_version2();
});

// node_modules/@tensorflow/tfjs-converter/dist/flags.js
var ENV4;
var init_flags2 = __esm(() => {
  init_dist();
  ENV4 = env();
  ENV4.registerFlag("KEEP_INTERMEDIATE_TENSORS", () => false, (debugValue) => {
    if (debugValue) {
      console.warn("Keep intermediate tensors is ON. This will print the values of all " + "intermediate tensors during model inference. Not all models " + "support this mode. For details, check e2e/benchmarks/ " + "model_config.js. This significantly impacts performance.");
    }
  });
});

// node_modules/@tensorflow/tfjs-converter/dist/data/compiled_api.js
var DataType, SaverDef;
var init_compiled_api = __esm(() => {
  (function(DataType2) {
    DataType2[DataType2["DT_INVALID"] = 0] = "DT_INVALID";
    DataType2[DataType2["DT_FLOAT"] = 1] = "DT_FLOAT";
    DataType2[DataType2["DT_DOUBLE"] = 2] = "DT_DOUBLE";
    DataType2[DataType2["DT_INT32"] = 3] = "DT_INT32";
    DataType2[DataType2["DT_UINT8"] = 4] = "DT_UINT8";
    DataType2[DataType2["DT_INT16"] = 5] = "DT_INT16";
    DataType2[DataType2["DT_INT8"] = 6] = "DT_INT8";
    DataType2[DataType2["DT_STRING"] = 7] = "DT_STRING";
    DataType2[DataType2["DT_COMPLEX64"] = 8] = "DT_COMPLEX64";
    DataType2[DataType2["DT_INT64"] = 9] = "DT_INT64";
    DataType2[DataType2["DT_BOOL"] = 10] = "DT_BOOL";
    DataType2[DataType2["DT_QINT8"] = 11] = "DT_QINT8";
    DataType2[DataType2["DT_QUINT8"] = 12] = "DT_QUINT8";
    DataType2[DataType2["DT_QINT32"] = 13] = "DT_QINT32";
    DataType2[DataType2["DT_BFLOAT16"] = 14] = "DT_BFLOAT16";
    DataType2[DataType2["DT_QINT16"] = 15] = "DT_QINT16";
    DataType2[DataType2["DT_QUINT16"] = 16] = "DT_QUINT16";
    DataType2[DataType2["DT_UINT16"] = 17] = "DT_UINT16";
    DataType2[DataType2["DT_COMPLEX128"] = 18] = "DT_COMPLEX128";
    DataType2[DataType2["DT_HALF"] = 19] = "DT_HALF";
    DataType2[DataType2["DT_RESOURCE"] = 20] = "DT_RESOURCE";
    DataType2[DataType2["DT_VARIANT"] = 21] = "DT_VARIANT";
    DataType2[DataType2["DT_UINT32"] = 22] = "DT_UINT32";
    DataType2[DataType2["DT_UINT64"] = 23] = "DT_UINT64";
    DataType2[DataType2["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF";
    DataType2[DataType2["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF";
    DataType2[DataType2["DT_INT32_REF"] = 103] = "DT_INT32_REF";
    DataType2[DataType2["DT_UINT8_REF"] = 104] = "DT_UINT8_REF";
    DataType2[DataType2["DT_INT16_REF"] = 105] = "DT_INT16_REF";
    DataType2[DataType2["DT_INT8_REF"] = 106] = "DT_INT8_REF";
    DataType2[DataType2["DT_STRING_REF"] = 107] = "DT_STRING_REF";
    DataType2[DataType2["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF";
    DataType2[DataType2["DT_INT64_REF"] = 109] = "DT_INT64_REF";
    DataType2[DataType2["DT_BOOL_REF"] = 110] = "DT_BOOL_REF";
    DataType2[DataType2["DT_QINT8_REF"] = 111] = "DT_QINT8_REF";
    DataType2[DataType2["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF";
    DataType2[DataType2["DT_QINT32_REF"] = 113] = "DT_QINT32_REF";
    DataType2[DataType2["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF";
    DataType2[DataType2["DT_QINT16_REF"] = 115] = "DT_QINT16_REF";
    DataType2[DataType2["DT_QUINT16_REF"] = 116] = "DT_QUINT16_REF";
    DataType2[DataType2["DT_UINT16_REF"] = 117] = "DT_UINT16_REF";
    DataType2[DataType2["DT_COMPLEX128_REF"] = 118] = "DT_COMPLEX128_REF";
    DataType2[DataType2["DT_HALF_REF"] = 119] = "DT_HALF_REF";
    DataType2[DataType2["DT_RESOURCE_REF"] = 120] = "DT_RESOURCE_REF";
    DataType2[DataType2["DT_VARIANT_REF"] = 121] = "DT_VARIANT_REF";
    DataType2[DataType2["DT_UINT32_REF"] = 122] = "DT_UINT32_REF";
    DataType2[DataType2["DT_UINT64_REF"] = 123] = "DT_UINT64_REF";
  })(DataType || (DataType = {}));
  (function(SaverDef2) {
    let CheckpointFormatVersion;
    (function(CheckpointFormatVersion2) {
      CheckpointFormatVersion2[CheckpointFormatVersion2["LEGACY"] = 0] = "LEGACY";
      CheckpointFormatVersion2[CheckpointFormatVersion2["V1"] = 1] = "V1";
      CheckpointFormatVersion2[CheckpointFormatVersion2["V2"] = 2] = "V2";
    })(CheckpointFormatVersion = SaverDef2.CheckpointFormatVersion || (SaverDef2.CheckpointFormatVersion = {}));
  })(SaverDef || (SaverDef = {}));
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/custom_op/register.js
function registerOp(name, opFunc) {
  const opMapper = {
    tfOpName: name,
    category: "custom",
    inputs: [],
    attrs: [],
    customExecutor: opFunc
  };
  CUSTOM_OPS[name] = opMapper;
}
function getRegisteredOp(name) {
  return CUSTOM_OPS[name];
}
function deregisterOp(name) {
  delete CUSTOM_OPS[name];
}
var CUSTOM_OPS;
var init_register = __esm(() => {
  CUSTOM_OPS = {};
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/utils.js
function getParamValue(paramName, node, tensorMap, context, resourceManager) {
  const inputParam = node.inputParams[paramName];
  if (inputParam && inputParam.inputIndexStart !== undefined) {
    const start = inputParam.inputIndexStart;
    const end = inputParam.inputIndexEnd === 0 ? undefined : inputParam.inputIndexEnd === undefined ? start + 1 : inputParam.inputIndexEnd;
    const shiftedStart = start < 0 ? node.inputNames.length + start : start;
    if (inputParam.type === "tensor") {
      return getTensor(node.inputNames[shiftedStart], tensorMap, context, resourceManager);
    }
    if (inputParam.type === "tensors") {
      const inputs = node.inputs.slice(start, end);
      const inputNames = node.inputNames.slice(start, end).filter((_name, index) => {
        var _a;
        return ((_a = inputs[index]) === null || _a === undefined ? undefined : _a.op) !== "NoOp";
      });
      return inputNames.map((name) => getTensor(name, tensorMap, context, resourceManager));
    }
    const tensor153 = getTensor(node.inputNames[shiftedStart], tensorMap, context, resourceManager);
    const data = tensor153.dataSync();
    return inputParam.type === "number" ? data[0] : exports_util.toNestedArray(tensor153.shape, data);
  }
  const attrParam = node.attrParams[paramName];
  return attrParam && attrParam.value;
}
function getTensor(name, tensorsMap, context, resourceManager) {
  const [nodeName, index] = parseNodeName(name, context);
  if (resourceManager != null) {
    const tensor153 = resourceManager.getHashTableHandleByName(nodeName);
    if (tensor153 != null) {
      return tensor153;
    }
  }
  const contextId = context.currentContextIds.find((contextId2) => {
    return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId2)];
  });
  return contextId !== undefined ? tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] : undefined;
}
function getTensorsForCurrentContext(name, tensorsMap, context) {
  return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];
}
function getNodeNameAndIndex(inputName, context) {
  const [nodeName, index, outputName] = parseNodeName(inputName, context);
  return [
    getNodeNameWithContextId(nodeName, context && context.currentContextId),
    index,
    outputName
  ];
}
function getNodeNameWithContextId(name, contextId) {
  return contextId ? `${name}-${contextId}` : name;
}
function parseNodeName(name, context) {
  if (name === "") {
    return ["", 0, undefined];
  }
  const isCacheEnabled = context != null && context.parseNodeNameCache != null;
  if (isCacheEnabled) {
    const cachedResult = context.parseNodeNameCache.get(name);
    if (cachedResult != null) {
      return cachedResult;
    }
  }
  const parts = name.split(":");
  let result;
  if (parts.length === 1) {
    result = [name, 0, undefined];
  } else {
    const nodeName = parts[0];
    const outputName = parts.length === 3 ? parts[1] : undefined;
    const index = Number(parts[parts.length - 1]);
    result = [nodeName, index, outputName];
  }
  if (isCacheEnabled) {
    context.parseNodeNameCache.set(name, result);
  }
  return result;
}
function getPadding(node, tensorMap, context) {
  let pad9 = getParamValue("pad", node, tensorMap, context);
  if (pad9 === "explicit") {
    pad9 = getParamValue("explicitPaddings", node, tensorMap, context);
    const explicitPadding = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let i = 0;i < 4; i++) {
      explicitPadding[i][0] = pad9[i * 2];
      explicitPadding[i][1] = pad9[i * 2 + 1];
    }
    return explicitPadding;
  }
  return pad9;
}
function cloneTensor(tensor153) {
  return tensor153.kept ? tensor153 : clone(tensor153);
}
var init_utils = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/arithmetic.js
var exports_arithmetic = {};
__export(exports_arithmetic, {
  json: () => json
});
var json;
var init_arithmetic = __esm(() => {
  json = [
    {
      tfOpName: "Add",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "AddV2",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "AddN",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }
      ]
    },
    {
      tfOpName: "BiasAdd",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Sub",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "RealDiv",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Div",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "DivNoNan",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "FloorDiv",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Mul",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Maximum",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Minimum",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Pow",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "SquaredDifference",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Mod",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "FloorMod",
      category: "arithmetic",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/basic_math.js
var exports_basic_math = {};
__export(exports_basic_math, {
  json: () => json2
});
var json2;
var init_basic_math = __esm(() => {
  json2 = [
    {
      tfOpName: "Abs",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Acos",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Asin",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Atan",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Atan2",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "y",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Ceil",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "ClipByValue",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "clipValueMin",
          type: "number"
        },
        {
          start: 2,
          name: "clipValueMax",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Complex",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "real",
          type: "tensor"
        },
        {
          start: 1,
          name: "imag",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "ComplexAbs",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Cos",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Cosh",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Elu",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Exp",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Floor",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Log",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Imag",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "Tout",
          name: "outputType",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Neg",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Real",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "Tout",
          name: "outputType",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Prelu",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "alpha",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Relu",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Relu6",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Selu",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Sigmoid",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Sin",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Sinh",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Sqrt",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Rsqrt",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Square",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Tan",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Tanh",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Sign",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Round",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Expm1",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Log1p",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Reciprocal",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Softplus",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Asinh",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Acosh",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Atanh",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Erf",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LeakyRelu",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "alpha",
          name: "alpha",
          type: "number",
          defaultValue: 0.2
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "IsNan",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "IsFinite",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "IsInf",
      category: "basic_math",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/control.js
var exports_control = {};
__export(exports_control, {
  json: () => json3
});
var json3;
var init_control = __esm(() => {
  json3 = [
    {
      tfOpName: "EmptyTensorList",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "elementShape",
          type: "shape"
        },
        {
          start: 1,
          name: "maxNumElements",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "LoopCond",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "pred",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "Switch",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "data",
          type: "tensor"
        },
        {
          start: 1,
          name: "pred",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "Merge",
      category: "control",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }
      ]
    },
    {
      tfOpName: "Enter",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "frame_name",
          name: "frameName",
          type: "string"
        },
        {
          tfName: "is_constant",
          name: "isConstant",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Exit",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "NextIteration",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "TensorArrayV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "size",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "element_shape",
          name: "elementShape",
          type: "shape"
        },
        {
          tfName: "dynamic_size",
          name: "dynamicSize",
          type: "bool"
        },
        {
          tfName: "clear_after_read",
          name: "clearAfterRead",
          type: "bool"
        },
        {
          tfName: "identical_element_shapes",
          name: "identicalElementShapes",
          type: "bool"
        },
        {
          tfName: "tensor_array_name",
          name: "name",
          type: "string"
        }
      ]
    },
    {
      tfOpName: "TensorArrayWriteV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "index",
          type: "number"
        },
        {
          start: 2,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 3,
          name: "flowIn",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "TensorArrayReadV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "index",
          type: "number"
        },
        {
          start: 2,
          name: "flowIn",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "TensorArrayGatherV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "number[]"
        },
        {
          start: 2,
          name: "flowIn",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "element_shape",
          name: "elementShape",
          type: "shape"
        }
      ]
    },
    {
      tfOpName: "TensorArrayScatterV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "number[]"
        },
        {
          start: 2,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 3,
          name: "flowIn",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorArrayConcatV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "flowIn",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "element_shape_except0",
          name: "elementShapeExcept0",
          type: "shape",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "TensorArraySplitV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 2,
          name: "lengths",
          type: "number[]"
        },
        {
          start: 3,
          name: "flowIn",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorArraySizeV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        },
        {
          start: 1,
          name: "flowIn",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "TensorArrayCloseV3",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorArrayId",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "StatelessIf",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "cond",
          type: "tensor"
        },
        {
          start: 1,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "then_branch",
          name: "thenBranch",
          type: "func"
        },
        {
          tfName: "else_branch",
          name: "elseBranch",
          type: "func"
        }
      ]
    },
    {
      tfOpName: "If",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "cond",
          type: "tensor"
        },
        {
          start: 1,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "then_branch",
          name: "thenBranch",
          type: "func"
        },
        {
          tfName: "else_branch",
          name: "elseBranch",
          type: "func"
        }
      ]
    },
    {
      tfOpName: "StatelessWhile",
      category: "control",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "cond",
          name: "cond",
          type: "func"
        },
        {
          tfName: "body",
          name: "body",
          type: "func"
        }
      ]
    },
    {
      tfOpName: "While",
      category: "control",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "cond",
          name: "cond",
          type: "func"
        },
        {
          tfName: "body",
          name: "body",
          type: "func"
        }
      ]
    },
    {
      tfOpName: "TensorListScatter",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "number[]"
        },
        {
          start: 2,
          name: "elementShape",
          type: "shape"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListScatterV2",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "number[]"
        },
        {
          start: 2,
          name: "elementShape",
          type: "shape"
        },
        {
          start: 3,
          name: "numElements",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListGather",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "number[]"
        },
        {
          start: 2,
          name: "elementShape",
          type: "shape"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListGetItem",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "index",
          type: "number"
        },
        {
          start: 2,
          name: "elementShape",
          type: "shape"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListSetItem",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "index",
          type: "number"
        },
        {
          start: 2,
          name: "tensor",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListReserve",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "elementShape",
          type: "shape"
        },
        {
          start: 1,
          name: "numElements",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListFromTensor",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 1,
          name: "elementShape",
          type: "shape"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListStack",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "elementShape",
          type: "shape"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        },
        {
          tfName: "num_elements",
          name: "numElements",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListSplit",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 1,
          name: "elementShape",
          type: "shape"
        },
        {
          start: 2,
          name: "lengths",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListConcat",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "element_shape",
          name: "elementShape",
          type: "shape"
        },
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListConcatV2",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "element_shape",
          name: "elementShape",
          type: "shape"
        },
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListPopBack",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "elementShape",
          type: "shape"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListPushBack",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "tensor",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "element_dtype",
          name: "elementDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TensorListLength",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "TensorListResize",
      category: "control",
      inputs: [
        {
          start: 0,
          name: "tensorListId",
          type: "tensor"
        },
        {
          start: 1,
          name: "size",
          type: "number"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/convolution.js
var exports_convolution = {};
__export(exports_convolution, {
  json: () => json4
});
var json4;
var init_convolution = __esm(() => {
  json4 = [
    {
      tfOpName: "AvgPool",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        },
        {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "MaxPool",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        },
        {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: [],
          notSupported: true
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "MaxPoolWithArgmax",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        },
        {
          tfName: "include_batch_in_index",
          name: "includeBatchInIndex",
          type: "bool"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "AvgPool3D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        },
        {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "MaxPool3D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        },
        {
          tfName: "ksize",
          name: "kernelSize",
          type: "number[]"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Conv1D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "stride",
          name: "stride",
          type: "number"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NWC"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "dilation",
          name: "dilation",
          type: "number",
          defaultValue: 1
        }
      ]
    },
    {
      tfOpName: "Conv2D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "useCudnnOnGpu",
          name: "useCudnnOnGpu",
          type: "bool"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "_FusedConv2D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        },
        {
          start: 2,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "num_args",
          name: "numArgs",
          type: "number"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        },
        {
          tfName: "use_cudnn_on_gpu",
          name: "useCudnnOnGpu",
          type: "bool",
          defaultValue: true
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]",
          defaultValue: [
            1,
            1,
            1,
            1
          ]
        },
        {
          tfName: "fused_ops",
          name: "fusedOps",
          type: "string[]",
          defaultValue: []
        },
        {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 0.0001
        },
        {
          tfName: "leakyrelu_alpha",
          name: "leakyreluAlpha",
          type: "number",
          defaultValue: 0.2
        }
      ]
    },
    {
      tfOpName: "Conv2DBackpropInput",
      category: "convolution",
      inputs: [
        {
          start: 2,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        },
        {
          start: 0,
          name: "outputShape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "DepthwiseConv2d",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "input",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "DepthwiseConv2dNative",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "input",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "FusedDepthwiseConv2dNative",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        },
        {
          start: 2,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "num_args",
          name: "numArgs",
          type: "number"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]",
          defaultValue: [
            1,
            1,
            1,
            1
          ]
        },
        {
          tfName: "fused_ops",
          name: "fusedOps",
          type: "string[]",
          defaultValue: []
        },
        {
          tfName: "explicit_paddings",
          name: "explicitPaddings",
          type: "number[]",
          defaultValue: []
        }
      ]
    },
    {
      tfOpName: "Conv3D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          defaultValue: "NHWC"
        },
        {
          tfName: "dilations",
          name: "dilations",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "Dilation2D",
      category: "convolution",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "filter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "strides",
          name: "strides",
          type: "number[]"
        },
        {
          tfName: "rates",
          name: "dilations",
          type: "number[]"
        },
        {
          tfName: "padding",
          name: "pad",
          type: "string"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/creation.js
var exports_creation = {};
__export(exports_creation, {
  json: () => json5
});
var json5;
var init_creation = __esm(() => {
  json5 = [
    {
      tfOpName: "Fill",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        },
        {
          start: 1,
          name: "value",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "LinSpace",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "start",
          type: "number"
        },
        {
          start: 1,
          name: "stop",
          type: "number"
        },
        {
          start: 2,
          name: "num",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "OneHot",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "indices",
          type: "tensor"
        },
        {
          start: 1,
          name: "depth",
          type: "number"
        },
        {
          start: 2,
          name: "onValue",
          type: "number",
          defaultValue: 1
        },
        {
          start: 3,
          name: "offValue",
          type: "number",
          defaultValue: 0
        }
      ],
      attrs: [
        {
          tfName: "axis",
          name: "axis",
          type: "number",
          notSupported: true
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "Ones",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "OnesLike",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "RandomStandardNormal",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "seed",
          name: "seed",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "seed2",
          name: "seed2",
          type: "number",
          defaultValue: 0,
          notSupported: true
        },
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "T",
          name: "T",
          type: "number",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "RandomUniform",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "minval",
          name: "minval",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "maxval",
          name: "maxval",
          type: "number",
          defaultValue: 1
        },
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "seed",
          name: "seed",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "seed2",
          name: "seed2",
          type: "number",
          defaultValue: 0,
          notSupported: true
        },
        {
          tfName: "T",
          name: "T",
          type: "number",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "RandomUniformInt",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "minval",
          name: "minval",
          type: "number"
        },
        {
          tfName: "maxval",
          name: "maxval",
          type: "number"
        },
        {
          tfName: "seed",
          name: "seed",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "seed2",
          name: "seed2",
          type: "number",
          defaultValue: 0,
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Range",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "start",
          type: "number"
        },
        {
          start: 1,
          name: "stop",
          type: "number"
        },
        {
          start: 2,
          name: "step",
          type: "number",
          defaultValue: 0
        }
      ],
      attrs: [
        {
          tfName: "Tidx",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "TruncatedNormal",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "means",
          name: "mean",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "stddev",
          name: "stdDev",
          type: "number",
          defaultValue: 1
        },
        {
          tfName: "seed",
          name: "seed",
          type: "number"
        },
        {
          tfName: "seed2",
          name: "seed2",
          type: "number",
          defaultValue: 0,
          notSupported: true
        },
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "T",
          name: "T",
          type: "number",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Zeros",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "ZerosLike",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "Multinomial",
      category: "creation",
      inputs: [
        {
          start: 0,
          name: "logits",
          type: "tensor"
        },
        {
          start: 1,
          name: "numSamples",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "seed",
          name: "seed",
          type: "number"
        },
        {
          tfName: "seed2",
          name: "seed2",
          type: "number"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        },
        {
          tfName: "output_dtype",
          name: "output_dtype",
          type: "dtype"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/dynamic.js
var exports_dynamic = {};
__export(exports_dynamic, {
  json: () => json6
});
var json6;
var init_dynamic = __esm(() => {
  json6 = [
    {
      tfOpName: "NonMaxSuppressionV2",
      category: "dynamic",
      inputs: [
        {
          start: 0,
          name: "boxes",
          type: "tensor"
        },
        {
          start: 1,
          name: "scores",
          type: "tensor"
        },
        {
          start: 2,
          name: "maxOutputSize",
          type: "number"
        },
        {
          start: 3,
          name: "iouThreshold",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "NonMaxSuppressionV3",
      category: "dynamic",
      inputs: [
        {
          start: 0,
          name: "boxes",
          type: "tensor"
        },
        {
          start: 1,
          name: "scores",
          type: "tensor"
        },
        {
          start: 2,
          name: "maxOutputSize",
          type: "number"
        },
        {
          start: 3,
          name: "iouThreshold",
          type: "number"
        },
        {
          start: 4,
          name: "scoreThreshold",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "NonMaxSuppressionV4",
      category: "dynamic",
      inputs: [
        {
          start: 0,
          name: "boxes",
          type: "tensor"
        },
        {
          start: 1,
          name: "scores",
          type: "tensor"
        },
        {
          start: 2,
          name: "maxOutputSize",
          type: "number"
        },
        {
          start: 3,
          name: "iouThreshold",
          type: "number"
        },
        {
          start: 4,
          name: "scoreThreshold",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "T_threshold",
          name: "threshold",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "pad_to_max_output_size",
          name: "padToMaxOutputSize",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "NonMaxSuppressionV5",
      category: "dynamic",
      inputs: [
        {
          start: 0,
          name: "boxes",
          type: "tensor"
        },
        {
          start: 1,
          name: "scores",
          type: "tensor"
        },
        {
          start: 2,
          name: "maxOutputSize",
          type: "number"
        },
        {
          start: 3,
          name: "iouThreshold",
          type: "number"
        },
        {
          start: 4,
          name: "scoreThreshold",
          type: "number"
        },
        {
          start: 5,
          name: "softNmsSigma",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "Where",
      category: "dynamic",
      inputs: [
        {
          start: 0,
          name: "condition",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "ListDiff",
      category: "dynamic",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "y",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/evaluation.js
var exports_evaluation = {};
__export(exports_evaluation, {
  json: () => json7
});
var json7;
var init_evaluation = __esm(() => {
  json7 = [
    {
      tfOpName: "LowerBound",
      category: "evaluation",
      inputs: [
        {
          start: 0,
          name: "sortedSequence",
          type: "tensor"
        },
        {
          start: 1,
          name: "values",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "TopKV2",
      category: "evaluation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "k",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "sorted",
          name: "sorted",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "UpperBound",
      category: "evaluation",
      inputs: [
        {
          start: 0,
          name: "sortedSequence",
          type: "tensor"
        },
        {
          start: 1,
          name: "values",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "Unique",
      category: "evaluation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "UniqueV2",
      category: "evaluation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/graph.js
var exports_graph = {};
__export(exports_graph, {
  json: () => json8
});
var json8;
var init_graph = __esm(() => {
  json8 = [
    {
      tfOpName: "PlaceholderWithDefault",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "default",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "shape",
          name: "shape",
          type: "shape"
        },
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "Placeholder",
      category: "graph",
      attrs: [
        {
          tfName: "shape",
          name: "shape",
          type: "shape"
        },
        {
          tfName: "dtype",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "Const",
      category: "graph"
    },
    {
      tfOpName: "Identity",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "IdentityN",
      category: "graph",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "x",
          type: "tensors"
        }
      ]
    },
    {
      tfOpName: "Snapshot",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "Rank",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "Size",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "Shape",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "ShapeN",
      category: "graph",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "x",
          type: "tensors"
        }
      ]
    },
    {
      tfOpName: "Print",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "data",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "message",
          name: "message",
          type: "string"
        },
        {
          tfName: "first_n",
          name: "firstN",
          type: "number",
          notSupported: true
        },
        {
          tfName: "summarize",
          name: "summarize",
          type: "number",
          defaultValue: 3
        }
      ]
    },
    {
      tfOpName: "NoOp",
      category: "graph",
      inputs: []
    },
    {
      tfOpName: "StopGradient",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "FakeQuantWithMinMaxVars",
      category: "graph",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "min",
          name: "min",
          type: "number"
        },
        {
          tfName: "max",
          name: "max",
          type: "number"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/hash_table.js
var exports_hash_table = {};
__export(exports_hash_table, {
  json: () => json9
});
var json9;
var init_hash_table = __esm(() => {
  json9 = [
    {
      tfOpName: "HashTable",
      category: "hash_table",
      inputs: [],
      attrs: [
        {
          tfName: "shared_name",
          name: "sharedName",
          type: "string"
        },
        {
          tfName: "use_node_name_sharing",
          name: "useNodeNameSharing",
          type: "bool"
        },
        {
          tfName: "key_dtype",
          name: "keyDType",
          type: "dtype"
        },
        {
          tfName: "value_dtype",
          name: "valueDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "HashTableV2",
      category: "hash_table",
      inputs: [],
      attrs: [
        {
          tfName: "shared_name",
          name: "sharedName",
          type: "string"
        },
        {
          tfName: "use_node_name_sharing",
          name: "useNodeNameSharing",
          type: "bool"
        },
        {
          tfName: "key_dtype",
          name: "keyDType",
          type: "dtype"
        },
        {
          tfName: "value_dtype",
          name: "valueDType",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "LookupTableImport",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        },
        {
          start: 1,
          name: "keys",
          type: "tensor"
        },
        {
          start: 2,
          name: "values",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "Tin",
          name: "tIn",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "Tout",
          name: "tOut",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LookupTableImportV2",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        },
        {
          start: 1,
          name: "keys",
          type: "tensor"
        },
        {
          start: 2,
          name: "values",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "Tin",
          name: "tIn",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "Tout",
          name: "tOut",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LookupTableFind",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        },
        {
          start: 1,
          name: "keys",
          type: "tensor"
        },
        {
          start: 2,
          name: "defaultValue",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "Tin",
          name: "tIn",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "Tout",
          name: "tOut",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LookupTableFindV2",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        },
        {
          start: 1,
          name: "keys",
          type: "tensor"
        },
        {
          start: 2,
          name: "defaultValue",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "Tin",
          name: "tIn",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "Tout",
          name: "tOut",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LookupTableSize",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "LookupTableSizeV2",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "InitializeTable",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        },
        {
          start: 1,
          name: "keys",
          type: "tensor"
        },
        {
          start: 2,
          name: "values",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "InitializeTableV2",
      category: "hash_table",
      inputs: [
        {
          start: 0,
          name: "tableHandle",
          type: "tensor"
        },
        {
          start: 1,
          name: "keys",
          type: "tensor"
        },
        {
          start: 2,
          name: "values",
          type: "tensor"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/image.js
var exports_image = {};
__export(exports_image, {
  json: () => json10
});
var json10;
var init_image = __esm(() => {
  json10 = [
    {
      tfOpName: "ResizeBilinear",
      category: "image",
      inputs: [
        {
          start: 0,
          name: "images",
          type: "tensor"
        },
        {
          start: 1,
          name: "size",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "align_corners",
          name: "alignCorners",
          type: "bool"
        },
        {
          tfName: "half_pixel_centers",
          name: "halfPixelCenters",
          type: "bool"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "ResizeNearestNeighbor",
      category: "image",
      inputs: [
        {
          start: 0,
          name: "images",
          type: "tensor"
        },
        {
          start: 1,
          name: "size",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "align_corners",
          name: "alignCorners",
          type: "bool"
        },
        {
          tfName: "half_pixel_centers",
          name: "halfPixelCenters",
          type: "bool"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "CropAndResize",
      category: "image",
      inputs: [
        {
          start: 0,
          name: "image",
          type: "tensor"
        },
        {
          start: 1,
          name: "boxes",
          type: "tensor"
        },
        {
          start: 2,
          name: "boxInd",
          type: "tensor"
        },
        {
          start: 3,
          name: "cropSize",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "method",
          name: "method",
          type: "string"
        },
        {
          tfName: "extrapolation_value",
          name: "extrapolationValue",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "ImageProjectiveTransformV3",
      category: "image",
      inputs: [
        {
          start: 0,
          name: "images",
          type: "tensor"
        },
        {
          start: 1,
          name: "transforms",
          type: "tensor"
        },
        {
          start: 2,
          name: "outputShape",
          type: "number[]"
        },
        {
          start: 3,
          name: "fillValue",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "interpolation",
          name: "interpolation",
          type: "string"
        },
        {
          tfName: "fill_mode",
          name: "fillMode",
          type: "string"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/logical.js
var exports_logical = {};
__export(exports_logical, {
  json: () => json11
});
var json11;
var init_logical = __esm(() => {
  json11 = [
    {
      tfOpName: "Equal",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "NotEqual",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Greater",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "GreaterEqual",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Less",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LessEqual",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LogicalAnd",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LogicalNot",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LogicalOr",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Select",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "condition",
          type: "tensor"
        },
        {
          start: 1,
          name: "a",
          type: "tensor"
        },
        {
          start: 2,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "SelectV2",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "condition",
          type: "tensor"
        },
        {
          start: 1,
          name: "a",
          type: "tensor"
        },
        {
          start: 2,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "BitwiseAnd",
      category: "logical",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "y",
          type: "tensor"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/matrices.js
var exports_matrices = {};
__export(exports_matrices, {
  json: () => json12
});
var json12;
var init_matrices = __esm(() => {
  json12 = [
    {
      tfOpName: "_FusedMatMul",
      category: "matrices",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        },
        {
          start: 2,
          end: 0,
          name: "args",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "num_args",
          name: "numArgs",
          type: "number"
        },
        {
          tfName: "fused_ops",
          name: "fusedOps",
          type: "string[]",
          defaultValue: []
        },
        {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 0.0001
        },
        {
          tfName: "transpose_a",
          name: "transposeA",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "transpose_b",
          name: "transposeB",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "leakyrelu_alpha",
          name: "leakyreluAlpha",
          type: "number",
          defaultValue: 0.2
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "MatMul",
      category: "matrices",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "transpose_a",
          name: "transposeA",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "transpose_b",
          name: "transposeB",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "BatchMatMul",
      category: "matrices",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "adj_x",
          name: "transposeA",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "adj_y",
          name: "transposeB",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "BatchMatMulV2",
      category: "matrices",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "b",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "adj_x",
          name: "transposeA",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "adj_y",
          name: "transposeB",
          type: "bool",
          defaultValue: false
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Transpose",
      category: "matrices",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "perm",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Einsum",
      category: "matrices",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "equation",
          name: "equation",
          type: "string"
        },
        {
          tfName: "N",
          name: "n",
          type: "number",
          defaultValue: 2
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "MatrixBandPart",
      category: "matrices",
      inputs: [
        {
          start: 0,
          name: "a",
          type: "tensor"
        },
        {
          start: 1,
          name: "numLower",
          type: "tensor"
        },
        {
          start: 1,
          name: "numUpper",
          type: "tensor"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/normalization.js
var exports_normalization = {};
__export(exports_normalization, {
  json: () => json13
});
var json13;
var init_normalization2 = __esm(() => {
  json13 = [
    {
      tfOpName: "EuclideanNorm",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool",
          defaultValue: false
        }
      ]
    },
    {
      tfOpName: "FusedBatchNorm",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "scale",
          type: "tensor"
        },
        {
          start: 2,
          name: "offset",
          type: "tensor"
        },
        {
          start: 3,
          name: "mean",
          type: "tensor"
        },
        {
          start: 4,
          name: "variance",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 0.001
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "FusedBatchNormV2",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "scale",
          type: "tensor"
        },
        {
          start: 2,
          name: "offset",
          type: "tensor"
        },
        {
          start: 3,
          name: "mean",
          type: "tensor"
        },
        {
          start: 4,
          name: "variance",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 0.001
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "FusedBatchNormV3",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "scale",
          type: "tensor"
        },
        {
          start: 2,
          name: "offset",
          type: "tensor"
        },
        {
          start: 3,
          name: "mean",
          type: "tensor"
        },
        {
          start: 4,
          name: "variance",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "epsilon",
          name: "epsilon",
          type: "number",
          defaultValue: 0.001
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "LRN",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "depth_radius",
          name: "radius",
          type: "number",
          defaultValue: 5
        },
        {
          tfName: "bias",
          name: "bias",
          type: "number",
          defaultValue: 1
        },
        {
          tfName: "alpha",
          name: "alpha",
          type: "number",
          defaultValue: 1
        },
        {
          tfName: "beta",
          name: "beta",
          type: "number",
          defaultValue: 0.5
        }
      ]
    },
    {
      tfOpName: "Softmax",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "LogSoftmax",
      category: "normalization",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/reduction.js
var exports_reduction = {};
__export(exports_reduction, {
  json: () => json14
});
var json14;
var init_reduction = __esm(() => {
  json14 = [
    {
      tfOpName: "Bincount",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "size",
          type: "number"
        },
        {
          start: 2,
          name: "weights",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "DenseBincount",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "size",
          type: "number"
        },
        {
          start: 2,
          name: "weights",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "binary_output",
          name: "binaryOutput",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Max",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Mean",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Min",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Sum",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "All",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Any",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "ArgMax",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "ArgMin",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "Prod",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "keep_dims",
          name: "keepDims",
          type: "bool"
        },
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Cumprod",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "exclusive",
          name: "exclusive",
          type: "bool"
        },
        {
          tfName: "reverse",
          name: "reverse",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "Cumsum",
      category: "reduction",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "exclusive",
          name: "exclusive",
          type: "bool"
        },
        {
          tfName: "reverse",
          name: "reverse",
          type: "bool"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/slice_join.js
var exports_slice_join = {};
__export(exports_slice_join, {
  json: () => json15
});
var json15;
var init_slice_join = __esm(() => {
  json15 = [
    {
      tfOpName: "ConcatV2",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          end: -1,
          name: "tensors",
          type: "tensors"
        },
        {
          start: -1,
          name: "axis",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "N",
          name: "n",
          type: "number",
          defaultValue: 2
        }
      ]
    },
    {
      tfOpName: "Concat",
      category: "slice_join",
      inputs: [
        {
          start: 1,
          end: 0,
          name: "tensors",
          type: "tensors"
        },
        {
          start: 0,
          name: "axis",
          type: "number"
        }
      ],
      attrs: [
        {
          tfName: "N",
          name: "n",
          type: "number",
          defaultValue: 2
        }
      ]
    },
    {
      tfOpName: "GatherV2",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "tensor"
        },
        {
          start: 2,
          name: "axis",
          type: "number",
          defaultValue: 0
        }
      ],
      attrs: [
        {
          tfName: "batch_dims",
          name: "batchDims",
          type: "number",
          defaultValue: 0
        }
      ]
    },
    {
      tfOpName: "Gather",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Reverse",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "dims",
          type: "bool[]"
        }
      ]
    },
    {
      tfOpName: "ReverseV2",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "Slice",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "begin",
          type: "number[]"
        },
        {
          start: 2,
          name: "size",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "StridedSlice",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "begin",
          type: "number[]"
        },
        {
          start: 2,
          name: "end",
          type: "number[]"
        },
        {
          start: 3,
          name: "strides",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "begin_mask",
          name: "beginMask",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "end_mask",
          name: "endMask",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "new_axis_mask",
          name: "newAxisMask",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "ellipsis_mask",
          name: "ellipsisMask",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "shrink_axis_mask",
          name: "shrinkAxisMask",
          type: "number",
          defaultValue: 0
        }
      ]
    },
    {
      tfOpName: "Pack",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          end: 0,
          name: "tensors",
          type: "tensors"
        }
      ],
      attrs: [
        {
          tfName: "axis",
          name: "axis",
          type: "number",
          defaultValue: 0
        }
      ]
    },
    {
      tfOpName: "Unpack",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "axis",
          name: "axis",
          type: "number",
          defaultValue: 0
        },
        {
          tfName: "num",
          name: "num",
          type: "number",
          defaultValue: 0,
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "Tile",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "reps",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "Split",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "axis",
          type: "number",
          defaultValue: 0
        },
        {
          start: 1,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "num_split",
          name: "numOrSizeSplits",
          type: "number",
          defaultValue: 1
        }
      ]
    },
    {
      tfOpName: "SplitV",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "numOrSizeSplits",
          type: "number[]"
        },
        {
          start: 2,
          name: "axis",
          type: "number",
          defaultValue: 0
        }
      ]
    },
    {
      tfOpName: "ScatterNd",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "indices",
          type: "tensor"
        },
        {
          start: 1,
          name: "values",
          type: "tensor"
        },
        {
          start: 2,
          name: "shape",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "GatherNd",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "SparseToDense",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "sparseIndices",
          type: "tensor"
        },
        {
          start: 1,
          name: "outputShape",
          type: "number[]"
        },
        {
          start: 2,
          name: "sparseValues",
          type: "tensor"
        },
        {
          start: 3,
          name: "defaultValue",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "validate_indices",
          name: "validateIndices",
          type: "bool",
          defaultValue: false,
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "TensorScatterUpdate",
      category: "slice_join",
      inputs: [
        {
          start: 0,
          name: "tensor",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "tensor"
        },
        {
          start: 2,
          name: "values",
          type: "tensor"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/sparse.js
var exports_sparse = {};
__export(exports_sparse, {
  json: () => json16
});
var json16;
var init_sparse = __esm(() => {
  json16 = [
    {
      tfOpName: "SparseFillEmptyRows",
      category: "sparse",
      inputs: [
        {
          start: 0,
          name: "indices",
          type: "tensor"
        },
        {
          start: 1,
          name: "values",
          type: "tensor"
        },
        {
          start: 2,
          name: "denseShape",
          type: "tensor"
        },
        {
          start: 3,
          name: "defaultValue",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "SparseReshape",
      category: "sparse",
      inputs: [
        {
          start: 0,
          name: "inputIndices",
          type: "tensor"
        },
        {
          start: 1,
          name: "inputShape",
          type: "tensor"
        },
        {
          start: 2,
          name: "newShape",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "T",
          name: "dtype",
          type: "dtype",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "SparseSegmentMean",
      category: "sparse",
      inputs: [
        {
          start: 0,
          name: "data",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "tensor"
        },
        {
          start: 2,
          name: "segmentIds",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "SparseSegmentSum",
      category: "sparse",
      inputs: [
        {
          start: 0,
          name: "data",
          type: "tensor"
        },
        {
          start: 1,
          name: "indices",
          type: "tensor"
        },
        {
          start: 2,
          name: "segmentIds",
          type: "tensor"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/spectral.js
var exports_spectral = {};
__export(exports_spectral, {
  json: () => json17
});
var json17;
var init_spectral = __esm(() => {
  json17 = [
    {
      tfOpName: "FFT",
      category: "spectral",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "IFFT",
      category: "spectral",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ]
    },
    {
      tfOpName: "RFFT",
      category: "spectral",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "fft_length",
          type: "number",
          notSupported: true
        }
      ]
    },
    {
      tfOpName: "IRFFT",
      category: "spectral",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "fft_length",
          type: "number",
          notSupported: true
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/string.js
var exports_string = {};
__export(exports_string, {
  json: () => json18
});
var json18;
var init_string = __esm(() => {
  json18 = [
    {
      tfOpName: "StaticRegexReplace",
      category: "string",
      inputs: [
        {
          start: 0,
          name: "input",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "pattern",
          name: "pattern",
          type: "string"
        },
        {
          tfName: "rewrite",
          name: "rewrite",
          type: "string"
        },
        {
          tfName: "replace_global",
          name: "replaceGlobal",
          type: "bool"
        }
      ]
    },
    {
      tfOpName: "StringNGrams",
      category: "string",
      inputs: [
        {
          start: 0,
          name: "data",
          type: "tensor"
        },
        {
          start: 1,
          name: "dataSplits",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "separator",
          name: "separator",
          type: "string"
        },
        {
          tfName: "ngram_widths",
          name: "nGramWidths",
          type: "number[]"
        },
        {
          tfName: "left_pad",
          name: "leftPad",
          type: "string"
        },
        {
          tfName: "right_pad",
          name: "rightPad",
          type: "string"
        },
        {
          tfName: "pad_width",
          name: "padWidth",
          type: "number"
        },
        {
          tfName: "preserve_short_sequences",
          name: "preserveShortSequences",
          type: "bool"
        }
      ],
      outputs: [
        "ngrams",
        "ngrams_splits"
      ]
    },
    {
      tfOpName: "StringSplit",
      category: "string",
      inputs: [
        {
          start: 0,
          name: "input",
          type: "tensor"
        },
        {
          start: 1,
          name: "delimiter",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "skip_empty",
          name: "skipEmpty",
          type: "bool"
        }
      ],
      outputs: [
        "indices",
        "values",
        "shape"
      ]
    },
    {
      tfOpName: "StringToHashBucketFast",
      category: "string",
      inputs: [
        {
          start: 0,
          name: "input",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "num_buckets",
          name: "numBuckets",
          type: "number"
        }
      ]
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/op_list/transformation.js
var exports_transformation = {};
__export(exports_transformation, {
  json: () => json19
});
var json19;
var init_transformation = __esm(() => {
  json19 = [
    {
      tfOpName: "Cast",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "SrcT",
          name: "sdtype",
          type: "dtype",
          notSupported: true
        },
        {
          tfName: "DstT",
          name: "dtype",
          type: "dtype"
        }
      ]
    },
    {
      tfOpName: "ExpandDims",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "axis",
          type: "number"
        }
      ]
    },
    {
      tfOpName: "MirrorPad",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "padding",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "mode",
          name: "mode",
          type: "string"
        }
      ]
    },
    {
      tfOpName: "Pad",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "padding",
          type: "number[]"
        }
      ],
      attrs: [
        {
          tfName: "constant_value",
          name: "constantValue",
          type: "number",
          defaultValue: 0
        }
      ]
    },
    {
      tfOpName: "PadV2",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "padding",
          type: "number[]"
        },
        {
          start: 2,
          name: "constantValue",
          type: "number",
          defaultValue: 0
        }
      ]
    },
    {
      tfOpName: "Reshape",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "shape",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "EnsureShape",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "shape",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "Squeeze",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "axis",
          tfDeprecatedName: "squeeze_dims",
          name: "axis",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "SpaceToBatchND",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "blockShape",
          type: "number[]"
        },
        {
          start: 2,
          name: "paddings",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "BatchToSpaceND",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "blockShape",
          type: "number[]"
        },
        {
          start: 2,
          name: "crops",
          type: "number[]"
        }
      ]
    },
    {
      tfOpName: "DepthToSpace",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        }
      ],
      attrs: [
        {
          tfName: "block_size",
          name: "blockSize",
          type: "number"
        },
        {
          tfName: "data_format",
          name: "dataFormat",
          type: "string"
        }
      ]
    },
    {
      tfOpName: "BroadcastTo",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "x",
          type: "tensor"
        },
        {
          start: 1,
          name: "shape",
          type: "number[]"
        }
      ],
      attrs: []
    },
    {
      tfOpName: "BroadcastArgs",
      category: "transformation",
      inputs: [
        {
          start: 0,
          name: "s0",
          type: "tensor"
        },
        {
          start: 1,
          name: "s1",
          type: "tensor"
        }
      ],
      attrs: []
    }
  ];
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/operation_mapper.js
function decodeBase64(text) {
  const global2 = env().global;
  if (typeof global2.atob !== "undefined") {
    return global2.atob(text);
  } else if (typeof Buffer !== "undefined") {
    return new Buffer(text, "base64").toString();
  } else {
    throw new Error("Unable to decode base64 in this environment. " + "Missing built-in atob() or Buffer()");
  }
}
function parseStringParam(s, keepCase) {
  const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);
  return keepCase ? value : value.toLowerCase();
}
function getStringParam(attrs, name, def, keepCase = false) {
  const param = attrs[name];
  if (param != null) {
    return parseStringParam(param.s, keepCase);
  }
  return def;
}
function getBoolParam(attrs, name, def) {
  const param = attrs[name];
  return param ? param.b : def;
}
function getNumberParam(attrs, name, def) {
  const param = attrs[name] || {};
  const value = param["i"] != null ? param["i"] : param["f"] != null ? param["f"] : def;
  return typeof value === "number" ? value : parseInt(value, 10);
}
function parseDtypeParam(value) {
  if (typeof value === "string") {
    value = DataType[value];
  }
  switch (value) {
    case DataType.DT_FLOAT:
    case DataType.DT_HALF:
      return "float32";
    case DataType.DT_INT32:
    case DataType.DT_INT64:
    case DataType.DT_INT8:
    case DataType.DT_UINT8:
      return "int32";
    case DataType.DT_BOOL:
      return "bool";
    case DataType.DT_DOUBLE:
      return "float32";
    case DataType.DT_STRING:
      return "string";
    case DataType.DT_COMPLEX64:
    case DataType.DT_COMPLEX128:
      return "complex64";
    default:
      return null;
  }
}
function getFuncParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.func) {
    return param.func.name;
  }
  return def;
}
function getDtypeParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.type) {
    return parseDtypeParam(param.type);
  }
  return def;
}
function getDtypeArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.type) {
    return param.list.type.map((v) => parseDtypeParam(v));
  }
  return def;
}
function parseTensorShapeParam(shape) {
  if (shape.unknownRank) {
    return;
  }
  if (shape.dim != null) {
    return shape.dim.map((dim) => typeof dim.size === "number" ? dim.size : parseInt(dim.size, 10));
  }
  return [];
}
function getTensorShapeParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.shape) {
    return parseTensorShapeParam(param.shape);
  }
  return def;
}
function getNumericArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param) {
    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map((v) => typeof v === "number" ? v : parseInt(v, 10));
  }
  return def;
}
function getStringArrayParam(attrs, name, def, keepCase = false) {
  const param = attrs[name];
  if (param && param.list && param.list.s) {
    return param.list.s.map((v) => {
      return parseStringParam(v, keepCase);
    });
  }
  return def;
}
function getTensorShapeArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.shape) {
    return param.list.shape.map((v) => {
      return parseTensorShapeParam(v);
    });
  }
  return def;
}
function getBoolArrayParam(attrs, name, def) {
  const param = attrs[name];
  if (param && param.list && param.list.b) {
    return param.list.b;
  }
  return def;
}

class OperationMapper {
  static get Instance() {
    return this._instance || (this._instance = new this);
  }
  constructor() {
    const ops55 = [
      exports_arithmetic,
      exports_basic_math,
      exports_control,
      exports_convolution,
      exports_creation,
      exports_dynamic,
      exports_evaluation,
      exports_graph,
      exports_hash_table,
      exports_image,
      exports_logical,
      exports_matrices,
      exports_normalization,
      exports_reduction,
      exports_slice_join,
      exports_sparse,
      exports_spectral,
      exports_string,
      exports_transformation
    ];
    const mappersJson = [].concat(...ops55.map((op2) => op2.json));
    this.opMappers = mappersJson.reduce((map, mapper) => {
      map[mapper.tfOpName] = mapper;
      return map;
    }, {});
  }
  transformGraph(graph, signature = {}) {
    const tfNodes = graph.node;
    const placeholders = [];
    const weights = [];
    const initNodes = [];
    const nodes = tfNodes.reduce((map, node) => {
      map[node.name] = this.mapNode(node);
      if (node.op.startsWith("Placeholder")) {
        placeholders.push(map[node.name]);
      } else if (node.op === "Const") {
        weights.push(map[node.name]);
      } else if (node.input == null || node.input.length === 0) {
        initNodes.push(map[node.name]);
      }
      return map;
    }, {});
    let inputs = [];
    const outputs = [];
    let inputNodeNameToKey = {};
    let outputNodeNameToKey = {};
    if (signature != null) {
      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);
      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);
    }
    const allNodes = Object.keys(nodes);
    allNodes.forEach((key) => {
      const node = nodes[key];
      node.inputNames.forEach((name, index) => {
        const [nodeName, , outputName] = getNodeNameAndIndex(name);
        const inputNode = nodes[nodeName];
        if (inputNode.outputs != null) {
          const outputIndex = inputNode.outputs.indexOf(outputName);
          if (outputIndex !== -1) {
            const inputName = `${nodeName}:${outputIndex}`;
            node.inputNames[index] = inputName;
          }
        }
        node.inputs.push(inputNode);
        inputNode.children.push(node);
      });
    });
    if (Object.keys(outputNodeNameToKey).length === 0) {
      allNodes.forEach((key) => {
        const node = nodes[key];
        if (node.children.length === 0) {
          outputs.push(node);
        }
      });
    } else {
      Object.keys(outputNodeNameToKey).forEach((name) => {
        const [nodeName] = getNodeNameAndIndex(name);
        const node = nodes[nodeName];
        if (node != null) {
          node.signatureKey = outputNodeNameToKey[name];
          outputs.push(node);
        }
      });
    }
    if (Object.keys(inputNodeNameToKey).length > 0) {
      Object.keys(inputNodeNameToKey).forEach((name) => {
        const [nodeName] = getNodeNameAndIndex(name);
        const node = nodes[nodeName];
        if (node) {
          node.signatureKey = inputNodeNameToKey[name];
          inputs.push(node);
        }
      });
    } else {
      inputs = placeholders;
    }
    let functions = {};
    if (graph.library != null && graph.library.function != null) {
      functions = graph.library.function.reduce((functions2, func) => {
        functions2[func.signature.name] = this.mapFunction(func);
        return functions2;
      }, {});
    }
    const result = { nodes, inputs, outputs, weights, placeholders, signature, functions };
    if (initNodes.length > 0) {
      result.initNodes = initNodes;
    }
    return result;
  }
  mapSignatureEntries(entries) {
    return Object.keys(entries || {}).reduce((prev, curr) => {
      prev[entries[curr].name] = curr;
      return prev;
    }, {});
  }
  mapNode(node) {
    const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};
    if (node.attr == null) {
      node.attr = {};
    }
    const newNode = {
      name: node.name,
      op: node.op,
      category: mapper.category,
      inputNames: (node.input || []).map((input2) => input2.startsWith("^") ? input2.slice(1) : input2),
      inputs: [],
      children: [],
      inputParams: {},
      attrParams: {},
      rawAttrs: node.attr,
      outputs: mapper.outputs
    };
    if (mapper.inputs != null) {
      newNode.inputParams = mapper.inputs.reduce((map, param) => {
        map[param.name] = {
          type: param.type,
          inputIndexStart: param.start,
          inputIndexEnd: param.end
        };
        return map;
      }, {});
    }
    if (mapper.attrs != null) {
      newNode.attrParams = mapper.attrs.reduce((map, param) => {
        const type = param.type;
        let value = undefined;
        switch (param.type) {
          case "string":
            value = getStringParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "string[]":
            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "number":
            value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "number[]":
            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "bool":
            value = getBoolParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "bool[]":
            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "shape":
            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "shape[]":
            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "dtype":
            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "dtype[]":
            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "func":
            value = getFuncParam(node.attr, param.tfName, param.defaultValue);
            if (value === undefined && !!param.tfDeprecatedName) {
              value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);
            }
            break;
          case "tensor":
          case "tensors":
            break;
          default:
            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);
        }
        map[param.name] = { value, type };
        return map;
      }, {});
    }
    return newNode;
  }
  mapFunction(functionDef) {
    const tfNodes = functionDef.nodeDef;
    const placeholders = [];
    const weights = [];
    let nodes = {};
    if (tfNodes != null) {
      nodes = tfNodes.reduce((map, node) => {
        map[node.name] = this.mapNode(node);
        if (node.op === "Const") {
          weights.push(map[node.name]);
        }
        return map;
      }, {});
    }
    const inputs = [];
    const outputs = [];
    functionDef.signature.inputArg.forEach((arg) => {
      const [nodeName] = getNodeNameAndIndex(arg.name);
      const node = {
        name: nodeName,
        op: "Placeholder",
        inputs: [],
        inputNames: [],
        category: "graph",
        inputParams: {},
        attrParams: { dtype: { value: parseDtypeParam(arg.type), type: "dtype" } },
        children: []
      };
      node.signatureKey = arg.name;
      inputs.push(node);
      nodes[nodeName] = node;
    });
    const allNodes = Object.keys(nodes);
    allNodes.forEach((key) => {
      const node = nodes[key];
      node.inputNames.forEach((name, index) => {
        const [nodeName, , outputName] = getNodeNameAndIndex(name);
        const inputNode = nodes[nodeName];
        if (inputNode.outputs != null) {
          const outputIndex = inputNode.outputs.indexOf(outputName);
          if (outputIndex !== -1) {
            const inputName = `${nodeName}:${outputIndex}`;
            node.inputNames[index] = inputName;
          }
        }
        node.inputs.push(inputNode);
        inputNode.children.push(node);
      });
    });
    const returnNodeMap = functionDef.ret;
    functionDef.signature.outputArg.forEach((output) => {
      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);
      const node = nodes[nodeName];
      if (node != null) {
        node.defaultOutput = index;
        outputs.push(node);
      }
    });
    const signature = this.mapArgsToSignature(functionDef);
    return { nodes, inputs, outputs, weights, placeholders, signature };
  }
  mapArgsToSignature(functionDef) {
    return {
      methodName: functionDef.signature.name,
      inputs: functionDef.signature.inputArg.reduce((map, arg) => {
        map[arg.name] = this.mapArgToTensorInfo(arg);
        return map;
      }, {}),
      outputs: functionDef.signature.outputArg.reduce((map, arg) => {
        map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);
        return map;
      }, {})
    };
  }
  mapArgToTensorInfo(arg, nameMap2) {
    let name = arg.name;
    if (nameMap2 != null) {
      name = nameMap2[name];
    }
    return { name, dtype: arg.type };
  }
}
var init_operation_mapper = __esm(() => {
  init_dist();
  init_compiled_api();
  init_register();
  init_utils();
  init_arithmetic();
  init_basic_math();
  init_control();
  init_convolution();
  init_creation();
  init_dynamic();
  init_evaluation();
  init_graph();
  init_hash_table();
  init_image();
  init_logical();
  init_matrices();
  init_normalization2();
  init_reduction();
  init_slice_join();
  init_sparse();
  init_spectral();
  init_string();
  init_transformation();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/custom_op/node_value_impl.js
class NodeValueImpl {
  constructor(node, tensorMap, context) {
    this.node = node;
    this.tensorMap = tensorMap;
    this.context = context;
    this.inputs = [];
    this.attrs = {};
    this.inputs = node.inputNames.map((name) => this.getInput(name));
    if (node.rawAttrs != null) {
      this.attrs = Object.keys(node.rawAttrs).reduce((attrs, key) => {
        attrs[key] = this.getAttr(key);
        return attrs;
      }, {});
    }
  }
  getInput(name) {
    return getTensor(name, this.tensorMap, this.context);
  }
  getAttr(name, defaultValue) {
    const value = this.node.rawAttrs[name];
    if (value.tensor != null) {
      return getTensor(name, this.tensorMap, this.context);
    }
    if (value.i != null || value.f != null) {
      return getNumberParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.s != null) {
      return getStringParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.b != null) {
      return getBoolParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.shape != null) {
      return getTensorShapeParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.type != null) {
      return getDtypeParam(this.node.rawAttrs, name, defaultValue);
    }
    if (value.list != null) {
      if (value.list.i != null || value.list.f != null) {
        return getNumericArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.s != null) {
        return getStringArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.shape != null) {
        return getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.b != null) {
        return getBoolArrayParam(this.node.rawAttrs, name, defaultValue);
      }
      if (value.list.type != null) {
        return getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);
      }
    }
    return defaultValue;
  }
}
var init_node_value_impl = __esm(() => {
  init_utils();
  init_operation_mapper();
});

// node_modules/@tensorflow/tfjs-core/dist/ops/ops_for_converter.js
var exports_ops_for_converter = {};
__export(exports_ops_for_converter, {
  zerosLike: () => zerosLike,
  zeros: () => zeros,
  whereAsync: () => whereAsync,
  where: () => where,
  variable: () => variable,
  upperBound: () => upperBound,
  unstack: () => unstack,
  unsortedSegmentSum: () => unsortedSegmentSum,
  unique: () => unique,
  truncatedNormal: () => truncatedNormal,
  transpose: () => transpose,
  topk: () => topk,
  tile: () => tile,
  tensorScatterUpdate: () => tensorScatterUpdate,
  tensor6d: () => tensor6d,
  tensor5d: () => tensor5d,
  tensor4d: () => tensor4d,
  tensor3d: () => tensor3d,
  tensor2d: () => tensor2d,
  tensor1d: () => tensor1d,
  tensor: () => tensor4,
  tanh: () => tanh2,
  tan: () => tan,
  sum: () => sum2,
  sub: () => sub,
  string: () => string,
  stridedSlice: () => stridedSlice,
  step: () => step,
  stack: () => stack,
  squeeze: () => squeeze,
  squaredDifference: () => squaredDifference,
  square: () => square,
  sqrt: () => sqrt,
  split: () => split,
  spectral: () => spectral,
  sparseToDense: () => sparseToDense,
  sparse: () => sparse,
  spaceToBatchND: () => spaceToBatchND,
  softplus: () => softplus,
  softmax: () => softmax,
  slice4d: () => slice4d,
  slice3d: () => slice3d,
  slice2d: () => slice2d,
  slice1d: () => slice1d,
  slice: () => slice,
  sinh: () => sinh,
  sin: () => sin,
  signal: () => signal,
  sign: () => sign,
  sigmoid: () => sigmoid,
  setdiff1dAsync: () => setdiff1dAsync,
  separableConv2d: () => separableConv2d,
  selu: () => selu,
  searchSorted: () => searchSorted,
  scatterND: () => scatterND,
  scalar: () => scalar,
  rsqrt: () => rsqrt,
  round: () => round2,
  rfft: () => rfft,
  reverse4d: () => reverse4d,
  reverse3d: () => reverse3d,
  reverse2d: () => reverse2d,
  reverse1d: () => reverse1d,
  reverse: () => reverse,
  reshape: () => reshape,
  relu6: () => relu6,
  relu: () => relu,
  reciprocal: () => reciprocal,
  real: () => real,
  range: () => range,
  randomUniformInt: () => randomUniformInt,
  randomUniform: () => randomUniform,
  randomStandardNormal: () => randomStandardNormal,
  randomNormal: () => randomNormal,
  randomGamma: () => randomGamma,
  rand: () => rand,
  raggedTensorToTensor: () => raggedTensorToTensor,
  raggedRange: () => raggedRange,
  raggedGather: () => raggedGather,
  prod: () => prod,
  print: () => print,
  prelu: () => prelu,
  pow: () => pow,
  pool: () => pool,
  pad4d: () => pad4d,
  pad3d: () => pad3d,
  pad2d: () => pad2d,
  pad1d: () => pad1d,
  pad: () => pad,
  outerProduct: () => outerProduct,
  op: () => op,
  onesLike: () => onesLike,
  ones: () => ones2,
  oneHot: () => oneHot,
  notEqual: () => notEqual,
  norm: () => norm,
  neg: () => neg,
  multinomial: () => multinomial,
  multiRNNCell: () => multiRNNCell,
  mul: () => mul,
  movingAverage: () => movingAverage,
  moments: () => moments,
  mod: () => mod,
  mirrorPad: () => mirrorPad,
  minimum: () => minimum,
  min: () => min,
  meshgrid: () => meshgrid,
  mean: () => mean,
  maximum: () => maximum,
  maxPoolWithArgmax: () => maxPoolWithArgmax,
  maxPool3d: () => maxPool3d,
  maxPool: () => maxPool,
  max: () => max,
  matMul: () => matMul,
  lowerBound: () => lowerBound,
  losses: () => losses,
  logicalXor: () => logicalXor,
  logicalOr: () => logicalOr,
  logicalNot: () => logicalNot,
  logicalAnd: () => logicalAnd,
  logSumExp: () => logSumExp,
  logSoftmax: () => logSoftmax,
  logSigmoid: () => logSigmoid,
  log1p: () => log1p,
  log: () => log2,
  localResponseNormalization: () => localResponseNormalization,
  linspace: () => linspace,
  linalg: () => linalg,
  lessEqual: () => lessEqual,
  less: () => less,
  leakyRelu: () => leakyRelu,
  isNaN: () => isNaN2,
  isInf: () => isInf,
  isFinite: () => isFinite2,
  irfft: () => irfft,
  inTopKAsync: () => inTopKAsync,
  image: () => image,
  imag: () => imag,
  ifft: () => ifft,
  greaterEqual: () => greaterEqual,
  greater: () => greater,
  gatherND: () => gatherND,
  gather: () => gather,
  fused: () => exports_fused_ops,
  floorDiv: () => floorDiv,
  floor: () => floor,
  fill: () => fill,
  fft: () => fft,
  eye: () => eye,
  expm1: () => expm1,
  expandDims: () => expandDims,
  exp: () => exp,
  euclideanNorm: () => euclideanNorm,
  erf: () => erf,
  equal: () => equal,
  ensureShape: () => ensureShape,
  enclosingPowerOfTwo: () => enclosingPowerOfTwo,
  elu: () => elu,
  einsum: () => einsum,
  dropout: () => dropout,
  dot: () => dot,
  divNoNan: () => divNoNan,
  div: () => div,
  dilation2d: () => dilation2d,
  diag: () => diag,
  depthwiseConv2d: () => depthwiseConv2d,
  depthToSpace: () => depthToSpace,
  denseBincount: () => denseBincount,
  cumsum: () => cumsum,
  cumprod: () => cumprod,
  cosineWindow: () => cosineWindow,
  cosh: () => cosh,
  cos: () => cos,
  conv3dTranspose: () => conv3dTranspose,
  conv3d: () => conv3d,
  conv2dTranspose: () => conv2dTranspose,
  conv2d: () => conv2d,
  conv1d: () => conv1d,
  concat4d: () => concat4d,
  concat3d: () => concat3d,
  concat2d: () => concat2d,
  concat1d: () => concat1d,
  concat: () => concat,
  complex: () => complex,
  clone: () => clone,
  clipByValue: () => clipByValue,
  ceil: () => ceil,
  cast: () => cast,
  buffer: () => buffer,
  broadcastTo: () => broadcastTo,
  broadcastArgs: () => broadcastArgs,
  booleanMaskAsync: () => booleanMaskAsync,
  bitwiseAnd: () => bitwiseAnd,
  bincount: () => bincount,
  batchToSpaceND: () => batchToSpaceND,
  batchNorm4d: () => batchNorm4d,
  batchNorm3d: () => batchNorm3d,
  batchNorm2d: () => batchNorm2d,
  batchNorm: () => batchNorm,
  basicLSTMCell: () => basicLSTMCell,
  avgPool3d: () => avgPool3d,
  avgPool: () => avgPool,
  atanh: () => atanh,
  atan2: () => atan2,
  atan: () => atan,
  asinh: () => asinh,
  asin: () => asin,
  argMin: () => argMin,
  argMax: () => argMax,
  any: () => any,
  all: () => all,
  addN: () => addN,
  add: () => add2,
  acosh: () => acosh,
  acos: () => acos,
  abs: () => abs,
  OP_SCOPE_SUFFIX: () => OP_SCOPE_SUFFIX
});
var init_ops_for_converter = __esm(() => {
  init_ops();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/arithmetic_executor.js
var executeOp = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "BiasAdd":
    case "AddV2":
    case "Add": {
      return [ops56.add(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "AddN": {
      return [ops56.addN(getParamValue("tensors", node, tensorMap, context))];
    }
    case "FloorMod":
    case "Mod":
      return [ops56.mod(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    case "Mul":
      return [ops56.mul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    case "RealDiv":
    case "Div": {
      return [ops56.div(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "DivNoNan": {
      return [ops56.divNoNan(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "FloorDiv": {
      return [ops56.floorDiv(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Sub": {
      return [ops56.sub(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Minimum": {
      return [ops56.minimum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Maximum": {
      return [ops56.maximum(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Pow": {
      return [ops56.pow(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "SquaredDifference": {
      return [ops56.squaredDifference(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_arithmetic_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/basic_math_executor.js
var executeOp2 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Abs":
    case "ComplexAbs":
      return [ops56.abs(getParamValue("x", node, tensorMap, context))];
    case "Acos":
      return [ops56.acos(getParamValue("x", node, tensorMap, context))];
    case "Acosh":
      return [ops56.acosh(getParamValue("x", node, tensorMap, context))];
    case "Asin":
      return [ops56.asin(getParamValue("x", node, tensorMap, context))];
    case "Asinh":
      return [ops56.asinh(getParamValue("x", node, tensorMap, context))];
    case "Atan":
      return [ops56.atan(getParamValue("x", node, tensorMap, context))];
    case "Atan2":
      return [ops56.atan2(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context))];
    case "Atanh":
      return [ops56.atanh(getParamValue("x", node, tensorMap, context))];
    case "Ceil":
      return [ops56.ceil(getParamValue("x", node, tensorMap, context))];
    case "Complex":
      return [ops56.complex(getParamValue("real", node, tensorMap, context), getParamValue("imag", node, tensorMap, context))];
    case "Cos":
      return [ops56.cos(getParamValue("x", node, tensorMap, context))];
    case "Cosh":
      return [ops56.cosh(getParamValue("x", node, tensorMap, context))];
    case "Elu":
      return [ops56.elu(getParamValue("x", node, tensorMap, context))];
    case "Erf":
      return [ops56.erf(getParamValue("x", node, tensorMap, context))];
    case "Exp":
      return [ops56.exp(getParamValue("x", node, tensorMap, context))];
    case "Expm1": {
      return [ops56.expm1(getParamValue("x", node, tensorMap, context))];
    }
    case "Floor":
      return [ops56.floor(getParamValue("x", node, tensorMap, context))];
    case "Log":
      return [ops56.log(getParamValue("x", node, tensorMap, context))];
    case "Log1p": {
      return [ops56.log1p(getParamValue("x", node, tensorMap, context))];
    }
    case "Imag":
      return [ops56.imag(getParamValue("x", node, tensorMap, context))];
    case "Neg":
      return [ops56.neg(getParamValue("x", node, tensorMap, context))];
    case "Reciprocal": {
      return [ops56.reciprocal(getParamValue("x", node, tensorMap, context))];
    }
    case "Real":
      return [ops56.real(getParamValue("x", node, tensorMap, context))];
    case "Relu":
      return [ops56.relu(getParamValue("x", node, tensorMap, context))];
    case "Round": {
      return [ops56.round(getParamValue("x", node, tensorMap, context))];
    }
    case "Selu":
      return [ops56.selu(getParamValue("x", node, tensorMap, context))];
    case "Sigmoid":
      return [ops56.sigmoid(getParamValue("x", node, tensorMap, context))];
    case "Sin":
      return [ops56.sin(getParamValue("x", node, tensorMap, context))];
    case "Sign": {
      return [ops56.sign(getParamValue("x", node, tensorMap, context))];
    }
    case "Sinh": {
      return [ops56.sinh(getParamValue("x", node, tensorMap, context))];
    }
    case "Softplus": {
      return [ops56.softplus(getParamValue("x", node, tensorMap, context))];
    }
    case "Sqrt": {
      return [ops56.sqrt(getParamValue("x", node, tensorMap, context))];
    }
    case "Square": {
      return [ops56.square(getParamValue("x", node, tensorMap, context))];
    }
    case "Tanh": {
      return [ops56.tanh(getParamValue("x", node, tensorMap, context))];
    }
    case "Tan":
      return [ops56.tan(getParamValue("x", node, tensorMap, context))];
    case "ClipByValue":
      return [ops56.clipByValue(getParamValue("x", node, tensorMap, context), getParamValue("clipValueMin", node, tensorMap, context), getParamValue("clipValueMax", node, tensorMap, context))];
    case "Relu6":
      return [ops56.relu6(getParamValue("x", node, tensorMap, context))];
    case "Rsqrt":
      return [ops56.rsqrt(getTensor(node.inputNames[0], tensorMap, context))];
    case "LeakyRelu":
      return [ops56.leakyRelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
    case "Prelu":
      return [ops56.prelu(getParamValue("x", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context))];
    case "IsNan":
      return [ops56.isNaN(getTensor(node.inputNames[0], tensorMap, context))];
    case "IsInf":
      return [ops56.isInf(getTensor(node.inputNames[0], tensorMap, context))];
    case "IsFinite":
      return [ops56.isFinite(getTensor(node.inputNames[0], tensorMap, context))];
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_basic_math_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_utils.js
function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = "") {
  if (typeof shapeA === "number" || typeof shapeB === "number") {
    return;
  }
  exports_util.assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  for (let i = 0;i < shapeA.length; i++) {
    const dim0 = shapeA[i];
    const dim1 = shapeB[i];
    exports_util.assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);
  }
}
function fullDefinedShape(elementShape) {
  if (typeof elementShape === "number" || elementShape.some((dim) => dim < 0)) {
    return false;
  }
  return true;
}
function inferElementShape(listElementShape, tensors, elementShape) {
  let partialShape = mergeElementShape(listElementShape, elementShape);
  const notfullDefinedShape = !fullDefinedShape(partialShape);
  if (notfullDefinedShape && tensors.length === 0) {
    throw new Error(`Tried to calculate elements of an empty list` + ` with non-fully-defined elementShape: ${partialShape}`);
  }
  if (notfullDefinedShape) {
    tensors.forEach((tensor153) => {
      partialShape = mergeElementShape(tensor153.shape, partialShape);
    });
  }
  if (!fullDefinedShape(partialShape)) {
    throw new Error(`Non-fully-defined elementShape: ${partialShape}`);
  }
  return partialShape;
}
function mergeElementShape(elementShapeA, elementShapeB) {
  if (typeof elementShapeA === "number") {
    return elementShapeB;
  }
  if (typeof elementShapeB === "number") {
    return elementShapeA;
  }
  if (elementShapeA.length !== elementShapeB.length) {
    throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);
  }
  const result = [];
  for (let i = 0;i < elementShapeA.length; ++i) {
    const dim0 = elementShapeA[i];
    const dim1 = elementShapeB[i];
    if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {
      throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);
    }
    result[i] = dim0 >= 0 ? dim0 : dim1;
  }
  return result;
}
var init_tensor_utils = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_array.js
class TensorArray {
  constructor(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {
    this.name = name;
    this.dtype = dtype;
    this.maxSize = maxSize;
    this.elementShape = elementShape;
    this.identicalElementShapes = identicalElementShapes;
    this.dynamicSize = dynamicSize;
    this.clearAfterRead = clearAfterRead;
    this.tensors = [];
    this.closed_ = false;
    this.idTensor = scalar(0);
    keep(this.idTensor);
  }
  get id() {
    return this.idTensor.id;
  }
  get closed() {
    return this.closed_;
  }
  clearAndClose(keepIds) {
    this.tensors.forEach((tensor153) => {
      if (keepIds == null || !keepIds.has(tensor153.tensor.id)) {
        tensor153.tensor.dispose();
      }
    });
    this.tensors = [];
    this.closed_ = true;
    this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  read(index) {
    if (this.closed_) {
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    }
    if (index < 0 || index >= this.size()) {
      throw new Error(`Tried to read from index ${index}, but array size is: ${this.size()}`);
    }
    const tensorWithState = this.tensors[index];
    if (tensorWithState.cleared) {
      throw new Error(`TensorArray ${this.name}: Could not read index ${index} twice because it was cleared after a previous read ` + `(perhaps try setting clear_after_read = false?).`);
    }
    if (this.clearAfterRead) {
      tensorWithState.cleared = true;
    }
    tensorWithState.read = true;
    return tensorWithState.tensor;
  }
  readMany(indices) {
    return indices.map((index) => this.read(index));
  }
  write(index, tensor153) {
    if (this.closed_) {
      throw new Error(`TensorArray ${this.name} has already been closed.`);
    }
    if (index < 0 || !this.dynamicSize && index >= this.maxSize) {
      throw new Error(`Tried to write to index ${index}, but array is not resizeable and size is: ${this.maxSize}`);
    }
    const t = this.tensors[index] || {};
    if (tensor153.dtype !== this.dtype) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index},
          because the value dtype is ${tensor153.dtype}, but TensorArray dtype is ${this.dtype}.`);
    }
    if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0)) {
      this.elementShape = tensor153.shape;
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor153.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index}.`);
    if (t.read) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been read.`);
    }
    if (t.written) {
      throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been written.`);
    }
    t.tensor = tensor153;
    keep(tensor153);
    t.written = true;
    this.tensors[index] = t;
  }
  writeMany(indices, tensors) {
    if (indices.length !== tensors.length) {
      throw new Error(`TensorArray ${this.name}: could not write multiple tensors,` + `because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);
    }
    indices.forEach((i, index) => this.write(i, tensors[index]));
  }
  gather(indices, dtype) {
    if (!!dtype && dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);
    }
    if (!indices) {
      indices = [];
      for (let i = 0;i < this.size(); i++) {
        indices.push(i);
      }
    } else {
      indices = indices.slice(0, this.size());
    }
    if (indices.length === 0) {
      return tensor4([], [0].concat(this.elementShape));
    }
    const tensors = this.readMany(indices);
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, "TensorArray shape mismatch: ");
    return stack(tensors, 0);
  }
  concat(dtype) {
    if (!!dtype && dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);
    }
    if (this.size() === 0) {
      return tensor4([], [0].concat(this.elementShape));
    }
    const indices = [];
    for (let i = 0;i < this.size(); i++) {
      indices.push(i);
    }
    const tensors = this.readMany(indices);
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);
    return concat(tensors, 0);
  }
  scatter(indices, tensor153) {
    if (tensor153.dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor153.dtype}`);
    }
    if (indices.length !== tensor153.shape[0]) {
      throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor153.shape[0]}`);
    }
    const maxIndex = Math.max(...indices);
    if (!this.dynamicSize && maxIndex >= this.maxSize) {
      throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);
    }
    this.writeMany(indices, unstack(tensor153, 0));
  }
  split(length, tensor153) {
    if (tensor153.dtype !== this.dtype) {
      throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor153.dtype}`);
    }
    let totalLength = 0;
    const cumulativeLengths = length.map((len) => {
      totalLength += len;
      return totalLength;
    });
    if (totalLength !== tensor153.shape[0]) {
      throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor153.shape}`);
    }
    if (!this.dynamicSize && length.length !== this.maxSize) {
      throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), ` + "and the TensorArray is not marked as dynamically resizeable");
    }
    const elementPerRow = totalLength === 0 ? 0 : tensor153.size / totalLength;
    const tensors = [];
    tidy(() => {
      tensor153 = reshape(tensor153, [1, totalLength, elementPerRow]);
      for (let i = 0;i < length.length; ++i) {
        const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
        const indices2 = [0, previousLength, 0];
        const sizes = [1, length[i], elementPerRow];
        tensors[i] = reshape(slice(tensor153, indices2, sizes), this.elementShape);
      }
      return tensors;
    });
    const indices = [];
    for (let i = 0;i < length.length; i++) {
      indices[i] = i;
    }
    this.writeMany(indices, tensors);
  }
}
var init_tensor_array = __esm(() => {
  init_dist();
  init_tensor_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_list.js
function fromTensor(tensor153, elementShape, elementDtype) {
  const dtype = tensor153.dtype;
  if (tensor153.shape.length < 1) {
    throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor153.shape}`);
  }
  if (tensor153.dtype !== elementDtype) {
    throw new Error(`Invalid data types; op elements ${tensor153.dtype}, but list elements ${elementDtype}`);
  }
  const tensorElementShape = tensor153.shape.slice(1);
  assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, "TensorList shape mismatch: ");
  const tensorList = unstack(tensor153);
  return new TensorList(tensorList, elementShape, dtype);
}
function reserve(elementShape, elementDtype, numElements, maxNumElements) {
  return new TensorList([], elementShape, elementDtype, maxNumElements);
}
function scatter(tensor153, indices, elementShape, numElements) {
  if (indices.length !== tensor153.shape[0]) {
    throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor153.shape[0]}`);
  }
  const maxIndex = Math.max(...indices);
  if (numElements != null && numElements !== -1 && maxIndex >= numElements) {
    throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);
  }
  const list = new TensorList([], elementShape, tensor153.dtype, numElements);
  const tensors = unstack(tensor153, 0);
  indices.forEach((value, index) => {
    list.setItem(value, tensors[index]);
  });
  return list;
}
function split8(tensor153, length, elementShape) {
  let totalLength = 0;
  const cumulativeLengths = length.map((len) => {
    totalLength += len;
    return totalLength;
  });
  if (totalLength !== tensor153.shape[0]) {
    throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${totalLength}, and tensor's shape is: ${tensor153.shape}`);
  }
  const shapeWithoutFirstDim = tensor153.shape.slice(1);
  const outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);
  const elementPerRow = totalLength === 0 ? 0 : tensor153.size / totalLength;
  const tensors = tidy(() => {
    const tensors2 = [];
    tensor153 = reshape(tensor153, [1, totalLength, elementPerRow]);
    for (let i = 0;i < length.length; ++i) {
      const previousLength = i === 0 ? 0 : cumulativeLengths[i - 1];
      const indices = [0, previousLength, 0];
      const sizes = [1, length[i], elementPerRow];
      tensors2[i] = reshape(slice(tensor153, indices, sizes), outputElementShape);
    }
    tensor153.dispose();
    return tensors2;
  });
  const list = new TensorList([], elementShape, tensor153.dtype, length.length);
  for (let i = 0;i < tensors.length; i++) {
    list.setItem(i, tensors[i]);
  }
  return list;
}

class TensorList {
  get id() {
    return this.idTensor.id;
  }
  constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {
    this.tensors = tensors;
    this.elementShape = elementShape;
    this.elementDtype = elementDtype;
    if (tensors != null) {
      tensors.forEach((tensor153) => {
        if (elementDtype !== tensor153.dtype) {
          throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor153.dtype}`);
        }
        assertShapesMatchAllowUndefinedSize(elementShape, tensor153.shape, "TensorList shape mismatch: ");
        keep(tensor153);
      });
    }
    this.idTensor = scalar(0);
    this.maxNumElements = maxNumElements;
    keep(this.idTensor);
  }
  copy() {
    return new TensorList([...this.tensors], this.elementShape, this.elementDtype);
  }
  clearAndClose(keepIds) {
    this.tensors.forEach((tensor153) => {
      if (keepIds == null || !keepIds.has(tensor153.id)) {
        tensor153.dispose();
      }
    });
    this.tensors.length = 0;
    this.idTensor.dispose();
  }
  size() {
    return this.tensors.length;
  }
  stack(elementShape, elementDtype, numElements = -1) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (numElements !== -1 && this.tensors.length !== numElements) {
      throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);
    }
    assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    return tidy(() => {
      const reshapedTensors = this.tensors.map((tensor153) => reshape(tensor153, outputElementShape));
      return stack(reshapedTensors, 0);
    });
  }
  popBack(elementShape, elementDtype) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (this.size() === 0) {
      throw new Error("Trying to pop from an empty list.");
    }
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    const tensor153 = this.tensors.pop();
    tensor153.kept = false;
    assertShapesMatchAllowUndefinedSize(tensor153.shape, elementShape, "TensorList shape mismatch: ");
    return reshape(tensor153, outputElementShape);
  }
  pushBack(tensor153) {
    if (tensor153.dtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor153.dtype}, but list elements ${this.elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(tensor153.shape, this.elementShape, "TensorList shape mismatch: ");
    if (this.maxNumElements === this.size()) {
      throw new Error(`Trying to push element into a full list.`);
    }
    keep(tensor153);
    this.tensors.push(tensor153);
  }
  resize(size) {
    if (size < 0) {
      throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);
    }
    if (this.maxNumElements !== -1 && size > this.maxNumElements) {
      throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);
    }
    const destTensorList = new TensorList([], this.elementShape, this.elementDtype, this.maxNumElements);
    destTensorList.tensors.length = size;
    for (let i = 0;i < Math.min(this.tensors.length, size); ++i) {
      destTensorList.tensors[i] = this.tensors[i];
    }
    return destTensorList;
  }
  getItem(elementIndex, elementShape, elementDtype) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    if (elementIndex < 0 || elementIndex > this.tensors.length) {
      throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);
    }
    if (this.tensors[elementIndex] == null) {
      throw new Error(`element at index ${elementIndex} is null.`);
    }
    assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    return reshape(this.tensors[elementIndex], outputElementShape);
  }
  setItem(elementIndex, tensor153) {
    if (tensor153.dtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${tensor153.dtype}, but list elements ${this.elementDtype}`);
    }
    if (elementIndex < 0 || this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {
      throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, tensor153.shape, "TensorList shape mismatch: ");
    keep(tensor153);
    if (this.tensors[elementIndex] != null) {
      this.tensors[elementIndex].kept = false;
    }
    this.tensors[elementIndex] = tensor153;
  }
  gather(indices, elementDtype, elementShape) {
    if (elementDtype !== this.elementDtype) {
      throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
    indices = indices.slice(0, this.size());
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    if (indices.length === 0) {
      return tensor4([], [0].concat(outputElementShape));
    }
    return tidy(() => {
      const tensors = indices.map((i) => reshape(this.tensors[i], outputElementShape));
      return stack(tensors, 0);
    });
  }
  concat(elementDtype, elementShape) {
    if (!!elementDtype && elementDtype !== this.elementDtype) {
      throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);
    }
    assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, "TensorList shape mismatch: ");
    const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);
    if (this.size() === 0) {
      return tensor4([], [0].concat(outputElementShape));
    }
    return tidy(() => {
      const tensors = this.tensors.map((t) => reshape(t, outputElementShape));
      return concat(tensors, 0);
    });
  }
}
var init_tensor_list = __esm(() => {
  init_dist();
  init_tensor_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js
var executeOp3 = async (node, tensorMap, context) => {
  switch (node.op) {
    case "If":
    case "StatelessIf": {
      const thenFunc = getParamValue("thenBranch", node, tensorMap, context);
      const elseFunc = getParamValue("elseBranch", node, tensorMap, context);
      const cond = getParamValue("cond", node, tensorMap, context);
      const args = getParamValue("args", node, tensorMap, context);
      const condValue = await cond.data();
      if (condValue[0]) {
        return context.functionMap[thenFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
      } else {
        return context.functionMap[elseFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
      }
    }
    case "While":
    case "StatelessWhile": {
      const bodyFunc = getParamValue("body", node, tensorMap, context);
      const condFunc = getParamValue("cond", node, tensorMap, context);
      const args = getParamValue("args", node, tensorMap, context);
      const condResult = await context.functionMap[condFunc].executeFunctionAsync(args, context.tensorArrayMap, context.tensorListMap);
      const argIds = args.map((tensor153) => tensor153.id);
      let condValue = await condResult[0].data();
      condResult.forEach((tensor153) => {
        if (!tensor153.kept && argIds.indexOf(tensor153.id) === -1) {
          tensor153.dispose();
        }
      });
      let result = args;
      while (condValue[0]) {
        const origResult = result;
        result = await context.functionMap[bodyFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
        const resultIds = result.map((tensor153) => tensor153.id);
        origResult.forEach((tensor153) => {
          if (!tensor153.kept && argIds.indexOf(tensor153.id) === -1 && resultIds.indexOf(tensor153.id) === -1) {
            tensor153.dispose();
          }
        });
        const condResult2 = await context.functionMap[condFunc].executeFunctionAsync(result, context.tensorArrayMap, context.tensorListMap);
        condValue = await condResult2[0].data();
        condResult2.forEach((tensor153) => {
          if (!tensor153.kept && argIds.indexOf(tensor153.id) === -1 && resultIds.indexOf(tensor153.id) === -1) {
            tensor153.dispose();
          }
        });
      }
      return result;
    }
    case "LoopCond": {
      const pred = getParamValue("pred", node, tensorMap, context);
      return [cloneTensor(pred)];
    }
    case "Switch": {
      const pred = getParamValue("pred", node, tensorMap, context);
      let data = getParamValue("data", node, tensorMap, context);
      if (!data.kept) {
        data = cloneTensor(data);
      }
      return (await pred.data())[0] ? [undefined, data] : [data, undefined];
    }
    case "Merge": {
      const inputName = node.inputNames.find((name) => getTensor(name, tensorMap, context) !== undefined);
      if (inputName) {
        const data = getTensor(inputName, tensorMap, context);
        return [cloneTensor(data)];
      }
      return;
    }
    case "Enter": {
      const frameId = getParamValue("frameName", node, tensorMap, context);
      const data = getParamValue("tensor", node, tensorMap, context);
      context.enterFrame(frameId);
      return [cloneTensor(data)];
    }
    case "Exit": {
      const data = getParamValue("tensor", node, tensorMap, context);
      context.exitFrame();
      return [cloneTensor(data)];
    }
    case "NextIteration": {
      const data = getParamValue("tensor", node, tensorMap, context);
      context.nextIteration();
      return [cloneTensor(data)];
    }
    case "TensorArrayV3": {
      const size = getParamValue("size", node, tensorMap, context);
      const dtype = getParamValue("dtype", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const dynamicSize = getParamValue("dynamicSize", node, tensorMap, context);
      const clearAfterRead = getParamValue("clearAfterRead", node, tensorMap, context);
      const identicalElementShapes = getParamValue("identicalElementShapes", node, tensorMap, context);
      const name = getParamValue("name", node, tensorMap, context);
      const tensorArray = new TensorArray(name, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);
      context.addTensorArray(tensorArray);
      return [tensorArray.idTensor, scalar(1)];
    }
    case "TensorArrayWriteV3": {
      const id = getParamValue("tensorArrayId", node, tensorMap, context);
      const index = getParamValue("index", node, tensorMap, context);
      const writeTensor = getParamValue("tensor", node, tensorMap, context);
      const writeTensorArray = context.getTensorArray(id.id);
      writeTensorArray.write(index, writeTensor);
      return [writeTensorArray.idTensor];
    }
    case "TensorArrayReadV3": {
      const readId = getParamValue("tensorArrayId", node, tensorMap, context);
      const readIndex = getParamValue("index", node, tensorMap, context);
      const readTensorArray = context.getTensorArray(readId.id);
      return [readTensorArray.read(readIndex)];
    }
    case "TensorArrayGatherV3": {
      const gatherId = getParamValue("tensorArrayId", node, tensorMap, context);
      const gatherIndices = getParamValue("indices", node, tensorMap, context);
      const gatherDtype = getParamValue("dtype", node, tensorMap, context);
      const gatherTensorArray = context.getTensorArray(gatherId.id);
      return [gatherTensorArray.gather(gatherIndices, gatherDtype)];
    }
    case "TensorArrayScatterV3": {
      const scatterId = getParamValue("tensorArrayId", node, tensorMap, context);
      const scatterIndices = getParamValue("indices", node, tensorMap, context);
      const scatterTensor = getParamValue("tensor", node, tensorMap, context);
      const scatterTensorArray = context.getTensorArray(scatterId.id);
      scatterTensorArray.scatter(scatterIndices, scatterTensor);
      return [scatterTensorArray.idTensor];
    }
    case "TensorArrayConcatV3": {
      const concatId = getParamValue("tensorArrayId", node, tensorMap, context);
      const concatTensorArray = context.getTensorArray(concatId.id);
      const concatDtype = getParamValue("dtype", node, tensorMap, context);
      return [concatTensorArray.concat(concatDtype)];
    }
    case "TensorArraySplitV3": {
      const splitId = getParamValue("tensorArrayId", node, tensorMap, context);
      const splitTensor = getParamValue("tensor", node, tensorMap, context);
      const lengths = getParamValue("lengths", node, tensorMap, context);
      const splitTensorArray = context.getTensorArray(splitId.id);
      splitTensorArray.split(lengths, splitTensor);
      return [splitTensorArray.idTensor];
    }
    case "TensorArraySizeV3": {
      const sizeId = getParamValue("tensorArrayId", node, tensorMap, context);
      const sizeTensorArray = context.getTensorArray(sizeId.id);
      return [scalar(sizeTensorArray.size(), "int32")];
    }
    case "TensorArrayCloseV3": {
      const closeId = getParamValue("tensorArrayId", node, tensorMap, context);
      const closeTensorArray = context.getTensorArray(closeId.id);
      closeTensorArray.clearAndClose();
      return [closeTensorArray.idTensor];
    }
    case "TensorListSetItem": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const index = getParamValue("index", node, tensorMap, context);
      const writeTensor = getParamValue("tensor", node, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      tensorList.setItem(index, writeTensor);
      return [tensorList.idTensor];
    }
    case "TensorListGetItem": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const readIndex = getParamValue("index", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const elementDType = getParamValue("elementDType", node, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [tensorList.getItem(readIndex, elementShape, elementDType)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const scatterIndices = getParamValue("indices", node, tensorMap, context);
      const scatterTensor = getParamValue("tensor", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const numElements = getParamValue("numElements", node, tensorMap, context);
      const tensorList = scatter(scatterTensor, scatterIndices, elementShape, numElements);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context);
      let numElementsParam;
      if (node.op === "TensorListReserve") {
        numElementsParam = "numElements";
      } else {
        numElementsParam = "maxNumElements";
      }
      const numElements = getParamValue(numElementsParam, node, tensorMap, context);
      const maxNumElements = node.op === "TensorListReserve" ? -1 : numElements;
      const tensorList = reserve(elementShape, elementDtype, numElements, maxNumElements);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListGather": {
      const gatherId = getParamValue("tensorListId", node, tensorMap, context);
      const gatherIndices = getParamValue("indices", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context);
      const tensorList = context.getTensorList(gatherId.id);
      return [tensorList.gather(gatherIndices, elementDtype, elementShape)];
    }
    case "TensorListStack": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context);
      const numElements = getParamValue("numElements", node, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [tensorList.stack(elementShape, elementDtype, numElements)];
    }
    case "TensorListFromTensor": {
      const tensor153 = getParamValue("tensor", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const elementDtype = getParamValue("elementDType", node, tensorMap, context);
      const tensorList = fromTensor(tensor153, elementShape, elementDtype);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListConcat":
    case "TensorListConcatV2": {
      const concatId = getParamValue("tensorListId", node, tensorMap, context);
      const tensorList = context.getTensorList(concatId.id);
      const concatDtype = getParamValue("dtype", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      return [tensorList.concat(concatDtype, elementShape)];
    }
    case "TensorListPushBack": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const writeTensor = getParamValue("tensor", node, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      tensorList.pushBack(writeTensor);
      return [tensorList.idTensor];
    }
    case "TensorListPopBack": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const elementDType = getParamValue("elementDType", node, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [tensorList.popBack(elementShape, elementDType)];
    }
    case "TensorListSplit": {
      const splitTensor = getParamValue("tensor", node, tensorMap, context);
      const elementShape = getParamValue("elementShape", node, tensorMap, context);
      const lengths = getParamValue("lengths", node, tensorMap, context);
      const tensorList = split8(splitTensor, lengths, elementShape);
      context.addTensorList(tensorList);
      return [tensorList.idTensor];
    }
    case "TensorListLength": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const tensorList = context.getTensorList(idTensor.id);
      return [scalar(tensorList.size(), "int32")];
    }
    case "TensorListResize": {
      const idTensor = getParamValue("tensorListId", node, tensorMap, context);
      const size = getParamValue("size", node, tensorMap, context);
      const srcTensorList = context.getTensorList(idTensor.id);
      const destTensorList = srcTensorList.resize(size);
      context.addTensorList(destTensorList);
      return [destTensorList.idTensor];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_control_executor = __esm(() => {
  init_dist();
  init_tensor_array();
  init_tensor_list();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/convolution_executor.js
function fusedConvAndDepthWiseParams(node, tensorMap, context) {
  const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context);
  const isBiasAdd = extraOp === "biasadd";
  const noBiasAdd = !isBiasAdd;
  const isPrelu = activationFunc === "prelu";
  const isBatchNorm = extraOp === "fusedbatchnorm";
  const numArgs = getParamValue("numArgs", node, tensorMap, context);
  if (isBiasAdd) {
    if (isPrelu && numArgs !== 2) {
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu " + "must have two extra arguments: bias and alpha.");
    }
    if (!isPrelu && isBiasAdd && numArgs !== 1) {
      throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have " + "one extra argument: bias.");
    }
  }
  if (isBatchNorm) {
    throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  }
  const stride = getParamValue("strides", node, tensorMap, context);
  const pad9 = getPadding(node, tensorMap, context);
  const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
  const dilations = getParamValue("dilations", node, tensorMap, context);
  let [biasArg, preluArg] = getParamValue("args", node, tensorMap, context);
  if (noBiasAdd) {
    preluArg = biasArg;
    biasArg = undefined;
  }
  const leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context);
  return {
    stride,
    pad: pad9,
    dataFormat,
    dilations,
    biasArg,
    preluArg,
    activationFunc,
    leakyreluAlpha
  };
}
var executeOp4 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Conv1D": {
      const stride = getParamValue("stride", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
      const dilation = getParamValue("dilation", node, tensorMap, context);
      return [ops56.conv1d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), stride, pad9, dataFormat, dilation)];
    }
    case "Conv2D": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getPadding(node, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
      const dilations = getParamValue("dilations", node, tensorMap, context);
      return [ops56.conv2d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad9, dataFormat, [dilations[1], dilations[2]])];
    }
    case "_FusedConv2D": {
      const { stride, pad: pad9, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context);
      return [ops56.fused.conv2d({
        x: getParamValue("x", node, tensorMap, context),
        filter: getParamValue("filter", node, tensorMap, context),
        strides: [stride[1], stride[2]],
        pad: pad9,
        dataFormat,
        dilations: [dilations[1], dilations[2]],
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride, pad: pad9, dataFormat, dilations, biasArg, preluArg, activationFunc, leakyreluAlpha } = fusedConvAndDepthWiseParams(node, tensorMap, context);
      return [ops56.fused.depthwiseConv2d({
        x: getParamValue("x", node, tensorMap, context),
        filter: getParamValue("filter", node, tensorMap, context),
        strides: [stride[1], stride[2]],
        pad: pad9,
        dataFormat,
        dilations: [dilations[1], dilations[2]],
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const shape = getParamValue("outputShape", node, tensorMap, context);
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getPadding(node, tensorMap, context);
      return [ops56.conv2dTranspose(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), shape, [stride[1], stride[2]], pad9)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getPadding(node, tensorMap, context);
      const dilations = getParamValue("dilations", node, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
      return [ops56.depthwiseConv2d(getParamValue("input", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2]], pad9, dataFormat, [dilations[1], dilations[2]])];
    }
    case "Conv3D": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
      const dilations = getParamValue("dilations", node, tensorMap, context);
      return [ops56.conv3d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [stride[1], stride[2], stride[3]], pad9, dataFormat, [dilations[1], dilations[2], dilations[3]])];
    }
    case "AvgPool": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
      return [ops56.avgPool(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad9)];
    }
    case "MaxPool": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
      return [ops56.maxPool(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad9)];
    }
    case "MaxPoolWithArgmax": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
      const includeBatchInIndex = getParamValue("includeBatchInIndex", node, tensorMap, context);
      const { result, indexes } = ops56.maxPoolWithArgmax(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad9, includeBatchInIndex);
      return [result, indexes];
    }
    case "AvgPool3D": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
      return [ops56.avgPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad9)];
    }
    case "MaxPool3D": {
      const stride = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const kernelSize = getParamValue("kernelSize", node, tensorMap, context);
      return [ops56.maxPool3d(getParamValue("x", node, tensorMap, context), [kernelSize[1], kernelSize[2], kernelSize[3]], [stride[1], stride[2], stride[3]], pad9)];
    }
    case "Dilation2D": {
      const strides = getParamValue("strides", node, tensorMap, context);
      const pad9 = getParamValue("pad", node, tensorMap, context);
      const dilations = getParamValue("dilations", node, tensorMap, context);
      const strideHeight = strides[1];
      const strideWidth = strides[2];
      const dilationHeight = dilations[1];
      const dilationWidth = dilations[2];
      return [ops56.dilation2d(getParamValue("x", node, tensorMap, context), getParamValue("filter", node, tensorMap, context), [strideHeight, strideWidth], pad9, [dilationHeight, dilationWidth], "NHWC")];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_convolution_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/creation_executor.js
var executeOp5 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Fill": {
      const shape = getParamValue("shape", node, tensorMap, context);
      const dtype = getParamValue("dtype", node, tensorMap, context);
      const value = getParamValue("value", node, tensorMap, context);
      return [ops56.fill(shape, value, dtype)];
    }
    case "LinSpace": {
      const start = getParamValue("start", node, tensorMap, context);
      const stop = getParamValue("stop", node, tensorMap, context);
      const num = getParamValue("num", node, tensorMap, context);
      return [ops56.linspace(start, stop, num)];
    }
    case "Multinomial": {
      const logits = getParamValue("logits", node, tensorMap, context);
      const numSamples = getParamValue("numSamples", node, tensorMap, context);
      const seed = getParamValue("seed", node, tensorMap, context);
      return [ops56.multinomial(logits, numSamples, seed)];
    }
    case "OneHot": {
      const indices = getParamValue("indices", node, tensorMap, context);
      const depth = getParamValue("depth", node, tensorMap, context);
      const onValue = getParamValue("onValue", node, tensorMap, context);
      const offValue = getParamValue("offValue", node, tensorMap, context);
      const dtype = getParamValue("dtype", node, tensorMap, context);
      return [ops56.oneHot(indices, depth, onValue, offValue, dtype)];
    }
    case "Ones": {
      return [ops56.ones(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
    }
    case "OnesLike": {
      return [ops56.onesLike(getParamValue("x", node, tensorMap, context))];
    }
    case "RandomStandardNormal": {
      return [ops56.randomStandardNormal(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context), getParamValue("seed", node, tensorMap, context))];
    }
    case "RandomUniform": {
      return [ops56.randomUniform(getParamValue("shape", node, tensorMap, context), getParamValue("minval", node, tensorMap, context), getParamValue("maxval", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
    }
    case "RandomUniformInt": {
      return [ops56.randomUniformInt(getParamValue("shape", node, tensorMap, context), getParamValue("minval", node, tensorMap, context), getParamValue("maxval", node, tensorMap, context), getParamValue("seed", node, tensorMap, context))];
    }
    case "Range": {
      const start = getParamValue("start", node, tensorMap, context);
      const stop = getParamValue("stop", node, tensorMap, context);
      const step7 = getParamValue("step", node, tensorMap, context);
      return [ops56.range(start, stop, step7, getParamValue("dtype", node, tensorMap, context))];
    }
    case "TruncatedNormal": {
      const shape = getParamValue("shape", node, tensorMap, context);
      const mean6 = getParamValue("mean", node, tensorMap, context);
      const stdDev = getParamValue("stdDev", node, tensorMap, context);
      const seed = getParamValue("seed", node, tensorMap, context);
      return [ops56.truncatedNormal(shape, mean6, stdDev, getParamValue("dtype", node, tensorMap, context), seed)];
    }
    case "Zeros": {
      return [ops56.zeros(getParamValue("shape", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
    }
    case "ZerosLike": {
      return [ops56.zerosLike(getParamValue("x", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_creation_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/dynamic_executor.js
function nmsParams(node, tensorMap, context) {
  const boxes = getParamValue("boxes", node, tensorMap, context);
  const scores = getParamValue("scores", node, tensorMap, context);
  const maxOutputSize = getParamValue("maxOutputSize", node, tensorMap, context);
  const iouThreshold = getParamValue("iouThreshold", node, tensorMap, context);
  const scoreThreshold = getParamValue("scoreThreshold", node, tensorMap, context);
  const softNmsSigma = getParamValue("softNmsSigma", node, tensorMap, context);
  return {
    boxes,
    scores,
    maxOutputSize,
    iouThreshold,
    scoreThreshold,
    softNmsSigma
  };
}
var executeOp6 = async (node, tensorMap, context, resourceManager, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "NonMaxSuppressionV5": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = nmsParams(node, tensorMap, context);
      const result = await ops56.image.nonMaxSuppressionWithScoreAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma);
      return [result.selectedIndices, result.selectedScores];
    }
    case "NonMaxSuppressionV4": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);
      const padToMaxOutputSize = getParamValue("padToMaxOutputSize", node, tensorMap, context);
      const result = await ops56.image.nonMaxSuppressionPaddedAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
      return [result.selectedIndices, result.validOutputs];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes, scores, maxOutputSize, iouThreshold, scoreThreshold } = nmsParams(node, tensorMap, context);
      return [await ops56.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];
    }
    case "Where": {
      const condition = ops56.cast(getParamValue("condition", node, tensorMap, context), "bool");
      const result = [await ops56.whereAsync(condition)];
      condition.dispose();
      return result;
    }
    case "ListDiff": {
      return ops56.setdiff1dAsync(getParamValue("x", node, tensorMap, context), getParamValue("y", node, tensorMap, context));
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_dynamic_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/evaluation_executor.js
var executeOp7 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "LowerBound": {
      const sortedSequence = getParamValue("sortedSequence", node, tensorMap, context);
      const values = getParamValue("values", node, tensorMap, context);
      return [ops56.lowerBound(sortedSequence, values)];
    }
    case "TopKV2": {
      const x = getParamValue("x", node, tensorMap, context);
      const k = getParamValue("k", node, tensorMap, context);
      const sorted = getParamValue("sorted", node, tensorMap, context);
      const result = ops56.topk(x, k, sorted);
      return [result.values, result.indices];
    }
    case "UpperBound": {
      const sortedSequence = getParamValue("sortedSequence", node, tensorMap, context);
      const values = getParamValue("values", node, tensorMap, context);
      return [ops56.upperBound(sortedSequence, values)];
    }
    case "Unique": {
      const x = getParamValue("x", node, tensorMap, context);
      const result = ops56.unique(x);
      return [result.values, result.indices];
    }
    case "UniqueV2": {
      const x = getParamValue("x", node, tensorMap, context);
      const axis = getParamValue("axis", node, tensorMap, context);
      const result = ops56.unique(x, axis);
      return [result.values, result.indices];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_evaluation_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/graph_executor.js
var executeOp8 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Const": {
      return tensorMap[node.name];
    }
    case "PlaceholderWithDefault":
      const def = getParamValue("default", node, tensorMap, context);
      return [getTensor(node.name, tensorMap, context) || def];
    case "Placeholder":
      return [getTensor(node.name, tensorMap, context)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const data2 = getParamValue("x", node, tensorMap, context);
      return [cloneTensor(data2)];
    }
    case "IdentityN":
      return getParamValue("x", node, tensorMap, context).map((t) => cloneTensor(t));
    case "Snapshot":
      const snapshot = getParamValue("x", node, tensorMap, context);
      return [cloneTensor(snapshot)];
    case "Shape":
      return [ops56.tensor1d(getParamValue("x", node, tensorMap, context).shape, "int32")];
    case "ShapeN":
      return getParamValue("x", node, tensorMap, context).map((t) => ops56.tensor1d(t.shape));
    case "Size":
      return [ops56.scalar(getParamValue("x", node, tensorMap, context).size, "int32")];
    case "Rank":
      return [ops56.scalar(getParamValue("x", node, tensorMap, context).rank, "int32")];
    case "NoOp":
      return [ops56.scalar(1)];
    case "Print":
      const input2 = getParamValue("x", node, tensorMap, context);
      const data = getParamValue("data", node, tensorMap, context);
      const message = getParamValue("message", node, tensorMap, context);
      const summarize = getParamValue("summarize", node, tensorMap, context);
      console.warn("The graph has a tf.print() operation," + "usually used for debugging, which slows down performance.");
      console.log(message);
      for (let i = 0;i < data.length; i++) {
        console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));
      }
      return [input2];
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_graph_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/hash_table.js
class HashTable {
  get id() {
    return this.handle.id;
  }
  constructor(keyDType, valueDType) {
    this.keyDType = keyDType;
    this.valueDType = valueDType;
    this.handle = scalar(0);
    this.tensorMap = new Map;
    keep(this.handle);
  }
  clearAndClose() {
    this.tensorMap.forEach((value) => value.dispose());
    this.tensorMap.clear();
    this.handle.dispose();
  }
  size() {
    return this.tensorMap.size;
  }
  tensorSize() {
    return scalar(this.size(), "int32");
  }
  async import(keys, values) {
    this.checkKeyAndValueTensor(keys, values);
    const $keys = await keys.data();
    this.tensorMap.forEach((value) => value.dispose());
    this.tensorMap.clear();
    return tidy(() => {
      const $values = unstack(values);
      const keysLength = $keys.length;
      const valuesLength = $values.length;
      exports_util.assert(keysLength === valuesLength, () => `The number of elements doesn't match, keys has ` + `${keysLength} elements, the values has ${valuesLength} ` + `elements.`);
      for (let i = 0;i < keysLength; i++) {
        const key = $keys[i];
        const value = $values[i];
        keep(value);
        this.tensorMap.set(key, value);
      }
      return this.handle;
    });
  }
  async find(keys, defaultValue) {
    this.checkKeyAndValueTensor(keys, defaultValue);
    const $keys = await keys.data();
    return tidy(() => {
      const result = [];
      for (let i = 0;i < $keys.length; i++) {
        const key = $keys[i];
        const value = this.findWithDefault(key, defaultValue);
        result.push(value);
      }
      return stack(result);
    });
  }
  findWithDefault(key, defaultValue) {
    const result = this.tensorMap.get(key);
    return result != null ? result : defaultValue;
  }
  checkKeyAndValueTensor(key, value) {
    if (key.dtype !== this.keyDType) {
      throw new Error(`Expect key dtype ${this.keyDType}, but got ` + `${key.dtype}`);
    }
    if (value.dtype !== this.valueDType) {
      throw new Error(`Expect value dtype ${this.valueDType}, but got ` + `${value.dtype}`);
    }
  }
}
var init_hash_table2 = __esm(() => {
  init_dist();
  init_ops_for_converter();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/hash_table_executor.js
var executeOp9 = async (node, tensorMap, context, resourceManager) => {
  switch (node.op) {
    case "HashTable":
    case "HashTableV2": {
      const existingTableHandle = resourceManager.getHashTableHandleByName(node.name);
      if (existingTableHandle != null) {
        return [existingTableHandle];
      } else {
        const keyDType = getParamValue("keyDType", node, tensorMap, context);
        const valueDType = getParamValue("valueDType", node, tensorMap, context);
        const hashTable = new HashTable(keyDType, valueDType);
        resourceManager.addHashTable(node.name, hashTable);
        return [hashTable.handle];
      }
    }
    case "InitializeTable":
    case "InitializeTableV2":
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
      const keys = getParamValue("keys", node, tensorMap, context);
      const values = getParamValue("values", node, tensorMap, context);
      const hashTable = resourceManager.getHashTableById(handle.id);
      return [await hashTable.import(keys, values)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
      const keys = getParamValue("keys", node, tensorMap, context);
      const defaultValue = getParamValue("defaultValue", node, tensorMap, context);
      const hashTable = resourceManager.getHashTableById(handle.id);
      return [await hashTable.find(keys, defaultValue)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const handle = getParamValue("tableHandle", node, tensorMap, context, resourceManager);
      const hashTable = resourceManager.getHashTableById(handle.id);
      return [hashTable.tensorSize()];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_hash_table_executor = __esm(() => {
  init_hash_table2();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/image_executor.js
var executeOp10 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "ResizeBilinear": {
      const images = getParamValue("images", node, tensorMap, context);
      const size = getParamValue("size", node, tensorMap, context);
      const alignCorners = getParamValue("alignCorners", node, tensorMap, context);
      const halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context);
      return [ops56.image.resizeBilinear(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
    }
    case "ResizeNearestNeighbor": {
      const images = getParamValue("images", node, tensorMap, context);
      const size = getParamValue("size", node, tensorMap, context);
      const alignCorners = getParamValue("alignCorners", node, tensorMap, context);
      const halfPixelCenters = getParamValue("halfPixelCenters", node, tensorMap, context);
      return [ops56.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners, halfPixelCenters)];
    }
    case "CropAndResize": {
      const image2 = getParamValue("image", node, tensorMap, context);
      const boxes = getParamValue("boxes", node, tensorMap, context);
      const boxInd = getParamValue("boxInd", node, tensorMap, context);
      const cropSize = getParamValue("cropSize", node, tensorMap, context);
      const method = getParamValue("method", node, tensorMap, context);
      const extrapolationValue = getParamValue("extrapolationValue", node, tensorMap, context);
      return [ops56.image.cropAndResize(image2, boxes, boxInd, cropSize, method, extrapolationValue)];
    }
    case "ImageProjectiveTransformV3": {
      const images = getParamValue("images", node, tensorMap, context);
      const transforms = getParamValue("transforms", node, tensorMap, context);
      const outputShape = getParamValue("outputShape", node, tensorMap, context);
      const fillValue = getParamValue("fillValue", node, tensorMap, context);
      const interpolation = getParamValue("interpolation", node, tensorMap, context);
      const fillMode = getParamValue("fillMode", node, tensorMap, context);
      return [ops56.image.transform(images, transforms, interpolation.toLowerCase(), fillMode.toLowerCase(), fillValue, outputShape)];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_image_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/logical_executor.js
var executeOp11 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Equal": {
      return [ops56.equal(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "NotEqual": {
      return [ops56.notEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Greater": {
      return [ops56.greater(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "GreaterEqual": {
      return [ops56.greaterEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Less": {
      return [ops56.less(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "LessEqual": {
      return [ops56.lessEqual(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "LogicalAnd": {
      return [ops56.logicalAnd(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "LogicalNot": {
      return [ops56.logicalNot(getParamValue("a", node, tensorMap, context))];
    }
    case "LogicalOr": {
      return [ops56.logicalOr(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "Select":
    case "SelectV2": {
      return [ops56.where(getParamValue("condition", node, tensorMap, context), getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    case "BitwiseAnd": {
      return [ops56.bitwiseAnd(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_logical_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/matrices_executor.js
var executeOp12 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [ops56.matMul(getParamValue("a", node, tensorMap, context), getParamValue("b", node, tensorMap, context), getParamValue("transposeA", node, tensorMap, context), getParamValue("transposeB", node, tensorMap, context))];
    case "Einsum":
      return [ops56.einsum(getParamValue("equation", node, tensorMap, context), ...getParamValue("tensors", node, tensorMap, context))];
    case "Transpose":
      return [ops56.transpose(getParamValue("x", node, tensorMap, context), getParamValue("perm", node, tensorMap, context))];
    case "_FusedMatMul":
      const [extraOp, activationFunc] = getParamValue("fusedOps", node, tensorMap, context);
      const isBiasAdd = extraOp === "biasadd";
      const isPrelu = activationFunc === "prelu";
      const numArgs = getParamValue("numArgs", node, tensorMap, context);
      const leakyreluAlpha = getParamValue("leakyreluAlpha", node, tensorMap, context);
      if (isBiasAdd) {
        if (isPrelu && numArgs !== 2) {
          throw new Error("Fused MatMul with BiasAdd and Prelu must have two " + "extra arguments: bias and alpha.");
        }
        if (!isPrelu && numArgs !== 1) {
          throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
        }
      }
      const [biasArg, preluArg] = getParamValue("args", node, tensorMap, context);
      return [ops56.fused.matMul({
        a: getParamValue("a", node, tensorMap, context),
        b: getParamValue("b", node, tensorMap, context),
        transposeA: getParamValue("transposeA", node, tensorMap, context),
        transposeB: getParamValue("transposeB", node, tensorMap, context),
        bias: biasArg,
        activation: activationFunc,
        preluActivationWeights: preluArg,
        leakyreluAlpha
      })];
    case "MatrixBandPart":
      return [ops56.linalg.bandPart(getParamValue("a", node, tensorMap, context), getParamValue("numLower", node, tensorMap, context), getParamValue("numUpper", node, tensorMap, context))];
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_matrices_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/normalization_executor.js
var executeOp13 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "EuclideanNorm":
      return [ops56.euclideanNorm(getParamValue("x", node, tensorMap, context), getParamValue("axis", node, tensorMap, context), getParamValue("keepDims", node, tensorMap, context))];
    case "FusedBatchNorm":
    case "FusedBatchNormV2": {
      return [ops56.batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
    }
    case "FusedBatchNormV3": {
      return [ops56.batchNorm(getParamValue("x", node, tensorMap, context), getParamValue("mean", node, tensorMap, context), getParamValue("variance", node, tensorMap, context), getParamValue("offset", node, tensorMap, context), getParamValue("scale", node, tensorMap, context), getParamValue("epsilon", node, tensorMap, context))];
    }
    case "LRN": {
      return [ops56.localResponseNormalization(getParamValue("x", node, tensorMap, context), getParamValue("radius", node, tensorMap, context), getParamValue("bias", node, tensorMap, context), getParamValue("alpha", node, tensorMap, context), getParamValue("beta", node, tensorMap, context))];
    }
    case "Softmax": {
      return [ops56.softmax(getParamValue("x", node, tensorMap, context))];
    }
    case "LogSoftmax": {
      return [ops56.logSoftmax(getParamValue("x", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_normalization_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/ragged_executor.js
var executeOp14 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "RaggedGather": {
      const { outputNestedSplits, outputDenseValues } = ops56.raggedGather(getParamValue("paramsNestedSplits", node, tensorMap, context), getParamValue("paramsDenseValues", node, tensorMap, context), getParamValue("indices", node, tensorMap, context), getParamValue("outputRaggedRank", node, tensorMap, context));
      return outputNestedSplits.concat(outputDenseValues);
    }
    case "RaggedRange": {
      const { rtNestedSplits, rtDenseValues } = ops56.raggedRange(getParamValue("starts", node, tensorMap, context), getParamValue("limits", node, tensorMap, context), getParamValue("splits", node, tensorMap, context));
      return [rtNestedSplits, rtDenseValues];
    }
    case "RaggedTensorToTensor": {
      return [ops56.raggedTensorToTensor(getParamValue("shape", node, tensorMap, context), getParamValue("values", node, tensorMap, context), getParamValue("defaultValue", node, tensorMap, context), getParamValue("rowPartitionTensors", node, tensorMap, context), getParamValue("rowPartitionTypes", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_ragged_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/reduction_executor.js
var executeOp15 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Max": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.max(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "Mean": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.mean(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "Min": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.min(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "Sum": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.sum(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "All": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.all(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "Any": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.any(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "ArgMax": {
      const axis = getParamValue("axis", node, tensorMap, context);
      return [ops56.argMax(getParamValue("x", node, tensorMap, context), axis)];
    }
    case "ArgMin": {
      const axis = getParamValue("axis", node, tensorMap, context);
      return [ops56.argMin(getParamValue("x", node, tensorMap, context), axis)];
    }
    case "Prod": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const keepDims = getParamValue("keepDims", node, tensorMap, context);
      return [ops56.prod(getParamValue("x", node, tensorMap, context), axis, keepDims)];
    }
    case "Cumprod": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const exclusive = getParamValue("exclusive", node, tensorMap, context);
      const reverse10 = getParamValue("reverse", node, tensorMap, context);
      return [ops56.cumprod(getParamValue("x", node, tensorMap, context), axis, exclusive, reverse10)];
    }
    case "Cumsum": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const exclusive = getParamValue("exclusive", node, tensorMap, context);
      const reverse10 = getParamValue("reverse", node, tensorMap, context);
      return [ops56.cumsum(getParamValue("x", node, tensorMap, context), axis, exclusive, reverse10)];
    }
    case "Bincount":
      const x = getParamValue("x", node, tensorMap, context);
      const weights = getParamValue("weights", node, tensorMap, context);
      const size = getParamValue("size", node, tensorMap, context);
      return [ops56.bincount(x, weights, size)];
    case "DenseBincount": {
      const x2 = getParamValue("x", node, tensorMap, context);
      const weights2 = getParamValue("weights", node, tensorMap, context);
      const size2 = getParamValue("size", node, tensorMap, context);
      const binaryOutput = getParamValue("binaryOutput", node, tensorMap, context);
      return [ops56.denseBincount(x2, weights2, size2, binaryOutput)];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_reduction_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js
var executeOp16 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "ConcatV2":
    case "Concat": {
      const n = getParamValue("n", node, tensorMap, context);
      const axis = getParamValue("axis", node, tensorMap, context);
      let inputs = getParamValue("tensors", node, tensorMap, context);
      inputs = inputs.slice(0, n);
      return [ops56.concat(inputs, axis)];
    }
    case "Gather": {
      const input2 = getParamValue("x", node, tensorMap, context);
      const indices = getParamValue("indices", node, tensorMap, context);
      return [ops56.gather(input2, ops56.cast(indices, "int32"), 0)];
    }
    case "GatherV2": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const batchDims = getParamValue("batchDims", node, tensorMap, context);
      const input2 = getParamValue("x", node, tensorMap, context);
      const indices = getParamValue("indices", node, tensorMap, context);
      return [ops56.gather(input2, ops56.cast(indices, "int32"), axis, batchDims)];
    }
    case "Reverse": {
      const dims = getParamValue("dims", node, tensorMap, context);
      const axis = [];
      for (let i = 0;i < dims.length; i++) {
        if (dims[i]) {
          axis.push(i);
        }
      }
      const input2 = getParamValue("x", node, tensorMap, context);
      return [ops56.reverse(input2, axis)];
    }
    case "ReverseV2": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const input2 = getParamValue("x", node, tensorMap, context);
      return [ops56.reverse(input2, axis)];
    }
    case "Slice": {
      const begin = getParamValue("begin", node, tensorMap, context);
      const size = getParamValue("size", node, tensorMap, context);
      return [ops56.slice(getParamValue("x", node, tensorMap, context), begin, size)];
    }
    case "StridedSlice": {
      const begin = getParamValue("begin", node, tensorMap, context);
      const end = getParamValue("end", node, tensorMap, context);
      const strides = getParamValue("strides", node, tensorMap, context);
      const beginMask = getParamValue("beginMask", node, tensorMap, context);
      const endMask = getParamValue("endMask", node, tensorMap, context);
      const ellipsisMask = getParamValue("ellipsisMask", node, tensorMap, context);
      const newAxisMask = getParamValue("newAxisMask", node, tensorMap, context);
      const shrinkAxisMask = getParamValue("shrinkAxisMask", node, tensorMap, context);
      const tensor153 = getParamValue("x", node, tensorMap, context);
      return [ops56.stridedSlice(tensor153, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];
    }
    case "Pack": {
      return tidy(() => {
        const axis = getParamValue("axis", node, tensorMap, context);
        const tensors = getParamValue("tensors", node, tensorMap, context);
        const shape = tensors[0].shape;
        const squeezedShape = ops56.squeeze(tensors[0]).shape;
        const mapped = tensors.map((tensor153) => {
          const sameShape = exports_util.arraysEqual(tensor153.shape, shape);
          if (!sameShape && !exports_util.arraysEqual(ops56.squeeze(tensor153).shape, squeezedShape)) {
            throw new Error("the input tensors shape does not match");
          }
          return sameShape ? tensor153 : ops56.reshape(tensor153, shape);
        });
        return [ops56.stack(mapped, axis)];
      });
    }
    case "Unpack": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const tensor153 = getParamValue("tensor", node, tensorMap, context);
      return ops56.unstack(tensor153, axis);
    }
    case "Tile": {
      const reps = getParamValue("reps", node, tensorMap, context);
      return [ops56.tile(getParamValue("x", node, tensorMap, context), reps)];
    }
    case "Split":
    case "SplitV": {
      const axis = getParamValue("axis", node, tensorMap, context);
      const numOrSizeSplits = getParamValue("numOrSizeSplits", node, tensorMap, context);
      const tensor153 = getParamValue("x", node, tensorMap, context);
      return ops56.split(tensor153, numOrSizeSplits, axis);
    }
    case "ScatterNd": {
      const indices = getParamValue("indices", node, tensorMap, context);
      const values = getParamValue("values", node, tensorMap, context);
      const shape = getParamValue("shape", node, tensorMap, context);
      return [ops56.scatterND(indices, values, shape)];
    }
    case "GatherNd": {
      const x = getParamValue("x", node, tensorMap, context);
      const indices = getParamValue("indices", node, tensorMap, context);
      return [ops56.gatherND(x, indices)];
    }
    case "SparseToDense": {
      const indices = getParamValue("sparseIndices", node, tensorMap, context);
      const shape = getParamValue("outputShape", node, tensorMap, context);
      const sparseValues = getParamValue("sparseValues", node, tensorMap, context);
      const defaultValue = getParamValue("defaultValue", node, tensorMap, context);
      return [ops56.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops56.cast(defaultValue, sparseValues.dtype))];
    }
    case "TensorScatterUpdate": {
      const indices = getParamValue("indices", node, tensorMap, context);
      const values = getParamValue("values", node, tensorMap, context);
      const tensor153 = getParamValue("tensor", node, tensorMap, context);
      return [ops56.tensorScatterUpdate(tensor153, indices, values)];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_slice_join_executor = __esm(() => {
  init_dist();
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/sparse_executor.js
var executeOp17 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "SparseFillEmptyRows": {
      const { outputIndices, outputValues, emptyRowIndicator, reverseIndexMap } = ops56.sparse.sparseFillEmptyRows(getParamValue("indices", node, tensorMap, context), getParamValue("values", node, tensorMap, context), getParamValue("denseShape", node, tensorMap, context), getParamValue("defaultValue", node, tensorMap, context));
      return [
        outputIndices,
        outputValues,
        emptyRowIndicator,
        reverseIndexMap
      ];
    }
    case "SparseReshape": {
      const { outputIndices, outputShape } = ops56.sparse.sparseReshape(getParamValue("inputIndices", node, tensorMap, context), getParamValue("inputShape", node, tensorMap, context), getParamValue("newShape", node, tensorMap, context));
      return [outputIndices, outputShape];
    }
    case "SparseSegmentMean": {
      const outputData = ops56.sparse.sparseSegmentMean(getParamValue("data", node, tensorMap, context), getParamValue("indices", node, tensorMap, context), getParamValue("segmentIds", node, tensorMap, context));
      return [outputData];
    }
    case "SparseSegmentSum": {
      const outputData = ops56.sparse.sparseSegmentSum(getParamValue("data", node, tensorMap, context), getParamValue("indices", node, tensorMap, context), getParamValue("segmentIds", node, tensorMap, context));
      return [outputData];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_sparse_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/spectral_executor.js
var executeOp18 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "FFT": {
      return [ops56.fft(getParamValue("x", node, tensorMap, context))];
    }
    case "IFFT": {
      return [ops56.ifft(getParamValue("x", node, tensorMap, context))];
    }
    case "RFFT": {
      return [ops56.rfft(getParamValue("x", node, tensorMap, context))];
    }
    case "IRFFT": {
      return [ops56.irfft(getParamValue("x", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_spectral_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/string_executor.js
var executeOp19 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "StaticRegexReplace": {
      return [ops56.string.staticRegexReplace(getParamValue("input", node, tensorMap, context), getParamValue("pattern", node, tensorMap, context), getParamValue("rewrite", node, tensorMap, context), getParamValue("replaceGlobal", node, tensorMap, context))];
    }
    case "StringNGrams": {
      const { nGrams, nGramsSplits } = ops56.string.stringNGrams(getParamValue("data", node, tensorMap, context), getParamValue("dataSplits", node, tensorMap, context), getParamValue("separator", node, tensorMap, context), getParamValue("nGramWidths", node, tensorMap, context), getParamValue("leftPad", node, tensorMap, context), getParamValue("rightPad", node, tensorMap, context), getParamValue("padWidth", node, tensorMap, context), getParamValue("preserveShortSequences", node, tensorMap, context));
      return [nGrams, nGramsSplits];
    }
    case "StringSplit": {
      const { indices, values, shape } = ops56.string.stringSplit(getParamValue("input", node, tensorMap, context), getParamValue("delimiter", node, tensorMap, context), getParamValue("skipEmpty", node, tensorMap, context));
      return [indices, values, shape];
    }
    case "StringToHashBucketFast": {
      const output = ops56.string.stringToHashBucketFast(getParamValue("input", node, tensorMap, context), getParamValue("numBuckets", node, tensorMap, context));
      return [output];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_string_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/executors/transformation_executor.js
var executeOp20 = (node, tensorMap, context, ops56 = exports_ops_for_converter) => {
  switch (node.op) {
    case "Cast": {
      return [ops56.cast(getParamValue("x", node, tensorMap, context), getParamValue("dtype", node, tensorMap, context))];
    }
    case "ExpandDims": {
      const axis = getParamValue("axis", node, tensorMap, context);
      return [ops56.expandDims(getParamValue("x", node, tensorMap, context), axis)];
    }
    case "Squeeze": {
      const axis = getParamValue("axis", node, tensorMap, context);
      return [ops56.squeeze(getParamValue("x", node, tensorMap, context), axis)];
    }
    case "Reshape": {
      return [ops56.reshape(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
    }
    case "EnsureShape": {
      return [ops56.ensureShape(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
    }
    case "MirrorPad": {
      return [ops56.mirrorPad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("mode", node, tensorMap, context))];
    }
    case "PadV2":
    case "Pad": {
      return [ops56.pad(getParamValue("x", node, tensorMap, context), getParamValue("padding", node, tensorMap, context), getParamValue("constantValue", node, tensorMap, context))];
    }
    case "SpaceToBatchND": {
      const blockShape = getParamValue("blockShape", node, tensorMap, context);
      const paddings = getParamValue("paddings", node, tensorMap, context);
      return [ops56.spaceToBatchND(getParamValue("x", node, tensorMap, context), blockShape, paddings)];
    }
    case "BatchToSpaceND": {
      const blockShape = getParamValue("blockShape", node, tensorMap, context);
      const crops = getParamValue("crops", node, tensorMap, context);
      return [ops56.batchToSpaceND(getParamValue("x", node, tensorMap, context), blockShape, crops)];
    }
    case "DepthToSpace": {
      const blockSize = getParamValue("blockSize", node, tensorMap, context);
      const dataFormat = getParamValue("dataFormat", node, tensorMap, context).toUpperCase();
      return [ops56.depthToSpace(getParamValue("x", node, tensorMap, context), blockSize, dataFormat)];
    }
    case "BroadcastTo": {
      return [ops56.broadcastTo(getParamValue("x", node, tensorMap, context), getParamValue("shape", node, tensorMap, context))];
    }
    case "BroadcastArgs": {
      return [ops56.broadcastArgs(getParamValue("s0", node, tensorMap, context), getParamValue("s1", node, tensorMap, context))];
    }
    default:
      throw TypeError(`Node type ${node.op} is not implemented`);
  }
};
var init_transformation_executor = __esm(() => {
  init_ops_for_converter();
  init_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/operations/operation_executor.js
function executeOp21(node, tensorMap, context, resourceManager, tidy2 = tidy) {
  const value = ((node2, tensorMap2, context2) => {
    switch (node2.category) {
      case "arithmetic":
        return tidy2(() => executeOp(node2, tensorMap2, context2));
      case "basic_math":
        return tidy2(() => executeOp2(node2, tensorMap2, context2));
      case "control":
        return executeOp3(node2, tensorMap2, context2);
      case "convolution":
        return tidy2(() => executeOp4(node2, tensorMap2, context2));
      case "creation":
        return tidy2(() => executeOp5(node2, tensorMap2, context2));
      case "dynamic":
        return executeOp6(node2, tensorMap2, context2);
      case "evaluation":
        return tidy2(() => executeOp7(node2, tensorMap2, context2));
      case "image":
        return tidy2(() => executeOp10(node2, tensorMap2, context2));
      case "graph":
        return tidy2(() => executeOp8(node2, tensorMap2, context2));
      case "logical":
        return tidy2(() => executeOp11(node2, tensorMap2, context2));
      case "matrices":
        return tidy2(() => executeOp12(node2, tensorMap2, context2));
      case "normalization":
        return tidy2(() => executeOp13(node2, tensorMap2, context2));
      case "ragged":
        return tidy2(() => executeOp14(node2, tensorMap2, context2));
      case "reduction":
        return tidy2(() => executeOp15(node2, tensorMap2, context2));
      case "slice_join":
        return tidy2(() => executeOp16(node2, tensorMap2, context2));
      case "sparse":
        return tidy2(() => executeOp17(node2, tensorMap2, context2));
      case "spectral":
        return tidy2(() => executeOp18(node2, tensorMap2, context2));
      case "string":
        return tidy2(() => executeOp19(node2, tensorMap2, context2));
      case "transformation":
        return tidy2(() => executeOp20(node2, tensorMap2, context2));
      case "hash_table":
        return executeOp9(node2, tensorMap2, context2, resourceManager);
      case "custom":
        const opMapper = getRegisteredOp(node2.op);
        if (opMapper && opMapper.customExecutor) {
          return opMapper.customExecutor(new NodeValueImpl(node2, tensorMap2, context2));
        } else {
          throw TypeError(`Custom op ${node2.op} is not registered.`);
        }
      default:
        throw TypeError(`Unknown op '${node2.op}'. File an issue at ` + `https://github.com/tensorflow/tfjs/issues so we can add it` + `, or register a custom execution with tf.registerOp()`);
    }
  })(node, tensorMap, context);
  if (exports_util.isPromise(value)) {
    return value.then((data) => [].concat(data));
  }
  return [].concat(value);
}
var init_operation_executor = __esm(() => {
  init_dist();
  init_node_value_impl();
  init_register();
  init_arithmetic_executor();
  init_basic_math_executor();
  init_control_executor();
  init_convolution_executor();
  init_creation_executor();
  init_dynamic_executor();
  init_evaluation_executor();
  init_graph_executor();
  init_hash_table_executor();
  init_image_executor();
  init_logical_executor();
  init_matrices_executor();
  init_normalization_executor();
  init_ragged_executor();
  init_reduction_executor();
  init_slice_join_executor();
  init_sparse_executor();
  init_spectral_executor();
  init_string_executor();
  init_transformation_executor();
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/execution_context.js
class ExecutionContext {
  constructor(weightMap = {}, tensorArrayMap = {}, tensorListMap = {}, functionMap = {}, parseNodeNameCache) {
    this.weightMap = weightMap;
    this.tensorArrayMap = tensorArrayMap;
    this.tensorListMap = tensorListMap;
    this.functionMap = functionMap;
    this.parseNodeNameCache = parseNodeNameCache;
    this.rootContext = { id: 0, frameName: "", iterationId: 0 };
    this.contexts = [this.rootContext];
    this.lastId = 0;
    this.generateCurrentContextIds();
  }
  newFrame(id, frameName) {
    return { id, frameName, iterationId: 0 };
  }
  set currentContext(contexts) {
    if (this.contexts !== contexts) {
      this.contexts = contexts;
      this.generateCurrentContextIds();
    }
  }
  get currentContext() {
    return this.contexts;
  }
  get currentContextId() {
    return this._currentContextIds[0];
  }
  get currentContextIds() {
    return this._currentContextIds;
  }
  generateCurrentContextIds() {
    const names = [];
    for (let i = 0;i < this.contexts.length - 1; i++) {
      const contexts = this.contexts.slice(0, this.contexts.length - i);
      names.push(this.contextIdforContexts(contexts));
    }
    names.push("");
    this._currentContextIds = names;
  }
  contextIdforContexts(contexts) {
    return contexts ? contexts.map((context) => context.id === 0 && context.iterationId === 0 ? "" : `${context.frameName}-${context.iterationId}`).join("/") : "";
  }
  enterFrame(frameId) {
    if (this.contexts) {
      this.lastId++;
      this.contexts = this.contexts.slice();
      this.contexts.push(this.newFrame(this.lastId, frameId));
      this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));
    }
  }
  exitFrame() {
    if (this.contexts && this.contexts.length > 1) {
      this.contexts = this.contexts.slice();
      this.contexts.splice(-1);
      this.currentContextIds.shift();
    } else {
      throw new Error("Cannot exit frame, the context is empty");
    }
  }
  nextIteration() {
    if (this.contexts && this.contexts.length > 0) {
      this.contexts = this.contexts.slice();
      this.lastId++;
      const context = Object.assign({}, this.contexts[this.contexts.length - 1]);
      context.iterationId += 1;
      context.id = this.lastId;
      this.contexts.splice(-1, 1, context);
      this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
    } else {
      throw new Error("Cannot increase frame iteration, the context is empty");
    }
  }
  getWeight(name) {
    return this.weightMap[name];
  }
  addTensorArray(tensorArray) {
    this.tensorArrayMap[tensorArray.id] = tensorArray;
  }
  getTensorArray(id) {
    return this.tensorArrayMap[id];
  }
  addTensorList(tensorList) {
    this.tensorListMap[tensorList.id] = tensorList;
  }
  getTensorList(id) {
    return this.tensorListMap[id];
  }
  dispose(keepIds) {
    for (const key in this.tensorArrayMap) {
      this.tensorArrayMap[key].clearAndClose(keepIds);
    }
    for (const key in this.tensorListMap) {
      this.tensorListMap[key].clearAndClose(keepIds);
    }
  }
}

// node_modules/@tensorflow/tfjs-converter/dist/executor/model_analysis.js
function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {
  const usedNodes = new Set;
  const missingInputs = [];
  let dynamicNode = null;
  let syncInputs = null;
  const seen = new Set;
  const inputNodeNames = new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));
  initNodes = initNodes || [];
  const initNodeNames = new Set(initNodes.map((node) => parseNodeName(node.name)[0]));
  const frontier = [...outputs];
  while (frontier.length > 0) {
    const node = frontier.pop();
    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {
      if (dynamicNode == null) {
        dynamicNode = node;
        syncInputs = dynamicNode.children.map((child) => child.name).filter((name) => usedNodes.has(name));
      }
    }
    usedNodes.add(node.name);
    if (weightMap[node.name] != null) {
      continue;
    }
    if (inputNodeNames.has(node.name)) {
      continue;
    }
    if (initNodeNames.has(node.name)) {
      continue;
    }
    if (node.inputs.length === 0) {
      missingInputs.push(node.name);
      continue;
    }
    node.inputs.forEach((input2) => {
      if (seen.has(input2.name)) {
        return;
      }
      seen.add(input2.name);
      frontier.push(input2);
    });
  }
  return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };
}
function getNodesInTopologicalOrder(graph, executionInfo) {
  const { usedNodes, inputs } = executionInfo;
  const inputNodes = Object.keys(inputs).map((name) => parseNodeName(name)[0]).map((name) => graph.nodes[name]);
  const initNodes = graph.initNodes || [];
  const isUsed = (node) => usedNodes.has(typeof node === "string" ? node : node.name);
  function unique5(nodes) {
    return [...new Map(nodes.map((node) => [node.name, node])).values()];
  }
  const predefinedNodes = unique5([
    ...inputNodes,
    ...graph.weights,
    ...initNodes
  ]).filter(isUsed);
  const allNodes = unique5([
    ...predefinedNodes,
    ...Object.values(graph.nodes)
  ]).filter(isUsed);
  const nameToNode = new Map(allNodes.map((node) => [node.name, node]));
  const inCounts = {};
  for (const node of allNodes) {
    inCounts[node.name] = inCounts[node.name] || 0;
    for (const child of node.children) {
      if (!isUsed(child)) {
        inCounts[child.name] = Number.POSITIVE_INFINITY;
      }
      inCounts[child.name] = (inCounts[child.name] || 0) + 1;
    }
  }
  const frontier = Object.entries(inCounts).filter(([, inCount]) => inCount === 0).map(([name]) => name);
  const orderedNodeNames = [...frontier];
  while (frontier.length > 0) {
    const nodeName = frontier.pop();
    const node = nameToNode.get(nodeName);
    for (const child of node.children.filter(isUsed)) {
      if (--inCounts[child.name] === 0) {
        orderedNodeNames.push(child.name);
        frontier.push(child.name);
      }
    }
  }
  const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));
  const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);
  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);
  return filteredOrderedNodes;
}
function filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {
  const nameToNode = new Map(orderedNodes.map((node) => [node.name, node]));
  const stack9 = predefinedNodes.map((node) => node.name);
  const predefinedReachableNodeNames = new Set(stack9);
  while (stack9.length > 0) {
    const nodeName = stack9.pop();
    const node = nameToNode.get(nodeName);
    for (const child of node.children) {
      if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {
        continue;
      }
      predefinedReachableNodeNames.add(child.name);
      stack9.push(child.name);
    }
  }
  const filteredOrderedNodes = orderedNodes.filter((node) => predefinedReachableNodeNames.has(node.name));
  return filteredOrderedNodes;
}
function validateNodesExecutionOrder(orderedNodes, predefinedNodes) {
  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
  const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));
  const isPredefined = (node) => predefinedNodeNames.has(typeof node === "string" ? node : node.name);
  const willBeExecutedNodeNames = new Set(orderedNodes.map((node) => node.name));
  const willBeExecuted = (node) => willBeExecutedNodeNames.has(typeof node === "string" ? node : node.name);
  for (const node of orderedNodes) {
    for (const child of node.children.filter(willBeExecuted)) {
      if (!nodeNameToOrder.has(child.name)) {
        throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);
      }
      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {
        throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);
      }
    }
    if (!isPredefined(node)) {
      for (const input2 of node.inputs) {
        if (!nodeNameToOrder.has(input2.name)) {
          throw new NodesExecutionOrderError(`Input ${input2.name} of node ${node.name} is unreachable.`);
        }
        if (nodeNameToOrder.get(input2.name) > nodeNameToOrder.get(node.name)) {
          throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input2.name}.`);
        }
      }
    }
  }
}
function getNodeLiveUntilMap(orderedNodes) {
  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));
  const INF_LIFE = Number.MAX_SAFE_INTEGER;
  const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);
  const getSelfLifeSpan = (node) => {
    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];
    if (selfLife == null) {
      return -1;
    }
    return selfLife;
  };
  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {
    return node.children.map(getSelfLifeSpan).reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);
  });
  const liveUntilMap = new Map;
  for (let nodeOrder = 0;nodeOrder < orderedNodes.length; ++nodeOrder) {
    const liveUntilOrder = liveUntilOrders[nodeOrder];
    if (liveUntilOrder === INF_LIFE) {
      continue;
    }
    const node = orderedNodes[nodeOrder];
    const liveUntilNode = orderedNodes[liveUntilOrder];
    if (!liveUntilMap.has(liveUntilNode.name)) {
      liveUntilMap.set(liveUntilNode.name, []);
    }
    liveUntilMap.get(liveUntilNode.name).push(node);
  }
  return liveUntilMap;
}
function isControlFlow(node) {
  return CONTROL_FLOW_OPS.has(node.op);
}
function isDynamicShape(node) {
  return DYNAMIC_SHAPE_OPS.has(node.op);
}
function isHashTable(node) {
  return HASH_TABLE_OPS.has(node.op);
}
var NodesExecutionOrderError, CONTROL_FLOW_OPS, DYNAMIC_SHAPE_OPS, HASH_TABLE_OPS;
var init_model_analysis = __esm(() => {
  init_utils();
  NodesExecutionOrderError = class NodesExecutionOrderError extends Error {
    constructor(message) {
      super(`NodesExecutionOrderError: ${message}`);
    }
  };
  CONTROL_FLOW_OPS = new Set([
    "Switch",
    "Merge",
    "Enter",
    "Exit",
    "NextIteration",
    "StatelessIf",
    "StatelessWhile",
    "if",
    "While"
  ]);
  DYNAMIC_SHAPE_OPS = new Set([
    "NonMaxSuppressionV2",
    "NonMaxSuppressionV3",
    "NonMaxSuppressionV5",
    "Where"
  ]);
  HASH_TABLE_OPS = new Set([
    "HashTable",
    "HashTableV2",
    "LookupTableImport",
    "LookupTableImportV2",
    "LookupTableFind",
    "LookupTableFindV2",
    "LookupTableSize",
    "LookupTableSizeV2"
  ]);
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/graph_executor.js
class GraphExecutor {
  get weightIds() {
    return this.parent ? this.parent.weightIds : this._weightIds;
  }
  get functionExecutorMap() {
    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
  }
  get weightMap() {
    return this.parent ? this.parent.weightMap : this._weightMap;
  }
  set weightMap(weightMap) {
    const weightIds = Object.keys(weightMap).map((key) => weightMap[key].map((tensor153) => tensor153.id));
    this._weightIds = [].concat(...weightIds);
    this._weightMap = weightMap;
  }
  set resourceManager(resourceManager) {
    this._resourceManager = resourceManager;
  }
  get inputs() {
    return this._inputs.map((node) => {
      return {
        name: node.name,
        shape: node.attrParams["shape"] ? node.attrParams["shape"].value : undefined,
        dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : undefined
      };
    });
  }
  get outputs() {
    return this._outputs.map((node) => {
      return {
        name: node.name,
        shape: node.attrParams["shape"] ? node.attrParams["shape"].value : undefined,
        dtype: node.attrParams["dtype"] ? node.attrParams["dtype"].value : undefined
      };
    });
  }
  get inputNodes() {
    return this._inputs.map((node) => node.signatureKey || node.name);
  }
  get outputNodes() {
    return this._outputs.map((node) => {
      const name = node.signatureKey || node.name;
      return node.defaultOutput ? `${name}:${node.defaultOutput}` : name;
    });
  }
  get functions() {
    return Object.keys(this._functions).reduce((map, key) => {
      map[key] = this._functions[key].signature;
      return map;
    }, {});
  }
  constructor(graph, parent) {
    this.graph = graph;
    this.parent = parent;
    this.compiledMap = new Map;
    this.parseNodeNameCache = new Map;
    this._weightMap = {};
    this.SEPARATOR = ",";
    this._functions = {};
    this._functionExecutorMap = {};
    this.keepIntermediateTensors = false;
    this._outputs = graph.outputs;
    this._inputs = graph.inputs;
    this._initNodes = graph.initNodes;
    this._signature = graph.signature;
    this._functions = graph.functions;
    if (graph.functions != null) {
      Object.keys(graph.functions).forEach((name) => {
        this._functionExecutorMap[name] = new GraphExecutor(graph.functions[name], this);
      });
    }
  }
  getCompilationKey(inputs, outputs) {
    const sortedInputs = inputs.map((node) => node.name).sort();
    const sortedOutputs = outputs.map((node) => node.name).sort();
    return sortedInputs.join(this.SEPARATOR) + "--" + sortedOutputs.join(this.SEPARATOR);
  }
  compile(inputs, outputs) {
    const executionInfo = getExecutionSubgraph(inputs, outputs, this.weightMap, this._initNodes);
    const { missingInputs, dynamicNode, syncInputs } = executionInfo;
    if (dynamicNode != null) {
      throw new Error(`This execution contains the node '${dynamicNode.name}', which has ` + `the dynamic op '${dynamicNode.op}'. Please use ` + `model.executeAsync() instead. Alternatively, to avoid the ` + `dynamic ops, specify the inputs [${syncInputs}]`);
    }
    if (missingInputs.length > 0) {
      const outNames = outputs.map((n) => n.name);
      const inNames = Object.keys(inputs);
      throw new Error(`Cannot compute the outputs [${outNames}] from the provided inputs ` + `[${inNames}]. Missing the following inputs: [${missingInputs}]`);
    }
    const orderedNodes = getNodesInTopologicalOrder(this.graph, executionInfo);
    const nodeLiveUntilMap = getNodeLiveUntilMap(orderedNodes);
    return { orderedNodes, nodeLiveUntilMap };
  }
  cloneAndKeepTensor(tensor153) {
    if (tensor153 == null) {
      return null;
    }
    const clone6 = tensor153.clone();
    keep(clone6);
    return clone6;
  }
  cloneTensorList(tensors) {
    if (!tensors) {
      return null;
    }
    const clonedTensor = tensors.map((tensor153) => {
      return this.cloneAndKeepTensor(tensor153);
    });
    return clonedTensor;
  }
  cloneTensorMap(tensorsMap) {
    return Object.fromEntries(Object.entries(tensorsMap).map(([name, tensorsList]) => {
      return [name, this.cloneTensorList(tensorsList)];
    }));
  }
  execute(inputs, outputs) {
    this.disposeIntermediateTensors();
    inputs = this.mapInputs(inputs);
    const names = Object.keys(inputs).sort();
    this.checkInputs(inputs);
    this.checkInputShapeAndType(inputs);
    outputs = this.mapOutputs(outputs);
    this.checkOutputs(outputs);
    const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
    const outputNodeNames = outputs.map((name) => parseNodeName(name)[0]);
    const outputNodeNameSet = new Set(outputNodeNames);
    let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
    if (outputNodes.length === 0) {
      outputNodes = this._outputs;
    }
    const compilationKey = this.getCompilationKey(inputNodes, outputNodes);
    let compilation = this.compiledMap.get(compilationKey);
    if (compilation == null) {
      compilation = this.compile(inputs, outputNodes);
      this.compiledMap.set(compilationKey, compilation);
    }
    try {
      this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (e) {
      this.keepIntermediateTensors = false;
      console.warn(e.message);
    }
    const tensorArrayMap = {};
    const tensorListMap = {};
    return tidy(() => {
      const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap, this.parseNodeNameCache);
      const tensorsMap = Object.assign({}, this.weightMap);
      if (this.keepIntermediateTensors) {
        this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
      }
      Object.keys(inputs).forEach((name) => {
        const [nodeName, index] = parseNodeName(name, context);
        const tensors = [];
        tensors[index] = inputs[name];
        tensorsMap[nodeName] = tensors;
        if (this.keepIntermediateTensors) {
          this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
        }
      });
      const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
      const { orderedNodes, nodeLiveUntilMap } = compilation;
      for (const node of orderedNodes) {
        if (tensorsMap[node.name]) {
          continue;
        }
        const tensors = executeOp21(node, tensorsMap, context, this._resourceManager);
        if (exports_util.isPromise(tensors)) {
          throw new Error(`The execution of the op '${node.op}' returned a promise. ` + `Please use model.executeAsync() instead.`);
        }
        tensorsMap[node.name] = tensors;
        if (this.keepIntermediateTensors) {
          this.clonedTensorsMap[node.name] = this.cloneTensorList(tensors);
        }
        this.checkTensorForDisposalWithNodeLiveUntilInfo(node, tensorsMap, context, tensorsToKeep, outputNodeNameSet, nodeLiveUntilMap.get(node.name));
      }
      if (this.parent == null) {
        context.dispose(tensorsToKeep);
      }
      return outputs.map((name) => getTensor(name, tensorsMap, context));
    });
  }
  getFrozenTensorIds(tensorMap) {
    const ids = [].concat.apply([], Object.keys(tensorMap).map((key) => tensorMap[key]).map((tensors) => tensors.map((tensor153) => tensor153.id)));
    return new Set(ids);
  }
  checkTensorForDisposal(nodeName, node, tensorMap, context, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount) {
    if (isControlFlow(node) || outputNodeNameSet.has(nodeName)) {
      return;
    }
    for (const tensor153 of tensorMap[nodeName]) {
      if (tensor153 == null) {
        continue;
      }
      intermediateTensorConsumerCount[tensor153.id] = (intermediateTensorConsumerCount[tensor153.id] || 0) + node.children.length;
    }
    for (const input2 of node.inputs) {
      if (isControlFlow(input2)) {
        continue;
      }
      const tensors = getTensorsForCurrentContext(input2.name, tensorMap, context);
      if (tensors == null) {
        continue;
      }
      for (const tensor153 of tensors) {
        if (!tensor153 || tensor153.kept || tensorsToKeep.has(tensor153.id)) {
          continue;
        }
        const count2 = intermediateTensorConsumerCount[tensor153.id];
        if (count2 === 1) {
          tensor153.dispose();
          delete intermediateTensorConsumerCount[tensor153.id];
        } else if (count2 != null) {
          intermediateTensorConsumerCount[tensor153.id]--;
        }
      }
    }
  }
  checkTensorForDisposalWithNodeLiveUntilInfo(node, tensorMap, context, tensorsToKeep, outputNodeNameSet, liveUntilNodes) {
    function isNonDisposableNode(node2) {
      return isControlFlow(node2) || outputNodeNameSet.has(node2.name);
    }
    if (isControlFlow(node) || liveUntilNodes == null) {
      return;
    }
    for (const nodeToDispose of liveUntilNodes) {
      if (isNonDisposableNode(nodeToDispose)) {
        continue;
      }
      const tensors = getTensorsForCurrentContext(nodeToDispose.name, tensorMap, context);
      for (const tensor153 of tensors) {
        if (!tensor153 || tensor153.kept || tensorsToKeep.has(tensor153.id)) {
          continue;
        }
        tensor153.dispose();
      }
    }
  }
  async executeAsync(inputs, outputs) {
    return this._executeAsync(inputs, outputs);
  }
  disposeIntermediateTensors() {
    if (!this.clonedTensorsMap) {
      return;
    }
    Object.values(this.clonedTensorsMap).forEach((tensorsList) => {
      for (const tensor153 of tensorsList) {
        if (tensor153 && !tensor153.isDisposed) {
          tensor153.dispose();
        }
      }
    });
    this.clonedTensorsMap = null;
  }
  getIntermediateTensors() {
    return this.clonedTensorsMap;
  }
  async _executeAsync(inputs, outputs, isFunctionExecution = false, tensorArrayMap = {}, tensorListMap = {}) {
    this.disposeIntermediateTensors();
    if (!isFunctionExecution) {
      inputs = this.mapInputs(inputs);
      this.checkInputs(inputs);
      this.checkInputShapeAndType(inputs);
      outputs = this.mapOutputs(outputs);
      this.checkOutputs(outputs);
    }
    try {
      this.keepIntermediateTensors = env().getBool("KEEP_INTERMEDIATE_TENSORS");
    } catch (e) {
      this.keepIntermediateTensors = false;
      console.warn(e.message);
    }
    const context = new ExecutionContext(this.weightMap, tensorArrayMap, tensorListMap, this.functionExecutorMap, this.parseNodeNameCache);
    if (this.keepIntermediateTensors) {
      this.clonedTensorsMap = this.cloneTensorMap(this.weightMap);
    }
    const tensorsMap = await this.executeWithControlFlow(inputs, context, outputs, isFunctionExecution);
    const results = outputs.map((name) => getTensor(name, tensorsMap, context));
    const outputIds = results.map((t) => t.id);
    const inputIds = Object.keys(inputs).map((name) => inputs[name].id);
    const keepIds = new Set([...outputIds, ...inputIds, ...this.weightIds]);
    Object.values(tensorsMap).forEach((tensorsList) => {
      tensorsList.forEach((tensor153) => {
        if (tensor153 && !tensor153.isDisposed && !keepIds.has(tensor153.id)) {
          tensor153.dispose();
        }
      });
    });
    if (this.parent == null) {
      context.dispose(keepIds);
    }
    return results;
  }
  async executeFunctionAsync(inputs, tensorArrayMap, tensorListMap) {
    const mappedInputs = inputs.reduce((map, tensor153, index) => {
      map[this.inputs[index].name] = tensor153;
      return map;
    }, {});
    return this._executeAsync(mappedInputs, this.outputNodes, true, tensorArrayMap, tensorListMap);
  }
  async executeWithControlFlow(inputs, context, outputNames, isFunctionExecution) {
    const names = Object.keys(inputs);
    const inputNodes = names.map((name) => this.graph.nodes[parseNodeName(name)[0]]);
    const outputNodeNames = outputNames.map((name) => parseNodeName(name)[0]);
    const outputNodeNameSet = new Set(outputNodeNames);
    let outputNodes = outputNodeNames.map((name) => this.graph.nodes[name]);
    if (outputNodes.length === 0) {
      outputNodes = this._outputs;
    }
    const { usedNodes, missingInputs, dynamicNode, syncInputs } = getExecutionSubgraph(inputs, outputNodes, this.weightMap, this._initNodes);
    const stack9 = [
      ...inputNodes,
      ...this.graph.weights,
      ...this._initNodes || []
    ].map((node) => {
      return { node, contexts: context.currentContext };
    });
    const tensorsMap = Object.assign({}, this.weightMap);
    Object.keys(inputs).forEach((name) => {
      const [nodeName, index] = parseNodeName(name);
      const tensors = [];
      tensors[index] = inputs[name];
      tensorsMap[nodeName] = tensors;
    });
    const intermediateTensorConsumerCount = {};
    const tensorsToKeep = this.getFrozenTensorIds(tensorsMap);
    const added = {};
    while (stack9.length > 0) {
      const promises = this.processStack(inputNodes, stack9, context, tensorsMap, added, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount, usedNodes);
      await Promise.all(promises);
    }
    if (dynamicNode == null && !isFunctionExecution) {
      console.warn(`This model execution did not contain any nodes with control flow ` + `or dynamic output shapes. You can use model.execute() instead.`);
    }
    const missingOutputs = outputNodes.filter((node) => !isControlFlow(node) && !getTensor(node.name, tensorsMap, context)).map((node) => node.name);
    if (missingOutputs.length > 0) {
      let alternativeMsg = "";
      if (dynamicNode != null) {
        alternativeMsg = `Alternatively, to avoid the dynamic ops, use model.execute() ` + `and specify the inputs [${syncInputs}]`;
      }
      throw new Error(`Cannot compute the outputs [${missingOutputs}] from the provided ` + `inputs [${names}]. Consider providing the following inputs: ` + `[${missingInputs}]. ${alternativeMsg}`);
    }
    return tensorsMap;
  }
  processStack(inputNodes, stack9, context, tensorMap, added, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount, usedNodes) {
    const promises = [];
    while (stack9.length > 0) {
      const item = stack9.pop();
      context.currentContext = item.contexts;
      let nodeName = "";
      if (item.node.op === "Enter" && getParamValue("isConstant", item.node, tensorMap, context)) {
        [nodeName] = getNodeNameAndIndex(item.node.name, context);
      }
      if (tensorMap[item.node.name] == null) {
        const tensors = executeOp21(item.node, tensorMap, context, this._resourceManager);
        if (!nodeName) {
          [nodeName] = getNodeNameAndIndex(item.node.name, context);
        }
        const currentContext = context.currentContext;
        if (exports_util.isPromise(tensors)) {
          promises.push(tensors.then((t) => {
            tensorMap[nodeName] = t;
            if (this.keepIntermediateTensors) {
              this.clonedTensorsMap[nodeName] = this.cloneTensorList(t);
            }
            context.currentContext = currentContext;
            this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount);
            this.processChildNodes(item.node, stack9, context, tensorMap, added, usedNodes);
            return t;
          }));
        } else {
          tensorMap[nodeName] = tensors;
          if (this.keepIntermediateTensors) {
            this.clonedTensorsMap[nodeName] = this.cloneTensorList(tensors);
          }
          this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNodeNameSet, intermediateTensorConsumerCount);
          this.processChildNodes(item.node, stack9, context, tensorMap, added, usedNodes);
        }
      } else {
        this.processChildNodes(item.node, stack9, context, tensorMap, added, usedNodes);
      }
    }
    return promises;
  }
  processChildNodes(node, stack9, context, tensorMap, added, usedNodes) {
    node.children.forEach((childNode) => {
      const [nodeName] = getNodeNameAndIndex(childNode.name, context);
      if (added[nodeName] || !usedNodes.has(childNode.name)) {
        return;
      }
      if (childNode.op === "Merge") {
        if (childNode.inputNames.some((name) => {
          return !!getTensor(name, tensorMap, context);
        })) {
          added[nodeName] = true;
          stack9.push({ contexts: context.currentContext, node: childNode });
        }
      } else if (childNode.inputNames.every((name) => {
        return !!getTensor(name, tensorMap, context);
      })) {
        added[nodeName] = true;
        stack9.push({ contexts: context.currentContext, node: childNode });
      }
    });
  }
  dispose() {
    Object.keys(this.weightMap).forEach((key) => this.weightMap[key].forEach((tensor153) => tensor153.dispose()));
  }
  checkInputShapeAndType(inputs) {
    Object.keys(inputs).forEach((name) => {
      const input2 = inputs[name];
      const [nodeName] = parseNodeName(name);
      const node = this.graph.nodes[nodeName];
      if (node.attrParams["shape"] && node.attrParams["shape"].value) {
        const shape = node.attrParams["shape"].value;
        const match = shape.length === input2.shape.length && input2.shape.every((dim, index) => shape[index] === -1 || shape[index] === dim);
        exports_util.assert(match, () => `The shape of dict['${node.name}'] provided in ` + `model.execute(dict) must be [${shape}], but was ` + `[${input2.shape}]`);
      }
      if (node.attrParams["dtype"] && node.attrParams["dtype"].value) {
        exports_util.assert(input2.dtype === node.attrParams["dtype"].value, () => `The dtype of dict['${node.name}'] provided in ` + `model.execute(dict) must be ` + `${node.attrParams["dtype"].value}, but was ${input2.dtype}`);
      }
    });
  }
  mapInputs(inputs) {
    var _a, _b;
    const result = {};
    for (const inputName in inputs) {
      const tensor153 = (_b = (_a = this._signature) === null || _a === undefined ? undefined : _a.inputs) === null || _b === undefined ? undefined : _b[inputName];
      if (tensor153 != null) {
        result[tensor153.name] = inputs[inputName];
      } else {
        result[inputName] = inputs[inputName];
      }
    }
    return result;
  }
  checkInputs(inputs) {
    const notInGraph = Object.keys(inputs).filter((name) => {
      const [nodeName] = parseNodeName(name);
      return this.graph.nodes[nodeName] == null;
    });
    if (notInGraph.length > 0) {
      throw new Error(`The dict provided in model.execute(dict) has ` + `keys: [${notInGraph}] that are not part of graph`);
    }
  }
  mapOutputs(outputs) {
    return outputs.map((name) => {
      var _a, _b;
      const tensor153 = (_b = (_a = this._signature) === null || _a === undefined ? undefined : _a.outputs) === null || _b === undefined ? undefined : _b[name];
      if (tensor153 != null) {
        return tensor153.name;
      }
      return name;
    }, {});
  }
  checkOutputs(outputs) {
    outputs.forEach((name) => {
      const [normalizedName] = parseNodeName(name);
      if (!this.graph.nodes[normalizedName]) {
        throw new Error(`The output '${name}' is not found in the graph`);
      }
    });
  }
}
var init_graph_executor2 = __esm(() => {
  init_dist();
  init_utils();
  init_operation_executor();
  init_model_analysis();
});

// node_modules/@tensorflow/tfjs-converter/dist/executor/resource_manager.js
class ResourceManager {
  constructor(hashTableNameToHandle = {}, hashTableMap = {}) {
    this.hashTableNameToHandle = hashTableNameToHandle;
    this.hashTableMap = hashTableMap;
  }
  addHashTable(name, hashTable) {
    this.hashTableNameToHandle[name] = hashTable.handle;
    this.hashTableMap[hashTable.id] = hashTable;
  }
  getHashTableHandleByName(name) {
    return this.hashTableNameToHandle[name];
  }
  getHashTableById(id) {
    return this.hashTableMap[id];
  }
  dispose() {
    for (const key in this.hashTableMap) {
      this.hashTableMap[key].clearAndClose();
      delete this.hashTableMap[key];
    }
    for (const name in this.hashTableNameToHandle) {
      this.hashTableNameToHandle[name].dispose();
      delete this.hashTableNameToHandle[name];
    }
  }
}

// node_modules/@tensorflow/tfjs-converter/dist/executor/graph_model.js
async function loadGraphModel(modelUrl, options = {}, tfio = exports_io) {
  if (modelUrl == null) {
    throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url " + "or an IOHandler that loads the model");
  }
  if (options == null) {
    options = {};
  }
  if (options.fromTFHub && typeof modelUrl === "string") {
    modelUrl = getTFHubUrl(modelUrl);
  }
  const model2 = new GraphModel(modelUrl, options, tfio);
  await model2.load();
  return model2;
}
function loadGraphModelSync(modelSource) {
  if (modelSource == null) {
    throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide " + "model artifacts or an IOHandler that loads the model");
  }
  let ioHandler;
  if (modelSource instanceof Array) {
    const [modelJSON, weights] = modelSource;
    if (!modelJSON) {
      throw new Error("modelJSON must be the first element of the array");
    }
    if (!weights || !(weights instanceof ArrayBuffer)) {
      throw new Error("An ArrayBuffer of weights must be the second element of" + " the array");
    }
    if (!("modelTopology" in modelJSON)) {
      throw new Error("Model JSON is missing \'modelTopology\'");
    }
    if (!("weightsManifest" in modelJSON)) {
      throw new Error("Model JSON is missing \'weightsManifest\'");
    }
    const weightSpecs = exports_io.getWeightSpecs(modelJSON.weightsManifest);
    const modelArtifacts = exports_io.getModelArtifactsForJSONSync(modelJSON, weightSpecs, weights);
    ioHandler = exports_io.fromMemorySync(modelArtifacts);
  } else if ("load" in modelSource) {
    ioHandler = modelSource;
  } else if ("modelTopology" in modelSource && "weightSpecs" in modelSource && "weightData" in modelSource) {
    ioHandler = exports_io.fromMemorySync(modelSource);
  } else {
    throw new Error("Unknown model format");
  }
  const model2 = new GraphModel(ioHandler);
  model2.load();
  return model2;
}
function getTFHubUrl(modelUrl) {
  if (!modelUrl.endsWith("/")) {
    modelUrl = modelUrl + "/";
  }
  return `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
}

class GraphModel {
  get modelVersion() {
    return this.version;
  }
  get inputNodes() {
    return this.executor.inputNodes;
  }
  get outputNodes() {
    return this.executor.outputNodes;
  }
  get inputs() {
    return this.executor.inputs;
  }
  get outputs() {
    return this.executor.outputs;
  }
  get weights() {
    return this.executor.weightMap;
  }
  get metadata() {
    return this.artifacts.userDefinedMetadata;
  }
  get modelSignature() {
    return this.signature;
  }
  get modelStructuredOutputKeys() {
    return this.structuredOutputKeys;
  }
  constructor(modelUrl, loadOptions = {}, tfio = exports_io) {
    this.modelUrl = modelUrl;
    this.loadOptions = loadOptions;
    this.version = "n/a";
    this.io = tfio;
    if (loadOptions == null) {
      this.loadOptions = {};
    }
    this.resourceManager = new ResourceManager;
  }
  findIOHandler() {
    const path = this.modelUrl;
    if (path.load != null) {
      this.handler = path;
    } else if (this.loadOptions.requestInit != null) {
      this.handler = this.io.browserHTTPRequest(path, this.loadOptions);
    } else {
      const handlers = this.io.getLoadHandlers(path, this.loadOptions);
      if (handlers.length === 0) {
        handlers.push(this.io.browserHTTPRequest(path, this.loadOptions));
      } else if (handlers.length > 1) {
        throw new Error(`Found more than one (${handlers.length}) load handlers for ` + `URL '${[path]}'`);
      }
      this.handler = handlers[0];
    }
  }
  load() {
    this.findIOHandler();
    if (this.handler.load == null) {
      throw new Error("Cannot proceed with model loading because the IOHandler provided " + "does not have the `load` method implemented.");
    }
    const loadResult = this.handler.load();
    if (exports_util.isPromise(loadResult)) {
      return loadResult.then((artifacts) => {
        if (artifacts.getWeightStream == null) {
          return this.loadSync(artifacts);
        }
        return this.loadStreaming(artifacts);
      });
    }
    return this.loadSync(loadResult);
  }
  loadSync(artifacts) {
    const weightMap = this.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs);
    return this.loadWithWeightMap(artifacts, weightMap);
  }
  async loadStreaming(artifacts) {
    if (artifacts.getWeightStream == null) {
      throw new Error("Model artifacts missing streamWeights function");
    }
    const weightMap = await decodeWeightsStream(artifacts.getWeightStream(), artifacts.weightSpecs);
    return this.loadWithWeightMap(artifacts, weightMap);
  }
  loadWithWeightMap(artifacts, weightMap) {
    this.artifacts = artifacts;
    const graph = this.artifacts.modelTopology;
    let signature = this.artifacts.signature;
    if (this.artifacts.userDefinedMetadata != null) {
      const metadata = this.artifacts.userDefinedMetadata;
      if (metadata.signature != null) {
        signature = metadata.signature;
      }
      if (metadata.structuredOutputKeys != null) {
        this.structuredOutputKeys = metadata.structuredOutputKeys;
      }
    }
    this.signature = signature;
    this.version = `${graph.versions.producer}.${graph.versions.minConsumer}`;
    this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph, this.signature));
    this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
    this.executor.resourceManager = this.resourceManager;
    if (artifacts.modelInitializer != null && artifacts.modelInitializer.node != null) {
      const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
      this.initializer = new GraphExecutor(initializer);
      this.initializer.weightMap = this.executor.weightMap;
      this.initializer.resourceManager = this.resourceManager;
      this.initializerSignature = artifacts.initializerSignature;
    }
    return true;
  }
  async save(handlerOrURL, config) {
    if (typeof handlerOrURL === "string") {
      const handlers = this.io.getSaveHandlers(handlerOrURL);
      if (handlers.length === 0) {
        throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
      } else if (handlers.length > 1) {
        throw new Error(`Found more than one (${handlers.length}) save handlers for ` + `URL '${handlerOrURL}'`);
      }
      handlerOrURL = handlers[0];
    }
    if (handlerOrURL.save == null) {
      throw new Error("GraphModel.save() cannot proceed because the IOHandler " + "provided does not have the `save` attribute defined.");
    }
    return handlerOrURL.save(this.artifacts);
  }
  addStructuredOutputNames(outputTensors) {
    if (this.structuredOutputKeys) {
      const outputTensorsArray = outputTensors instanceof Tensor ? [outputTensors] : outputTensors;
      const outputTensorMap = {};
      outputTensorsArray.forEach((outputTensor, i) => outputTensorMap[this.structuredOutputKeys[i]] = outputTensor);
      return outputTensorMap;
    }
    return outputTensors;
  }
  predict(inputs, config) {
    const outputTensors = this.execute(inputs, this.outputNodes);
    return this.addStructuredOutputNames(outputTensors);
  }
  async predictAsync(inputs, config) {
    const outputTensors = await this.executeAsync(inputs, this.outputNodes);
    return this.addStructuredOutputNames(outputTensors);
  }
  normalizeInputs(inputs) {
    var _a;
    if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
      const signatureInputs = (_a = this.signature) === null || _a === undefined ? undefined : _a.inputs;
      if (signatureInputs != null) {
        for (const input2 in signatureInputs) {
          const tensor153 = signatureInputs[input2];
          if (tensor153.resourceId != null) {
            inputs[input2] = this.resourceIdToCapturedInput[tensor153.resourceId];
          }
        }
      }
      return inputs;
    }
    inputs = Array.isArray(inputs) ? inputs : [inputs];
    const numCapturedInputs = Object.keys(this.resourceIdToCapturedInput).length;
    if (inputs.length + numCapturedInputs !== this.inputNodes.length) {
      throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - numCapturedInputs} non-resource placeholders, while there are ${inputs.length} input tensors provided.`);
    }
    let inputIndex = 0;
    return this.inputNodes.reduce((map, inputName) => {
      var _a2, _b, _c;
      const resourceId = (_c = (_b = (_a2 = this.signature) === null || _a2 === undefined ? undefined : _a2.inputs) === null || _b === undefined ? undefined : _b[inputName]) === null || _c === undefined ? undefined : _c.resourceId;
      if (resourceId != null) {
        map[inputName] = this.resourceIdToCapturedInput[resourceId];
      } else {
        map[inputName] = inputs[inputIndex++];
      }
      return map;
    }, {});
  }
  normalizeOutputs(outputs) {
    outputs = outputs || this.outputNodes;
    return !Array.isArray(outputs) ? [outputs] : outputs;
  }
  executeInitializerGraph() {
    if (this.initializer == null) {
      return [];
    }
    if (this.initializerSignature == null) {
      return this.initializer.execute({}, []);
    } else {
      return this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
    }
  }
  async executeInitializerGraphAsync() {
    if (this.initializer == null) {
      return [];
    }
    if (this.initializerSignature == null) {
      return this.initializer.executeAsync({}, []);
    } else {
      return this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
    }
  }
  setResourceIdToCapturedInput(outputs) {
    this.resourceIdToCapturedInput = {};
    if (this.initializerSignature) {
      const signatureOutputs = this.initializerSignature.outputs;
      const outputNames = Object.keys(signatureOutputs);
      for (let i = 0;i < outputNames.length; i++) {
        const outputName = outputNames[i];
        const tensorInfo = signatureOutputs[outputName];
        this.resourceIdToCapturedInput[tensorInfo.resourceId] = outputs[i];
      }
    }
  }
  execute(inputs, outputs) {
    if (this.resourceIdToCapturedInput == null) {
      this.setResourceIdToCapturedInput(this.executeInitializerGraph());
    }
    inputs = this.normalizeInputs(inputs);
    outputs = this.normalizeOutputs(outputs);
    const result = this.executor.execute(inputs, outputs);
    return result.length > 1 ? result : result[0];
  }
  async executeAsync(inputs, outputs) {
    if (this.resourceIdToCapturedInput == null) {
      this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync());
    }
    inputs = this.normalizeInputs(inputs);
    outputs = this.normalizeOutputs(outputs);
    const result = await this.executor.executeAsync(inputs, outputs);
    return result.length > 1 ? result : result[0];
  }
  getIntermediateTensors() {
    return this.executor.getIntermediateTensors();
  }
  disposeIntermediateTensors() {
    this.executor.disposeIntermediateTensors();
  }
  convertTensorMapToTensorsMap(map) {
    return Object.keys(map).reduce((newMap, key) => {
      newMap[key] = [map[key]];
      return newMap;
    }, {});
  }
  dispose() {
    this.executor.dispose();
    if (this.initializer) {
      this.initializer.dispose();
      if (this.resourceIdToCapturedInput) {
        dispose(this.resourceIdToCapturedInput);
      }
    }
    this.resourceManager.dispose();
  }
}
var TFHUB_SEARCH_PARAM = "?tfjs-format=file", DEFAULT_MODEL_NAME = "model.json";
var init_graph_model = __esm(() => {
  init_dist();
  init_operation_mapper();
  init_graph_executor2();
  init_io_utils();
});

// node_modules/@tensorflow/tfjs-converter/dist/version.js
var version6 = "4.22.0";
var init_version3 = () => {
};

// node_modules/@tensorflow/tfjs-converter/dist/index.js
var init_dist3 = __esm(() => {
  init_flags2();
  init_graph_model();
  init_register();
  init_version3();
});

// node:string_decoder
var exports_string_decoder = {};
__export(exports_string_decoder, {
  default: () => export_default,
  StringDecoder: () => export_StringDecoder
});
var Tt2, Z, Nt, St, Rt, _t, R = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Lt = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of St(t))
      !_t.call(e, n) && n !== r && Z(e, n, { get: () => t[n], enumerable: !(i = Nt(t, n)) || i.enumerable });
  return e;
}, kt = (e, t, r) => (r = e != null ? Tt2(Rt(e)) : {}, Lt(t || !e || !e.__esModule ? Z(r, "default", { value: e, enumerable: true }) : r, e)), tt2, rt2, Bt, mt2, At2, Ut2, export_StringDecoder, export_default;
var init_string_decoder = __esm(() => {
  Tt2 = Object.create;
  Z = Object.defineProperty;
  Nt = Object.getOwnPropertyDescriptor;
  St = Object.getOwnPropertyNames;
  Rt = Object.getPrototypeOf;
  _t = Object.prototype.hasOwnProperty;
  tt2 = R((k) => {
    k.byteLength = Mt;
    k.toByteArray = Pt;
    k.fromByteArray = Gt;
    var d = [], w = [], Dt = typeof Uint8Array < "u" ? Uint8Array : Array, O = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (I = 0, Q = O.length;I < Q; ++I)
      d[I] = O[I], w[O.charCodeAt(I)] = I;
    var I, Q;
    w["-".charCodeAt(0)] = 62;
    w["_".charCodeAt(0)] = 63;
    function v(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var i = r === t ? 0 : 4 - r % 4;
      return [r, i];
    }
    function Mt(e) {
      var t = v(e), r = t[0], i = t[1];
      return (r + i) * 3 / 4 - i;
    }
    function $t(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function Pt(e) {
      var t, r = v(e), i = r[0], n = r[1], o = new Dt($t(e, i, n)), u = 0, s = n > 0 ? i - 4 : i, f;
      for (f = 0;f < s; f += 4)
        t = w[e.charCodeAt(f)] << 18 | w[e.charCodeAt(f + 1)] << 12 | w[e.charCodeAt(f + 2)] << 6 | w[e.charCodeAt(f + 3)], o[u++] = t >> 16 & 255, o[u++] = t >> 8 & 255, o[u++] = t & 255;
      return n === 2 && (t = w[e.charCodeAt(f)] << 2 | w[e.charCodeAt(f + 1)] >> 4, o[u++] = t & 255), n === 1 && (t = w[e.charCodeAt(f)] << 10 | w[e.charCodeAt(f + 1)] << 4 | w[e.charCodeAt(f + 2)] >> 2, o[u++] = t >> 8 & 255, o[u++] = t & 255), o;
    }
    function Ot(e) {
      return d[e >> 18 & 63] + d[e >> 12 & 63] + d[e >> 6 & 63] + d[e & 63];
    }
    function qt(e, t, r) {
      for (var i, n = [], o = t;o < r; o += 3)
        i = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), n.push(Ot(i));
      return n.join("");
    }
    function Gt(e) {
      for (var t, r = e.length, i = r % 3, n = [], o = 16383, u = 0, s = r - i;u < s; u += o)
        n.push(qt(e, u, u + o > s ? s : u + o));
      return i === 1 ? (t = e[r - 1], n.push(d[t >> 2] + d[t << 4 & 63] + "==")) : i === 2 && (t = (e[r - 2] << 8) + e[r - 1], n.push(d[t >> 10] + d[t >> 4 & 63] + d[t << 2 & 63] + "=")), n.join("");
    }
  });
  rt2 = R((q) => {
    q.read = function(e, t, r, i, n) {
      var o, u, s = n * 8 - i - 1, f = (1 << s) - 1, l = f >> 1, a = -7, c = r ? n - 1 : 0, U = r ? -1 : 1, x = e[t + c];
      for (c += U, o = x & (1 << -a) - 1, x >>= -a, a += s;a > 0; o = o * 256 + e[t + c], c += U, a -= 8)
        ;
      for (u = o & (1 << -a) - 1, o >>= -a, a += i;a > 0; u = u * 256 + e[t + c], c += U, a -= 8)
        ;
      if (o === 0)
        o = 1 - l;
      else {
        if (o === f)
          return u ? NaN : (x ? -1 : 1) * (1 / 0);
        u = u + Math.pow(2, i), o = o - l;
      }
      return (x ? -1 : 1) * u * Math.pow(2, o - i);
    };
    q.write = function(e, t, r, i, n, o) {
      var u, s, f, l = o * 8 - n - 1, a = (1 << l) - 1, c = a >> 1, U = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = i ? 0 : o - 1, P = i ? 1 : -1, Ct = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, u = a) : (u = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -u)) < 1 && (u--, f *= 2), u + c >= 1 ? t += U / f : t += U * Math.pow(2, 1 - c), t * f >= 2 && (u++, f /= 2), u + c >= a ? (s = 0, u = a) : u + c >= 1 ? (s = (t * f - 1) * Math.pow(2, n), u = u + c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, n), u = 0));n >= 8; e[r + x] = s & 255, x += P, s /= 256, n -= 8)
        ;
      for (u = u << n | s, l += n;l > 0; e[r + x] = u & 255, x += P, u /= 256, l -= 8)
        ;
      e[r + x - P] |= Ct * 128;
    };
  });
  Bt = R((S) => {
    var G = tt2(), T2 = rt2(), et = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    S.Buffer = h;
    S.SlowBuffer = Vt;
    S.INSPECT_MAX_BYTES = 50;
    var D = 2147483647;
    S.kMaxLength = D;
    h.TYPED_ARRAY_SUPPORT = Wt();
    !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Wt() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h.prototype, "parent", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h.prototype, "offset", { enumerable: true, get: function() {
      if (!!h.isBuffer(this))
        return this.byteOffset;
    } });
    function E2(e) {
      if (e > D)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, h.prototype), t;
    }
    function h(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return b(e);
      }
      return ut(e, t, r);
    }
    h.poolSize = 8192;
    function ut(e, t, r) {
      if (typeof e == "string")
        return jt(e, t);
      if (ArrayBuffer.isView(e))
        return bt2(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (B(e, ArrayBuffer) || e && B(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (B(e, SharedArrayBuffer) || e && B(e.buffer, SharedArrayBuffer)))
        return Y2(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let i = e.valueOf && e.valueOf();
      if (i != null && i !== e)
        return h.from(i, t, r);
      let n = Ht(e);
      if (n)
        return n;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return h.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    h.from = function(e, t, r) {
      return ut(e, t, r);
    };
    Object.setPrototypeOf(h.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h, Uint8Array);
    function ht(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Yt(e, t, r) {
      return ht(e), e <= 0 ? E2(e) : t !== undefined ? typeof r == "string" ? E2(e).fill(t, r) : E2(e).fill(t) : E2(e);
    }
    h.alloc = function(e, t, r) {
      return Yt(e, t, r);
    };
    function b(e) {
      return ht(e), E2(e < 0 ? 0 : H2(e) | 0);
    }
    h.allocUnsafe = function(e) {
      return b(e);
    };
    h.allocUnsafeSlow = function(e) {
      return b(e);
    };
    function jt(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !h.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = st2(e, t) | 0, i = E2(r), n = i.write(e, t);
      return n !== r && (i = i.slice(0, n)), i;
    }
    function W(e) {
      let t = e.length < 0 ? 0 : H2(e.length) | 0, r = E2(t);
      for (let i = 0;i < t; i += 1)
        r[i] = e[i] & 255;
      return r;
    }
    function bt2(e) {
      if (B(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Y2(t.buffer, t.byteOffset, t.byteLength);
      }
      return W(e);
    }
    function Y2(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let i;
      return t === undefined && r === undefined ? i = new Uint8Array(e) : r === undefined ? i = new Uint8Array(e, t) : i = new Uint8Array(e, t, r), Object.setPrototypeOf(i, h.prototype), i;
    }
    function Ht(e) {
      if (h.isBuffer(e)) {
        let t = H2(e.length) | 0, r = E2(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || X(e.length) ? E2(0) : W(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return W(e.data);
    }
    function H2(e) {
      if (e >= D)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + D.toString(16) + " bytes");
      return e | 0;
    }
    function Vt(e) {
      return +e != e && (e = 0), h.alloc(+e);
    }
    h.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== h.prototype;
    };
    h.compare = function(t, r) {
      if (B(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), B(r, Uint8Array) && (r = h.from(r, r.offset, r.byteLength)), !h.isBuffer(t) || !h.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let i = t.length, n = r.length;
      for (let o = 0, u = Math.min(i, n);o < u; ++o)
        if (t[o] !== r[o]) {
          i = t[o], n = r[o];
          break;
        }
      return i < n ? -1 : n < i ? 1 : 0;
    };
    h.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return h.alloc(0);
      let i;
      if (r === undefined)
        for (r = 0, i = 0;i < t.length; ++i)
          r += t[i].length;
      let n = h.allocUnsafe(r), o = 0;
      for (i = 0;i < t.length; ++i) {
        let u = t[i];
        if (B(u, Uint8Array))
          o + u.length > n.length ? (h.isBuffer(u) || (u = h.from(u)), u.copy(n, o)) : Uint8Array.prototype.set.call(n, u, o);
        else if (h.isBuffer(u))
          u.copy(n, o);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o += u.length;
      }
      return n;
    };
    function st2(e, t) {
      if (h.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || B(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, i = arguments.length > 2 && arguments[2] === true;
      if (!i && r === 0)
        return 0;
      let n = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return j(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return dt2(e).length;
          default:
            if (n)
              return i ? -1 : j(e).length;
            t = ("" + t).toLowerCase(), n = true;
        }
    }
    h.byteLength = st2;
    function Xt2(e, t, r) {
      let i = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return ir(this, t, r);
          case "utf8":
          case "utf-8":
            return ct2(this, t, r);
          case "ascii":
            return rr(this, t, r);
          case "latin1":
          case "binary":
            return er(this, t, r);
          case "base64":
            return vt(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return nr(this, t, r);
          default:
            if (i)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), i = true;
        }
    }
    h.prototype._isBuffer = true;
    function F3(e, t, r) {
      let i = e[t];
      e[t] = e[r], e[r] = i;
    }
    h.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        F3(this, r, r + 1);
      return this;
    };
    h.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        F3(this, r, r + 3), F3(this, r + 1, r + 2);
      return this;
    };
    h.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        F3(this, r, r + 7), F3(this, r + 1, r + 6), F3(this, r + 2, r + 5), F3(this, r + 3, r + 4);
      return this;
    };
    h.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? ct2(this, 0, t) : Xt2.apply(this, arguments);
    };
    h.prototype.toLocaleString = h.prototype.toString;
    h.prototype.equals = function(t) {
      if (!h.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : h.compare(this, t) === 0;
    };
    h.prototype.inspect = function() {
      let t = "", r = S.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    et && (h.prototype[et] = h.prototype.inspect);
    h.prototype.compare = function(t, r, i, n, o) {
      if (B(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), i === undefined && (i = t ? t.length : 0), n === undefined && (n = 0), o === undefined && (o = this.length), r < 0 || i > t.length || n < 0 || o > this.length)
        throw new RangeError("out of range index");
      if (n >= o && r >= i)
        return 0;
      if (n >= o)
        return -1;
      if (r >= i)
        return 1;
      if (r >>>= 0, i >>>= 0, n >>>= 0, o >>>= 0, this === t)
        return 0;
      let u = o - n, s = i - r, f = Math.min(u, s), l = this.slice(n, o), a = t.slice(r, i);
      for (let c = 0;c < f; ++c)
        if (l[c] !== a[c]) {
          u = l[c], s = a[c];
          break;
        }
      return u < s ? -1 : s < u ? 1 : 0;
    };
    function ft(e, t, r, i, n) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, X(r) && (r = n ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (n)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (n)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = h.from(t, i)), h.isBuffer(t))
        return t.length === 0 ? -1 : it(e, t, r, i, n);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : it(e, [t], r, i, n);
      throw new TypeError("val must be string, number or Buffer");
    }
    function it(e, t, r, i, n) {
      let o = 1, u = e.length, s = t.length;
      if (i !== undefined && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o = 2, u /= 2, s /= 2, r /= 2;
      }
      function f(a, c) {
        return o === 1 ? a[c] : a.readUInt16BE(c * o);
      }
      let l;
      if (n) {
        let a = -1;
        for (l = r;l < u; l++)
          if (f(e, l) === f(t, a === -1 ? 0 : l - a)) {
            if (a === -1 && (a = l), l - a + 1 === s)
              return a * o;
          } else
            a !== -1 && (l -= l - a), a = -1;
      } else
        for (r + s > u && (r = u - s), l = r;l >= 0; l--) {
          let a = true;
          for (let c = 0;c < s; c++)
            if (f(e, l + c) !== f(t, c)) {
              a = false;
              break;
            }
          if (a)
            return l;
        }
      return -1;
    }
    h.prototype.includes = function(t, r, i) {
      return this.indexOf(t, r, i) !== -1;
    };
    h.prototype.indexOf = function(t, r, i) {
      return ft(this, t, r, i, true);
    };
    h.prototype.lastIndexOf = function(t, r, i) {
      return ft(this, t, r, i, false);
    };
    function Jt2(e, t, r, i) {
      r = Number(r) || 0;
      let n = e.length - r;
      i ? (i = Number(i), i > n && (i = n)) : i = n;
      let o = t.length;
      i > o / 2 && (i = o / 2);
      let u;
      for (u = 0;u < i; ++u) {
        let s = parseInt(t.substr(u * 2, 2), 16);
        if (X(s))
          return u;
        e[r + u] = s;
      }
      return u;
    }
    function zt(e, t, r, i) {
      return M(j(t, e.length - r), e, r, i);
    }
    function Kt(e, t, r, i) {
      return M(sr(t), e, r, i);
    }
    function Zt(e, t, r, i) {
      return M(dt2(t), e, r, i);
    }
    function Qt(e, t, r, i) {
      return M(fr(t, e.length - r), e, r, i);
    }
    h.prototype.write = function(t, r, i, n) {
      if (r === undefined)
        n = "utf8", i = this.length, r = 0;
      else if (i === undefined && typeof r == "string")
        n = r, i = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(i) ? (i = i >>> 0, n === undefined && (n = "utf8")) : (n = i, i = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o = this.length - r;
      if ((i === undefined || i > o) && (i = o), t.length > 0 && (i < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      let u = false;
      for (;; )
        switch (n) {
          case "hex":
            return Jt2(this, t, r, i);
          case "utf8":
          case "utf-8":
            return zt(this, t, r, i);
          case "ascii":
          case "latin1":
          case "binary":
            return Kt(this, t, r, i);
          case "base64":
            return Zt(this, t, r, i);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Qt(this, t, r, i);
          default:
            if (u)
              throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), u = true;
        }
    };
    h.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function vt(e, t, r) {
      return t === 0 && r === e.length ? G.fromByteArray(e) : G.fromByteArray(e.slice(t, r));
    }
    function ct2(e, t, r) {
      r = Math.min(e.length, r);
      let i = [], n = t;
      for (;n < r; ) {
        let o = e[n], u = null, s = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
        if (n + s <= r) {
          let f, l, a, c;
          switch (s) {
            case 1:
              o < 128 && (u = o);
              break;
            case 2:
              f = e[n + 1], (f & 192) === 128 && (c = (o & 31) << 6 | f & 63, c > 127 && (u = c));
              break;
            case 3:
              f = e[n + 1], l = e[n + 2], (f & 192) === 128 && (l & 192) === 128 && (c = (o & 15) << 12 | (f & 63) << 6 | l & 63, c > 2047 && (c < 55296 || c > 57343) && (u = c));
              break;
            case 4:
              f = e[n + 1], l = e[n + 2], a = e[n + 3], (f & 192) === 128 && (l & 192) === 128 && (a & 192) === 128 && (c = (o & 15) << 18 | (f & 63) << 12 | (l & 63) << 6 | a & 63, c > 65535 && c < 1114112 && (u = c));
          }
        }
        u === null ? (u = 65533, s = 1) : u > 65535 && (u -= 65536, i.push(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), i.push(u), n += s;
      }
      return tr(i);
    }
    var nt2 = 4096;
    function tr(e) {
      let t = e.length;
      if (t <= nt2)
        return String.fromCharCode.apply(String, e);
      let r = "", i = 0;
      for (;i < t; )
        r += String.fromCharCode.apply(String, e.slice(i, i += nt2));
      return r;
    }
    function rr(e, t, r) {
      let i = "";
      r = Math.min(e.length, r);
      for (let n = t;n < r; ++n)
        i += String.fromCharCode(e[n] & 127);
      return i;
    }
    function er(e, t, r) {
      let i = "";
      r = Math.min(e.length, r);
      for (let n = t;n < r; ++n)
        i += String.fromCharCode(e[n]);
      return i;
    }
    function ir(e, t, r) {
      let i = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > i) && (r = i);
      let n = "";
      for (let o = t;o < r; ++o)
        n += cr[e[o]];
      return n;
    }
    function nr(e, t, r) {
      let i = e.slice(t, r), n = "";
      for (let o = 0;o < i.length - 1; o += 2)
        n += String.fromCharCode(i[o] + i[o + 1] * 256);
      return n;
    }
    h.prototype.slice = function(t, r) {
      let i = this.length;
      t = ~~t, r = r === undefined ? i : ~~r, t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < t && (r = t);
      let n = this.subarray(t, r);
      return Object.setPrototypeOf(n, h.prototype), n;
    };
    function p2(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h.prototype.readUintLE = h.prototype.readUIntLE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p2(t, r, this.length);
      let n = this[t], o = 1, u = 0;
      for (;++u < r && (o *= 256); )
        n += this[t + u] * o;
      return n;
    };
    h.prototype.readUintBE = h.prototype.readUIntBE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p2(t, r, this.length);
      let n = this[t + --r], o = 1;
      for (;r > 0 && (o *= 256); )
        n += this[t + --r] * o;
      return n;
    };
    h.prototype.readUint8 = h.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || p2(t, 1, this.length), this[t];
    };
    h.prototype.readUint16LE = h.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || p2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    h.prototype.readUint16BE = h.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || p2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    h.prototype.readUint32LE = h.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || p2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    h.prototype.readUint32BE = h.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || p2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    h.prototype.readBigUInt64LE = m(function(t) {
      t = t >>> 0, N4(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _(t, this.length - 8);
      let n = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + i * 2 ** 24;
      return BigInt(n) + (BigInt(o) << BigInt(32));
    });
    h.prototype.readBigUInt64BE = m(function(t) {
      t = t >>> 0, N4(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _(t, this.length - 8);
      let n = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i;
      return (BigInt(n) << BigInt(32)) + BigInt(o);
    });
    h.prototype.readIntLE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p2(t, r, this.length);
      let n = this[t], o = 1, u = 0;
      for (;++u < r && (o *= 256); )
        n += this[t + u] * o;
      return o *= 128, n >= o && (n -= Math.pow(2, 8 * r)), n;
    };
    h.prototype.readIntBE = function(t, r, i) {
      t = t >>> 0, r = r >>> 0, i || p2(t, r, this.length);
      let n = r, o = 1, u = this[t + --n];
      for (;n > 0 && (o *= 256); )
        u += this[t + --n] * o;
      return o *= 128, u >= o && (u -= Math.pow(2, 8 * r)), u;
    };
    h.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || p2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    h.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || p2(t, 2, this.length);
      let i = this[t] | this[t + 1] << 8;
      return i & 32768 ? i | 4294901760 : i;
    };
    h.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || p2(t, 2, this.length);
      let i = this[t + 1] | this[t] << 8;
      return i & 32768 ? i | 4294901760 : i;
    };
    h.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || p2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    h.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || p2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    h.prototype.readBigInt64LE = m(function(t) {
      t = t >>> 0, N4(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _(t, this.length - 8);
      let n = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (i << 24);
      return (BigInt(n) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    h.prototype.readBigInt64BE = m(function(t) {
      t = t >>> 0, N4(t, "offset");
      let r = this[t], i = this[t + 7];
      (r === undefined || i === undefined) && _(t, this.length - 8);
      let n = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(n) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + i);
    });
    h.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || p2(t, 4, this.length), T2.read(this, t, true, 23, 4);
    };
    h.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || p2(t, 4, this.length), T2.read(this, t, false, 23, 4);
    };
    h.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || p2(t, 8, this.length), T2.read(this, t, true, 52, 8);
    };
    h.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || p2(t, 8, this.length), T2.read(this, t, false, 52, 8);
    };
    function y(e, t, r, i, n, o) {
      if (!h.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > n || t < o)
        throw new RangeError('"value" argument is out of bounds');
      if (r + i > e.length)
        throw new RangeError("Index out of range");
    }
    h.prototype.writeUintLE = h.prototype.writeUIntLE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
        let s = Math.pow(2, 8 * i) - 1;
        y(this, t, r, i, s, 0);
      }
      let o = 1, u = 0;
      for (this[r] = t & 255;++u < i && (o *= 256); )
        this[r + u] = t / o & 255;
      return r + i;
    };
    h.prototype.writeUintBE = h.prototype.writeUIntBE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, i = i >>> 0, !n) {
        let s = Math.pow(2, 8 * i) - 1;
        y(this, t, r, i, s, 0);
      }
      let o = i - 1, u = 1;
      for (this[r + o] = t & 255;--o >= 0 && (u *= 256); )
        this[r + o] = t / u & 255;
      return r + i;
    };
    h.prototype.writeUint8 = h.prototype.writeUInt8 = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function at(e, t, r, i, n) {
      xt(t, i, n, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o;
      let u = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = u, u = u >> 8, e[r++] = u, u = u >> 8, e[r++] = u, u = u >> 8, e[r++] = u, r;
    }
    function lt2(e, t, r, i, n) {
      xt(t, i, n, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      e[r + 7] = o, o = o >> 8, e[r + 6] = o, o = o >> 8, e[r + 5] = o, o = o >> 8, e[r + 4] = o;
      let u = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = u, u = u >> 8, e[r + 2] = u, u = u >> 8, e[r + 1] = u, u = u >> 8, e[r] = u, r + 8;
    }
    h.prototype.writeBigUInt64LE = m(function(t, r = 0) {
      return at(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeBigUInt64BE = m(function(t, r = 0) {
      return lt2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h.prototype.writeIntLE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, !n) {
        let f = Math.pow(2, 8 * i - 1);
        y(this, t, r, i, f - 1, -f);
      }
      let o = 0, u = 1, s = 0;
      for (this[r] = t & 255;++o < i && (u *= 256); )
        t < 0 && s === 0 && this[r + o - 1] !== 0 && (s = 1), this[r + o] = (t / u >> 0) - s & 255;
      return r + i;
    };
    h.prototype.writeIntBE = function(t, r, i, n) {
      if (t = +t, r = r >>> 0, !n) {
        let f = Math.pow(2, 8 * i - 1);
        y(this, t, r, i, f - 1, -f);
      }
      let o = i - 1, u = 1, s = 0;
      for (this[r + o] = t & 255;--o >= 0 && (u *= 256); )
        t < 0 && s === 0 && this[r + o + 1] !== 0 && (s = 1), this[r + o] = (t / u >> 0) - s & 255;
      return r + i;
    };
    h.prototype.writeInt8 = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    h.prototype.writeInt16LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    h.prototype.writeInt16BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    h.prototype.writeInt32LE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    h.prototype.writeInt32BE = function(t, r, i) {
      return t = +t, r = r >>> 0, i || y(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    h.prototype.writeBigInt64LE = m(function(t, r = 0) {
      return at(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h.prototype.writeBigInt64BE = m(function(t, r = 0) {
      return lt2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function pt2(e, t, r, i, n, o) {
      if (r + i > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function yt2(e, t, r, i, n) {
      return t = +t, r = r >>> 0, n || pt2(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T2.write(e, t, r, i, 23, 4), r + 4;
    }
    h.prototype.writeFloatLE = function(t, r, i) {
      return yt2(this, t, r, true, i);
    };
    h.prototype.writeFloatBE = function(t, r, i) {
      return yt2(this, t, r, false, i);
    };
    function wt(e, t, r, i, n) {
      return t = +t, r = r >>> 0, n || pt2(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T2.write(e, t, r, i, 52, 8), r + 8;
    }
    h.prototype.writeDoubleLE = function(t, r, i) {
      return wt(this, t, r, true, i);
    };
    h.prototype.writeDoubleBE = function(t, r, i) {
      return wt(this, t, r, false, i);
    };
    h.prototype.copy = function(t, r, i, n) {
      if (!h.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (i < 0 || i >= this.length)
        throw new RangeError("Index out of range");
      if (n < 0)
        throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), t.length - r < n - i && (n = t.length - r + i);
      let o = n - i;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, i, n) : Uint8Array.prototype.set.call(t, this.subarray(i, n), r), o;
    };
    h.prototype.fill = function(t, r, i, n) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== undefined && typeof n != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n == "string" && !h.isEncoding(n))
          throw new TypeError("Unknown encoding: " + n);
        if (t.length === 1) {
          let u = t.charCodeAt(0);
          (n === "utf8" && u < 128 || n === "latin1") && (t = u);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < i)
        throw new RangeError("Out of range index");
      if (i <= r)
        return this;
      r = r >>> 0, i = i === undefined ? this.length : i >>> 0, t || (t = 0);
      let o;
      if (typeof t == "number")
        for (o = r;o < i; ++o)
          this[o] = t;
      else {
        let u = h.isBuffer(t) ? t : h.from(t, n), s = u.length;
        if (s === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o = 0;o < i - r; ++o)
          this[o + r] = u[o % s];
      }
      return this;
    };
    var C = {};
    function V3(e, t, r) {
      C[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(n) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    V3("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    V3("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    V3("ERR_OUT_OF_RANGE", function(e, t, r) {
      let i = `The value of "${e}" is out of range.`, n = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = ot2(String(r)) : typeof r == "bigint" && (n = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (n = ot2(n)), n += "n"), i += ` It must be ${t}. Received ${n}`, i;
    }, RangeError);
    function ot2(e) {
      let t = "", r = e.length, i = e[0] === "-" ? 1 : 0;
      for (;r >= i + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function or2(e, t, r) {
      N4(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && _(t, e.length - (r + 1));
    }
    function xt(e, t, r, i, n, o) {
      if (e > r || e < t) {
        let u = typeof t == "bigint" ? "n" : "", s;
        throw o > 3 ? t === 0 || t === BigInt(0) ? s = `>= 0${u} and < 2${u} ** ${(o + 1) * 8}${u}` : s = `>= -(2${u} ** ${(o + 1) * 8 - 1}${u}) and < 2 ** ${(o + 1) * 8 - 1}${u}` : s = `>= ${t}${u} and <= ${r}${u}`, new C.ERR_OUT_OF_RANGE("value", s, e);
      }
      or2(i, n, o);
    }
    function N4(e, t) {
      if (typeof e != "number")
        throw new C.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function _(e, t, r) {
      throw Math.floor(e) !== e ? (N4(e, r), new C.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new C.ERR_BUFFER_OUT_OF_BOUNDS : new C.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var ur2 = /[^+/0-9A-Za-z-_]/g;
    function hr(e) {
      if (e = e.split("=")[0], e = e.trim().replace(ur2, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function j(e, t) {
      t = t || 1 / 0;
      let r, i = e.length, n = null, o = [];
      for (let u = 0;u < i; ++u) {
        if (r = e.charCodeAt(u), r > 55295 && r < 57344) {
          if (!n) {
            if (r > 56319) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            } else if (u + 1 === i) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            n = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o.push(239, 191, 189), n = r;
            continue;
          }
          r = (n - 55296 << 10 | r - 56320) + 65536;
        } else
          n && (t -= 3) > -1 && o.push(239, 191, 189);
        if (n = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o;
    }
    function sr(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function fr(e, t) {
      let r, i, n, o = [];
      for (let u = 0;u < e.length && !((t -= 2) < 0); ++u)
        r = e.charCodeAt(u), i = r >> 8, n = r % 256, o.push(n), o.push(i);
      return o;
    }
    function dt2(e) {
      return G.toByteArray(hr(e));
    }
    function M(e, t, r, i) {
      let n;
      for (n = 0;n < i && !(n + r >= t.length || n >= e.length); ++n)
        t[n + r] = e[n];
      return n;
    }
    function B(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function X(e) {
      return e !== e;
    }
    var cr = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let i = r * 16;
        for (let n = 0;n < 16; ++n)
          t[i + n] = e[r] + e[n];
      }
      return t;
    }();
    function m(e) {
      return typeof BigInt > "u" ? ar2 : e;
    }
    function ar2() {
      throw new Error("BigInt not supported");
    }
  });
  mt2 = R((J, Et) => {
    var $ = Bt(), g = $.Buffer;
    function gt2(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    g.from && g.alloc && g.allocUnsafe && g.allocUnsafeSlow ? Et.exports = $ : (gt2($, J), J.Buffer = A);
    function A(e, t, r) {
      return g(e, t, r);
    }
    A.prototype = Object.create(g.prototype);
    gt2(g, A);
    A.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return g(e, t, r);
    };
    A.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var i = g(e);
      return t !== undefined ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
    };
    A.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return g(e);
    };
    A.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return $.SlowBuffer(e);
    };
  });
  At2 = R((Ft) => {
    var K = mt2().Buffer, It = K.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function lr(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function pr2(e) {
      var t = lr(e);
      if (typeof t != "string" && (K.isEncoding === It || !It(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    Ft.StringDecoder = L;
    function L(e) {
      this.encoding = pr2(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = gr2, this.end = Er, t = 4;
          break;
        case "utf8":
          this.fillLast = xr, t = 4;
          break;
        case "base64":
          this.text = mr, this.end = Ir, t = 3;
          break;
        default:
          this.write = Fr2, this.end = Ar;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = K.allocUnsafe(t);
    }
    L.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    L.prototype.end = Br2;
    L.prototype.text = dr2;
    L.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function z(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function yr(e, t, r) {
      var i = t.length - 1;
      if (i < r)
        return 0;
      var n = z(t[i]);
      return n >= 0 ? (n > 0 && (e.lastNeed = n - 1), n) : --i < r || n === -2 ? 0 : (n = z(t[i]), n >= 0 ? (n > 0 && (e.lastNeed = n - 2), n) : --i < r || n === -2 ? 0 : (n = z(t[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : e.lastNeed = n - 3), n) : 0));
    }
    function wr(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "\uFFFD";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "\uFFFD";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "\uFFFD";
      }
    }
    function xr(e) {
      var t = this.lastTotal - this.lastNeed, r = wr(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function dr2(e, t) {
      var r = yr(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var i = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, i), e.toString("utf8", t, i);
    }
    function Br2(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "\uFFFD" : t;
    }
    function gr2(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var i = r.charCodeAt(r.length - 1);
          if (i >= 55296 && i <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Er(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function mr(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Ir(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Fr2(e) {
      return e.toString(this.encoding);
    }
    function Ar(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Ut2 = kt(At2());
  export_StringDecoder = Ut2.StringDecoder;
  export_default = Ut2.StringDecoder;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/@tensorflow/tfjs-data/dist/util/deep_map.js
function deepMap(input2, mapFn) {
  return deepMapInternal(input2, mapFn);
}
function deepMapInternal(input2, mapFn, seen = new Map, containedIn = new Set) {
  if (input2 == null) {
    return null;
  }
  if (typeof Blob === "function" && input2 instanceof Blob) {
    return input2.slice();
  }
  if (containedIn.has(input2)) {
    throw new Error("Circular references are not supported.");
  }
  if (seen.has(input2)) {
    return seen.get(input2);
  }
  const result = mapFn(input2);
  if (result.recurse && result.value !== null) {
    throw new Error("A deep map function may not return both a value and recurse=true.");
  }
  if (!result.recurse) {
    seen.set(input2, result.value);
    return result.value;
  } else if (isIterable2(input2)) {
    const mappedIterable = Array.isArray(input2) ? [] : {};
    containedIn.add(input2);
    for (const k in input2) {
      const child = input2[k];
      const childResult = deepMapInternal(child, mapFn, seen, containedIn);
      mappedIterable[k] = childResult;
    }
    containedIn.delete(input2);
    if (input2.__proto__) {
      mappedIterable.__proto__ = input2.__proto__;
    }
    return mappedIterable;
  } else {
    throw new Error(`Can't recurse into non-iterable type: ${input2}`);
  }
}
function deepZip(inputs, zipFn = zipToList) {
  return deepZipInternal(inputs, zipFn);
}
function deepZipInternal(inputs, zipFn, containedIn = new Set) {
  const input2 = inputs[0];
  if (containedIn.has(input2)) {
    throw new Error("Circular references are not supported.");
  }
  const result = zipFn(inputs);
  if (result.recurse && result.value !== null) {
    throw new Error("A deep zip function may not return both a value and recurse=true.");
  }
  if (!result.recurse) {
    return result.value;
  } else if (isIterable2(input2)) {
    const mappedIterable = Array.isArray(input2) ? [] : {};
    containedIn.add(input2);
    for (const k in input2) {
      const children = inputs.map((x) => x[k]);
      const childResult = deepZipInternal(children, zipFn, containedIn);
      mappedIterable[k] = childResult;
    }
    containedIn.delete(input2);
    return mappedIterable;
  } else {
    throw new Error(`Can't recurse into non-iterable type: ${input2}`);
  }
}
function zipToList(x) {
  if (x === null) {
    return null;
  }
  if (isIterable2(x[0])) {
    return { value: null, recurse: true };
  } else {
    return { value: x, recurse: false };
  }
}
async function deepMapAndAwaitAll(input2, mapFn) {
  const seen = new Map;
  deepMapInternal(input2, mapFn, seen);
  for (const key of Array.from(seen.keys())) {
    const value = seen.get(key);
    if (exports_util.isPromise(value)) {
      const mappedValue = await value;
      seen.set(key, mappedValue);
    }
  }
  const result = deepMapInternal(input2, mapFn, seen);
  return result;
}
function isIterable2(obj) {
  let isTextDecoder = false;
  if (env().get("IS_BROWSER")) {
    isTextDecoder = obj instanceof TextDecoder;
  } else {
    const { StringDecoder } = (init_string_decoder(), __toCommonJS(exports_string_decoder));
    isTextDecoder = obj instanceof StringDecoder;
  }
  return obj != null && !ArrayBuffer.isView(obj) && (Array.isArray(obj) || typeof obj === "object" && !(obj instanceof Tensor) && !(obj instanceof Promise) && !isTextDecoder);
}
function canTensorify(obj) {
  return obj == null || isPrimitive(obj) || Array.isArray(obj) || typeof obj === "object" && obj instanceof Tensor || exports_util.isTypedArray(obj);
}
function isPrimitive(value) {
  return value === null || typeof value !== "object" && typeof value !== "function";
}
var init_deep_map = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-data/dist/util/deep_clone.js
function deepClone(container2) {
  return deepMap(container2, cloneIfTensor);
}
function cloneIfTensor(item) {
  if (item instanceof Tensor) {
    return { value: item.clone(), recurse: false };
  } else if (isIterable2(item)) {
    return { value: null, recurse: true };
  } else {
    return { value: item, recurse: false };
  }
}
var init_deep_clone = __esm(() => {
  init_dist();
  init_deep_map();
});

// node_modules/@tensorflow/tfjs-data/dist/util/ring_buffer.js
class RingBuffer {
  constructor(capacity) {
    this.capacity = capacity;
    this.begin = 0;
    this.end = 0;
    if (capacity == null) {
      throw new RangeError("Can\'t create a ring buffer of unknown capacity.");
    }
    if (capacity < 1) {
      throw new RangeError("Can\'t create ring buffer of capacity < 1.");
    }
    this.data = new Array(capacity);
    this.doubledCapacity = 2 * capacity;
  }
  wrap(index) {
    while (index < 0) {
      index += this.doubledCapacity;
    }
    return index % this.doubledCapacity;
  }
  get(index) {
    if (index < 0) {
      throw new RangeError("Can\'t get item at a negative index.");
    }
    return this.data[index % this.capacity];
  }
  set(index, value) {
    if (index < 0) {
      throw new RangeError("Can\'t set item at a negative index.");
    }
    this.data[index % this.capacity] = value;
  }
  length() {
    let length = this.end - this.begin;
    if (length < 0) {
      length = this.doubledCapacity + length;
    }
    return length;
  }
  isFull() {
    return this.length() === this.capacity;
  }
  isEmpty() {
    return this.length() === 0;
  }
  push(value) {
    if (this.isFull()) {
      throw new RangeError("Ring buffer is full.");
    }
    this.set(this.end, value);
    this.end = this.wrap(this.end + 1);
  }
  pushAll(values) {
    for (const value of values) {
      this.push(value);
    }
  }
  pop() {
    if (this.isEmpty()) {
      throw new RangeError("Ring buffer is empty.");
    }
    this.end = this.wrap(this.end - 1);
    const result = this.get(this.end);
    this.set(this.end, undefined);
    return result;
  }
  unshift(value) {
    if (this.isFull()) {
      throw new RangeError("Ring buffer is full.");
    }
    this.begin = this.wrap(this.begin - 1);
    this.set(this.begin, value);
  }
  shift() {
    if (this.isEmpty()) {
      throw new RangeError("Ring buffer is empty.");
    }
    const result = this.get(this.begin);
    this.set(this.begin, undefined);
    this.begin = this.wrap(this.begin + 1);
    return result;
  }
  shuffleExcise(relativeIndex) {
    if (this.isEmpty()) {
      throw new RangeError("Ring buffer is empty.");
    }
    const index = this.wrap(this.begin + relativeIndex);
    const result = this.get(index);
    this.set(index, this.pop());
    return result;
  }
}

// node_modules/@tensorflow/tfjs-data/dist/util/growing_ring_buffer.js
var GrowingRingBuffer;
var init_growing_ring_buffer = __esm(() => {
  GrowingRingBuffer = class GrowingRingBuffer extends RingBuffer {
    constructor() {
      super(GrowingRingBuffer.INITIAL_CAPACITY);
    }
    isFull() {
      return false;
    }
    push(value) {
      if (super.isFull()) {
        this.expand();
      }
      super.push(value);
    }
    unshift(value) {
      if (super.isFull()) {
        this.expand();
      }
      super.unshift(value);
    }
    expand() {
      const newCapacity = this.capacity * 2;
      const newData = new Array(newCapacity);
      const len = this.length();
      for (let i = 0;i < len; i++) {
        newData[i] = this.get(this.wrap(this.begin + i));
      }
      this.data = newData;
      this.capacity = newCapacity;
      this.doubledCapacity = 2 * this.capacity;
      this.begin = 0;
      this.end = len;
    }
  };
  GrowingRingBuffer.INITIAL_CAPACITY = 32;
});

// node_modules/@tensorflow/tfjs-data/dist/iterators/lazy_iterator.js
function iteratorFromItems(items) {
  return new ArrayIterator(items);
}
function iteratorFromFunction(func) {
  return new FunctionCallIterator(func);
}
function iteratorFromConcatenated(baseIterators, baseErrorHandler) {
  return new ChainedIterator(baseIterators, baseErrorHandler);
}
function iteratorFromZipped(iterators, mismatchMode = ZipMismatchMode.FAIL) {
  return new ZipIterator(iterators, mismatchMode);
}

class LazyIterator {
  async toArray() {
    const result = [];
    let x = await this.next();
    while (!x.done) {
      result.push(x.value);
      x = await this.next();
    }
    return result;
  }
  async toArrayForTest() {
    const stream = this.prefetch(100);
    const result = [];
    let x = await stream.next();
    while (!x.done) {
      result.push(x.value);
      x = await stream.next();
    }
    return result;
  }
  async resolveFully() {
    let x = await this.next();
    while (!x.done) {
      x = await this.next();
    }
  }
  async resolveWhile(predicate) {
    let x = await this.next();
    let shouldContinue = predicate(x.value);
    while (!x.done && shouldContinue) {
      x = await this.next();
      shouldContinue = predicate(x.value);
    }
  }
  handleErrors(handler) {
    return new ErrorHandlingLazyIterator(this, handler);
  }
  filter(predicate) {
    return new FilterIterator(this, predicate);
  }
  map(transform3) {
    return new MapIterator(this, transform3);
  }
  mapAsync(transform3) {
    return new AsyncMapIterator(this, transform3);
  }
  serialMapAsync(transform3) {
    return new AsyncMapIterator(this, transform3).serial();
  }
  flatmap(transform3) {
    return new FlatmapIterator(this, transform3);
  }
  async forEachAsync(f) {
    return this.map(f).resolveFully();
  }
  async serialForEach(f) {
    return this.serialMapAsync(f).resolveWhile((x) => x === true);
  }
  rowMajorBatch(batchSize, smallLastBatch = true) {
    return new RowMajorBatchIterator(this, batchSize, smallLastBatch);
  }
  columnMajorBatch(batchSize, smallLastBatch = true, zipFn = zipToList) {
    const rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);
    return rowBatches.map((x) => deepZip(x, zipFn));
  }
  concatenate(iterator, baseErrorHandler) {
    return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);
  }
  take(count2) {
    if (count2 < 0 || count2 == null) {
      return this;
    }
    return new TakeIterator(this, count2);
  }
  skip(count2) {
    if (count2 < 0 || count2 == null) {
      return this;
    }
    return new SkipIterator(this, count2);
  }
  prefetch(bufferSize) {
    return new PrefetchIterator(this, bufferSize);
  }
  shuffle(windowSize, seed) {
    return new ShuffleIterator(this, windowSize, seed);
  }
  serial() {
    return new SerialIterator(this);
  }
}
var seedrandom2, ArrayIterator, FunctionCallIterator, SerialIterator, SkipIterator, TakeIterator, RowMajorBatchIterator, FilterIterator, MapIterator, ErrorHandlingLazyIterator, AsyncMapIterator, OneToManyIterator, FlatmapIterator, ChainedIterator, ZipMismatchMode, ZipIterator, PrefetchIterator, ShuffleIterator;
var init_lazy_iterator = __esm(() => {
  init_dist();
  seedrandom2 = __toESM(require_seedrandom2(), 1);
  init_deep_clone();
  init_deep_map();
  init_growing_ring_buffer();
  ArrayIterator = class ArrayIterator extends LazyIterator {
    constructor(items) {
      super();
      this.items = items;
      this.trav = 0;
    }
    summary() {
      return `Array of ${this.items.length} items`;
    }
    async next() {
      if (this.trav >= this.items.length) {
        return { value: null, done: true };
      }
      const item = this.items[this.trav];
      this.trav++;
      return { value: deepClone(item), done: false };
    }
  };
  FunctionCallIterator = class FunctionCallIterator extends LazyIterator {
    constructor(nextFn) {
      super();
      this.nextFn = nextFn;
    }
    summary() {
      return `Function call`;
    }
    async next() {
      try {
        return this.nextFn();
      } catch (e) {
        e.message = `Error thrown while iterating through a dataset: ${e.message}`;
        throw e;
      }
    }
  };
  SerialIterator = class SerialIterator extends LazyIterator {
    constructor(upstream) {
      super();
      this.upstream = upstream;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Serial`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      return this.upstream.next();
    }
  };
  SkipIterator = class SkipIterator extends LazyIterator {
    constructor(upstream, maxCount) {
      super();
      this.upstream = upstream;
      this.maxCount = maxCount;
      this.count = 0;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Skip`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (this.count++ < this.maxCount) {
        const skipped = await this.upstream.next();
        if (skipped.done) {
          return skipped;
        }
        dispose(skipped.value);
      }
      return this.upstream.next();
    }
  };
  TakeIterator = class TakeIterator extends LazyIterator {
    constructor(upstream, maxCount) {
      super();
      this.upstream = upstream;
      this.maxCount = maxCount;
      this.count = 0;
    }
    summary() {
      return `${this.upstream.summary()} -> Take`;
    }
    async next() {
      if (this.count++ >= this.maxCount) {
        return { value: null, done: true };
      }
      return this.upstream.next();
    }
  };
  RowMajorBatchIterator = class RowMajorBatchIterator extends LazyIterator {
    constructor(upstream, batchSize, enableSmallLastBatch = true) {
      super();
      this.upstream = upstream;
      this.batchSize = batchSize;
      this.enableSmallLastBatch = enableSmallLastBatch;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> RowMajorBatch`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      const batch = [];
      while (batch.length < this.batchSize) {
        const item = await this.upstream.next();
        if (item.done) {
          if (this.enableSmallLastBatch && batch.length > 0) {
            return { value: batch, done: false };
          }
          return { value: null, done: true };
        }
        batch.push(item.value);
      }
      return { value: batch, done: false };
    }
  };
  FilterIterator = class FilterIterator extends LazyIterator {
    constructor(upstream, predicate) {
      super();
      this.upstream = upstream;
      this.predicate = predicate;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> Filter`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (true) {
        const item = await this.upstream.next();
        if (item.done || this.predicate(item.value)) {
          return item;
        }
        dispose(item.value);
      }
    }
  };
  MapIterator = class MapIterator extends LazyIterator {
    constructor(upstream, transform3) {
      super();
      this.upstream = upstream;
      this.transform = transform3;
    }
    summary() {
      return `${this.upstream.summary()} -> Map`;
    }
    async next() {
      const item = await this.upstream.next();
      if (item.done) {
        return { value: null, done: true };
      }
      const inputTensors = exports_tensor_util.getTensorsInContainer(item.value);
      const mapped = this.transform(item.value);
      const outputTensors = exports_tensor_util.getTensorsInContainer(mapped);
      for (const t of inputTensors) {
        if (!exports_tensor_util.isTensorInList(t, outputTensors)) {
          t.dispose();
        }
      }
      return { value: mapped, done: false };
    }
  };
  ErrorHandlingLazyIterator = class ErrorHandlingLazyIterator extends LazyIterator {
    constructor(upstream, handler) {
      super();
      this.upstream = upstream;
      this.handler = handler;
      this.count = 0;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    summary() {
      return `${this.upstream.summary()} -> handleErrors`;
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (true) {
        try {
          return await this.upstream.next();
        } catch (e) {
          if (!this.handler(e)) {
            return { value: null, done: true };
          }
        }
      }
    }
  };
  AsyncMapIterator = class AsyncMapIterator extends LazyIterator {
    constructor(upstream, transform3) {
      super();
      this.upstream = upstream;
      this.transform = transform3;
    }
    summary() {
      return `${this.upstream.summary()} -> AsyncMap`;
    }
    async next() {
      const item = await this.upstream.next();
      if (item.done) {
        return { value: null, done: true };
      }
      const inputTensors = exports_tensor_util.getTensorsInContainer(item.value);
      const mapped = await this.transform(item.value);
      const outputTensors = exports_tensor_util.getTensorsInContainer(mapped);
      for (const t of inputTensors) {
        if (!exports_tensor_util.isTensorInList(t, outputTensors)) {
          t.dispose();
        }
      }
      return { value: mapped, done: false };
    }
  };
  OneToManyIterator = class OneToManyIterator extends LazyIterator {
    constructor() {
      super();
      this.outputQueue = new GrowingRingBuffer;
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    async serialNext() {
      while (this.outputQueue.length() === 0) {
        if (!await this.pump()) {
          return { value: null, done: true };
        }
      }
      return { value: this.outputQueue.shift(), done: false };
    }
  };
  FlatmapIterator = class FlatmapIterator extends OneToManyIterator {
    constructor(upstream, transform3) {
      super();
      this.upstream = upstream;
      this.transform = transform3;
    }
    summary() {
      return `${this.upstream.summary()} -> Flatmap`;
    }
    async pump() {
      const item = await this.upstream.next();
      if (item.done) {
        return false;
      }
      const inputTensors = exports_tensor_util.getTensorsInContainer(item.value);
      const mappedArray = this.transform(item.value);
      const outputTensors = exports_tensor_util.getTensorsInContainer(mappedArray);
      this.outputQueue.pushAll(mappedArray);
      for (const t of inputTensors) {
        if (!exports_tensor_util.isTensorInList(t, outputTensors)) {
          t.dispose();
        }
      }
      return true;
    }
  };
  ChainedIterator = class ChainedIterator extends LazyIterator {
    constructor(iterators, baseErrorHandler) {
      super();
      this.baseErrorHandler = baseErrorHandler;
      this.lastRead = null;
      this.iterator = null;
      this.moreIterators = iterators;
    }
    summary() {
      const upstreamSummaries = "TODO: fill in upstream of chained summaries";
      return `${upstreamSummaries} -> Chained`;
    }
    async next() {
      this.lastRead = this.readFromChain(this.lastRead);
      return this.lastRead;
    }
    async readFromChain(lastRead) {
      await lastRead;
      if (this.iterator == null) {
        const iteratorResult = await this.moreIterators.next();
        if (iteratorResult.done) {
          return { value: null, done: true };
        }
        this.iterator = iteratorResult.value;
        if (this.baseErrorHandler != null) {
          this.iterator = this.iterator.handleErrors(this.baseErrorHandler);
        }
      }
      const itemResult = await this.iterator.next();
      if (itemResult.done) {
        this.iterator = null;
        return this.readFromChain(lastRead);
      }
      return itemResult;
    }
  };
  (function(ZipMismatchMode2) {
    ZipMismatchMode2[ZipMismatchMode2["FAIL"] = 0] = "FAIL";
    ZipMismatchMode2[ZipMismatchMode2["SHORTEST"] = 1] = "SHORTEST";
    ZipMismatchMode2[ZipMismatchMode2["LONGEST"] = 2] = "LONGEST";
  })(ZipMismatchMode || (ZipMismatchMode = {}));
  ZipIterator = class ZipIterator extends LazyIterator {
    constructor(iterators, mismatchMode = ZipMismatchMode.FAIL) {
      super();
      this.iterators = iterators;
      this.mismatchMode = mismatchMode;
      this.count = 0;
      this.currentPromise = null;
    }
    summary() {
      const upstreamSummaries = "TODO: fill in upstream of zip summaries";
      return `{${upstreamSummaries}} -> Zip`;
    }
    async nextState(afterState) {
      await afterState;
      let numIterators = 0;
      let iteratorsDone = 0;
      function getNext(container2) {
        if (container2 instanceof LazyIterator) {
          const result = container2.next();
          return {
            value: result.then((x) => {
              numIterators++;
              if (x.done) {
                iteratorsDone++;
              }
              return x.value;
            }),
            recurse: false
          };
        } else {
          return { value: null, recurse: true };
        }
      }
      const mapped = await deepMapAndAwaitAll(this.iterators, getNext);
      if (numIterators === iteratorsDone) {
        return { value: null, done: true };
      }
      if (iteratorsDone > 0) {
        switch (this.mismatchMode) {
          case ZipMismatchMode.FAIL:
            throw new Error("Zipped streams should have the same length. " + `Mismatched at element ${this.count}.`);
          case ZipMismatchMode.SHORTEST:
            return { value: null, done: true };
          case ZipMismatchMode.LONGEST:
          default:
        }
      }
      this.count++;
      return { value: mapped, done: false };
    }
    async next() {
      this.currentPromise = this.nextState(this.currentPromise);
      return this.currentPromise;
    }
  };
  PrefetchIterator = class PrefetchIterator extends LazyIterator {
    constructor(upstream, bufferSize) {
      super();
      this.upstream = upstream;
      this.bufferSize = bufferSize;
      this.buffer = new RingBuffer(bufferSize);
    }
    summary() {
      return `${this.upstream.summary()} -> Prefetch`;
    }
    refill() {
      while (!this.buffer.isFull()) {
        const v = this.upstream.next();
        this.buffer.push(v);
      }
    }
    next() {
      this.refill();
      return this.buffer.shift();
    }
  };
  ShuffleIterator = class ShuffleIterator extends PrefetchIterator {
    constructor(upstream, windowSize, seed) {
      super(upstream, windowSize);
      this.upstream = upstream;
      this.windowSize = windowSize;
      this.upstreamExhausted = false;
      this.random = seedrandom2.alea(seed || exports_util.now().toString());
      this.lastRead = Promise.resolve({ value: null, done: false });
    }
    async next() {
      this.lastRead = this.lastRead.then(() => this.serialNext());
      return this.lastRead;
    }
    randomInt(max8) {
      return Math.floor(this.random() * max8);
    }
    chooseIndex() {
      return this.randomInt(this.buffer.length());
    }
    async serialNext() {
      if (!this.upstreamExhausted) {
        this.refill();
      }
      while (!this.buffer.isEmpty()) {
        const chosenIndex = this.chooseIndex();
        const result = await this.buffer.shuffleExcise(chosenIndex);
        if (result.done) {
          this.upstreamExhausted = true;
        } else {
          this.refill();
          return result;
        }
      }
      return { value: null, done: true };
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/dataset.js
function datasetFromIteratorFn(iteratorFn, size = null) {
  return new class extends Dataset {
    constructor() {
      super(...arguments);
      this.size = size;
    }
    async iterator() {
      return iteratorFn();
    }
  };
}
function array(items) {
  return datasetFromIteratorFn(async () => iteratorFromItems(items), items.length);
}
function zip(datasets) {
  if (!isIterable2(datasets)) {
    throw new Error("The argument to zip() must be an object or array.");
  }
  let size;
  if (Array.isArray(datasets)) {
    for (let i = 0;i < datasets.length; i++) {
      size = size == null ? datasets[i].size : Math.min(size, datasets[i].size);
    }
  } else if (datasets instanceof Object) {
    for (const ds in datasets) {
      size = size == null ? datasets[ds].size : Math.min(size, datasets[ds].size);
    }
  }
  return datasetFromIteratorFn(async () => {
    const streams = await deepMapAndAwaitAll(datasets, (d) => {
      if (d instanceof Dataset) {
        return { value: d.iterator(), recurse: false };
      } else if (isIterable2(d)) {
        return { value: null, recurse: true };
      } else {
        throw new Error("Leaves of the structure passed to zip() must be Datasets, " + "not primitives.");
      }
    });
    return iteratorFromZipped(streams, ZipMismatchMode.SHORTEST);
  }, size);
}
function deepBatchConcat(rows) {
  if (rows === null) {
    return null;
  }
  const exampleRow = rows[0];
  if (canTensorify(exampleRow)) {
    const value = batchConcat(rows);
    return { value, recurse: false };
  }
  return { value: null, recurse: true };
}
function batchConcat(arrays) {
  if (arrays.length === 0) {
    throw new Error("Can\'t make a batch of zero elements.");
  }
  if (arrays[0] instanceof Tensor) {
    return stack(arrays);
  } else {
    return tensor4(arrays);
  }
}

class Dataset {
  constructor() {
    this.size = null;
  }
  batch(batchSize, smallLastBatch = true) {
    const base3 = this;
    exports_util.assert(batchSize > 0, () => `batchSize needs to be positive, but it is
      ${batchSize}`);
    let size;
    if (this.size === Infinity || this.size == null) {
      size = this.size;
    } else if (smallLastBatch) {
      size = Math.ceil(this.size / batchSize);
    } else {
      size = Math.floor(this.size / batchSize);
    }
    return datasetFromIteratorFn(async () => {
      return (await base3.iterator()).columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat);
    }, size);
  }
  concatenate(dataset) {
    const base3 = this;
    let size;
    if (this.size === Infinity || dataset.size === Infinity) {
      size = Infinity;
    } else if (this.size != null && dataset.size != null) {
      size = this.size + dataset.size;
    } else {
      size = null;
    }
    return datasetFromIteratorFn(async () => (await base3.iterator()).concatenate(await dataset.iterator()), size);
  }
  filter(predicate) {
    const base3 = this;
    let size;
    if (this.size === Infinity) {
      size = Infinity;
    } else {
      size = null;
    }
    return datasetFromIteratorFn(async () => {
      return (await base3.iterator()).filter((x) => tidy(() => predicate(x)));
    }, size);
  }
  async forEachAsync(f) {
    return (await this.iterator()).forEachAsync(f);
  }
  map(transform3) {
    const base3 = this;
    return datasetFromIteratorFn(async () => {
      return (await base3.iterator()).map((x) => tidy(() => transform3(x)));
    }, this.size);
  }
  mapAsync(transform3) {
    const base3 = this;
    return datasetFromIteratorFn(async () => {
      return (await base3.iterator()).mapAsync(transform3);
    }, this.size);
  }
  prefetch(bufferSize) {
    if (bufferSize == null) {
      throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
    }
    const base3 = this;
    return datasetFromIteratorFn(async () => (await base3.iterator()).prefetch(bufferSize), this.size);
  }
  repeat(count2) {
    const base3 = this;
    let size;
    if (this.size != null && count2 > 0) {
      size = this.size * count2;
    } else if (count2 === 0) {
      size = 0;
    } else if (this.size != null && (count2 === undefined || count2 < 0)) {
      size = Infinity;
    } else {
      size = null;
    }
    return datasetFromIteratorFn(async () => {
      const iteratorIterator = iteratorFromFunction(async () => ({ value: await base3.iterator(), done: false }));
      return iteratorFromConcatenated(iteratorIterator.take(count2));
    }, size);
  }
  skip(count2) {
    const base3 = this;
    let size;
    if (this.size != null && count2 >= 0 && this.size >= count2) {
      size = this.size - count2;
    } else if (this.size != null && (this.size < count2 || count2 === undefined || count2 < 0)) {
      size = 0;
    } else {
      size = null;
    }
    return datasetFromIteratorFn(async () => (await base3.iterator()).skip(count2), size);
  }
  shuffle(bufferSize, seed, reshuffleEachIteration = true) {
    if (bufferSize == null || bufferSize < 0) {
      if (this.size == null) {
        throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.");
      } else {
        throw new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  " + "If your data fits in main memory (for regular JS objects), " + "and/or GPU memory (for `tf.Tensor`s), consider setting " + `bufferSize to the dataset size (${this.size} elements)`);
      }
    }
    const base3 = this;
    const random = seedrandom3.alea(seed || exports_util.now().toString());
    return datasetFromIteratorFn(async () => {
      let seed2 = random.int32();
      if (reshuffleEachIteration) {
        seed2 += random.int32();
      }
      return (await base3.iterator()).shuffle(bufferSize, seed2.toString());
    }, this.size);
  }
  take(count2) {
    const base3 = this;
    let size;
    if (this.size != null && this.size > count2) {
      size = count2;
    } else if (this.size != null && this.size <= count2) {
      size = this.size;
    } else {
      size = null;
    }
    return datasetFromIteratorFn(async () => (await base3.iterator()).take(count2), size);
  }
  async toArray() {
    if (this.size === Infinity) {
      throw new Error("Can not convert infinite data stream to array.");
    }
    return (await this.iterator()).toArray();
  }
  async toArrayForTest() {
    if (this.size === Infinity) {
      throw new Error("Can not convert infinite data stream to array.");
    }
    return (await this.iterator()).toArrayForTest();
  }
}
var seedrandom3;
var init_dataset = __esm(() => {
  init_dist();
  seedrandom3 = __toESM(require_seedrandom2(), 1);
  init_lazy_iterator();
  init_deep_map();
  Dataset.MAX_BUFFER_SIZE = 1e4;
});

// node_modules/@tensorflow/tfjs-data/dist/datasets/text_line_dataset.js
var TextLineDataset;
var init_text_line_dataset = __esm(() => {
  init_dataset();
  TextLineDataset = class TextLineDataset extends Dataset {
    constructor(input2) {
      super();
      this.input = input2;
    }
    async iterator() {
      const inputIterator = await this.input.iterator();
      const utf8Iterator = inputIterator.decodeUTF8();
      const lineIterator = utf8Iterator.split("\n").map((line) => {
        if (line.endsWith("\r")) {
          line = line.slice(0, -1);
        }
        return line;
      });
      return lineIterator;
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/datasets/csv_dataset.js
var CODE_QUOTE = '"', STATE_OUT, STATE_FIELD, STATE_QUOTE, STATE_QUOTE_AFTER_QUOTE, STATE_WITHIN_QUOTE_IN_QUOTE, CSVDataset;
var init_csv_dataset = __esm(() => {
  init_dist();
  init_dataset();
  init_text_line_dataset();
  STATE_OUT = Symbol("out");
  STATE_FIELD = Symbol("field");
  STATE_QUOTE = Symbol("quote");
  STATE_QUOTE_AFTER_QUOTE = Symbol("quoteafterquote");
  STATE_WITHIN_QUOTE_IN_QUOTE = Symbol("quoteinquote");
  CSVDataset = class CSVDataset extends Dataset {
    async columnNames() {
      if (!this.columnNamesValidated) {
        await this.setColumnNames();
      }
      return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames;
    }
    async setColumnNames() {
      const columnNamesFromFile = await this.maybeReadHeaderLine();
      if (!this.fullColumnNames && !columnNamesFromFile) {
        throw new Error("Column names must be provided if there is no header line.");
      } else if (this.fullColumnNames && columnNamesFromFile) {
        exports_util.assert(columnNamesFromFile.length === this.fullColumnNames.length, () => "The length of provided columnNames (" + this.fullColumnNames.length.toString() + ") does not match the length of the header line read from " + "file (" + columnNamesFromFile.length.toString() + ").");
      }
      if (!this.fullColumnNames) {
        this.fullColumnNames = columnNamesFromFile;
      }
      const counts = this.fullColumnNames.reduce((countAcc, name) => {
        countAcc[name] = countAcc[name] + 1 || 1;
        return countAcc;
      }, {});
      const duplicateNames = Object.keys(counts).filter((name) => counts[name] > 1);
      exports_util.assert(duplicateNames.length === 0, () => "Duplicate column names found: " + duplicateNames.toString());
      if (this.columnConfigs) {
        for (const key of Object.keys(this.columnConfigs)) {
          const index = this.fullColumnNames.indexOf(key);
          if (index === -1) {
            throw new Error('The key "' + key + '" provided in columnConfigs does not match any of the column ' + "names (" + this.fullColumnNames.toString() + ").");
          }
        }
      }
      this.columnNamesValidated = true;
    }
    async maybeReadHeaderLine() {
      if (this.hasHeader) {
        const iter = await this.base.iterator();
        const firstElement = await iter.next();
        if (firstElement.done) {
          throw new Error("No data was found for CSV parsing.");
        }
        const firstLine = firstElement.value;
        const headers = this.parseRow(firstLine, false);
        return headers;
      } else {
        return null;
      }
    }
    constructor(input2, csvConfig) {
      super();
      this.input = input2;
      this.hasHeader = true;
      this.fullColumnNames = null;
      this.columnNamesValidated = false;
      this.columnConfigs = null;
      this.configuredColumnsOnly = false;
      this.delimiter = ",";
      this.delimWhitespace = false;
      this.base = new TextLineDataset(input2);
      if (!csvConfig) {
        csvConfig = {};
      }
      this.hasHeader = csvConfig.hasHeader === false ? false : true;
      this.fullColumnNames = csvConfig.columnNames;
      this.columnConfigs = csvConfig.columnConfigs;
      this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;
      if (csvConfig.delimWhitespace) {
        exports_util.assert(csvConfig.delimiter == null, () => "Delimiter should not be provided when delimWhitespace is true.");
        this.delimWhitespace = true;
        this.delimiter = " ";
      } else {
        this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ",";
      }
    }
    async iterator() {
      if (!this.columnNamesValidated) {
        await this.setColumnNames();
      }
      let lines = await this.base.iterator();
      if (this.hasHeader) {
        lines = lines.skip(1);
      }
      return lines.map((x) => this.makeDataElement(x));
    }
    makeDataElement(line) {
      const values = this.parseRow(line);
      const features = {};
      const labels = {};
      for (let i = 0;i < this.fullColumnNames.length; i++) {
        const key = this.fullColumnNames[i];
        const config = this.columnConfigs ? this.columnConfigs[key] : null;
        if (this.configuredColumnsOnly && !config) {
          continue;
        } else {
          const value = values[i];
          let parsedValue = null;
          if (value === "") {
            if (config && config.default !== undefined) {
              parsedValue = config.default;
            } else if (config && (config.required || config.isLabel)) {
              throw new Error(`Required column ${key} is empty in this line: ${line}`);
            } else {
              parsedValue = undefined;
            }
          } else {
            const valueAsNum = Number(value);
            if (isNaN(valueAsNum)) {
              if (config && config.dtype === "bool") {
                parsedValue = this.getBoolean(value);
              } else {
                parsedValue = value;
              }
            } else if (!config || !config.dtype) {
              parsedValue = valueAsNum;
            } else {
              switch (config.dtype) {
                case "float32":
                  parsedValue = valueAsNum;
                  break;
                case "int32":
                  parsedValue = Math.floor(valueAsNum);
                  break;
                case "bool":
                  parsedValue = this.getBoolean(value);
                  break;
                default:
                  parsedValue = valueAsNum;
              }
            }
          }
          config && config.isLabel ? labels[key] = parsedValue : features[key] = parsedValue;
        }
      }
      if (Object.keys(labels).length === 0) {
        return features;
      } else {
        return { xs: features, ys: labels };
      }
    }
    getBoolean(value) {
      if (value === "1" || value.toLowerCase() === "true") {
        return 1;
      } else {
        return 0;
      }
    }
    parseRow(line, validateElementCount = true) {
      const result = [];
      let readOffset = 0;
      const readLength = line.length;
      let currentState = STATE_OUT;
      for (let i = 0;i < readLength; i++) {
        switch (currentState) {
          case STATE_OUT:
            switch (line.charAt(i)) {
              case CODE_QUOTE:
                readOffset = i + 1;
                currentState = STATE_QUOTE;
                break;
              case this.delimiter:
                readOffset = i + 1;
                if (this.delimiter === " " && this.delimWhitespace) {
                  break;
                }
                result.push("");
                currentState = STATE_OUT;
                break;
              default:
                currentState = STATE_FIELD;
                readOffset = i;
                break;
            }
            break;
          case STATE_FIELD:
            switch (line.charAt(i)) {
              case this.delimiter:
                result.push(line.substring(readOffset, i));
                currentState = STATE_OUT;
                readOffset = i + 1;
                break;
              default:
            }
            break;
          case STATE_QUOTE:
            switch (line.charAt(i)) {
              case CODE_QUOTE:
                currentState = STATE_QUOTE_AFTER_QUOTE;
                break;
              default:
            }
            break;
          case STATE_QUOTE_AFTER_QUOTE:
            switch (line.charAt(i)) {
              case this.delimiter:
                result.push(line.substring(readOffset, i - 1));
                currentState = STATE_OUT;
                readOffset = i + 1;
                break;
              case CODE_QUOTE:
                currentState = STATE_QUOTE;
                break;
              default:
                currentState = STATE_WITHIN_QUOTE_IN_QUOTE;
                break;
            }
            break;
          case STATE_WITHIN_QUOTE_IN_QUOTE:
            switch (line.charAt(i)) {
              case CODE_QUOTE:
                currentState = STATE_QUOTE;
                break;
              default:
            }
            break;
          default:
        }
      }
      if (currentState === STATE_QUOTE_AFTER_QUOTE) {
        result.push(line.substring(readOffset, readLength - 1));
      } else {
        result.push(line.substring(readOffset));
      }
      if (validateElementCount && result.length !== this.fullColumnNames.length) {
        throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);
      }
      return result;
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/iterators/microphone_iterator.js
var MicrophoneIterator;
var init_microphone_iterator = __esm(() => {
  init_dist();
  init_lazy_iterator();
  MicrophoneIterator = class MicrophoneIterator extends LazyIterator {
    constructor(microphoneConfig) {
      super();
      this.microphoneConfig = microphoneConfig;
      this.isClosed = false;
      this.fftSize = microphoneConfig.fftSize || 1024;
      const fftSizeLog2 = Math.log2(this.fftSize);
      if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {
        throw new Error(`Invalid fftSize: it must be a power of 2 between ` + `2 to 4 and 2 to 14, but got ${this.fftSize}`);
      }
      this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;
      this.sampleRateHz = microphoneConfig.sampleRateHz;
      this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;
      this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;
      this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;
      this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;
      this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;
      if (!this.includeSpectrogram && !this.includeWaveform) {
        throw new Error("Both includeSpectrogram and includeWaveform are false. " + "At least one type of data should be returned.");
      }
    }
    summary() {
      return `microphone`;
    }
    static async create(microphoneConfig = {}) {
      if (!env().get("IS_BROWSER")) {
        throw new Error("microphone API is only supported in browser environment.");
      }
      const microphoneIterator = new MicrophoneIterator(microphoneConfig);
      await microphoneIterator.start();
      return microphoneIterator;
    }
    async start() {
      try {
        this.stream = await navigator.mediaDevices.getUserMedia({
          audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,
          video: false
        });
      } catch (e) {
        throw new Error(`Error thrown while initializing video stream: ${e.message}`);
      }
      if (!this.stream) {
        throw new Error("Could not obtain audio from microphone.");
      }
      const ctxConstructor = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new ctxConstructor;
      if (!this.sampleRateHz) {
        this.sampleRateHz = this.audioContext.sampleRate;
      } else if (this.audioContext.sampleRate !== this.sampleRateHz) {
        throw new Error(`Mismatch in sampling rate: ` + `Expected: ${this.sampleRateHz}; ` + `Actual: ${this.audioContext.sampleRate}`);
      }
      const streamSource = this.audioContext.createMediaStreamSource(this.stream);
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = this.fftSize * 2;
      this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;
      streamSource.connect(this.analyser);
      this.freqData = new Float32Array(this.fftSize);
      this.timeData = new Float32Array(this.fftSize);
      return;
    }
    async next() {
      if (this.isClosed) {
        return { value: null, done: true };
      }
      let spectrogramTensor;
      let waveformTensor;
      const audioDataQueue = await this.getAudioData();
      if (this.includeSpectrogram) {
        const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);
        spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);
      }
      if (this.includeWaveform) {
        const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);
        waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);
      }
      return {
        value: { spectrogram: spectrogramTensor, waveform: waveformTensor },
        done: false
      };
    }
    async capture() {
      return (await this.next()).value;
    }
    async getAudioData() {
      const freqDataQueue = [];
      const timeDataQueue = [];
      let currentFrames = 0;
      return new Promise((resolve) => {
        const intervalID = setInterval(() => {
          if (this.includeSpectrogram) {
            this.analyser.getFloatFrequencyData(this.freqData);
            if (this.freqData[0] === -Infinity) {
              resolve({ freqDataQueue, timeDataQueue });
            }
            freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));
          }
          if (this.includeWaveform) {
            this.analyser.getFloatTimeDomainData(this.timeData);
            timeDataQueue.push(this.timeData.slice());
          }
          if (++currentFrames === this.numFrames) {
            clearInterval(intervalID);
            resolve({ freqDataQueue, timeDataQueue });
          }
        }, this.fftSize / this.sampleRateHz * 1000);
      });
    }
    stop() {
      if (!this.isClosed) {
        this.isClosed = true;
        this.analyser.disconnect();
        this.audioContext.close();
        if (this.stream != null && this.stream.getTracks().length > 0) {
          this.stream.getTracks()[0].stop();
        }
      }
    }
    toArray() {
      throw new Error("Can not convert infinite audio stream to array.");
    }
    getSampleRate() {
      return this.sampleRateHz;
    }
    flattenQueue(queue) {
      const frameSize = queue[0].length;
      const freqData = new Float32Array(queue.length * frameSize);
      queue.forEach((data, i) => freqData.set(data, i * frameSize));
      return freqData;
    }
    getTensorFromAudioDataArray(freqData, shape) {
      const vals = new Float32Array(exports_util.sizeFromShape(shape));
      vals.set(freqData, vals.length - freqData.length);
      return tensor4(vals, shape);
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/iterators/webcam_iterator.js
var WebcamIterator;
var init_webcam_iterator = __esm(() => {
  init_dist();
  init_lazy_iterator();
  WebcamIterator = class WebcamIterator extends LazyIterator {
    constructor(webcamVideoElement, webcamConfig) {
      super();
      this.webcamVideoElement = webcamVideoElement;
      this.webcamConfig = webcamConfig;
      this.isClosed = true;
      this.resize = false;
      if (this.needToResize()) {
        this.resize = true;
        this.cropSize = [this.webcamConfig.resizeHeight, this.webcamConfig.resizeWidth];
        this.cropBoxInd = tensor1d([0], "int32");
        if (this.webcamConfig.centerCrop) {
          const widthCroppingRatio = this.webcamConfig.resizeWidth * 1 / this.webcamVideoElement.width;
          const heightCroppingRatio = this.webcamConfig.resizeHeight * 1 / this.webcamVideoElement.height;
          const widthCropStart = (1 - widthCroppingRatio) / 2;
          const heightCropStart = (1 - heightCroppingRatio) / 2;
          const widthCropEnd = widthCropStart + widthCroppingRatio;
          const heightCropEnd = heightCroppingRatio + heightCropStart;
          this.cropBox = tensor2d([heightCropStart, widthCropStart, heightCropEnd, widthCropEnd], [1, 4]);
        } else {
          this.cropBox = tensor2d([0, 0, 1, 1], [1, 4]);
        }
      }
    }
    summary() {
      return `webcam`;
    }
    static async create(webcamVideoElement, webcamConfig = {}) {
      if (!env().get("IS_BROWSER")) {
        throw new Error("tf.data.webcam is only supported in browser environment.");
      }
      if (!webcamVideoElement) {
        webcamVideoElement = document.createElement("video");
        if (!webcamConfig.resizeWidth || !webcamConfig.resizeHeight) {
          throw new Error("Please provide webcam video element, or resizeWidth and " + "resizeHeight to create a hidden video element.");
        }
        webcamVideoElement.width = webcamConfig.resizeWidth;
        webcamVideoElement.height = webcamConfig.resizeHeight;
      }
      const webcamIterator = new WebcamIterator(webcamVideoElement, webcamConfig);
      await webcamIterator.start();
      return webcamIterator;
    }
    async start() {
      if (this.webcamConfig.facingMode) {
        exports_util.assert(this.webcamConfig.facingMode === "user" || this.webcamConfig.facingMode === "environment", () => `Invalid webcam facing mode: ${this.webcamConfig.facingMode}. ` + `Please provide 'user' or 'environment'`);
      }
      try {
        this.stream = await navigator.mediaDevices.getUserMedia({
          video: {
            deviceId: this.webcamConfig.deviceId,
            facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
            width: this.webcamVideoElement.width,
            height: this.webcamVideoElement.height
          }
        });
      } catch (e) {
        e.message = `Error thrown while initializing video stream: ${e.message}`;
        throw e;
      }
      if (!this.stream) {
        throw new Error("Could not obtain video from webcam.");
      }
      try {
        this.webcamVideoElement.srcObject = this.stream;
      } catch (error) {
        console.log(error);
        this.webcamVideoElement.src = window.URL.createObjectURL(this.stream);
      }
      this.webcamVideoElement.play();
      this.isClosed = false;
      return new Promise((resolve) => {
        this.webcamVideoElement.onloadedmetadata = () => {
          resolve();
        };
      });
    }
    async next() {
      if (this.isClosed) {
        return { value: null, done: true };
      }
      let img;
      try {
        img = exports_browser.fromPixels(this.webcamVideoElement);
      } catch (e) {
        throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`);
      }
      if (this.resize) {
        try {
          return { value: this.cropAndResizeFrame(img), done: false };
        } catch (e) {
          throw new Error(`Error thrown cropping the video: ${e.message}`);
        } finally {
          img.dispose();
        }
      } else {
        return { value: img, done: false };
      }
    }
    needToResize() {
      if (this.webcamConfig.resizeWidth && this.webcamConfig.resizeHeight && (this.webcamVideoElement.width !== this.webcamConfig.resizeWidth || this.webcamVideoElement.height !== this.webcamConfig.resizeHeight)) {
        return true;
      }
      return false;
    }
    cropAndResizeFrame(img) {
      return tidy(() => {
        const expandedImage = expandDims(cast(img, "float32"), 0);
        let resizedImage;
        resizedImage = image.cropAndResize(expandedImage, this.cropBox, this.cropBoxInd, this.cropSize, "bilinear");
        const shape = resizedImage.shape;
        return reshape(resizedImage, shape.slice(1));
      });
    }
    async capture() {
      return (await this.next()).value;
    }
    stop() {
      const tracks = this.stream.getTracks();
      tracks.forEach((track) => track.stop());
      try {
        this.webcamVideoElement.srcObject = null;
      } catch (error) {
        console.log(error);
        this.webcamVideoElement.src = null;
      }
      this.isClosed = true;
    }
    toArray() {
      throw new Error("Can not convert infinite video stream to array.");
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/datasource.js
class DataSource {
}

// node_modules/@tensorflow/tfjs-data/dist/iterators/string_iterator.js
var StringIterator, SplitIterator, SplitIteratorImpl;
var init_string_iterator = __esm(() => {
  init_lazy_iterator();
  StringIterator = class StringIterator extends LazyIterator {
    split(separator) {
      return new SplitIterator(this, separator);
    }
  };
  SplitIterator = class SplitIterator extends StringIterator {
    constructor(upstream, separator) {
      super();
      this.upstream = upstream;
      this.impl = new SplitIteratorImpl(upstream, separator);
    }
    summary() {
      return this.impl.summary();
    }
    async next() {
      return this.impl.next();
    }
  };
  SplitIteratorImpl = class SplitIteratorImpl extends OneToManyIterator {
    constructor(upstream, separator) {
      super();
      this.upstream = upstream;
      this.separator = separator;
      this.carryover = "";
    }
    summary() {
      return `${this.upstream.summary()} -> Split('${this.separator}')`;
    }
    async pump() {
      const chunkResult = await this.upstream.next();
      if (chunkResult.done) {
        if (this.carryover === "") {
          return false;
        }
        this.outputQueue.push(this.carryover);
        this.carryover = "";
        return true;
      }
      const lines = chunkResult.value.split(this.separator);
      lines[0] = this.carryover + lines[0];
      for (const line of lines.slice(0, -1)) {
        this.outputQueue.push(line);
      }
      this.carryover = lines[lines.length - 1];
      return true;
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/iterators/byte_chunk_iterator.js
var ByteChunkIterator, Utf8Iterator, Utf8IteratorImpl;
var init_byte_chunk_iterator = __esm(() => {
  init_dist();
  init_lazy_iterator();
  init_string_iterator();
  ByteChunkIterator = class ByteChunkIterator extends LazyIterator {
    decodeUTF8() {
      return new Utf8Iterator(this);
    }
  };
  Utf8Iterator = class Utf8Iterator extends StringIterator {
    constructor(upstream) {
      super();
      this.upstream = upstream;
      this.impl = new Utf8IteratorImpl(upstream);
    }
    summary() {
      return this.impl.summary();
    }
    async next() {
      return this.impl.next();
    }
  };
  Utf8IteratorImpl = class Utf8IteratorImpl extends OneToManyIterator {
    constructor(upstream) {
      super();
      this.upstream = upstream;
      if (env().get("IS_BROWSER")) {
        this.decoder = new TextDecoder("utf-8");
      } else {
        const { StringDecoder } = (init_string_decoder(), __toCommonJS(exports_string_decoder));
        this.decoder = new StringDecoder("utf8");
      }
    }
    summary() {
      return `${this.upstream.summary()} -> Utf8`;
    }
    async pump() {
      const chunkResult = await this.upstream.next();
      let chunk;
      if (chunkResult.done) {
        return false;
      } else {
        chunk = chunkResult.value;
      }
      let text;
      if (env().get("IS_BROWSER")) {
        text = this.decoder.decode(chunk, { stream: true });
      } else {
        text = this.decoder.write(Buffer.from(chunk.buffer));
      }
      this.outputQueue.push(text);
      return true;
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/iterators/file_chunk_iterator.js
var FileChunkIterator;
var init_file_chunk_iterator = __esm(() => {
  init_dist();
  init_byte_chunk_iterator();
  FileChunkIterator = class FileChunkIterator extends ByteChunkIterator {
    constructor(file, options = {}) {
      super();
      this.file = file;
      this.options = options;
      exports_util.assert(file instanceof Uint8Array || (env().get("IS_BROWSER") ? file instanceof File || file instanceof Blob : false), () => "FileChunkIterator only supports File, Blob and Uint8Array " + "right now.");
      this.offset = options.offset || 0;
      this.chunkSize = options.chunkSize || 1024 * 1024;
    }
    summary() {
      return `FileChunks ${this.file}`;
    }
    async next() {
      if (this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size)) {
        return { value: null, done: true };
      }
      const chunk = new Promise((resolve, reject) => {
        const end = this.offset + this.chunkSize;
        if (this.file instanceof Uint8Array) {
          resolve(new Uint8Array(this.file.slice(this.offset, end)));
        } else {
          const fileReader = new FileReader;
          fileReader.onload = (event) => {
            let data = fileReader.result;
            if (data instanceof ArrayBuffer) {
              data = new Uint8Array(data);
            }
            if (!(data instanceof Uint8Array)) {
              return reject(new TypeError("FileReader returned unknown type."));
            }
            resolve(data);
          };
          fileReader.onabort = (event) => {
            return reject(new Error("Aborted"));
          };
          fileReader.onerror = (event) => {
            return reject(new Error(event.type));
          };
          const slice16 = this.file.slice(this.offset, end);
          fileReader.readAsArrayBuffer(slice16);
        }
        this.offset = end;
      });
      return { value: await chunk, done: false };
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/iterators/url_chunk_iterator.js
async function urlChunkIterator(url, options = {}, fetchFunc) {
  let urlString;
  let requestInit;
  if (typeof url === "string") {
    urlString = url;
  } else {
    urlString = url.url;
    requestInit = getRequestInitFromRequest(url);
  }
  const response = await (fetchFunc || exports_util.fetch)(urlString, requestInit);
  if (response.ok) {
    const uint8Array = new Uint8Array(await response.arrayBuffer());
    return new FileChunkIterator(uint8Array, options);
  } else {
    throw new Error(response.statusText);
  }
}
var getRequestInitFromRequest = (request) => {
  const init = {
    method: request.method,
    headers: request.headers,
    body: request.body,
    mode: request.mode,
    credentials: request.credentials,
    cache: request.cache,
    redirect: request.redirect,
    referrer: request.referrer,
    integrity: request.integrity
  };
  return init;
};
var init_url_chunk_iterator = __esm(() => {
  init_dist();
  init_file_chunk_iterator();
});

// node_modules/@tensorflow/tfjs-data/dist/util/source_util.js
function isLocalPath(source) {
  return typeof source === "string" && source.slice(0, 7) === "file://";
}

// node_modules/@tensorflow/tfjs-data/dist/sources/file_data_source.js
var FileDataSource;
var init_file_data_source = __esm(() => {
  init_dist();
  init_file_chunk_iterator();
  FileDataSource = class FileDataSource extends DataSource {
    constructor(input2, options = {}) {
      super();
      this.input = input2;
      this.options = options;
    }
    async iterator() {
      if (isLocalPath(this.input) && env().get("IS_NODE")) {
        const fs = (()=>({}));
        this.input = fs.readFileSync(this.input.slice(7));
      }
      return new FileChunkIterator(this.input, this.options);
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/sources/url_data_source.js
var URLDataSource;
var init_url_data_source = __esm(() => {
  init_url_chunk_iterator();
  init_file_data_source();
  URLDataSource = class URLDataSource extends DataSource {
    constructor(url, fileOptions = {}) {
      super();
      this.url = url;
      this.fileOptions = fileOptions;
    }
    async iterator() {
      if (isLocalPath(this.url)) {
        return new FileDataSource(this.url, this.fileOptions).iterator();
      } else {
        return urlChunkIterator(this.url, this.fileOptions);
      }
    }
  };
});

// node_modules/@tensorflow/tfjs-data/dist/readers.js
function csv(source, csvConfig = {}) {
  return new CSVDataset(new URLDataSource(source), csvConfig);
}
function func(f) {
  const iter = iteratorFromFunction(f);
  return datasetFromIteratorFn(async () => iter);
}
function generator(generator2) {
  return datasetFromIteratorFn(async () => {
    const gen = await generator2();
    return iteratorFromFunction(() => gen.next());
  });
}
async function webcam(webcamVideoElement, webcamConfig) {
  return WebcamIterator.create(webcamVideoElement, webcamConfig);
}
async function microphone(microphoneConfig) {
  return MicrophoneIterator.create(microphoneConfig);
}
var init_readers = __esm(() => {
  init_dataset();
  init_csv_dataset();
  init_lazy_iterator();
  init_microphone_iterator();
  init_webcam_iterator();
  init_url_data_source();
});

// node_modules/@tensorflow/tfjs-data/dist/version.js
var version7 = "4.22.0";
var init_version4 = () => {
};

// node_modules/@tensorflow/tfjs-data/dist/index.js
var exports_dist2 = {};
__export(exports_dist2, {
  zip: () => zip,
  webcam: () => webcam,
  version_data: () => version7,
  microphone: () => microphone,
  generator: () => generator,
  func: () => func,
  csv: () => csv,
  array: () => array,
  URLDataSource: () => URLDataSource,
  TextLineDataset: () => TextLineDataset,
  FileDataSource: () => FileDataSource,
  Dataset: () => Dataset,
  CSVDataset: () => CSVDataset
});
var init_dist4 = __esm(() => {
  init_dataset();
  init_csv_dataset();
  init_text_line_dataset();
  init_readers();
  init_file_data_source();
  init_url_data_source();
  init_version4();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js
function assertNotComplex(tensor153, opName) {
  if (!Array.isArray(tensor153)) {
    tensor153 = [tensor153];
  }
  tensor153.forEach((t) => {
    if (t != null) {
      exports_util.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors in the CPU backend.`);
    }
  });
}
var init_cpu_util = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js
var whereImpl2, MathBackendCPU;
var init_backend_cpu = __esm(() => {
  init_dist();
  init_cpu_util();
  whereImpl2 = exports_kernel_impls.whereImpl;
  MathBackendCPU = class MathBackendCPU extends KernelBackend {
    nextDataId() {
      return MathBackendCPU.nextDataId++;
    }
    constructor() {
      super();
      this.blockSize = 48;
      this.firstUse = true;
      this.data = new DataStorage(this, engine7());
    }
    write(values, shape, dtype) {
      if (this.firstUse) {
        this.firstUse = false;
        if (env().get("IS_NODE")) {
          exports_backend_util.warn("\n============================\n" + "Hi, looks like you are running TensorFlow.js in " + "Node.js. To speed things up dramatically, install our node " + "backend, visit https://github.com/tensorflow/tfjs-node for more details. " + "\n============================");
        }
      }
      const dataId = { id: this.nextDataId() };
      this.data.set(dataId, { values, dtype, refCount: 1 });
      return dataId;
    }
    makeTensorInfo(shape, dtype, values) {
      let outId;
      if (dtype === "string" && values != null && values.length > 0 && exports_util.isString(values[0])) {
        const encodedValues = values.map((d) => exports_util.encodeString(d));
        outId = this.write(encodedValues, shape, dtype);
      } else {
        outId = this.write(values, shape, dtype);
      }
      return { dataId: outId, shape, dtype };
    }
    refCount(dataId) {
      if (this.data.has(dataId)) {
        const tensorData = this.data.get(dataId);
        return tensorData.refCount;
      }
      return 0;
    }
    incRef(dataId) {
      const tensorData = this.data.get(dataId);
      tensorData.refCount++;
    }
    decRef(dataId) {
      if (this.data.has(dataId)) {
        const tensorData = this.data.get(dataId);
        tensorData.refCount--;
      }
    }
    move(dataId, values, shape, dtype, refCount) {
      this.data.set(dataId, { values, dtype, refCount });
    }
    numDataIds() {
      return this.data.numDataIds();
    }
    async read(dataId) {
      return this.readSync(dataId);
    }
    readSync(dataId) {
      const { dtype, complexTensorInfos } = this.data.get(dataId);
      if (dtype === "complex64") {
        const realValues = this.readSync(complexTensorInfos.real.dataId);
        const imagValues = this.readSync(complexTensorInfos.imag.dataId);
        return exports_backend_util.mergeRealAndImagArrays(realValues, imagValues);
      }
      return exports_util.convertBackendValuesAndArrayBuffer(this.data.get(dataId).values, dtype);
    }
    bufferSync(t) {
      const data = this.readSync(t.dataId);
      if (t.dtype === "string") {
        try {
          const strings = data.map((d) => exports_util.decodeString(d));
          return buffer(t.shape, t.dtype, strings);
        } catch (_a) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      }
      return buffer(t.shape, t.dtype, data);
    }
    makeOutput(values, shape, dtype) {
      return engine7().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);
    }
    disposeData(dataId, force = false) {
      if (this.data.has(dataId)) {
        this.data.get(dataId).refCount--;
        if (!force && this.data.get(dataId).refCount > 0) {
          return false;
        }
        const { complexTensorInfos } = this.data.get(dataId);
        if (complexTensorInfos != null) {
          this.disposeData(complexTensorInfos.real.dataId, true);
          this.disposeData(complexTensorInfos.imag.dataId, true);
        }
        this.data.delete(dataId);
      }
      return true;
    }
    disposeIntermediateTensorInfo(tensorInfo) {
      this.disposeData(tensorInfo.dataId);
    }
    async time(f) {
      const start = exports_util.now();
      f();
      const kernelMs = exports_util.now() - start;
      return { kernelMs };
    }
    memory() {
      return {
        unreliable: true,
        reasons: ["The reported memory is an upper bound. Due to automatic garbage " + "collection, the true allocated memory may be less."]
      };
    }
    where(condition) {
      assertNotComplex([condition], "where");
      const condVals = this.readSync(condition.dataId);
      return whereImpl2(condition.shape, condVals);
    }
    dispose() {
    }
    floatPrecision() {
      return 32;
    }
    epsilon() {
      return super.epsilon();
    }
  };
  MathBackendCPU.nextDataId = 0;
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Abs.js
function simpleAbsImpl(vals) {
  const resultValues = new Float32Array(vals.length);
  for (let i = 0;i < vals.length; ++i) {
    resultValues[i] = Math.abs(vals[i]);
  }
  return resultValues;
}
var abs8 = (args) => {
  const { x } = args.inputs;
  const cpuBackend = args.backend;
  assertNotComplex(x, "abs");
  let resultValues = new Float32Array(exports_util.sizeFromShape(x.shape));
  const values = cpuBackend.data.get(x.dataId).values;
  resultValues = simpleAbsImpl(values);
  return cpuBackend.makeOutput(resultValues, x.shape, x.dtype);
}, absConfig;
var init_Abs = __esm(() => {
  init_dist();
  init_cpu_util();
  absConfig = {
    kernelName: Abs,
    backendName: "cpu",
    kernelFunc: abs8
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js
function createSimpleBinaryKernelImpl(op2) {
  return (aShape, bShape, aVals, bVals, dtype) => {
    const newShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    const resultRank = newShape.length;
    const resultStrides = exports_util.computeStrides(newShape);
    const resultSize = exports_util.sizeFromShape(newShape);
    const result = exports_util.getTypedArrayFromDType(dtype, resultSize);
    const aRank = aShape.length;
    const bRank = bShape.length;
    const aStrides = exports_util.computeStrides(aShape);
    const bStrides = exports_util.computeStrides(bShape);
    const aBroadcastDims = exports_backend_util.getBroadcastDims(aShape, newShape);
    const bBroadcastDims = exports_backend_util.getBroadcastDims(bShape, newShape);
    if (aBroadcastDims.length + bBroadcastDims.length === 0) {
      for (let i = 0;i < result.length; ++i) {
        result[i] = op2(aVals[i % aVals.length], bVals[i % bVals.length]);
      }
    } else {
      for (let i = 0;i < result.length; ++i) {
        const loc = exports_util.indexToLoc(i, resultRank, resultStrides);
        const aLoc = loc.slice(-aRank);
        aBroadcastDims.forEach((d) => aLoc[d] = 0);
        const aIndex = exports_util.locToIndex(aLoc, aRank, aStrides);
        const bLoc = loc.slice(-bRank);
        bBroadcastDims.forEach((d) => bLoc[d] = 0);
        const bIndex = exports_util.locToIndex(bLoc, bRank, bStrides);
        result[i] = op2(aVals[aIndex], bVals[bIndex]);
      }
    }
    return [result, newShape];
  };
}
var init_binary_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Complex.js
function complex8(args) {
  const { inputs, backend: backend3 } = args;
  const { real: real5, imag: imag5 } = inputs;
  const realVals = backend3.data.get(real5.dataId).values;
  const imagVals = backend3.data.get(imag5.dataId).values;
  const complexInfo = backend3.makeTensorInfo(real5.shape, "complex64");
  const complex9 = backend3.data.get(complexInfo.dataId);
  complex9.complexTensorInfos = {
    real: backend3.makeTensorInfo(real5.shape, "float32", realVals),
    imag: backend3.makeTensorInfo(imag5.shape, "float32", imagVals)
  };
  return complexInfo;
}
var complexConfig;
var init_Complex = __esm(() => {
  init_dist();
  complexConfig = {
    kernelName: Complex,
    backendName: "cpu",
    kernelFunc: complex8
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js
function zeros7(backend3, shape, dtype = "float32") {
  if (dtype === "complex64") {
    const real5 = zeros7(backend3, shape, "float32");
    const imag5 = zeros7(backend3, shape, "float32");
    return complex8({ inputs: { real: real5, imag: imag5 }, backend: backend3 });
  }
  const values = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(shape), dtype);
  return backend3.makeTensorInfo(shape, dtype, values);
}
var init_zeros_impl = __esm(() => {
  init_dist();
  init_Complex();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Identity.js
function identity2(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  backend3.incRef(x.dataId);
  return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
}
var identityConfig;
var init_Identity = __esm(() => {
  init_dist();
  identityConfig = {
    kernelName: Identity,
    backendName: "cpu",
    kernelFunc: identity2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Real.js
function real5(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const real6 = backend3.data.get(input2.dataId).complexTensorInfos.real;
  const realVal = backend3.data.get(real6.dataId).values;
  return backend3.makeTensorInfo(real6.shape, real6.dtype, realVal);
}
var realConfig;
var init_Real = __esm(() => {
  init_dist();
  realConfig = {
    kernelName: Real,
    backendName: "cpu",
    kernelFunc: real5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cast.js
function castImpl(values, shape, inputType, dtype) {
  if (dtype === "int32") {
    const resultValues = Int32Array.from(values);
    return [shape, "int32", resultValues];
  }
  if (dtype === "bool") {
    const zero = exports_util.toTypedArray([0], inputType);
    const [resultData, resultShape] = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0)(shape, [], values, zero, "bool");
    return [resultShape, "bool", resultData];
  }
  throw new Error(`Error in Cast: failed to cast ${inputType} to ${dtype}`);
}
function cast46(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { dtype } = attrs;
  if (dtype === "complex64") {
    if (x.dtype === "complex64") {
      return identity2({ inputs: { x }, backend: backend3 });
    }
    const zerosTensorInfo = zeros7(backend3, x.shape, x.dtype);
    const floatX = cast46({ inputs: { x }, backend: backend3, attrs: { dtype: "float32" } });
    const result = complex8({ inputs: { real: floatX, imag: zerosTensorInfo }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(zerosTensorInfo);
    backend3.disposeIntermediateTensorInfo(floatX);
    return result;
  }
  if (x.dtype === "complex64") {
    const realPart = real5({ inputs: { input: x }, backend: backend3 });
    const result = cast46({ inputs: { x: realPart }, backend: backend3, attrs: { dtype } });
    backend3.disposeIntermediateTensorInfo(realPart);
    return result;
  }
  if (!exports_util.hasEncodingLoss(x.dtype, dtype)) {
    const result = identity2({ inputs: { x }, backend: backend3 });
    return { dataId: result.dataId, shape: result.shape, dtype };
  }
  const values = backend3.data.get(x.dataId).values;
  const [resultShape, resultType, resultData] = castImpl(values, x.shape, x.dtype, dtype);
  return backend3.makeTensorInfo(resultShape, resultType, resultData);
}
var castConfig;
var init_Cast = __esm(() => {
  init_dist();
  init_binary_impl();
  init_zeros_impl();
  init_Complex();
  init_Identity();
  init_Real();
  castConfig = {
    kernelName: Cast,
    backendName: "cpu",
    kernelFunc: cast46
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js
function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {
  if (complexImpl == null) {
    return ({ inputs, backend: backend3 }) => {
      const { a, b } = inputs;
      const cpuBackend = backend3;
      assertNotComplex([a, b], name);
      const aVals = cpuBackend.data.get(a.dataId).values;
      const bVals = cpuBackend.data.get(b.dataId).values;
      const decodedAVals = a.dtype === "string" ? exports_backend_util.fromUint8ToStringArray(aVals) : aVals;
      const decodedBVals = a.dtype === "string" ? exports_backend_util.fromUint8ToStringArray(bVals) : bVals;
      const $dtype = dtype || a.dtype;
      const [resultData, resultShape] = simpleImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
    };
  }
  return ({ inputs, backend: backend3 }) => {
    const { a, b } = inputs;
    const cpuBackend = backend3;
    if (a.dtype === "complex64" || b.dtype === "complex64") {
      const $aComplex = cast46({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: "complex64" } });
      const $aComplexVals = cpuBackend.data.get($aComplex.dataId);
      const aReal = $aComplexVals.complexTensorInfos.real;
      const aImag = $aComplexVals.complexTensorInfos.imag;
      const aRealVals = cpuBackend.data.get(aReal.dataId).values;
      const aImagVals = cpuBackend.data.get(aImag.dataId).values;
      const $bComplex = cast46({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: "complex64" } });
      const $bComplexVals = cpuBackend.data.get($bComplex.dataId);
      const bReal = $bComplexVals.complexTensorInfos.real;
      const bImag = $bComplexVals.complexTensorInfos.imag;
      const bRealVals = cpuBackend.data.get(bReal.dataId).values;
      const bImagVals = cpuBackend.data.get(bImag.dataId).values;
      const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);
      const resultReal = cpuBackend.makeTensorInfo(resultShape, "float32", resultRealData);
      const resultImag = cpuBackend.makeTensorInfo(resultShape, "float32", resultImagData);
      const result = complex8({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });
      cpuBackend.disposeIntermediateTensorInfo($aComplex);
      cpuBackend.disposeIntermediateTensorInfo($bComplex);
      cpuBackend.disposeIntermediateTensorInfo(resultReal);
      cpuBackend.disposeIntermediateTensorInfo(resultImag);
      return result;
    } else {
      const aVals = cpuBackend.data.get(a.dataId).values;
      const bVals = cpuBackend.data.get(b.dataId).values;
      const $dtype = dtype || a.dtype;
      const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);
      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);
    }
  };
}
function createComplexBinaryKernelImpl(op2) {
  return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {
    const resultShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    const resultSize = exports_util.sizeFromShape(resultShape);
    const resultRank = resultShape.length;
    const resultStrides = exports_util.computeStrides(resultShape);
    const resultRealVals = exports_util.getTypedArrayFromDType("float32", resultSize);
    const resultImagVals = exports_util.getTypedArrayFromDType("float32", resultSize);
    const aBroadcastDims = exports_backend_util.getBroadcastDims(aShape, resultShape);
    const bBroadcastDims = exports_backend_util.getBroadcastDims(bShape, resultShape);
    const aVals = exports_backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);
    const bVals = exports_backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);
    const aRank = aShape.length;
    const aStrides = exports_util.computeStrides(aShape);
    const bRank = bShape.length;
    const bStrides = exports_util.computeStrides(bShape);
    if (aBroadcastDims.length + bBroadcastDims.length === 0) {
      for (let i = 0;i < resultRealVals.length; i++) {
        const aIdx = i % aVals.length;
        const bIdx = i % bVals.length;
        const result = op2(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);
        resultRealVals[i] = result.real;
        resultImagVals[i] = result.imag;
      }
    } else {
      for (let i = 0;i < resultRealVals.length; i++) {
        const loc = exports_util.indexToLoc(i, resultRank, resultStrides);
        const aLoc = loc.slice(-aRank);
        aBroadcastDims.forEach((d) => aLoc[d] = 0);
        const aIndex = exports_util.locToIndex(aLoc, aRank, aStrides);
        const bLoc = loc.slice(-bRank);
        bBroadcastDims.forEach((d) => bLoc[d] = 0);
        const bIndex = exports_util.locToIndex(bLoc, bRank, bStrides);
        const opResult = op2(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);
        resultRealVals[i] = opResult.real;
        resultImagVals[i] = opResult.imag;
      }
    }
    return [resultRealVals, resultImagVals, resultShape];
  };
}
var init_binary_utils = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Cast();
  init_Complex();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Add.js
var addImpl, addComplexImpl, add31, addConfig;
var init_Add = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  addImpl = createSimpleBinaryKernelImpl((a, b) => a + b);
  addComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return { real: aReal + bReal, imag: aImag + bImag };
  });
  add31 = binaryKernelFunc(Add, addImpl, addComplexImpl);
  addConfig = {
    kernelName: Add,
    backendName: "cpu",
    kernelFunc: add31
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount_impl.js
function bincountImpl(xVals, weightsVals, weightsDtype, weightsShape, size) {
  const weightsSize = exports_util.sizeFromShape(weightsShape);
  const outVals = exports_util.makeZerosTypedArray(size, weightsDtype);
  for (let i = 0;i < xVals.length; i++) {
    const value = xVals[i];
    if (value < 0) {
      throw new Error("Input x must be non-negative!");
    }
    if (value >= size) {
      continue;
    }
    if (weightsSize > 0) {
      outVals[value] += weightsVals[i];
    } else {
      outVals[value] += 1;
    }
  }
  return outVals;
}
function bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput = false) {
  const numRows = xBuf.shape[0];
  const numCols = xBuf.shape[1];
  const outBuf = buffer([numRows, size], weightsBuf.dtype);
  for (let i = 0;i < numRows; i++) {
    for (let j = 0;j < numCols; j++) {
      const value = xBuf.get(i, j);
      if (value < 0) {
        throw new Error("Input x must be non-negative!");
      }
      if (value >= size) {
        continue;
      }
      if (binaryOutput) {
        outBuf.set(1, i, value);
      } else {
        if (weightsBuf.size > 0) {
          outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);
        } else {
          outBuf.set(outBuf.get(i, value) + 1, i, value);
        }
      }
    }
  }
  return outBuf;
}
var init_Bincount_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BitwiseAnd.js
var bitwiseAndImpl, bitwiseAnd2, bitwiseAndConfig;
var init_BitwiseAnd = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  bitwiseAndImpl = createSimpleBinaryKernelImpl((a, b) => a & b);
  bitwiseAnd2 = binaryKernelFunc(BitwiseAnd, bitwiseAndImpl);
  bitwiseAndConfig = {
    kernelName: BitwiseAnd,
    backendName: "cpu",
    kernelFunc: bitwiseAnd2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js
function createSimpleUnaryImpl(op2) {
  return (values, dtype, attrs) => {
    const newValues = exports_util.getArrayFromDType(dtype, values.length);
    for (let i = 0;i < values.length; ++i) {
      newValues[i] = op2(values[i], attrs);
    }
    return newValues;
  };
}
var init_unary_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js
function unaryKernelFunc(name, op2, dtype) {
  const impl = createSimpleUnaryImpl(op2);
  return unaryKernelFuncFromImpl(name, impl, dtype);
}
function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {
  return ({ inputs, attrs, backend: backend3 }) => {
    const { x } = inputs;
    assertNotComplex(x, name);
    const cpuBackend = backend3;
    const values = cpuBackend.data.get(x.dataId).values;
    let decoded;
    if (x.dtype === "string") {
      if (!Array.isArray(values)) {
        throw new Error("String tensor\'s value was not an instance of Array");
      }
      decoded = exports_backend_util.fromUint8ToStringArray(values);
    } else {
      decoded = values;
    }
    const $dtype = dtype || x.dtype;
    const newValues = unaryImpl(decoded, $dtype, attrs);
    return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);
  };
}
var init_unary_utils = __esm(() => {
  init_dist();
  init_cpu_util();
  init_unary_impl();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Ceil.js
var ceilImpl, ceil3, ceilConfig;
var init_Ceil = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));
  ceil3 = unaryKernelFuncFromImpl(Ceil, ceilImpl);
  ceilConfig = {
    kernelName: Ceil,
    backendName: "cpu",
    kernelFunc: ceil3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat_impl.js
function concatImpl(inputs, outShape, dtype, simplyConcat) {
  const outVals = exports_util.getArrayFromDType(dtype, exports_util.sizeFromShape(outShape));
  if (simplyConcat && dtype !== "string") {
    let offset = 0;
    inputs.forEach((input2) => {
      const size = exports_util.sizeFromShape(input2.shape);
      outVals.set(input2.vals, offset);
      offset += size;
    });
  } else {
    let colOffset = 0;
    inputs.forEach((input2) => {
      const decodedData = dtype === "string" ? exports_backend_util.fromUint8ToStringArray(input2.vals) : input2.vals;
      let tIdx = 0;
      for (let row = 0;row < input2.shape[0]; ++row) {
        const resIdx = row * outShape[1] + colOffset;
        for (let col = 0;col < input2.shape[1]; ++col) {
          outVals[resIdx + col] = decodedData[tIdx++];
        }
      }
      colOffset += input2.shape[1];
    });
  }
  return outVals;
}
var init_Concat_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Equal.js
var equalImpl, equal6, equalConfig;
var init_Equal = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  equalImpl = createSimpleBinaryKernelImpl((a, b) => a === b ? 1 : 0);
  equal6 = binaryKernelFunc(Equal, equalImpl, null, "bool");
  equalConfig = {
    kernelName: Equal,
    backendName: "cpu",
    kernelFunc: equal6
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Exp.js
var expImpl, exp11, expConfig;
var init_Exp = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));
  exp11 = unaryKernelFuncFromImpl(Exp, expImpl, "float32");
  expConfig = {
    kernelName: Exp,
    backendName: "cpu",
    kernelFunc: exp11
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Expm1.js
var expm1Impl, expm13, expm1Config;
var init_Expm1 = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));
  expm13 = unaryKernelFuncFromImpl(Expm1, expm1Impl);
  expm1Config = {
    kernelName: Expm1,
    backendName: "cpu",
    kernelFunc: expm13
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Floor.js
var floorImpl, floor5, floorConfig;
var init_Floor = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));
  floor5 = unaryKernelFuncFromImpl(Floor, floorImpl);
  floorConfig = {
    kernelName: Floor,
    backendName: "cpu",
    kernelFunc: floor5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FloorDiv.js
var floorDivImpl, floorDiv5, floorDivConfig;
var init_FloorDiv = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  floorDivImpl = createSimpleBinaryKernelImpl((a, b) => Math.floor(a / b));
  floorDiv5 = binaryKernelFunc(FloorDiv, floorDivImpl, null, "int32");
  floorDivConfig = {
    kernelName: FloorDiv,
    backendName: "cpu",
    kernelFunc: floorDiv5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd_Impl.js
function gatherNdImpl(indicesData, paramsBuf, dtype, numSlices, sliceRank, sliceSize, strides, paramsShape, paramsSize) {
  const outBuf = buffer([numSlices, sliceSize], dtype);
  for (let i = 0;i < numSlices; i++) {
    const index = [];
    let flattenIndex = 0;
    for (let j = 0;j < sliceRank; j++) {
      const dim = indicesData[i * sliceRank + j];
      flattenIndex += dim * strides[j];
      index.push(dim);
    }
    if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {
      throw new Error(`Invalid indices: ${index} does not index into ${paramsShape}`);
    }
    for (let k = 0;k < sliceSize; k++) {
      outBuf.values[i * sliceSize + k] = paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k));
    }
  }
  return outBuf;
}
var init_GatherNd_Impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2_impl.js
function gatherV2Impl(xBuf, indicesBuf, flattenOutputShape) {
  const outBuf = buffer(flattenOutputShape, xBuf.dtype);
  for (let i = 0;i < outBuf.size; ++i) {
    const newLoc = outBuf.indexToLoc(i);
    const originalLoc = newLoc.slice();
    const batchIdx = originalLoc[0];
    const indicesIdx = originalLoc[2];
    const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);
    originalLoc[2] = indicesBuf.values[indicesIndex];
    const originalIndex = xBuf.locToIndex(originalLoc);
    if (0 <= originalIndex && originalIndex < xBuf.values.length) {
      outBuf.values[i] = xBuf.values[originalIndex];
    }
  }
  return outBuf;
}
var init_GatherV2_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Greater.js
var greaterImpl, greater12, greaterConfig;
var init_Greater = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  greaterImpl = createSimpleBinaryKernelImpl((a, b) => a > b ? 1 : 0);
  greater12 = binaryKernelFunc(Greater, greaterImpl, null, "bool");
  greaterConfig = {
    kernelName: Greater,
    backendName: "cpu",
    kernelFunc: greater12
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GreaterEqual.js
var greaterEqualImpl, greaterEqual2, greaterEqualConfig;
var init_GreaterEqual = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  greaterEqualImpl = createSimpleBinaryKernelImpl((a, b) => a >= b ? 1 : 0);
  greaterEqual2 = binaryKernelFunc(GreaterEqual, greaterEqualImpl, null, "bool");
  greaterEqualConfig = {
    kernelName: GreaterEqual,
    backendName: "cpu",
    kernelFunc: greaterEqual2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Less.js
var lessImpl, less7, lessConfig;
var init_Less = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  lessImpl = createSimpleBinaryKernelImpl((a, b) => a < b ? 1 : 0);
  less7 = binaryKernelFunc(Less, lessImpl, null, "bool");
  lessConfig = {
    kernelName: Less,
    backendName: "cpu",
    kernelFunc: less7
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LessEqual.js
var lessEqualImpl, lessEqual2, lessEqualConfig;
var init_LessEqual = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  lessEqualImpl = createSimpleBinaryKernelImpl((a, b) => a <= b ? 1 : 0);
  lessEqual2 = binaryKernelFunc(LessEqual, lessEqualImpl, null, "bool");
  lessEqualConfig = {
    kernelName: LessEqual,
    backendName: "cpu",
    kernelFunc: lessEqual2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace_impl.js
function linSpaceImpl(start, stop, num) {
  const step7 = (stop - start) / (num - 1);
  const values = exports_util.makeZerosTypedArray(num, "float32");
  values[0] = start;
  for (let i = 1;i < values.length; i++) {
    values[i] = values[i - 1] + step7;
  }
  return values;
}
var init_LinSpace_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log.js
var logImpl, log9, logConfig;
var init_Log = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));
  log9 = unaryKernelFuncFromImpl(Log, logImpl);
  logConfig = {
    kernelName: Log,
    backendName: "cpu",
    kernelFunc: log9
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max_impl.js
function maxImpl(aVals, reduceSize, outShape, dtype) {
  const vals = exports_util.getTypedArrayFromDType(dtype, exports_util.sizeFromShape(outShape));
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let max8 = aVals[offset];
    for (let j = 0;j < reduceSize; ++j) {
      const value = aVals[offset + j];
      if (Number.isNaN(value) || value > max8) {
        max8 = value;
      }
    }
    vals[i] = max8;
  }
  return vals;
}
var init_Max_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Maximum.js
var maximumImpl, maximum7, maximumConfig;
var init_Maximum = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  maximumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.max(aValue, bValue));
  maximum7 = binaryKernelFunc(Maximum, maximumImpl);
  maximumConfig = {
    kernelName: Maximum,
    backendName: "cpu",
    kernelFunc: maximum7
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Minimum.js
var minimumImpl, minimum7, minimumConfig;
var init_Minimum = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  minimumImpl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.min(aValue, bValue));
  minimum7 = binaryKernelFunc(Minimum, minimumImpl);
  minimumConfig = {
    kernelName: Minimum,
    backendName: "cpu",
    kernelFunc: minimum7
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multiply.js
var multiplyImpl, multiplyComplexImpl, multiply2, multiplyConfig;
var init_Multiply = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  multiplyImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue * bValue);
  multiplyComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return {
      real: aReal * bReal - aImag * bImag,
      imag: aReal * bImag + aImag * bReal
    };
  });
  multiply2 = binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);
  multiplyConfig = {
    kernelName: Multiply,
    backendName: "cpu",
    kernelFunc: multiply2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Neg.js
function negImpl(xVals, xShape, xDtype) {
  const minusOne = exports_util.createScalarValue(-1, xDtype);
  return multiplyImpl([], xShape, minusOne, xVals, xDtype);
}
function neg21(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  assertNotComplex(x, "neg");
  const xVals = backend3.data.get(x.dataId).values;
  const [res, newShape] = negImpl(xVals, x.shape, x.dtype);
  return backend3.makeTensorInfo(newShape, x.dtype, res);
}
var negConfig;
var init_Neg = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Multiply();
  negConfig = {
    kernelName: Neg,
    backendName: "cpu",
    kernelFunc: neg21
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NotEqual.js
var notEqualImpl, notEqual2, notEqualConfig;
var init_NotEqual = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  notEqualImpl = createSimpleBinaryKernelImpl((a, b) => a !== b ? 1 : 0);
  notEqual2 = binaryKernelFunc(NotEqual, notEqualImpl, null, "bool");
  notEqualConfig = {
    kernelName: NotEqual,
    backendName: "cpu",
    kernelFunc: notEqual2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose_impl.js
function transposeImpl(xVals, xShape, dtype, perm, newShape) {
  const xRank = xShape.length;
  const xSize = exports_util.sizeFromShape(xShape);
  const xStrides = exports_util.computeStrides(xShape);
  const newStrides = exports_util.computeStrides(newShape);
  const result = exports_util.getTypedArrayFromDType(dtype, exports_util.sizeFromShape(newShape));
  for (let i = 0;i < xSize; ++i) {
    const loc = exports_util.indexToLoc(i, xRank, xStrides);
    const newLoc = new Array(loc.length);
    for (let i3 = 0;i3 < newLoc.length; i3++) {
      newLoc[i3] = loc[perm[i3]];
    }
    const newIndex = exports_util.locToIndex(newLoc, xRank, newStrides);
    result[newIndex] = xVals[i];
  }
  return result;
}
var init_Transpose_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transpose.js
function transpose11(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { x } = inputs;
  const { perm } = attrs;
  assertNotComplex(x, "transpose");
  const xRank = x.shape.length;
  const newShape = new Array(xRank);
  for (let i = 0;i < newShape.length; i++) {
    newShape[i] = x.shape[perm[i]];
  }
  const values = backend3.data.get(x.dataId).values;
  const result = transposeImpl(values, x.shape, x.dtype, perm, newShape);
  const dataId = backend3.write(result, newShape, x.dtype);
  return { dataId, shape: newShape, dtype: x.dtype };
}
var transposeConfig;
var init_Transpose = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Transpose_impl();
  transposeConfig = {
    kernelName: Transpose,
    backendName: "cpu",
    kernelFunc: transpose11
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prod.js
function prodImpl(xShape, xDtype, xVals, reductionAxes) {
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(xShape, reductionAxes);
  const outDtype = upcastType(xDtype, "int32");
  const outVals = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(outShape), outDtype);
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  for (let i = 0;i < outVals.length; ++i) {
    const offset = i * reduceSize;
    let prod4 = 1;
    for (let j = 0;j < reduceSize; ++j) {
      prod4 *= xVals[offset + j];
    }
    outVals[i] = prod4;
  }
  return { outVals, outShape, outDtype };
}
function prod4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x, "prod");
  const xRank = x.shape.length;
  const axes = exports_util.parseAxisParam(axis, x.shape);
  const permutation = exports_backend_util.getAxesPermutation(axes, xRank);
  let reductionAxes = axes;
  let permutedX = x;
  const intermediateTensorInfos = [];
  if (permutation != null) {
    permutedX = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
    intermediateTensorInfos.push(permutedX);
    reductionAxes = exports_backend_util.getInnerMostAxes(reductionAxes.length, xRank);
  }
  const xVals = backend3.data.get(permutedX.dataId).values;
  const { outVals, outShape, outDtype } = prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);
  let resultShape = outShape;
  if (keepDims) {
    resultShape = exports_backend_util.expandShapeToKeepDim(outShape, axes);
  }
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return backend3.makeTensorInfo(resultShape, outDtype, outVals);
}
var prodConfig;
var init_Prod = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Transpose();
  prodConfig = {
    kernelName: Prod,
    backendName: "cpu",
    kernelFunc: prod4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather_impl.js
function validateIndices(indices, indicesShape, numParams) {
  indices.forEach((index, i) => {
    if (index < 0 || index >= numParams) {
      const locString = exports_util.indexToLoc(i, indicesShape.length, exports_util.computeStrides(indicesShape)).join(",");
      throw new Error(`indices[${locString}] = ${index} is not in [0, ${numParams})`);
    }
  });
}
function validateSplits(paramsNestedSplits, numParamsDenseValues) {
  for (let dim = 0;dim < paramsNestedSplits.length; ++dim) {
    const splits = paramsNestedSplits[dim];
    const lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;
    if (splits.length === 0) {
      throw new Error("Ragged splits may not be empty");
    }
    if (splits[0] < 0) {
      throw new Error("Ragged splits must be non-negative");
    }
    if (splits[splits.length - 1] > lastSplit) {
      throw new Error("Ragged splits must not point past values");
    }
    for (let i = 1;i < splits.length; ++i) {
      if (splits[i - 1] > splits[i]) {
        throw new Error("Ragged splits must be sorted in ascending order");
      }
    }
  }
}
function makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {
  const valueSlices = [];
  let numValues = 0;
  const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;
  const outSplits = new Array(numSplits).fill(null).map(() => [0]);
  validateSplits(paramsNestedSplits, numParamsDenseValues);
  let nrows = 1;
  for (let dim = 0;dim < indicesShape.length - 1; ++dim) {
    nrows *= indicesShape[dim];
    const rowLength = indicesShape[dim + 1];
    for (let i = 1;i < nrows + 1; ++i) {
      outSplits[dim].push(i * rowLength);
    }
  }
  for (let i = 0;i < indices.length; ++i) {
    let start = indices[i];
    let limit = indices[i] + 1;
    for (let dim = 0;dim < paramsNestedSplits.length; ++dim) {
      const splits = paramsNestedSplits[dim];
      const outDim = dim + indicesShape.length - 1;
      if (outDim >= 0) {
        const outSplitsOutDim = outSplits[outDim];
        const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];
        for (let j = start;j < limit; ++j) {
          outSplits[outDim].push(splits[j + 1] + delta);
        }
      }
      start = splits[start];
      limit = splits[limit];
    }
    if (limit !== start) {
      valueSlices.push([start, limit]);
      numValues += limit - start;
    }
  }
  return { outSplits, valueSlices, numValues };
}
function getSplits(outSplits) {
  const splitsOut = [];
  for (let i = 0;i < outSplits.length; ++i) {
    const numSplits = outSplits[i].length;
    const splits = exports_util.getArrayFromDType("int32", numSplits);
    splitsOut.push(splits);
    outSplits[i].forEach((value, j) => splits[j] = value);
  }
  return splitsOut;
}
function computeFlatOuterDims(orig, numOutDims) {
  const outDims = orig.slice(0, numOutDims);
  while (outDims.length < numOutDims) {
    outDims.push(1);
  }
  for (let inDim = numOutDims;inDim < orig.length; inDim++) {
    outDims[numOutDims - 1] *= orig[inDim];
  }
  return outDims;
}
function writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {
  const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];
  const valuesM = computeFlatOuterDims(valuesShape, 2)[1];
  let outPos = 0;
  for (const slice16 of valueSlices) {
    for (let i = slice16[0];i < slice16[1]; ++i) {
      for (let j = 0;j < valueSize; ++j) {
        values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];
      }
      ++outPos;
    }
  }
}
function getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {
  const valuesShape = paramsDenseValuesShape.slice();
  valuesShape[0] = numValues;
  const valuesOut = exports_util.getArrayFromDType(paramsDenseValuesDType, exports_util.sizeFromShape(valuesShape));
  const numElements = paramsDenseValues.length;
  const valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];
  writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);
  return [valuesOut, valuesShape];
}
function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {
  if (paramsNestedSplits.length === 0) {
    throw new Error("paramsNestedSplits must be non empty");
  }
  if (paramsNestedSplitsShapes[0].length === 0) {
    throw new Error("Split tensors must not be scalars");
  }
  const numParams = paramsNestedSplitsShapes[0][0] - 1;
  validateIndices(indices, indicesShape, numParams);
  if (paramsDenseValuesShape.length === 0) {
    throw new Error("params.rank must be nonzero");
  }
  const numParamsDenseValues = paramsDenseValuesShape[0];
  const { outSplits, valueSlices, numValues } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues);
  const outputNestedSplits = getSplits(outSplits);
  const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);
  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];
}
var init_RaggedGather_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange_impl.js
function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {
  if (startsShape.length > 1) {
    throw new Error("starts must be a scalar or vector");
  }
  if (limitsShape.length > 1) {
    throw new Error("limits must be a scalar or vector");
  }
  if (deltasShape.length > 1) {
    throw new Error("deltas must be a scalar or vector");
  }
  const broadcastStarts = startsShape.length === 0;
  const broadcastLimits = limitsShape.length === 0;
  const broadcastDeltas = deltasShape.length === 0;
  const inSizes = [];
  if (!broadcastStarts) {
    inSizes.push(startsShape[0]);
  }
  if (!broadcastLimits) {
    inSizes.push(limitsShape[0]);
  }
  if (!broadcastDeltas) {
    inSizes.push(deltasShape[0]);
  }
  for (let i = 1;i < inSizes.length; ++i) {
    if (inSizes[i] !== inSizes[i - 1]) {
      throw new Error("starts, limits, and deltas must have the same shape");
    }
  }
  const nRows = inSizes.length === 0 ? 1 : inSizes[0];
  const rtNestedSplits = exports_util.getArrayFromDType("int32", nRows + 1);
  rtNestedSplits[0] = 0;
  for (let row = 0;row < nRows; ++row) {
    const start = broadcastStarts ? starts[0] : starts[row];
    const limit = broadcastLimits ? limits[0] : limits[row];
    const delta = broadcastDeltas ? deltas[0] : deltas[row];
    if (delta === 0) {
      throw new Error("Requires delta != 0");
    }
    let size;
    if (delta > 0 && limit < start || delta < 0 && limit > start) {
      size = 0;
    } else {
      size = Math.ceil(Math.abs((limit - start) / delta));
      if (size > INT32_MAX2) {
        throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX2}`);
      }
    }
    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;
  }
  const nVals = rtNestedSplits[nRows];
  const rtDenseValues = exports_util.getArrayFromDType(startsDType, nVals);
  let valueIndex = 0;
  for (let row = 0;row < nRows; ++row) {
    const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];
    let value = broadcastStarts ? starts[0] : starts[row];
    const delta = broadcastDeltas ? deltas[0] : deltas[row];
    for (let i = 0;i < rowSize; ++i) {
      rtDenseValues[valueIndex++] = value;
      value += delta;
    }
  }
  return [rtNestedSplits, rtDenseValues];
}
var INT32_MAX2 = 2147483647;
var init_RaggedRange_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor_impl.js
function copyArray(dst, src, size) {
  for (let i = 0;i < size; i++) {
    dst[i] = src[i];
  }
}
function makeShape(shape, isPartial) {
  const out = [];
  for (let dim of shape) {
    if (dim < 0) {
      if (!isPartial) {
        throw new Error(`Dimension ${dim} must be >= 0`);
      }
      if (dim < -1) {
        throw new Error(`Dimension ${dim} must be >= -1`);
      }
      dim = -1;
    }
    out.push(dim);
  }
  return out;
}
function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {
  return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();
}

class RaggedTensorToTensorOp {
  constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {
    this.shape = shape;
    this.shapeShape = shapeShape;
    this.values = values;
    this.valuesShape = valuesShape;
    this.valuesDType = valuesDType;
    this.defaultValue = defaultValue;
    this.defaultValueShape = defaultValueShape;
    this.rowPartitionValues = rowPartitionValues;
    this.rowPartitionValuesShapes = rowPartitionValuesShapes;
    this.rowPartitionTypes = exports_backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);
    this.raggedRank = exports_backend_util.getRaggedRank(this.rowPartitionTypes);
  }
  getRowPartitionTypeByDimension(dimension) {
    if (this.rowPartitionTypes[0] === RowPartitionType2.FIRST_DIM_SIZE) {
      return this.rowPartitionTypes[dimension + 1];
    } else {
      return this.rowPartitionTypes[dimension];
    }
  }
  getRowPartitionTensor(dimension) {
    if (this.rowPartitionTypes[0] === RowPartitionType2.FIRST_DIM_SIZE) {
      return this.rowPartitionValues[dimension + 1];
    } else {
      return this.rowPartitionValues[dimension];
    }
  }
  getMaxWidth(dimension) {
    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);
    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {
      case RowPartitionType2.VALUE_ROWIDS:
        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);
      case RowPartitionType2.ROW_SPLITS:
        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);
      default:
        throw new Error(`Cannot handle partition type ${RowPartitionType2[this.getRowPartitionTypeByDimension(dimension - 1)]}`);
    }
  }
  static getMaxWidthRowSplit(rowSplit) {
    const tensorLength = rowSplit.length;
    if (tensorLength === 0 || tensorLength === 1) {
      return 0;
    }
    let maxWidth = 0;
    for (let i = 0;i < tensorLength - 1; ++i) {
      const currentWidth = rowSplit[i + 1] - rowSplit[i];
      if (currentWidth > maxWidth) {
        maxWidth = currentWidth;
      }
    }
    return maxWidth;
  }
  static getMaxWidthValueRowID(valueRowIds) {
    const indexLength = valueRowIds.length;
    if (indexLength === 0) {
      return 0;
    }
    let firstEqualIndex = 0;
    let firstEqualIndexValue = valueRowIds[0];
    let maxWidth = 0;
    for (let i = 1;i < indexLength; ++i) {
      const value = valueRowIds[i];
      if (value !== firstEqualIndexValue) {
        firstEqualIndexValue = value;
        maxWidth = Math.max(i - firstEqualIndex, maxWidth);
        firstEqualIndex = i;
      }
    }
    return Math.max(indexLength - firstEqualIndex, maxWidth);
  }
  tensorShapeFromTensor(t, tShape, isPartial = true) {
    if (tShape.length === 0) {
      if (t[0] === -1) {
        return [];
      }
      throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);
    }
    return makeShape(t, isPartial);
  }
  calculateOutputSize(firstDim) {
    const valueShape = this.valuesShape;
    const defaultValueShape = this.defaultValueShape;
    exports_backend_util.validateDefaultValueShape(defaultValueShape, valueShape);
    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);
    const outputShape = exports_backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);
    const result = outputShape;
    if (result[0] < 0) {
      result[0] = firstDim;
    }
    for (let i = 1;i <= this.raggedRank; ++i) {
      if (result[i] < 0) {
        result[i] = this.getMaxWidth(i);
      }
    }
    return result;
  }
  calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {
    const minDimension = Math.min(firstDimension, firstDimensionOutput);
    const result = [];
    let currentOutputIndex = 0;
    for (let i = 0;i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {
      result.push(currentOutputIndex);
    }
    for (let i = minDimension;i < firstDimension; ++i) {
      result.push(-1);
    }
    exports_util.assert(result.length === firstDimension, () => "Final length of result must be equal to firstDimension.");
    return result;
  }
  calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {
    const rowSplitSize = rowSplit.length;
    const result = [];
    for (let i = 0;i < rowSplitSize - 1; ++i) {
      const rowLength = rowSplit[i + 1] - rowSplit[i];
      let realLength = Math.min(outputSize, rowLength);
      let parentOutputIndexCurrent = parentOutputIndex[i];
      if (parentOutputIndexCurrent === -1) {
        realLength = 0;
      }
      for (let j = 0;j < realLength; ++j) {
        result.push(parentOutputIndexCurrent);
        parentOutputIndexCurrent += outputIndexMultiplier;
      }
      for (let j = 0;j < rowLength - realLength; ++j) {
        result.push(-1);
      }
    }
    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {
      throw new Error("Invalid row split size.");
    }
    return result;
  }
  calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {
    const indexSize = valueRowIds.length;
    const result = [];
    if (indexSize === 0) {
      return [];
    }
    let currentOutputColumn = 0;
    let currentValueRowId = valueRowIds[0];
    if (currentValueRowId >= parentOutputIndex.length) {
      throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);
    }
    let currentOutputIndex = parentOutputIndex[currentValueRowId];
    result.push(currentOutputIndex);
    for (let i = 1;i < indexSize; ++i) {
      const nextValueRowId = valueRowIds[i];
      if (nextValueRowId === currentValueRowId) {
        if (currentOutputIndex >= 0) {
          ++currentOutputColumn;
          if (currentOutputColumn < outputSize) {
            currentOutputIndex += outputIndexMultiplier;
          } else {
            currentOutputIndex = -1;
          }
        }
      } else {
        currentOutputColumn = 0;
        currentValueRowId = nextValueRowId;
        if (nextValueRowId >= parentOutputIndex.length) {
          throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);
        }
        currentOutputIndex = parentOutputIndex[nextValueRowId];
      }
      result.push(currentOutputIndex);
    }
    if (result.length !== valueRowIds.length) {
      throw new Error("Invalid row ids.");
    }
    return result;
  }
  calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {
    const rowPartitionTensor = this.getRowPartitionTensor(dimension);
    const partitionType = this.getRowPartitionTypeByDimension(dimension);
    switch (partitionType) {
      case RowPartitionType2.VALUE_ROWIDS:
        return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);
      case RowPartitionType2.ROW_SPLITS:
        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {
          throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);
        }
        return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);
      default:
        throw new Error(`Unsupported partition type: ${RowPartitionType2[partitionType]}`);
    }
  }
  getFirstDimensionSize() {
    const firstPartitionTensor = this.rowPartitionValues[0];
    if (this.rowPartitionTypes.length === 0) {
      throw new Error("No row_partition_types given.");
    }
    const firstPartitionType = this.rowPartitionTypes[0];
    switch (firstPartitionType) {
      case RowPartitionType2.FIRST_DIM_SIZE:
        return firstPartitionTensor[0];
      case RowPartitionType2.VALUE_ROWIDS:
        throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
      case RowPartitionType2.ROW_SPLITS:
        return this.rowPartitionValuesShapes[0][0] - 1;
      default:
        throw new Error(`Cannot handle type ${RowPartitionType2[firstPartitionType]}`);
    }
  }
  compute() {
    const firstPartitionTensor = this.rowPartitionValues[0];
    if (firstPartitionTensor.length <= 0) {
      throw new Error("Invalid first partition input. " + "Tensor requires at least one element.");
    }
    const firstDimension = this.getFirstDimensionSize();
    const outputSize = this.calculateOutputSize(firstDimension);
    const multiplier = new Array(this.raggedRank + 1);
    multiplier[multiplier.length - 1] = 1;
    for (let i = multiplier.length - 2;i >= 0; --i) {
      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];
    }
    const outputShape = makeShape(outputSize, false);
    const outputTensor = exports_util.getArrayFromDType(this.valuesDType, exports_util.sizeFromShape(outputShape));
    const fullSize = multiplier[0] * outputSize[0];
    if (fullSize > 0) {
      let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);
      for (let i = 1;i <= this.raggedRank; ++i) {
        const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);
        outputIndex = newOutputIndex;
      }
      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);
    }
    return [outputShape, outputTensor];
  }
  setOutput(raggedRank, outputIndex, outputTensor, outputShape) {
    if (outputTensor.length === 0) {
      return;
    }
    const valuesBase = this.values;
    const outputBase = outputTensor;
    let elementShape = outputShape.slice();
    elementShape = elementShape.slice(raggedRank + 1);
    const valueElementSize = exports_util.sizeFromShape(elementShape);
    const outputIndexSize = outputIndex.length;
    let defaultValue = this.defaultValue;
    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {
      const srcShape = this.defaultValueShape;
      tidy(() => {
        const defaultValueTensor = reshape(defaultValue, srcShape);
        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);
        defaultValue = bCastDefault.dataSync();
      });
    }
    let srcStart = 0;
    let dstStart = 0;
    let dstEnd = 0;
    for (let srcI = 0;srcI <= outputIndexSize; ++srcI) {
      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;
      if (dstI === dstEnd) {
        ++dstEnd;
        continue;
      }
      if (dstStart < dstEnd) {
        const src = valuesBase.subarray(srcStart * valueElementSize);
        const dst = outputBase.subarray(dstStart * valueElementSize);
        const nVals = (dstEnd - dstStart) * valueElementSize;
        copyArray(dst, src, nVals);
      }
      if (srcI >= outputIndexSize) {
        const outputSize = outputTensor.length;
        dstI = Math.floor(outputSize / valueElementSize);
      }
      if (dstI > dstEnd) {
        if (this.defaultValue.length === 1) {
          outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);
          dstEnd = dstI;
        } else {
          while (dstI > dstEnd) {
            const dst = outputBase.slice(dstEnd * valueElementSize);
            copyArray(dst, defaultValue, valueElementSize);
            ++dstEnd;
          }
        }
      }
      if (dstI < 0) {
        srcStart = srcI + 1;
        dstStart = dstEnd;
      } else {
        srcStart = srcI;
        dstStart = dstEnd;
        dstEnd = dstStart + 1;
      }
    }
  }
}
var RowPartitionType2;
var init_RaggedTensorToTensor_impl = __esm(() => {
  init_dist();
  RowPartitionType2 = exports_backend_util.RowPartitionType;
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js
function rangeImpl(start, stop, step7, dtype) {
  const sameStartStop = start === stop;
  const increasingRangeNegativeStep = start < stop && step7 < 0;
  const decreasingRangePositiveStep = stop < start && step7 > 1;
  if (sameStartStop || increasingRangeNegativeStep || decreasingRangePositiveStep) {
    return exports_util.makeZerosTypedArray(0, dtype);
  }
  const numElements = Math.abs(Math.ceil((stop - start) / step7));
  const values = exports_util.makeZerosTypedArray(numElements, dtype);
  if (stop < start && step7 === 1) {
    step7 = -1;
  }
  values[0] = start;
  for (let i = 1;i < values.length; i++) {
    values[i] = values[i - 1] + step7;
  }
  return values;
}
var init_Range_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Rsqrt.js
var rsqrtImpl, rsqrt4, rsqrtConfig;
var init_Rsqrt = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));
  rsqrt4 = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);
  rsqrtConfig = {
    kernelName: Rsqrt,
    backendName: "cpu",
    kernelFunc: rsqrt4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Scatter_impl.js
function scatterImpl(indices, updates, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, defaultValue, sumDupeIndices) {
  const flattenShape = [outputSize / sliceSize, sliceSize];
  const indicesData = indices.values;
  const updatesData = updates.values;
  if (outputSize === 0) {
    return buffer(shape, updates.dtype);
  }
  const outBuf = defaultValue instanceof TensorBuffer ? defaultValue : buffer(flattenShape, updates.dtype);
  if (typeof defaultValue === "string") {
    outBuf.values.fill(defaultValue);
  } else if (typeof defaultValue === "number") {
    outBuf.values.fill(defaultValue);
  } else if (typeof defaultValue === "boolean") {
    outBuf.values.fill(+defaultValue);
  }
  for (let i = 0;i < numUpdates; i++) {
    const index = [];
    let flattenIndex = 0;
    for (let j = 0;j < sliceRank; j++) {
      const dim = indicesData[i * sliceRank + j];
      index.push(dim);
      flattenIndex += dim * strides[j];
    }
    if (flattenIndex < 0 || flattenIndex >= outputSize / sliceSize) {
      throw new Error(`Invalid indices: ${index} does not index into ${shape}`);
    }
    for (let k = 0;k < sliceSize; k++) {
      if (sumDupeIndices) {
        outBuf.values[flattenIndex * sliceSize + k] += updatesData[i * sliceSize + k];
      } else {
        outBuf.values[flattenIndex * sliceSize + k] = updates.rank === 0 ? updatesData[0] : updatesData[i * sliceSize + k];
      }
    }
  }
  return outBuf;
}
var init_Scatter_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sigmoid.js
var sigmoidImpl, sigmoid7, sigmoidConfig;
var init_Sigmoid = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  sigmoidImpl = createSimpleUnaryImpl((xi) => 1 / (1 + Math.exp(-xi)));
  sigmoid7 = unaryKernelFunc(Sigmoid, (xi) => 1 / (1 + Math.exp(-xi)));
  sigmoidConfig = {
    kernelName: Sigmoid,
    backendName: "cpu",
    kernelFunc: sigmoid7
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Slice.js
function sliceImpl(vals, begin, size, shape, dtype) {
  const isContinous = exports_slice_util.isSliceContinous(shape, begin, size);
  const length = exports_util.sizeFromShape(size);
  const xStrides = exports_util.computeStrides(shape);
  if (isContinous) {
    const flatOffset = exports_slice_util.computeFlatOffset(begin, xStrides);
    if (dtype === "string") {
      return vals.slice(flatOffset, flatOffset + length);
    }
    return vals.subarray(flatOffset, flatOffset + length);
  }
  const decodedData = dtype === "string" ? exports_backend_util.fromUint8ToStringArray(vals) : vals;
  const inBuf = buffer(shape, dtype, decodedData);
  const outBuf = buffer(size, dtype);
  for (let i = 0;i < outBuf.size; ++i) {
    const outLoc = outBuf.indexToLoc(i);
    const inLoc = outLoc.map((idx, j) => idx + begin[j]);
    outBuf.set(inBuf.get(...inLoc), ...outLoc);
  }
  if (dtype === "string") {
    return exports_backend_util.fromStringArrayToUint8(outBuf.values);
  }
  return outBuf.values;
}
function slice16(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { begin, size } = attrs;
  assertNotComplex(x, "slice");
  const [$begin, $size] = exports_slice_util.parseSliceParams(x, begin, size);
  exports_slice_util.assertParamsValid(x, $begin, $size);
  const vals = backend3.data.get(x.dataId).values;
  const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);
  return backend3.makeTensorInfo($size, x.dtype, outVals);
}
var sliceConfig;
var init_Slice = __esm(() => {
  init_dist();
  init_cpu_util();
  sliceConfig = {
    kernelName: Slice,
    backendName: "cpu",
    kernelFunc: slice16
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows_impl.js
function sparseFillEmptyRowsImpl(indices, indicesShape, indicesDType, values, valuesDType, denseShape, defaultValue) {
  const indicesCount = indicesShape[0];
  const denseRows = denseShape[0];
  const emptyRowIndicator = new Array(denseRows);
  const reverseIndexMap = new Array(indicesCount);
  const rank = indicesShape[1];
  if (denseRows === 0) {
    if (indicesCount !== 0) {
      throw new Error(exports_backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesCount));
    }
    const outputIndices = exports_util.getArrayFromDType(indicesDType, 0);
    const outputValues = exports_util.getArrayFromDType(valuesDType, 0);
    return [
      outputIndices,
      [0, rank],
      outputValues,
      emptyRowIndicator,
      reverseIndexMap
    ];
  }
  let rowsAreOrdered = true;
  let lastIndicesRow = 0;
  const csrOffset = new Array(denseRows).fill(0);
  for (let i = 0;i < indicesCount; ++i) {
    const row = indices[i * rank];
    if (row < 0) {
      throw new Error(exports_backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(i, row));
    }
    if (row >= denseRows) {
      throw new Error(exports_backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(i, row, denseRows));
    }
    ++csrOffset[row];
    rowsAreOrdered = rowsAreOrdered && row >= lastIndicesRow;
    lastIndicesRow = row;
  }
  let allRowsFull = true;
  for (let row = 0;row < denseRows; ++row) {
    const rowEmpty = csrOffset[row] === 0;
    emptyRowIndicator[row] = rowEmpty;
    allRowsFull = allRowsFull && !rowEmpty;
    csrOffset[row] = Math.max(csrOffset[row], 1);
    if (row > 0) {
      csrOffset[row] += csrOffset[row - 1];
    }
  }
  if (allRowsFull && rowsAreOrdered) {
    const outputIndices = indices;
    const outputValues = values;
    for (let i = 0;i < indicesCount; ++i) {
      reverseIndexMap[i] = i;
    }
    return [
      outputIndices,
      [indicesCount, rank],
      outputValues,
      emptyRowIndicator,
      reverseIndexMap
    ];
  } else {
    const fullIndicesCount = csrOffset[denseRows - 1];
    const outputIndices = exports_util.getArrayFromDType(indicesDType, fullIndicesCount * rank);
    const outputValues = exports_util.getArrayFromDType(valuesDType, fullIndicesCount);
    const filledCount = new Array(denseRows).fill(0);
    for (let i = 0;i < indicesCount; ++i) {
      const row = indices[i * rank];
      const offset = filledCount[row];
      const outputI = (row === 0 ? 0 : csrOffset[row - 1]) + offset;
      filledCount[row]++;
      for (let j = 0;j < rank; ++j) {
        outputIndices[outputI * rank + j] = indices[i * rank + j];
      }
      outputValues[outputI] = values[i];
      reverseIndexMap[i] = outputI;
    }
    for (let row = 0;row < denseRows; ++row) {
      const rowCount = filledCount[row];
      if (rowCount === 0) {
        const startingIndex = row === 0 ? 0 : csrOffset[row - 1];
        outputIndices[startingIndex * rank + 0] = row;
        for (let col = 1;col < rank; ++col) {
          outputIndices[startingIndex * rank + col] = 0;
        }
        outputValues[startingIndex] = defaultValue;
      }
    }
    return [
      outputIndices,
      [fullIndicesCount, rank],
      outputValues,
      emptyRowIndicator,
      reverseIndexMap
    ];
  }
}
var init_SparseFillEmptyRows_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape_impl.js
function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {
  const denseSize = exports_util.sizeFromShape(inputShape);
  const nnz = inputIndicesShape[0];
  const outputRank = targetShape.length;
  const outputShape = [];
  let product = 1;
  let unknownIndex = -1;
  for (let d = 0;d < outputRank; ++d) {
    const size = targetShape[d];
    if (size === -1) {
      if (unknownIndex !== -1) {
        throw new Error(exports_backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(unknownIndex, d));
      }
      unknownIndex = d;
      outputShape.push(1);
    } else {
      if (size < 0) {
        throw new Error(exports_backend_util.getSparseReshapeNegativeOutputDimErrorMessage(d, size));
      }
      product *= size;
      outputShape.push(size);
    }
  }
  if (unknownIndex !== -1) {
    if (product <= 0) {
      throw new Error(exports_backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
    }
    const missing = Math.trunc(denseSize / product);
    if (product * missing !== denseSize) {
      throw new Error(exports_backend_util.getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape));
    }
    outputShape[unknownIndex] = missing;
  }
  const outputSize = exports_util.sizeFromShape(outputShape);
  if (outputSize !== denseSize) {
    throw new Error(exports_backend_util.getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape));
  }
  const inputRank = inputShape.length;
  const inputStrides = [];
  if (inputRank > 0) {
    inputStrides[inputRank - 1] = 1;
    for (let d = inputRank - 2;d >= 0; --d) {
      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];
    }
  }
  const outputStrides = [];
  if (outputRank > 0) {
    outputStrides[outputRank - 1] = 1;
    for (let d = outputRank - 2;d >= 0; --d) {
      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];
    }
  }
  const newIndices = exports_util.getArrayFromDType(inputDType, nnz * outputRank);
  for (let i = 0;i < nnz; ++i) {
    let id = 0;
    for (let j = 0;j < inputRank; ++j) {
      id += inputIndices[i * inputRank + j] * inputStrides[j];
    }
    for (let j = 0;j < outputRank; ++j) {
      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);
      id %= outputStrides[j];
    }
  }
  return [newIndices, [nnz, outputRank], outputShape];
}
var init_SparseReshape_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentReduction_impl.js
function sparseSegmentReductionImpl(input2, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {
  const numIndices = indices.length;
  const inputFlat = [inputShape[0], input2.length / inputShape[0]];
  const numCol = inputFlat[1];
  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;
  const outputRows = lastSegmentIdPlusOne;
  if (outputRows < 0) {
    throw new Error(exports_backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  }
  const outputShape = inputShape.slice();
  outputShape[0] = outputRows;
  const outputLength = outputShape.reduce((product, value) => product * value, 1);
  const output = exports_util.getArrayFromDType(inputDType, outputLength);
  if (numIndices === 0) {
    if (outputRows > 0) {
      output.fill(defaultValue);
    }
    return [output, outputShape];
  }
  if (outputRows <= 0) {
    throw new Error(exports_backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
  }
  let start = 0, end = 1;
  let uninitializedIndex = 0;
  let outIndex = segmentIds[start];
  while (true) {
    let nextIndex = 0;
    if (end < numIndices) {
      nextIndex = segmentIds[end];
      if (outIndex === nextIndex) {
        ++end;
        continue;
      }
      if (outIndex >= nextIndex) {
        throw new Error(exports_backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
      }
    }
    if (outIndex < 0 || outIndex >= outputRows) {
      throw new Error(exports_backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));
    }
    if (outIndex > uninitializedIndex) {
      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);
    }
    for (let i = start;i < end; ++i) {
      const index = indices[i];
      if (index < 0 || index >= inputFlat[0]) {
        throw new Error(exports_backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));
      }
      for (let j = 0;j < numCol; j++) {
        output[outIndex * numCol + j] += input2[index * numCol + j];
      }
    }
    if (isMean) {
      for (let j = 0;j < numCol; j++) {
        output[outIndex * numCol + j] /= end - start;
      }
    }
    start = end;
    ++end;
    uninitializedIndex = outIndex + 1;
    outIndex = nextIndex;
    if (end > numIndices) {
      break;
    }
  }
  if (uninitializedIndex < outputRows) {
    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);
  }
  return [output, outputShape];
}
var init_SparseSegmentReduction_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sqrt.js
var sqrtImpl, sqrt12, sqrtConfig;
var init_Sqrt = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  sqrtImpl = createSimpleUnaryImpl((xi) => Math.sqrt(xi));
  sqrt12 = unaryKernelFunc(Sqrt, (xi) => Math.sqrt(xi));
  sqrtConfig = {
    kernelName: Sqrt,
    backendName: "cpu",
    kernelFunc: sqrt12
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SquaredDifference.js
var squaredDifferenceImpl, squaredDifference2, squaredDifferenceConfig;
var init_SquaredDifference = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  squaredDifferenceImpl = createSimpleBinaryKernelImpl((a, b) => {
    const diff = a - b;
    return diff * diff;
  });
  squaredDifference2 = binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);
  squaredDifferenceConfig = {
    kernelName: SquaredDifference,
    backendName: "cpu",
    kernelFunc: squaredDifference2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StaticRegexReplace.js
var staticRegexReplaceImpl, staticRegexReplace2, staticRegexReplaceConfig;
var init_StaticRegexReplace = __esm(() => {
  init_dist();
  init_unary_impl();
  init_unary_utils();
  staticRegexReplaceImpl = createSimpleUnaryImpl((x, attrs) => {
    const { pattern, replaceGlobal, rewrite } = attrs;
    return x.replace(new RegExp(pattern, replaceGlobal ? "g" : ""), rewrite);
  });
  staticRegexReplace2 = unaryKernelFuncFromImpl(StaticRegexReplace, staticRegexReplaceImpl);
  staticRegexReplaceConfig = {
    kernelName: StaticRegexReplace,
    backendName: "cpu",
    kernelFunc: staticRegexReplace2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice_impl.js
function stridedSliceImpl(outShape, xBuf, strides, begin) {
  const outBuf = buffer(outShape, xBuf.dtype);
  for (let i = 0;i < outBuf.size; i++) {
    const loc = outBuf.indexToLoc(i);
    const newLoc = new Array(loc.length);
    for (let j = 0;j < newLoc.length; j++) {
      newLoc[j] = loc[j] * strides[j] + begin[j];
    }
    outBuf.set(xBuf.get(...newLoc), ...loc);
  }
  return outBuf;
}
var init_StridedSlice_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams_impl.js
function stringNGramsImpl(data, dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
  return new StringNGramsOp(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences).compute(data, dataSplits);
}

class StringNGramsOp {
  constructor(separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences) {
    this.separator = exports_util.encodeString(separator);
    this.nGramWidths = nGramWidths;
    this.leftPad = exports_util.encodeString(leftPad);
    this.rightPad = exports_util.encodeString(rightPad2);
    this.padWidth = padWidth;
    this.preserveShort = preserveShortSequences;
  }
  getPadWidth(nGramWidth) {
    return Math.min(this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);
  }
  getNumNGrams(length, nGramWidth) {
    const padWidth = this.getPadWidth(nGramWidth);
    return Math.max(0, length + 2 * padWidth - nGramWidth + 1);
  }
  createNGrams(data, splitIndex, output, outputStartIndex, numNGrams, nGramWidth) {
    for (let nGramIndex = 0;nGramIndex < numNGrams; ++nGramIndex) {
      const padWidth = this.getPadWidth(nGramWidth);
      const leftPadding = Math.max(0, padWidth - nGramIndex);
      const rightPadding = Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));
      const numTokens = nGramWidth - (leftPadding + rightPadding);
      const dataStartIndex = splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);
      let nGramSize = 0;
      nGramSize += leftPadding * this.leftPad.length;
      for (let n = 0;n < numTokens; ++n) {
        nGramSize += data[dataStartIndex + n].length;
      }
      nGramSize += rightPadding * this.rightPad.length;
      const numSeparators = leftPadding + rightPadding + numTokens - 1;
      nGramSize += numSeparators * this.separator.length;
      output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);
      const nGram = output[outputStartIndex + nGramIndex];
      let nextNGramIndex = 0;
      const appendToNGram = (str) => str.forEach((value) => nGram[nextNGramIndex++] = value);
      for (let n = 0;n < leftPadding; ++n) {
        appendToNGram(this.leftPad);
        appendToNGram(this.separator);
      }
      for (let n = 0;n < numTokens - 1; ++n) {
        appendToNGram(data[dataStartIndex + n]);
        appendToNGram(this.separator);
      }
      if (numTokens > 0) {
        appendToNGram(data[dataStartIndex + numTokens - 1]);
        for (let n = 0;n < rightPadding; ++n) {
          appendToNGram(this.separator);
          appendToNGram(this.rightPad);
        }
      } else {
        for (let n = 0;n < rightPadding - 1; ++n) {
          appendToNGram(this.rightPad);
          appendToNGram(this.separator);
        }
        appendToNGram(this.rightPad);
      }
    }
  }
  compute(data, splits) {
    const inputDataSize = data.length;
    const splitsSize = splits.length;
    if (splitsSize > 0) {
      let prevSplit = splits[0];
      if (prevSplit !== 0) {
        throw new Error(`First split value must be 0, got ${prevSplit}`);
      }
      for (let i = 1;i < splitsSize; ++i) {
        let validSplits = splits[i] >= prevSplit;
        validSplits = validSplits && splits[i] <= inputDataSize;
        if (!validSplits) {
          throw new Error(`Invalid split value ${splits[i]}, must be in [${prevSplit}, ${inputDataSize}]`);
        }
        prevSplit = splits[i];
      }
      if (prevSplit !== inputDataSize) {
        throw new Error(`Last split value must be data size. Expected ${inputDataSize}, got ${prevSplit}`);
      }
    }
    const numBatchItems = splitsSize - 1;
    const nGramsSplits = exports_util.getArrayFromDType("int32", splitsSize);
    if (inputDataSize === 0 || splitsSize === 0) {
      const empty = new Array(inputDataSize);
      for (let i = 0;i <= numBatchItems; ++i) {
        nGramsSplits[i] = 0;
      }
      return [empty, nGramsSplits];
    }
    nGramsSplits[0] = 0;
    for (let i = 1;i <= numBatchItems; ++i) {
      const length = splits[i] - splits[i - 1];
      let numNGrams = 0;
      this.nGramWidths.forEach((nGramWidth) => {
        numNGrams += this.getNumNGrams(length, nGramWidth);
      });
      if (this.preserveShort && length > 0 && numNGrams === 0) {
        numNGrams = 1;
      }
      nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;
    }
    const nGrams = new Array(nGramsSplits[numBatchItems]);
    for (let i = 0;i < numBatchItems; ++i) {
      const splitIndex = splits[i];
      let outputStartIdx = nGramsSplits[i];
      this.nGramWidths.forEach((nGramWidth) => {
        const length = splits[i + 1] - splits[i];
        const numNGrams = this.getNumNGrams(length, nGramWidth);
        this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
        outputStartIdx += numNGrams;
      });
      if (this.preserveShort && outputStartIdx === nGramsSplits[i]) {
        const dataLength = splits[i + 1] - splits[i];
        if (dataLength === 0) {
          continue;
        }
        const nGramWidth = dataLength + 2 * this.padWidth;
        const numNGrams = 1;
        this.createNGrams(data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);
      }
    }
    return [nGrams, nGramsSplits];
  }
}
var init_StringNGrams_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit_impl.js
function split9(str, delimiters, skipEmpty, result) {
  if (!str.length) {
    return;
  }
  if (delimiters.length === 0) {
    for (let i = 0;i < str.length; ++i) {
      result.push(str.subarray(i, i + 1));
    }
    return;
  }
  if (delimiters.length === 1) {
    const delimiter = delimiters[0];
    let f = str.indexOf(delimiter);
    while (f !== -1) {
      const token = str.subarray(0, f);
      if (!skipEmpty || token.length !== 0) {
        result.push(token);
      }
      str = str.subarray(f + 1);
      f = str.indexOf(delimiter);
    }
    if (!skipEmpty || str.length !== 0) {
      result.push(str);
    }
    return;
  }
  let tokenStart = 0;
  for (let i = 0;i < str.length + 1; i++) {
    if (i === str.length || delimiters.indexOf(str[i]) !== -1) {
      const token = str.subarray(tokenStart, i);
      if (!skipEmpty || token.length !== 0) {
        result.push(token);
      }
      tokenStart = i + 1;
    }
  }
}
function stringSplitImpl(input2, delimiter, skipEmpty) {
  const batchSize = input2.length;
  const tokens = [];
  let outputSize = 0;
  let maxNumEntries = 0;
  const numIndices = new Array(batchSize);
  for (let i = 0;i < batchSize; ++i) {
    const prevTokensLength = tokens.length;
    split9(input2[i], delimiter, skipEmpty, tokens);
    const nEntries = tokens.length - prevTokensLength;
    numIndices[i] = nEntries;
    outputSize += nEntries;
    maxNumEntries = Math.max(maxNumEntries, nEntries);
  }
  const indices = exports_util.getArrayFromDType("int32", outputSize * 2);
  const values = new Array(outputSize);
  const shape = [batchSize, maxNumEntries];
  let c = 0;
  for (let i = 0;i < batchSize; ++i) {
    for (let j = 0;j < numIndices[i]; ++j) {
      indices[c * 2] = i;
      indices[c * 2 + 1] = j;
      values[c] = tokens[c];
      ++c;
    }
  }
  return [indices, values, shape];
}
var init_StringSplit_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast_impl.js
function stringToHashBucketFastImpl(input2, numBuckets) {
  const output = exports_util.getArrayFromDType("int32", input2.length);
  for (let i = 0;i < input2.length; ++i) {
    output[i] = exports_util.fingerPrint64(input2[i]).modulo(numBuckets).getLowBitsUnsigned();
  }
  return output;
}
var init_StringToHashBucketFast_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sub.js
var subImpl, subComplexImpl, sub33, subConfig;
var init_Sub = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  subImpl = createSimpleBinaryKernelImpl((aValue, bValue) => aValue - bValue);
  subComplexImpl = createComplexBinaryKernelImpl((aReal, aImag, bReal, bImag) => {
    return { real: aReal - bReal, imag: aImag - bImag };
  });
  sub33 = binaryKernelFunc(Sub, subImpl, subComplexImpl);
  subConfig = {
    kernelName: Sub,
    backendName: "cpu",
    kernelFunc: sub33
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile_impl.js
function tileImpl(xBuf, reps) {
  const newShape = new Array(xBuf.rank);
  for (let i = 0;i < newShape.length; i++) {
    newShape[i] = xBuf.shape[i] * reps[i];
  }
  const result = buffer(newShape, xBuf.dtype);
  for (let i = 0;i < result.values.length; ++i) {
    const newLoc = result.indexToLoc(i);
    const originalLoc = new Array(xBuf.rank);
    for (let j = 0;j < originalLoc.length; j++) {
      originalLoc[j] = newLoc[j] % xBuf.shape[j];
    }
    const originalIndex = xBuf.locToIndex(originalLoc);
    result.values[i] = xBuf.values[originalIndex];
  }
  return result;
}
var init_Tile_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK_impl.js
function select(array2, k, left = 0, right = array2.length - 1) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const i3 = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * Math.sign(i3 - n / 2);
      const newLeft = Math.max(left, Math.floor(k - i3 * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - i3) * s / n + sd));
      select(array2, k, newLeft, newRight);
    }
    const t = array2[k];
    let i = left;
    let j = right;
    exports_util.swap(array2, left, k);
    if (comparePair(array2[right], t) > 0) {
      exports_util.swap(array2, left, right);
    }
    while (i < j) {
      exports_util.swap(array2, i, j);
      i++;
      j--;
      while (comparePair(array2[i], t) < 0) {
        i = i + 1;
      }
      while (comparePair(array2[j], t) > 0) {
        j = j - 1;
      }
    }
    if (comparePair(array2[left], t) === 0) {
      exports_util.swap(array2, left, j);
    } else {
      j = j + 1;
      exports_util.swap(array2, j, right);
    }
    if (j <= k) {
      left = j + 1;
    }
    if (k <= j) {
      right = j - 1;
    }
  }
}
function topKImpl(x, xShape, xDtype, k, sorted) {
  const lastDim = xShape[xShape.length - 1];
  const [batch, size] = [x.length / lastDim, lastDim];
  const allTopKVals = exports_util.getTypedArrayFromDType(xDtype, batch * k);
  const allTopKIndices = exports_util.getTypedArrayFromDType("int32", batch * k);
  for (let b = 0;b < batch; b++) {
    const offset = b * size;
    const vals = x.subarray(offset, offset + size);
    let valAndInd = new Array(vals.length);
    vals.forEach((value, index) => valAndInd[index] = { value, index });
    if (k < valAndInd.length) {
      select(valAndInd, k);
      valAndInd = valAndInd.slice(0, k);
    }
    if (sorted) {
      valAndInd.sort(comparePair);
    }
    const outOffset = b * k;
    const topKVals = allTopKVals.subarray(outOffset, outOffset + k);
    const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);
    for (let i = 0;i < k; i++) {
      topKVals[i] = valAndInd[i].value;
      topKIndices[i] = valAndInd[i].index;
    }
  }
  const outputShape = xShape.slice();
  outputShape[outputShape.length - 1] = k;
  return [
    buffer(outputShape, xDtype, allTopKVals),
    buffer(outputShape, "int32", allTopKIndices)
  ];
}
var comparePair = (a, b) => {
  const valueDiff = b.value - a.value;
  return valueDiff === 0 ? a.index - b.index : valueDiff;
};
var init_TopK_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique_impl.js
function uniqueImpl(values, axis, shape, dtype) {
  const $axis = exports_util.parseAxisParam(axis, shape)[0];
  const newShape = [1, shape[0], 1];
  for (let i = 0;i < $axis; i++) {
    newShape[0] *= shape[i];
  }
  newShape[1] = shape[$axis];
  for (let i = $axis + 1;i < shape.length; i++) {
    newShape[2] *= shape[i];
  }
  const uniqueElements = new Map;
  const indices = new Int32Array(shape[$axis]);
  const inputBuffer = new TensorBuffer(newShape, dtype, values);
  const uniqueIndices = [];
  const is1DTensor = newShape[0] === 1 && newShape[2] === 1;
  for (let i = 0;i < shape[$axis]; i++) {
    let element;
    if (is1DTensor) {
      element = values[i].toString();
    } else {
      const axisValues = [];
      for (let m = 0;m < newShape[0]; m++) {
        for (let n = 0;n < newShape[2]; n++) {
          axisValues.push(inputBuffer.get(m, i, n));
        }
      }
      element = axisValues.join(",");
    }
    const existingIndex = uniqueElements.get(element);
    if (existingIndex != null) {
      indices[i] = existingIndex;
    } else {
      const uniqueIndex = uniqueElements.size;
      uniqueElements.set(element, uniqueIndex);
      indices[i] = uniqueIndex;
      uniqueIndices.push(i);
    }
  }
  const outputTmpShape = newShape.slice();
  outputTmpShape[1] = uniqueElements.size;
  const outputBuffer = new TensorBuffer(outputTmpShape, dtype);
  uniqueIndices.forEach((uniqueElementIndex, i) => {
    for (let m = 0;m < newShape[0]; m++) {
      for (let n = 0;n < newShape[2]; n++) {
        outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);
      }
    }
  });
  const outputShape = shape.slice();
  outputShape[$axis] = outputTmpShape[1];
  return {
    outputValues: outputBuffer.values,
    outputShape,
    indices
  };
}
var init_Unique_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/shared.js
var exports_shared = {};
__export(exports_shared, {
  uniqueImpl: () => uniqueImpl,
  transposeImpl: () => transposeImpl,
  topKImpl: () => topKImpl,
  tileImpl: () => tileImpl,
  subImpl: () => subImpl,
  stringToHashBucketFastImpl: () => stringToHashBucketFastImpl,
  stringSplitImpl: () => stringSplitImpl,
  stringNGramsImpl: () => stringNGramsImpl,
  stridedSliceImpl: () => stridedSliceImpl,
  staticRegexReplaceImpl: () => staticRegexReplaceImpl,
  squaredDifferenceImpl: () => squaredDifferenceImpl,
  sqrtImpl: () => sqrtImpl,
  sparseSegmentReductionImpl: () => sparseSegmentReductionImpl,
  sparseReshapeImpl: () => sparseReshapeImpl,
  sparseFillEmptyRowsImpl: () => sparseFillEmptyRowsImpl,
  sliceImpl: () => sliceImpl,
  simpleAbsImpl: () => simpleAbsImpl,
  sigmoidImpl: () => sigmoidImpl,
  scatterImpl: () => scatterImpl,
  rsqrtImpl: () => rsqrtImpl,
  rangeImpl: () => rangeImpl,
  raggedTensorToTensorImpl: () => raggedTensorToTensorImpl,
  raggedRangeImpl: () => raggedRangeImpl,
  raggedGatherImpl: () => raggedGatherImpl,
  prodImpl: () => prodImpl,
  notEqualImpl: () => notEqualImpl,
  negImpl: () => negImpl,
  multiplyImpl: () => multiplyImpl,
  minimumImpl: () => minimumImpl,
  maximumImpl: () => maximumImpl,
  maxImpl: () => maxImpl,
  logImpl: () => logImpl,
  linSpaceImpl: () => linSpaceImpl,
  lessImpl: () => lessImpl,
  lessEqualImpl: () => lessEqualImpl,
  greaterImpl: () => greaterImpl,
  greaterEqualImpl: () => greaterEqualImpl,
  gatherV2Impl: () => gatherV2Impl,
  gatherNdImpl: () => gatherNdImpl,
  floorImpl: () => floorImpl,
  floorDivImpl: () => floorDivImpl,
  expm1Impl: () => expm1Impl,
  expImpl: () => expImpl,
  equalImpl: () => equalImpl,
  concatImpl: () => concatImpl,
  ceilImpl: () => ceilImpl,
  castImpl: () => castImpl,
  bitwiseAndImpl: () => bitwiseAndImpl,
  bincountReduceImpl: () => bincountReduceImpl,
  bincountImpl: () => bincountImpl,
  addImpl: () => addImpl
});
var init_shared = __esm(() => {
  init_Abs();
  init_Add();
  init_Bincount_impl();
  init_BitwiseAnd();
  init_Cast();
  init_Ceil();
  init_Concat_impl();
  init_Equal();
  init_Exp();
  init_Expm1();
  init_Floor();
  init_FloorDiv();
  init_GatherNd_Impl();
  init_GatherV2_impl();
  init_Greater();
  init_GreaterEqual();
  init_Less();
  init_LessEqual();
  init_LinSpace_impl();
  init_Log();
  init_Max_impl();
  init_Maximum();
  init_Minimum();
  init_Multiply();
  init_Neg();
  init_NotEqual();
  init_Prod();
  init_RaggedGather_impl();
  init_RaggedRange_impl();
  init_RaggedTensorToTensor_impl();
  init_Range_impl();
  init_Rsqrt();
  init_Scatter_impl();
  init_Sigmoid();
  init_Slice();
  init_SparseFillEmptyRows_impl();
  init_SparseReshape_impl();
  init_SparseSegmentReduction_impl();
  init_Sqrt();
  init_SquaredDifference();
  init_StaticRegexReplace();
  init_StridedSlice_impl();
  init_StringNGrams_impl();
  init_StringSplit_impl();
  init_StringToHashBucketFast_impl();
  init_Sub();
  init_Tile_impl();
  init_TopK_impl();
  init_Transpose_impl();
  init_Unique_impl();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/version.js
var version8 = "4.22.0";
var init_version5 = () => {
};

// node_modules/@tensorflow/tfjs-backend-cpu/dist/base.js
var init_base2 = __esm(() => {
  init_dist();
  init_backend_cpu();
  init_shared();
  init_backend_cpu();
  init_version5();
  registerBackend("cpu", () => new MathBackendCPU, 1);
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Elu.js
var elu7, eluConfig;
var init_Elu = __esm(() => {
  init_dist();
  init_unary_utils();
  elu7 = unaryKernelFunc(Elu, (xi) => xi >= 0 ? xi : Math.exp(xi) - 1);
  eluConfig = {
    kernelName: Elu,
    backendName: "cpu",
    kernelFunc: elu7
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LeakyRelu.js
function leakyRelu2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { alpha } = attrs;
  assertNotComplex([x], "leakyRelu");
  const xSize = exports_util.sizeFromShape(x.shape);
  const xVals = backend3.data.get(x.dataId).values;
  const outVals = exports_util.getTypedArrayFromDType("float32", xSize);
  for (let i = 0;i < xVals.length; i++) {
    outVals[i] = xVals[i] < 0 ? alpha * xVals[i] : xVals[i];
  }
  return backend3.makeTensorInfo(x.shape, "float32", outVals);
}
var leakyReluConfig;
var init_LeakyRelu = __esm(() => {
  init_dist();
  init_cpu_util();
  leakyReluConfig = {
    kernelName: LeakyRelu,
    backendName: "cpu",
    kernelFunc: leakyRelu2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Prelu.js
function prelu6(args) {
  const { inputs, backend: backend3 } = args;
  const { x, alpha } = inputs;
  assertNotComplex([x, alpha], "prelu");
  const aVals = backend3.data.get(x.dataId).values;
  const bVals = backend3.data.get(alpha.dataId).values;
  const [resultData, resultShape] = preluImpl(x.shape, alpha.shape, aVals, bVals, "float32");
  return backend3.makeTensorInfo(resultShape, "float32", resultData);
}
var preluImpl, preluConfig;
var init_Prelu = __esm(() => {
  init_dist();
  init_cpu_util();
  init_binary_impl();
  preluImpl = createSimpleBinaryKernelImpl((xValue, aValue) => xValue < 0 ? aValue * xValue : xValue);
  preluConfig = {
    kernelName: Prelu,
    backendName: "cpu",
    kernelFunc: prelu6
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Relu.js
var relu9, reluConfig;
var init_Relu = __esm(() => {
  init_dist();
  init_unary_utils();
  relu9 = unaryKernelFunc(Relu, (xi) => Math.max(0, xi));
  reluConfig = {
    kernelName: Relu,
    backendName: "cpu",
    kernelFunc: relu9
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Relu6.js
var relu65, relu6Config;
var init_Relu6 = __esm(() => {
  init_dist();
  init_unary_utils();
  relu65 = unaryKernelFunc(Relu6, (xi) => Math.min(Math.max(0, xi), 6));
  relu6Config = {
    kernelName: Relu6,
    backendName: "cpu",
    kernelFunc: relu65
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fused_utils.js
function applyActivation2(backend3, x, activation2, preluActivationWeights, leakyreluAlpha) {
  if (activation2 === "linear") {
    return identity2({ inputs: { x }, backend: backend3 });
  } else if (activation2 === "relu") {
    return relu9({ inputs: { x }, backend: backend3 });
  } else if (activation2 === "elu") {
    return elu7({ inputs: { x }, backend: backend3 });
  } else if (activation2 === "relu6") {
    return relu65({ inputs: { x }, backend: backend3 });
  } else if (activation2 === "prelu") {
    return prelu6({ inputs: { x, alpha: preluActivationWeights }, backend: backend3 });
  } else if (activation2 === "leakyrelu") {
    return leakyRelu2({ inputs: { x }, backend: backend3, attrs: { alpha: leakyreluAlpha } });
  } else if (activation2 === "sigmoid") {
    return sigmoid7({ inputs: { x }, backend: backend3 });
  }
  throw new Error(`Activation ${activation2} has not been implemented for the CPU backend.`);
}
var init_fused_utils = __esm(() => {
  init_Elu();
  init_Identity();
  init_LeakyRelu();
  init_Prelu();
  init_Relu();
  init_Relu6();
  init_Sigmoid();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Reshape.js
function reshape77(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { shape } = attrs;
  const xSize = exports_util.sizeFromShape(x.shape);
  const $shape = exports_util.inferFromImplicitShape(shape, xSize);
  const $xSize = exports_util.sizeFromShape($shape);
  exports_util.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old ` + `shape (${x.shape}) has ${xSize} elements. The new shape and old ` + `shape must have the same number of elements.`);
  backend3.incRef(x.dataId);
  const xData = backend3.data.get(x.dataId);
  if (xData.complexTensorInfos != null) {
    const real6 = xData.complexTensorInfos.real;
    const imag5 = xData.complexTensorInfos.imag;
    real6.shape = $shape;
    imag5.shape = $shape;
  }
  return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
}
var reshapeConfig;
var init_Reshape = __esm(() => {
  init_dist();
  reshapeConfig = {
    kernelName: Reshape,
    backendName: "cpu",
    kernelFunc: reshape77
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchMatMul.js
function batchMatMul(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { a, b } = inputs;
  const { transposeA, transposeB } = attrs;
  assertNotComplex([a, b], "matMul");
  const aRank = a.shape.length;
  const bRank = b.shape.length;
  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
  const outerDimsA = a.shape.slice(0, -2);
  const outerDimsB = b.shape.slice(0, -2);
  const batchDimA = exports_util.sizeFromShape(outerDimsA);
  const batchDimB = exports_util.sizeFromShape(outerDimsB);
  const outShapeOuterDims = exports_broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  exports_util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape77({ inputs: { x: a }, backend: backend3, attrs: { shape: a3dShape } });
  const b3d = reshape77({ inputs: { x: b }, backend: backend3, attrs: { shape: b3dShape } });
  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
  const leftDim = transposeA ? a3d.shape[2] : a3d.shape[1];
  const rightDim = transposeB ? b3d.shape[1] : b3d.shape[2];
  const batchDim = Math.max(batchDimA, batchDimB);
  const a3dValues = backend3.data.get(a3d.dataId).values;
  const b3dValues = backend3.data.get(b3d.dataId).values;
  const a3dStrides = exports_util.computeStrides(a3d.shape);
  const b3dStrides = exports_util.computeStrides(b3d.shape);
  const [aBatch, aOuterStep, aInnerStep] = transposeA ? [a3dStrides[0], 1, a3dStrides[1]] : [a3dStrides[0], a3dStrides[1], 1];
  const [bInnerStep, bOuterStep, bBatch] = transposeB ? [1, b3dStrides[1], b3dStrides[0]] : [b3dStrides[1], 1, b3dStrides[0]];
  const size = leftDim * rightDim;
  const result = buffer([batchDim, leftDim, rightDim], a3d.dtype);
  const resVals = result.values;
  const blockSize = backend3.blockSize;
  for (let bi = 0;bi < batchDim; bi++) {
    const batchIndexA = bi % batchDimA;
    const batchIndexB = bi % batchDimB;
    for (let i0 = 0;i0 < leftDim; i0 += blockSize) {
      const iBlock = Math.min(i0 + blockSize, leftDim);
      for (let j0 = 0;j0 < rightDim; j0 += blockSize) {
        const jBlock = Math.min(j0 + blockSize, rightDim);
        for (let k02 = 0;k02 < sharedDim; k02 += blockSize) {
          const kBlock = Math.min(k02 + blockSize, sharedDim);
          for (let i = i0;i < iBlock; i++) {
            for (let j = j0;j < jBlock; j++) {
              let sum27 = 0;
              for (let k = k02;k < kBlock; k++) {
                const aVal = a3dValues[batchIndexA * aBatch + i * aOuterStep + k * aInnerStep];
                const bVal = b3dValues[k * bInnerStep + j * bOuterStep + batchIndexB * bBatch];
                sum27 += aVal * bVal;
              }
              resVals[bi * size + (i * rightDim + j)] += sum27;
            }
          }
        }
      }
    }
  }
  backend3.disposeIntermediateTensorInfo(a3d);
  backend3.disposeIntermediateTensorInfo(b3d);
  return backend3.makeTensorInfo(outShape, result.dtype, result.values);
}
var batchMatMulConfig;
var init_BatchMatMul = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Reshape();
  batchMatMulConfig = {
    kernelName: BatchMatMul,
    backendName: "cpu",
    kernelFunc: batchMatMul
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/_FusedMatMul.js
function _fusedMatMul(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { a, b, bias, preluActivationWeights } = inputs;
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  let current;
  let addRes;
  let activationRes;
  const intermediates = [];
  const matMulRes = batchMatMul({ inputs: { a, b }, attrs: { transposeA, transposeB }, backend: backend3 });
  current = matMulRes;
  if (bias) {
    addRes = add31({ inputs: { a: current, b: bias }, backend: backend3 });
    intermediates.push(current);
    current = addRes;
  }
  if (activation2) {
    activationRes = applyActivation2(backend3, current, activation2, preluActivationWeights, leakyreluAlpha);
    intermediates.push(current);
    current = activationRes;
  }
  for (const i of intermediates) {
    backend3.disposeIntermediateTensorInfo(i);
  }
  return current;
}
var _fusedMatMulConfig;
var init__FusedMatMul = __esm(() => {
  init_dist();
  init_fused_utils();
  init_Add();
  init_BatchMatMul();
  _fusedMatMulConfig = {
    kernelName: _FusedMatMul,
    backendName: "cpu",
    kernelFunc: _fusedMatMul
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Acos.js
var acos3, acosConfig;
var init_Acos = __esm(() => {
  init_dist();
  init_unary_utils();
  acos3 = unaryKernelFunc(Acos, (xi) => Math.acos(xi));
  acosConfig = {
    kernelName: Acos,
    backendName: "cpu",
    kernelFunc: acos3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Acosh.js
var acosh3, acoshConfig;
var init_Acosh = __esm(() => {
  init_dist();
  init_unary_utils();
  acosh3 = unaryKernelFunc(Acosh, (xi) => Math.acosh(xi));
  acoshConfig = {
    kernelName: Acosh,
    backendName: "cpu",
    kernelFunc: acosh3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AddN.js
function addN2(args) {
  const { inputs, backend: backend3 } = args;
  const tensors = inputs;
  assertNotComplex(inputs, "addN");
  const vals = tensors.map((t) => backend3.data.get(t.dataId).values);
  const outBuf = buffer(tensors[0].shape, tensors[0].dtype);
  const outVals = outBuf.values;
  for (let i = 0;i < tensors.length; i++) {
    const currVals = vals[i];
    for (let j = 0;j < outVals.length; j++) {
      outVals[j] += currVals[j];
    }
  }
  return backend3.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
var addNConfig;
var init_AddN = __esm(() => {
  init_dist();
  init_cpu_util();
  addNConfig = {
    kernelName: AddN,
    backendName: "cpu",
    kernelFunc: addN2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/All.js
function all4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x, "all");
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  if (permutedAxes != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("all", axes, $x.shape.length);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes($x.shape, axes);
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const vals = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(outShape), $x.dtype);
  const aVals = backend3.data.get($x.dataId).values;
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let all5 = aVals[offset];
    for (let j = 0;j < reduceSize; ++j) {
      const value = aVals[offset + j];
      all5 = all5 && value;
    }
    vals[i] = all5;
  }
  if (permutedAxes != null) {
    backend3.disposeIntermediateTensorInfo($x);
  }
  const result = backend3.makeTensorInfo(outShape, $x.dtype, vals);
  if (keepDims) {
    const expandedShape = exports_backend_util.expandShapeToKeepDim(outShape, origAxes);
    const reshapedResult = reshape77({ inputs: { x: result }, backend: backend3, attrs: { shape: expandedShape } });
    backend3.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  return result;
}
var allConfig;
var init_All = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Reshape();
  init_Transpose();
  allConfig = {
    kernelName: All,
    backendName: "cpu",
    kernelFunc: all4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Any.js
function any4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x, "any");
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  if (permutedAxes != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("any", axes, $x.shape.length);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes($x.shape, axes);
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const vals = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(outShape), $x.dtype);
  const aVals = backend3.data.get($x.dataId).values;
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let anyVal = aVals[offset];
    for (let j = 0;j < reduceSize; ++j) {
      const value = aVals[offset + j];
      anyVal = anyVal || value;
    }
    vals[i] = anyVal;
  }
  if (permutedAxes != null) {
    backend3.disposeIntermediateTensorInfo($x);
  }
  const result = backend3.makeTensorInfo(outShape, $x.dtype, vals);
  if (keepDims) {
    const expandedShape = exports_backend_util.expandShapeToKeepDim(outShape, origAxes);
    const reshapedResult = reshape77({ inputs: { x: result }, backend: backend3, attrs: { shape: expandedShape } });
    backend3.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  return result;
}
var anyConfig;
var init_Any = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Reshape();
  init_Transpose();
  anyConfig = {
    kernelName: Any,
    backendName: "cpu",
    kernelFunc: any4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ArgMax.js
function argMax2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis } = attrs;
  assertNotComplex(x, "argMax");
  let axes = exports_util.parseAxisParam(axis, x.shape);
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = exports_backend_util.getInnerMostAxes(axes.length, $x.shape.length);
  }
  axes = [axes[0]];
  exports_backend_util.assertAxesAreInnerMostDims("argMax", axes, $x.shape.length);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes($x.shape, axes);
  const outSize = exports_util.sizeFromShape(outShape);
  const vals = exports_util.makeZerosTypedArray(outSize, "int32");
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const aVals = backend3.data.get($x.dataId).values;
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let max8 = aVals[offset];
    let maxIndex = 0;
    for (let j = 0;j < reduceSize; ++j) {
      const value = aVals[offset + j];
      if (value > max8) {
        max8 = value;
        maxIndex = j;
      }
    }
    vals[i] = maxIndex;
  }
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return backend3.makeTensorInfo(outShape, "int32", vals);
}
var argMaxConfig;
var init_ArgMax = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Transpose();
  argMaxConfig = {
    kernelName: ArgMax,
    backendName: "cpu",
    kernelFunc: argMax2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ArgMin.js
function argMin2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis } = attrs;
  assertNotComplex(x, "argMin");
  let axes = exports_util.parseAxisParam(axis, x.shape);
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = exports_backend_util.getInnerMostAxes(axes.length, $x.shape.length);
  }
  axes = [axes[0]];
  exports_backend_util.assertAxesAreInnerMostDims("argMin", axes, $x.shape.length);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes($x.shape, axes);
  const outSize = exports_util.sizeFromShape(outShape);
  const vals = exports_util.makeZerosTypedArray(outSize, "int32");
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const aVals = backend3.data.get($x.dataId).values;
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let min6 = aVals[offset];
    let minIndex = 0;
    for (let j = 0;j < reduceSize; ++j) {
      const value = aVals[offset + j];
      if (value < min6) {
        min6 = value;
        minIndex = j;
      }
    }
    vals[i] = minIndex;
  }
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return backend3.makeTensorInfo(outShape, "int32", vals);
}
var argMinConfig;
var init_ArgMin = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Transpose();
  argMinConfig = {
    kernelName: ArgMin,
    backendName: "cpu",
    kernelFunc: argMin2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Asin.js
var asin3, asinConfig;
var init_Asin = __esm(() => {
  init_dist();
  init_unary_utils();
  asin3 = unaryKernelFunc(Asin, (xi) => Math.asin(xi));
  asinConfig = {
    kernelName: Asin,
    backendName: "cpu",
    kernelFunc: asin3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Asinh.js
var asinh3, asinhConfig;
var init_Asinh = __esm(() => {
  init_dist();
  init_unary_utils();
  asinh3 = unaryKernelFunc(Asinh, (xi) => Math.asinh(xi));
  asinhConfig = {
    kernelName: Asinh,
    backendName: "cpu",
    kernelFunc: asinh3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Atan.js
var atan5, atanConfig;
var init_Atan = __esm(() => {
  init_dist();
  init_unary_utils();
  atan5 = unaryKernelFunc(Atan, (xi) => Math.atan(xi));
  atanConfig = {
    kernelName: Atan,
    backendName: "cpu",
    kernelFunc: atan5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Atan2.js
var atan2Impl, atan24, atan2Config;
var init_Atan2 = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  atan2Impl = createSimpleBinaryKernelImpl((aValue, bValue) => Math.atan2(aValue, bValue));
  atan24 = binaryKernelFunc(Atan2, atan2Impl);
  atan2Config = {
    kernelName: Atan2,
    backendName: "cpu",
    kernelFunc: atan24
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Atanh.js
var atanh3, atanhConfig;
var init_Atanh = __esm(() => {
  init_dist();
  init_unary_utils();
  atanh3 = unaryKernelFunc(Atanh, (xi) => Math.atanh(xi));
  atanhConfig = {
    kernelName: Atanh,
    backendName: "cpu",
    kernelFunc: atanh3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/pool_utils.js
function pool4(xValues, xShape, dtype, strides, convInfo, poolType) {
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  const output = buffer(convInfo.outShape, dtype);
  const outputVals = output.values;
  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];
  const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];
  const outputColStrides = convInfo.outShape[3];
  for (let b = 0;b < convInfo.batchSize; ++b) {
    const outputBatchOffset = b * outputBatchStrides;
    const inputBatchOffset = b * strides[0];
    for (let d = 0;d < convInfo.inChannels; ++d) {
      for (let yR = 0;yR < convInfo.outHeight; ++yR) {
        const xRCorner = yR * strideHeight - padTop;
        const xRMin = Math.max(0, xRCorner);
        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
        const outputRowOffset = outputBatchOffset + yR * outputRowStrides;
        for (let yC = 0;yC < convInfo.outWidth; ++yC) {
          const xCCorner = yC * strideWidth - padLeft;
          const xCMin = Math.max(0, xCCorner);
          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
          let minMaxValue = initialValue;
          let avgValue = 0;
          let count2 = 0;
          for (let xR = xRMin;xR < xRMax; xR += dilationHeight) {
            const xROffset = inputBatchOffset + xR * strides[1];
            for (let xC = xCMin;xC < xCMax; xC += dilationWidth) {
              const xCOffset = xROffset + xC * strides[2];
              const pixel = xValues[xCOffset + d];
              if (poolType === "max" && pixel > minMaxValue) {
                minMaxValue = pixel;
              } else if (poolType === "avg") {
                avgValue += pixel;
                count2++;
              }
            }
            if (isNaN(minMaxValue)) {
              break;
            }
          }
          const outputOffset = outputRowOffset + yC * outputColStrides + d;
          outputVals[outputOffset] = poolType === "avg" ? avgValue / count2 : minMaxValue;
        }
      }
    }
  }
  return output;
}
function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {
  const maxPositions = buffer(convInfo.outShape, "int32");
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  const xBuf = buffer(xShape, dtype, xValues);
  for (let b = 0;b < convInfo.batchSize; ++b) {
    for (let d = 0;d < convInfo.inChannels; ++d) {
      for (let yR = 0;yR < convInfo.outHeight; ++yR) {
        const xRCorner = yR * strideHeight - padTop;
        let xRMin = xRCorner;
        while (xRMin < 0) {
          xRMin += dilationHeight;
        }
        const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);
        for (let yC = 0;yC < convInfo.outWidth; ++yC) {
          const xCCorner = yC * strideWidth - padLeft;
          let xCMin = xCCorner;
          while (xCMin < 0) {
            xCMin += dilationWidth;
          }
          const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);
          let maxValue = Number.NEGATIVE_INFINITY;
          let maxPosition = -1;
          for (let xR = xRMin;xR < xRMax; xR += dilationHeight) {
            const wR = xR - xRCorner;
            for (let xC = xCMin;xC < xCMax; xC += dilationWidth) {
              const wC = xC - xCCorner;
              const pixel = xBuf.get(b, xR, xC, d);
              if (pixel > maxValue) {
                maxValue = pixel;
                if (flattenPositions) {
                  maxPosition = includeBatchInIndex ? ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) * convInfo.inChannels + d : (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;
                } else {
                  maxPosition = wR * effectiveFilterWidth + wC;
                }
              }
            }
          }
          maxPositions.set(maxPosition, b, yR, yC, d);
        }
      }
    }
  }
  return maxPositions;
}
function pool3d2(xValues, xShape, dtype, strides, convInfo, poolType) {
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = convInfo.padInfo.front;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  const initialValue = poolType === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY;
  const output = buffer(convInfo.outShape, dtype);
  const outputVals = output.values;
  const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
  const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];
  const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];
  const outputColStrides = convInfo.outShape[4];
  for (let batch = 0;batch < convInfo.batchSize; ++batch) {
    const outputBatchOffset = batch * outputBatchStrides;
    const inputBatchOffset = batch * strides[0];
    for (let channel = 0;channel < convInfo.inChannels; ++channel) {
      for (let yDepth = 0;yDepth < convInfo.outDepth; ++yDepth) {
        const xDepthCorner = yDepth * strideDepth - padFront;
        let xDepthMin = xDepthCorner;
        while (xDepthMin < 0) {
          xDepthMin += dilationDepth;
        }
        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
        const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;
        for (let yRow = 0;yRow < convInfo.outHeight; ++yRow) {
          const xRowCorner = yRow * strideHeight - padTop;
          let xRowMin = xRowCorner;
          while (xRowMin < 0) {
            xRowMin += dilationHeight;
          }
          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
          const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;
          for (let yCol = 0;yCol < convInfo.outWidth; ++yCol) {
            const xColCorner = yCol * strideWidth - padLeft;
            let xColMin = xColCorner;
            while (xColMin < 0) {
              xColMin += dilationWidth;
            }
            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
            const outputColOffset = outputRowOffset + yCol * outputColStrides;
            let minMaxValue = initialValue;
            let avgValue = 0;
            let count2 = 0;
            for (let xDepth = xDepthMin;xDepth < xDepthMax; xDepth += dilationDepth) {
              const xDepthOffset = inputBatchOffset + xDepth * strides[1];
              for (let xRow = xRowMin;xRow < xRowMax; xRow += dilationHeight) {
                const xRowOffset = xDepthOffset + xRow * strides[2];
                for (let xCol = xColMin;xCol < xColMax; xCol += dilationWidth) {
                  const xColOffset = xRowOffset + xCol * strides[3];
                  const pixel = xValues[xColOffset + channel];
                  if (poolType === "max" && pixel > minMaxValue) {
                    minMaxValue = pixel;
                  } else if (poolType === "avg") {
                    avgValue += pixel;
                    count2++;
                  }
                  if (isNaN(minMaxValue)) {
                    break;
                  }
                }
                if (isNaN(minMaxValue)) {
                  break;
                }
              }
              if (isNaN(minMaxValue)) {
                break;
              }
            }
            const outputOffset = outputColOffset + channel;
            outputVals[outputOffset] = poolType === "avg" ? avgValue / Math.max(count2, 1) : minMaxValue;
          }
        }
      }
    }
  }
  return output;
}
function maxPool3dPositions(xBuf, convInfo) {
  const maxPositions = buffer(convInfo.outShape, "int32");
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = convInfo.padInfo.front;
  const padTop = convInfo.padInfo.top;
  const padLeft = convInfo.padInfo.left;
  for (let batch = 0;batch < convInfo.batchSize; ++batch) {
    for (let channel = 0;channel < convInfo.inChannels; ++channel) {
      for (let yDepth = 0;yDepth < convInfo.outDepth; ++yDepth) {
        const xDepthCorner = yDepth * strideDepth - padFront;
        let xDepthMin = xDepthCorner;
        while (xDepthMin < 0) {
          xDepthMin += dilationDepth;
        }
        const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);
        for (let yRow = 0;yRow < convInfo.outHeight; ++yRow) {
          const xRowCorner = yRow * strideHeight - padTop;
          let xRowMin = xRowCorner;
          while (xRowMin < 0) {
            xRowMin += dilationHeight;
          }
          const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);
          for (let yCol = 0;yCol < convInfo.outWidth; ++yCol) {
            const xColCorner = yCol * strideWidth - padLeft;
            let xColMin = xColCorner;
            while (xColMin < 0) {
              xColMin += dilationWidth;
            }
            const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);
            let maxValue = Number.NEGATIVE_INFINITY;
            let maxPosition = -1;
            for (let xDepth = xDepthMin;xDepth < xDepthMax; xDepth += dilationDepth) {
              const wDepth = xDepth - xDepthCorner;
              for (let xRow = xRowMin;xRow < xRowMax; xRow += dilationHeight) {
                const wRow = xRow - xRowCorner;
                for (let xCol = xColMin;xCol < xColMax; xCol += dilationWidth) {
                  const wCol = xCol - xColCorner;
                  const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);
                  if (pixel >= maxValue) {
                    maxValue = pixel;
                    maxPosition = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterHeight + wCol;
                  }
                }
              }
            }
            maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);
          }
        }
      }
    }
  }
  return maxPositions;
}
var init_pool_utils = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool.js
function avgPool2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  assertNotComplex(x, "avgPool");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = 1;
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in avgPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  let res;
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && exports_util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    res = identity2({ inputs: { x }, backend: backend3 });
  } else {
    const xValues = backend3.data.get(x.dataId).values;
    const strides2 = exports_util.computeStrides(x.shape);
    const buffer9 = pool4(xValues, x.shape, x.dtype, strides2, convInfo, "avg");
    res = backend3.makeTensorInfo(convInfo.outShape, x.dtype, buffer9.values);
  }
  return res;
}
var avgPoolConfig;
var init_AvgPool = __esm(() => {
  init_dist();
  init_cpu_util();
  init_pool_utils();
  init_Identity();
  avgPoolConfig = {
    kernelName: AvgPool,
    backendName: "cpu",
    kernelFunc: avgPool2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool3D.js
function avgPool3D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode, dataFormat } = attrs;
  assertNotComplex(x, "avgPool3d");
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, 1, pad9, dimRoundingMode, dataFormat);
  const xValues = backend3.data.get(x.dataId).values;
  const outBuf = pool3d2(xValues, x.shape, x.dtype, exports_util.computeStrides(x.shape), convInfo, "avg");
  return backend3.makeTensorInfo(outBuf.shape, "float32", outBuf.values);
}
var avgPool3DConfig;
var init_AvgPool3D = __esm(() => {
  init_dist();
  init_cpu_util();
  init_pool_utils();
  avgPool3DConfig = {
    kernelName: AvgPool3D,
    backendName: "cpu",
    kernelFunc: avgPool3D
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPool3DGrad.js
function avgPool3DGrad(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  assertNotComplex([dy2, input2], "avgPool3DGrad");
  const convInfo = exports_backend_util.computePool3DInfo(input2.shape, filterSize, strides, 1, pad9, dimRoundingMode);
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const filterDepth = convInfo.filterDepth;
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(input2.shape, "float32");
  const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
  const dyBuf = backend3.bufferSync(dy2);
  for (let batch = 0;batch < convInfo.batchSize; ++batch) {
    for (let channel = 0;channel < convInfo.inChannels; ++channel) {
      for (let dxDepth = 0;dxDepth < convInfo.inDepth; ++dxDepth) {
        for (let dxRow = 0;dxRow < convInfo.inHeight; ++dxRow) {
          for (let dxCol = 0;dxCol < convInfo.inWidth; ++dxCol) {
            const dyDepthCorner = dxDepth - padFront;
            const dyRowCorner = dxRow - padTop;
            const dyColCorner = dxCol - padLeft;
            let dotProd = 0;
            for (let wDepth = 0;wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
              const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
              if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                continue;
              }
              for (let wRow = 0;wRow < effectiveFilterHeight; wRow += dilationHeight) {
                const dyRow = (dyRowCorner + wRow) / strideHeight;
                if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                  continue;
                }
                for (let wCol = 0;wCol < effectiveFilterWidth; wCol += dilationWidth) {
                  const dyCol = (dyColCorner + wCol) / strideWidth;
                  if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                    continue;
                  }
                  const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                  dotProd += pixel;
                }
              }
            }
            dx.set(dotProd * avgMultiplier, batch, dxDepth, dxRow, dxCol, channel);
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var avgPool3DGradConfig2;
var init_AvgPool3DGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  avgPool3DGradConfig2 = {
    kernelName: AvgPool3DGrad,
    backendName: "cpu",
    kernelFunc: avgPool3DGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/AvgPoolGrad.js
function avgPoolGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  assertNotComplex([dy2, input2], "avgPoolGrad");
  const { filterSize, strides, pad: pad9 } = attrs;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, 1, pad9);
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(x.shape, "float32");
  const avgMultiplier = 1 / (filterHeight * filterWidth);
  const dyData = backend3.data.get(dy2.dataId).values;
  const dyBuf = buffer(dy2.shape, "float32", dyData);
  for (let b = 0;b < convInfo.batchSize; ++b) {
    for (let d = 0;d < convInfo.inChannels; ++d) {
      for (let dxR = 0;dxR < convInfo.inHeight; ++dxR) {
        for (let dxC = 0;dxC < convInfo.inWidth; ++dxC) {
          const dyRCorner = dxR - padTop;
          const dyCCorner = dxC - padLeft;
          let dotProd = 0;
          for (let wR = 0;wR < effectiveFilterHeight; wR += dilationHeight) {
            const dyR = (dyRCorner + wR) / strideHeight;
            if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
              continue;
            }
            for (let wC = 0;wC < effectiveFilterWidth; wC += dilationWidth) {
              const dyC = (dyCCorner + wC) / strideWidth;
              if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                continue;
              }
              const pixel = dyBuf.get(b, dyR, dyC, d);
              dotProd += pixel;
            }
          }
          dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var avgPoolGradConfig2;
var init_AvgPoolGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  avgPoolGradConfig2 = {
    kernelName: AvgPoolGrad,
    backendName: "cpu",
    kernelFunc: avgPoolGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchNorm.js
function batchNorm2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, scale, offset, mean: mean6, variance } = inputs;
  exports_util.assert(mean6.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have " + "equal ranks.");
  exports_util.assert(offset == null || mean6.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have " + "equal ranks.");
  exports_util.assert(scale == null || mean6.shape.length === scale.shape.length, () => "Batch normalization gradient requires mean and scale to have " + "equal ranks.");
  assertNotComplex([x, mean6, variance, scale, offset], "batchNorm");
  let { varianceEpsilon } = attrs;
  if (varianceEpsilon == null) {
    varianceEpsilon = 0.001;
  }
  const xVals = backend3.data.get(x.dataId).values;
  const mVals = backend3.data.get(mean6.dataId).values;
  const varVals = backend3.data.get(variance.dataId).values;
  const sVals = scale ? backend3.data.get(scale.dataId).values : new Float32Array([1]);
  const offVals = offset ? backend3.data.get(offset.dataId).values : new Float32Array([0]);
  const outVals = new Float32Array(xVals.length);
  const offValsLength = offVals.length;
  const sValsLength = sVals.length;
  const varValsLength = varVals.length;
  const mValsLength = mVals.length;
  let offi = 0;
  let mi = 0;
  let si = 0;
  let vi = 0;
  for (let i = 0;i < xVals.length; ++i) {
    outVals[i] = offVals[offi++] + (xVals[i] - mVals[mi++]) * sVals[si++] / Math.sqrt(varVals[vi++] + varianceEpsilon);
    if (offi >= offValsLength) {
      offi = 0;
    }
    if (mi >= mValsLength) {
      mi = 0;
    }
    if (si >= sValsLength) {
      si = 0;
    }
    if (vi >= varValsLength) {
      vi = 0;
    }
  }
  return backend3.makeTensorInfo(x.shape, x.dtype, outVals);
}
var batchNormConfig;
var init_BatchNorm = __esm(() => {
  init_dist();
  init_cpu_util();
  batchNormConfig = {
    kernelName: FusedBatchNorm,
    backendName: "cpu",
    kernelFunc: batchNorm2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchToSpaceND.js
function batchToSpaceND2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockShape, crops } = attrs;
  assertNotComplex([x], "batchToSpaceND");
  const prod5 = blockShape.reduce((a, b) => a * b);
  const reshaped = exports_backend_util.getReshaped(x.shape, blockShape, prod5);
  const permuted = exports_backend_util.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = exports_backend_util.getReshapedPermuted(x.shape, blockShape, prod5);
  const sliceBeginCoords = exports_backend_util.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = exports_backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const xReshaped = reshape77({ inputs: { x }, backend: backend3, attrs: { shape: reshaped } });
  const xTransposed = transpose11({ inputs: { x: xReshaped }, backend: backend3, attrs: { perm: permuted } });
  const xTransposedReshaped = reshape77({ inputs: { x: xTransposed }, backend: backend3, attrs: { shape: reshapedPermuted } });
  const result = slice16({
    inputs: { x: xTransposedReshaped },
    backend: backend3,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  backend3.disposeIntermediateTensorInfo(xReshaped);
  backend3.disposeIntermediateTensorInfo(xTransposed);
  backend3.disposeIntermediateTensorInfo(xTransposedReshaped);
  return result;
}
var batchToSpaceNDConfig;
var init_BatchToSpaceND = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Reshape();
  init_Slice();
  init_Transpose();
  batchToSpaceNDConfig = {
    kernelName: BatchToSpaceND,
    backendName: "cpu",
    kernelFunc: batchToSpaceND2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Bincount.js
function bincount3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, weights } = inputs;
  const { size } = attrs;
  const xVals = backend3.data.get(x.dataId).values;
  const weightsVals = backend3.data.get(weights.dataId).values;
  const outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size);
  return backend3.makeTensorInfo([size], weights.dtype, outVals);
}
var bincountConfig;
var init_Bincount = __esm(() => {
  init_dist();
  init_Bincount_impl();
  bincountConfig = {
    kernelName: Bincount,
    backendName: "cpu",
    kernelFunc: bincount3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BroadcastArgs.js
function broadcastArgs2(args) {
  const { inputs, backend: backend3 } = args;
  const { s0, s1 } = inputs;
  const s0Vals = backend3.data.get(s0.dataId).values;
  const s1Vals = backend3.data.get(s1.dataId).values;
  const broadcastShape = exports_backend_util.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
  return backend3.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
}
var broadcastArgsConfig;
var init_BroadcastArgs = __esm(() => {
  init_dist();
  broadcastArgsConfig = {
    kernelName: BroadcastArgs,
    backendName: "cpu",
    kernelFunc: broadcastArgs2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ClipByValue.js
var clipByValue2, clipByValueConfig;
var init_ClipByValue = __esm(() => {
  init_dist();
  init_unary_utils();
  clipByValue2 = unaryKernelFunc(ClipByValue, (xi, attrs) => {
    const clipAttrs = attrs;
    if (xi > clipAttrs.clipValueMax) {
      return clipAttrs.clipValueMax;
    }
    return xi < clipAttrs.clipValueMin ? clipAttrs.clipValueMin : xi;
  });
  clipByValueConfig = {
    kernelName: ClipByValue,
    backendName: "cpu",
    kernelFunc: clipByValue2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ComplexAbs.js
var complexAbs = (args) => {
  const { x } = args.inputs;
  const cpuBackend = args.backend;
  const resultValues = new Float32Array(exports_util.sizeFromShape(x.shape));
  const complexVals = cpuBackend.data.get(x.dataId);
  const real6 = complexVals.complexTensorInfos.real;
  const imag5 = complexVals.complexTensorInfos.imag;
  const realVals = cpuBackend.data.get(real6.dataId).values;
  const imagVals = cpuBackend.data.get(imag5.dataId).values;
  for (let i = 0;i < realVals.length; i++) {
    const real7 = realVals[i];
    const imag6 = imagVals[i];
    resultValues[i] = Math.hypot(real7, imag6);
  }
  return cpuBackend.makeOutput(resultValues, x.shape, "float32");
}, complexAbsConfig;
var init_ComplexAbs = __esm(() => {
  init_dist();
  complexAbsConfig = {
    kernelName: ComplexAbs,
    backendName: "cpu",
    kernelFunc: complexAbs
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Imag.js
function imag5(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const imag6 = backend3.data.get(input2.dataId).complexTensorInfos.imag;
  const imagVal = backend3.data.get(imag6.dataId).values;
  return backend3.makeTensorInfo(imag6.shape, imag6.dtype, imagVal);
}
var imagConfig;
var init_Imag = __esm(() => {
  init_dist();
  imagConfig = {
    kernelName: Imag,
    backendName: "cpu",
    kernelFunc: imag5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Concat.js
function concat14(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { axis } = attrs;
  const $axis = exports_util.parseAxisParam(axis, inputs[0].shape)[0];
  const shapes = inputs.map((t) => t.shape);
  exports_backend_util.assertParamsConsistent(shapes, $axis);
  let outShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), $axis);
  if (exports_util.sizeFromShape(outShape) === 0) {
    return backend3.makeTensorInfo(outShape, inputs[0].dtype, []);
  }
  const $inputs = inputs.filter((t) => exports_util.sizeFromShape(t.shape) > 0);
  if ($inputs.length === 1) {
    return identity2({ inputs: { x: $inputs[0] }, backend: backend3 });
  }
  if ($inputs[0].dtype === "complex64") {
    const reals = $inputs.map((t) => real5({ inputs: { input: t }, backend: backend3 }));
    const imags = $inputs.map((t) => imag5({ inputs: { input: t }, backend: backend3 }));
    const realConcated = concat14({ inputs: reals, backend: backend3, attrs: { axis: $axis } });
    const imagConcated = concat14({ inputs: imags, backend: backend3, attrs: { axis: $axis } });
    const result = complex8({ inputs: { real: realConcated, imag: imagConcated }, backend: backend3 });
    reals.forEach((r) => backend3.disposeIntermediateTensorInfo(r));
    imags.forEach((i) => backend3.disposeIntermediateTensorInfo(i));
    backend3.disposeIntermediateTensorInfo(realConcated);
    backend3.disposeIntermediateTensorInfo(imagConcated);
    return result;
  }
  const inputs2D = $inputs.map((t) => {
    const innerSize = exports_util.sizeFromShape(t.shape.slice($axis));
    const shape = [-1, innerSize];
    return reshape77({ inputs: { x: t }, backend: backend3, attrs: { shape } });
  });
  const inputsValShapes = inputs2D.map((t) => {
    return { vals: backend3.data.get(t.dataId).values, shape: t.shape };
  });
  outShape = exports_backend_util.computeOutShape(inputs2D.map((t) => t.shape), 1);
  const simplyConcat = inputs2D[0].shape[0] === 1;
  const outVals = concatImpl(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);
  const finalOutShape = exports_backend_util.computeOutShape($inputs.map((t) => t.shape), $axis);
  const outInfo = backend3.makeTensorInfo(finalOutShape, inputs[0].dtype, outVals);
  inputs2D.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return outInfo;
}
var concatConfig;
var init_Concat = __esm(() => {
  init_dist();
  init_Complex();
  init_Concat_impl();
  init_Identity();
  init_Imag();
  init_Real();
  init_Reshape();
  concatConfig = {
    kernelName: Concat,
    backendName: "cpu",
    kernelFunc: concat14
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2D.js
function conv2D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode } = attrs;
  assertNotComplex([x, filter], "conv2d");
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad9, dimRoundingMode, false, $dataFormat);
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const padLeft = convInfo.padInfo.left;
  const padTop = convInfo.padInfo.top;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const y = new TensorBuffer(convInfo.outShape, x.dtype);
  const xStrides = exports_util.computeStrides(x.shape);
  const filterStrides = exports_util.computeStrides(filter.shape);
  const xBatchStride = xStrides[0];
  const xRowStride = isChannelsLast ? xStrides[1] : xStrides[2];
  const xColStride = isChannelsLast ? xStrides[2] : 1;
  const xChannelStride = isChannelsLast ? 1 : xStrides[1];
  const yBatchStride = y.strides[0];
  const yRowStride = isChannelsLast ? y.strides[1] : y.strides[2];
  const yColStride = isChannelsLast ? y.strides[2] : 1;
  const yChannelStride = isChannelsLast ? 1 : y.strides[1];
  const xVals = backend3.data.get(x.dataId).values;
  const wVals = backend3.data.get(filter.dataId).values;
  const yVals = y.values;
  for (let b = 0;b < convInfo.batchSize; ++b) {
    const xOffset1 = b * xBatchStride;
    const yOffset1 = b * yBatchStride;
    for (let yR = 0;yR < convInfo.outHeight; ++yR) {
      const yOffset2 = yOffset1 + yR * yRowStride;
      const xRCorner = yR * convInfo.strideHeight - padTop;
      for (let wR = 0;wR < filterHeight; ++wR) {
        const xR = xRCorner + wR * dilationHeight;
        if (xR < 0 || xR >= convInfo.inHeight) {
          continue;
        }
        const wOffset1 = wR * filterStrides[0];
        const xOffset2 = xOffset1 + xR * xRowStride;
        for (let yC = 0;yC < convInfo.outWidth; ++yC) {
          const yOffset3 = yOffset2 + yC * yColStride;
          const xCCorner = yC * convInfo.strideWidth - padLeft;
          for (let wC = 0;wC < filterWidth; ++wC) {
            const xC = xCCorner + wC * dilationWidth;
            if (xC < 0 || xC >= convInfo.inWidth) {
              continue;
            }
            const wOffset2 = wOffset1 + wC * filterStrides[1];
            const xOffset3 = xOffset2 + xC * xColStride;
            let wOffset3 = wOffset2;
            for (let d1 = 0;d1 < convInfo.inChannels; ++d1) {
              const xVal = xVals[xOffset3 + d1 * xChannelStride];
              for (let d2 = 0;d2 < convInfo.outChannels; ++d2) {
                yVals[yOffset3 + d2 * yChannelStride] += xVal * wVals[wOffset3 + d2];
              }
              wOffset3 += convInfo.outChannels;
            }
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(y.shape, y.dtype, yVals);
}
var conv2DConfig;
var init_Conv2D = __esm(() => {
  init_dist();
  init_cpu_util();
  conv2DConfig = {
    kernelName: Conv2D,
    backendName: "cpu",
    kernelFunc: conv2D
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2DBackpropFilter.js
function conv2DBackpropFilter2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, pad: pad9, dataFormat, dimRoundingMode, filterShape } = attrs;
  assertNotComplex([x, dy2], "conv2dBackpropFilter");
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1, pad9, dimRoundingMode, false, $dataFormat);
  const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const dW = new TensorBuffer(convInfo.filterShape, "float32");
  const leftPad = convInfo.padInfo.left;
  const topPad = convInfo.padInfo.top;
  const xVals = backend3.data.get(x.dataId).values;
  const dyVals = backend3.data.get(dy2.dataId).values;
  const xBuf = new TensorBuffer(x.shape, x.dtype, xVals);
  const dyBuf = new TensorBuffer(dy2.shape, dy2.dtype, dyVals);
  for (let wR = 0;wR < filterHeight; ++wR) {
    const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
    const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
    for (let wC = 0;wC < filterWidth; ++wC) {
      const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
      const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
      for (let d1 = 0;d1 < convInfo.inChannels; ++d1) {
        for (let d2 = 0;d2 < convInfo.outChannels; ++d2) {
          let dotProd = 0;
          for (let b = 0;b < convInfo.batchSize; ++b) {
            for (let yR = yRMin;yR < yRMax; ++yR) {
              const xR = wR + yR * strideHeight - topPad;
              for (let yC = yCMin;yC < yCMax; ++yC) {
                const xC = wC + yC * strideWidth - leftPad;
                if (isChannelsLast) {
                  dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
                } else {
                  dotProd += xBuf.get(b, d1, xR, xC) * dyBuf.get(b, d2, yR, yC);
                }
              }
            }
          }
          dW.set(dotProd, wR, wC, d1, d2);
        }
      }
    }
  }
  return backend3.makeTensorInfo(dW.shape, dW.dtype, dW.values);
}
var conv2DBackpropFilterConfig;
var init_Conv2DBackpropFilter = __esm(() => {
  init_dist();
  init_cpu_util();
  conv2DBackpropFilterConfig = {
    kernelName: Conv2DBackpropFilter,
    backendName: "cpu",
    kernelFunc: conv2DBackpropFilter2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv2DBackpropInput.js
function conv2DBackpropInput2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { inputShape, strides, pad: pad9, dataFormat, dimRoundingMode } = attrs;
  assertNotComplex([dy2, filter], "conv2dBackpropInput");
  const filterStrides = exports_util.computeStrides(filter.shape);
  const dyStrides = exports_util.computeStrides(dy2.shape);
  let $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad9, dimRoundingMode, false, $dataFormat);
  const dx = new TensorBuffer(convInfo.inShape, "float32");
  const dxValues = dx.values;
  const dyValues = backend3.data.get(dy2.dataId).values;
  const fltValues = backend3.data.get(filter.dataId).values;
  const [fltS0, fltS1, fltS2] = filterStrides;
  const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
  $dataFormat = convInfo.dataFormat;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  const isChannelsLast = $dataFormat === "channelsLast";
  const xBatchStride = dx.strides[0];
  const xRowStride = isChannelsLast ? dx.strides[1] : dx.strides[2];
  const xColStride = isChannelsLast ? dx.strides[2] : 1;
  const xChannelStride = isChannelsLast ? 1 : dx.strides[1];
  const yBatchStride = dyStrides[0];
  const yRowStride = isChannelsLast ? dyStrides[1] : dyStrides[2];
  const yColStride = isChannelsLast ? dyStrides[2] : 1;
  const yChannelStride = isChannelsLast ? 1 : dyStrides[1];
  for (let b = 0;b < batchSize; ++b) {
    for (let d1 = 0;d1 < inChannels; ++d1) {
      for (let xR = 0;xR < inHeight; ++xR) {
        const xRCorner = xR - topPad;
        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
        for (let xC = 0;xC < inWidth; ++xC) {
          const xCCorner = xC - leftPad;
          const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
          const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
          let dotProd = 0;
          for (let yR = xRMin;yR < yRMax; ++yR) {
            const wR = yR * strideHeight - xRCorner;
            for (let yC = xCMin;yC < yCMax; ++yC) {
              const wC = yC * strideWidth - xCCorner;
              const dyOffset = yBatchStride * b + yRowStride * yR + yColStride * yC;
              const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
              for (let d2 = 0;d2 < outChannels; ++d2) {
                const pixel = dyValues[dyOffset + yChannelStride * d2];
                const weight = fltValues[fltOffset + d2];
                dotProd += pixel * weight;
              }
            }
          }
          const dxOffset = xBatchStride * b + xRowStride * xR + xColStride * xC + xChannelStride * d1;
          dxValues[dxOffset] = dotProd;
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var conv2DBackpropInputConfig;
var init_Conv2DBackpropInput = __esm(() => {
  init_dist();
  init_cpu_util();
  conv2DBackpropInputConfig = {
    kernelName: Conv2DBackpropInput,
    backendName: "cpu",
    kernelFunc: conv2DBackpropInput2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3D.js
function conv3D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  assertNotComplex([x, filter], "conv3d");
  const convInfo = exports_backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad9);
  const { filterDepth, filterHeight, filterWidth, dilationDepth, dilationHeight, dilationWidth, padInfo } = convInfo;
  const padFront = padInfo.front;
  const padLeft = padInfo.left;
  const padTop = padInfo.top;
  const y = new TensorBuffer(convInfo.outShape, x.dtype);
  const xVals = backend3.data.get(x.dataId).values;
  const wVals = backend3.data.get(filter.dataId).values;
  const yVals = y.values;
  const xStrides = exports_util.computeStrides(x.shape);
  const filterStrides = exports_util.computeStrides(filter.shape);
  for (let b = 0;b < convInfo.batchSize; ++b) {
    const xOffset1 = b * xStrides[0];
    const yOffset1 = b * y.strides[0];
    for (let yF = 0;yF < convInfo.outDepth; ++yF) {
      const yOffset2 = yOffset1 + yF * y.strides[1];
      const xFCorner = yF * convInfo.strideDepth - padFront;
      for (let wF = 0;wF < filterDepth; ++wF) {
        const xF = xFCorner + wF * dilationDepth;
        if (xF < 0 || xF >= convInfo.inDepth) {
          continue;
        }
        const wOffset1 = wF * filterStrides[0];
        const xOffset2 = xOffset1 + xF * xStrides[1];
        for (let yR = 0;yR < convInfo.outHeight; ++yR) {
          const yOffset3 = yOffset2 + yR * y.strides[2];
          const xRCorner = yR * convInfo.strideHeight - padTop;
          for (let wR = 0;wR < filterHeight; ++wR) {
            const xR = xRCorner + wR * dilationHeight;
            if (xR < 0 || xR >= convInfo.inHeight) {
              continue;
            }
            const wOffset2 = wOffset1 + wR * filterStrides[1];
            const xOffset3 = xOffset2 + xR * xStrides[2];
            for (let yC = 0;yC < convInfo.outWidth; ++yC) {
              const yOffset4 = yOffset3 + yC * convInfo.outChannels;
              const xCCorner = yC * convInfo.strideWidth - padLeft;
              for (let wC = 0;wC < filterWidth; ++wC) {
                const xC = xCCorner + wC * dilationWidth;
                if (xC < 0 || xC >= convInfo.inWidth) {
                  continue;
                }
                const wOffset3 = wOffset2 + wC * filterStrides[2];
                const xOffset4 = xOffset3 + xC * convInfo.inChannels;
                let wOffset4 = wOffset3;
                for (let d1 = 0;d1 < convInfo.inChannels; ++d1) {
                  const xVal = xVals[xOffset4 + d1];
                  for (let d2 = 0;d2 < convInfo.outChannels; ++d2) {
                    yVals[yOffset4 + d2] += xVal * wVals[wOffset4 + d2];
                  }
                  wOffset4 += convInfo.outChannels;
                }
              }
            }
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(y.shape, y.dtype, y.values);
}
var conv3DConfig;
var init_Conv3D = __esm(() => {
  init_dist();
  init_cpu_util();
  conv3DConfig = {
    kernelName: Conv3D,
    backendName: "cpu",
    kernelFunc: conv3D
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3DBackpropFilterV2.js
function conv3DBackpropFilterV2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, pad: pad9, filterShape } = attrs;
  assertNotComplex([x, dy2], "conv3dBackpropFilterV2");
  const xStrides = exports_util.computeStrides(x.shape);
  const dyStrides = exports_util.computeStrides(dy2.shape);
  const convInfo = exports_backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1, pad9);
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const filterDepth = convInfo.filterDepth;
  const filterHeight = convInfo.filterHeight;
  const filterWidth = convInfo.filterWidth;
  const dw2 = new TensorBuffer(convInfo.filterShape, "float32");
  const dwValues = dw2.values;
  const [dwS0, dwS1, dwS2, dwS3] = dw2.strides;
  const dyValues = backend3.data.get(dy2.dataId).values;
  const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
  const xValues = backend3.data.get(x.dataId).values;
  const [xS0, xS1, xS2, xS3] = xStrides;
  const frontPad = convInfo.padInfo.front;
  const leftPad = convInfo.padInfo.left;
  const topPad = convInfo.padInfo.top;
  for (let wF = 0;wF < filterDepth; ++wF) {
    const yFMin = Math.max(0, Math.ceil((frontPad - wF) / strideDepth));
    const yFMax = Math.min(convInfo.outDepth, (convInfo.inDepth + frontPad - wF) / strideDepth);
    const wOffset1 = wF * dwS0;
    for (let wR = 0;wR < filterHeight; ++wR) {
      const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
      const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
      const wOffset2 = wR * dwS1 + wOffset1;
      for (let wC = 0;wC < filterWidth; ++wC) {
        const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
        const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
        const wOffset3 = wC * dwS2 + wOffset2;
        for (let d1 = 0;d1 < convInfo.inChannels; ++d1) {
          const wOffset4 = d1 * dwS3 + wOffset3;
          for (let d2 = 0;d2 < convInfo.outChannels; ++d2) {
            let dotProd = 0;
            for (let b = 0;b < convInfo.batchSize; ++b) {
              const xOffset1 = b * xS0;
              const yOffset1 = b * dyS0;
              for (let yF = yFMin;yF < yFMax; ++yF) {
                const xF = wF + yF * strideDepth - frontPad;
                const xOffset2 = xF * xS1 + xOffset1;
                const yOffset2 = yF * dyS1 + yOffset1;
                for (let yR = yRMin;yR < yRMax; ++yR) {
                  const xR = wR + yR * strideHeight - topPad;
                  const xOffset3 = xR * xS2 + xOffset2;
                  const yOffset3 = yR * dyS2 + yOffset2;
                  for (let yC = yCMin;yC < yCMax; ++yC) {
                    const xC = wC + yC * strideWidth - leftPad;
                    const xOffset4 = xC * xS3 + xOffset3;
                    const yOffset4 = yC * dyS3 + yOffset3;
                    dotProd += xValues[xOffset4 + d1] * dyValues[yOffset4 + d2];
                  }
                }
              }
            }
            dwValues[wOffset4 + d2] = dotProd;
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(dw2.shape, dw2.dtype, dw2.values);
}
var conv3DBackpropFilterV2Config;
var init_Conv3DBackpropFilterV2 = __esm(() => {
  init_dist();
  init_cpu_util();
  conv3DBackpropFilterV2Config = {
    kernelName: Conv3DBackpropFilterV2,
    backendName: "cpu",
    kernelFunc: conv3DBackpropFilterV2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Conv3DBackpropInputV2.js
function conv3DBackpropInputV2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { pad: pad9, strides, inputShape } = attrs;
  assertNotComplex([dy2], "conv3dBackpropInputV2");
  const dyStrides = exports_util.computeStrides(dy2.shape);
  const filterStrides = exports_util.computeStrides(filter.shape);
  const convInfo = exports_backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad9);
  const dx = new TensorBuffer(convInfo.inShape, "float32");
  const dxValues = dx.values;
  const [dxS0, dxS1, dxS2, dxS3] = dx.strides;
  const dyValues = backend3.data.get(dy2.dataId).values;
  const [dyS0, dyS1, dyS2, dyS3] = dyStrides;
  const fltValues = backend3.data.get(filter.dataId).values;
  const [fltS0, fltS1, fltS2, fltS3] = filterStrides;
  const { batchSize, filterDepth, filterHeight, filterWidth, inChannels, inDepth, inHeight, inWidth, outChannels, outDepth, outHeight, outWidth, strideDepth, strideHeight, strideWidth } = convInfo;
  const frontPad = filterDepth - 1 - convInfo.padInfo.front;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  for (let b = 0;b < batchSize; ++b) {
    for (let d1 = 0;d1 < inChannels; ++d1) {
      for (let xF = 0;xF < inDepth; ++xF) {
        const xFCorner = xF - frontPad;
        const xFMin = Math.max(0, Math.ceil(xFCorner / strideDepth));
        const yFMax = Math.min(outDepth, (filterDepth + xFCorner) / strideDepth);
        for (let xR = 0;xR < inHeight; ++xR) {
          const xRCorner = xR - topPad;
          const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
          const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
          for (let xC = 0;xC < inWidth; ++xC) {
            const xCCorner = xC - leftPad;
            const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
            const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
            let dotProd = 0;
            for (let yF = xFMin;yF < yFMax; ++yF) {
              const wF = yF * strideDepth - xFCorner;
              for (let yR = xRMin;yR < yRMax; ++yR) {
                const wR = yR * strideHeight - xRCorner;
                for (let yC = xCMin;yC < yCMax; ++yC) {
                  const wC = yC * strideWidth - xCCorner;
                  const dyOffset = dyS0 * b + dyS1 * yF + dyS2 * yR + dyS3 * yC;
                  const fltOffset = fltS0 * (filterDepth - 1 - wF) + fltS1 * (filterHeight - 1 - wR) + fltS2 * (filterWidth - 1 - wC) + fltS3 * d1;
                  for (let d2 = 0;d2 < outChannels; ++d2) {
                    const pixel = dyValues[dyOffset + d2];
                    const weight = fltValues[fltOffset + d2];
                    dotProd += pixel * weight;
                  }
                }
              }
            }
            dxValues[dxS0 * b + dxS1 * xF + dxS2 * xR + dxS3 * xC + d1] = dotProd;
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var conv3DBackpropInputV2Config;
var init_Conv3DBackpropInputV2 = __esm(() => {
  init_dist();
  init_cpu_util();
  conv3DBackpropInputV2Config = {
    kernelName: Conv3DBackpropInputV2,
    backendName: "cpu",
    kernelFunc: conv3DBackpropInputV2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cos.js
var cos5, cosConfig;
var init_Cos = __esm(() => {
  init_dist();
  init_unary_utils();
  cos5 = unaryKernelFunc(Cos, (xi) => Math.cos(xi));
  cosConfig = {
    kernelName: Cos,
    backendName: "cpu",
    kernelFunc: cos5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cosh.js
var cosh4, coshConfig;
var init_Cosh = __esm(() => {
  init_dist();
  init_unary_utils();
  cosh4 = unaryKernelFunc(Cosh, (xi) => Math.cosh(xi));
  coshConfig = {
    kernelName: Cosh,
    backendName: "cpu",
    kernelFunc: cosh4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/CropAndResize.js
function cropAndResize3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2, boxes, boxInd } = inputs;
  const { cropSize, method, extrapolationValue } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
  const numBoxes = boxes.shape[0];
  const [cropHeight, cropWidth] = cropSize;
  const output = buffer([numBoxes, cropHeight, cropWidth, numChannels], "float32");
  const boxVals = backend3.data.get(boxes.dataId).values;
  const boxIndVals = backend3.data.get(boxInd.dataId).values;
  const imageVals = backend3.data.get(image2.dataId).values;
  const inStride = exports_util.computeStrides(image2.shape);
  const outStride = exports_util.computeStrides(output.shape);
  for (let b = 0;b < numBoxes; b++) {
    const startInd = b * 4;
    const y1 = boxVals[startInd];
    const x1 = boxVals[startInd + 1];
    const y22 = boxVals[startInd + 2];
    const x2 = boxVals[startInd + 3];
    const bInd = boxIndVals[b];
    if (bInd >= batch) {
      continue;
    }
    const heightScale = cropHeight > 1 ? (y22 - y1) * (imageHeight - 1) / (cropHeight - 1) : 0;
    const widthScale = cropWidth > 1 ? (x2 - x1) * (imageWidth - 1) / (cropWidth - 1) : 0;
    for (let y = 0;y < cropHeight; y++) {
      const yInd = cropHeight > 1 ? y1 * (imageHeight - 1) + y * heightScale : 0.5 * (y1 + y22) * (imageHeight - 1);
      if (yInd < 0 || yInd > imageHeight - 1) {
        for (let x = 0;x < cropWidth; x++) {
          for (let c = 0;c < numChannels; c++) {
            const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
            output.values[ind] = extrapolationValue;
          }
        }
        continue;
      }
      if (method === "bilinear") {
        const topInd = Math.floor(yInd);
        const bottomInd = Math.ceil(yInd);
        const yLerp = yInd - topInd;
        for (let x = 0;x < cropWidth; x++) {
          const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
          if (xInd < 0 || xInd > imageWidth - 1) {
            for (let c = 0;c < numChannels; c++) {
              const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
              output.values[ind] = extrapolationValue;
            }
            continue;
          }
          const leftInd = Math.floor(xInd);
          const rightInd = Math.ceil(xInd);
          const xLerp = xInd - leftInd;
          for (let c = 0;c < numChannels; c++) {
            let ind = c + leftInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
            const topLeft = imageVals[ind];
            ind = c + rightInd * inStride[2] + topInd * inStride[1] + bInd * inStride[0];
            const topRight = imageVals[ind];
            ind = c + leftInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
            const bottomLeft = imageVals[ind];
            ind = c + rightInd * inStride[2] + bottomInd * inStride[1] + bInd * inStride[0];
            const bottomRight = imageVals[ind];
            const top = topLeft + (topRight - topLeft) * xLerp;
            const bottom = bottomLeft + (bottomRight - bottomLeft) * xLerp;
            ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
            output.values[ind] = top + (bottom - top) * yLerp;
          }
        }
      } else {
        for (let x = 0;x < cropWidth; ++x) {
          const xInd = cropWidth > 1 ? x1 * (imageWidth - 1) + x * widthScale : 0.5 * (x1 + x2) * (imageWidth - 1);
          if (xInd < 0 || xInd > imageWidth - 1) {
            for (let c = 0;c < numChannels; c++) {
              const ind = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
              output.values[ind] = extrapolationValue;
            }
            continue;
          }
          const closestX = Math.round(xInd);
          const closestY = Math.round(yInd);
          for (let c = 0;c < numChannels; c++) {
            const inInd = c + closestX * inStride[2] + closestY * inStride[1] + bInd * inStride[0];
            const outInd = c + x * outStride[2] + y * outStride[1] + b * outStride[0];
            output.values[outInd] = imageVals[inInd];
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(output.shape, output.dtype, output.values);
}
var cropAndResizeConfig;
var init_CropAndResize = __esm(() => {
  init_dist();
  cropAndResizeConfig = {
    kernelName: CropAndResize,
    backendName: "cpu",
    kernelFunc: cropAndResize3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cumprod.js
function cumprod5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, exclusive, reverse: reverse10 } = attrs;
  assertNotComplex(x, "cumprod");
  const permutation = exports_backend_util.getAxesPermutation([axis], x.shape.length);
  let $x = x;
  if (permutation != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
  }
  const permutedAxis = exports_backend_util.getInnerMostAxes(1, x.shape.length)[0];
  if (permutedAxis !== $x.shape.length - 1) {
    throw new Error(`backend.cumprod in CPU expects an inner-most ` + `axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);
  }
  const resultDtype = upcastType($x.dtype, "int32");
  const vals = exports_util.makeOnesTypedArray(exports_util.sizeFromShape($x.shape), resultDtype);
  const aVals = backend3.data.get($x.dataId).values;
  const finalDim = $x.shape[$x.shape.length - 1];
  const indexAdjuster = reverse10 ? (i, j) => i + finalDim - j - 1 : (i, j) => i + j;
  for (let i = 0;i < aVals.length; i += finalDim) {
    for (let j = 0;j < finalDim; j++) {
      const idx = indexAdjuster(i, j);
      if (j === 0) {
        vals[idx] = exclusive ? 1 : aVals[idx];
      } else {
        const prevIdx = indexAdjuster(i, j - 1);
        vals[idx] = exclusive ? aVals[prevIdx] * vals[prevIdx] : aVals[idx] * vals[prevIdx];
      }
    }
  }
  const result = backend3.makeTensorInfo($x.shape, resultDtype, vals);
  if (permutation != null) {
    const reversePermutation = exports_backend_util.getUndoAxesPermutation(permutation);
    const reverseTransposedResult = transpose11({ inputs: { x: result }, backend: backend3, attrs: { perm: reversePermutation } });
    backend3.disposeIntermediateTensorInfo(result);
    backend3.disposeIntermediateTensorInfo($x);
    return reverseTransposedResult;
  }
  return result;
}
var cumprodConfig;
var init_Cumprod = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Transpose();
  cumprodConfig = {
    kernelName: Cumprod,
    backendName: "cpu",
    kernelFunc: cumprod5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Cumsum.js
function cumsum5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, exclusive, reverse: reverse10 } = attrs;
  assertNotComplex(x, "cumsum");
  const permutation = exports_backend_util.getAxesPermutation([axis], x.shape.length);
  let $x = x;
  if (permutation != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
  }
  const permutedAxis = exports_backend_util.getInnerMostAxes(1, x.shape.length)[0];
  if (permutedAxis !== $x.shape.length - 1) {
    throw new Error(`backend.cumsum in CPU expects an inner-most ` + `axis=${$x.shape.length - 1} but got axis=${permutedAxis}`);
  }
  const resultDtype = upcastType($x.dtype, "int32");
  const vals = exports_util.makeZerosTypedArray(exports_util.sizeFromShape($x.shape), resultDtype);
  const aVals = backend3.data.get($x.dataId).values;
  const finalDim = $x.shape[$x.shape.length - 1];
  const indexAdjuster = reverse10 ? (i, j) => i + finalDim - j - 1 : (i, j) => i + j;
  for (let i = 0;i < aVals.length; i += finalDim) {
    for (let j = 0;j < finalDim; j++) {
      const idx = indexAdjuster(i, j);
      if (j === 0) {
        vals[idx] = exclusive ? 0 : aVals[idx];
      } else {
        const prevIdx = indexAdjuster(i, j - 1);
        vals[idx] = exclusive ? aVals[prevIdx] + vals[prevIdx] : aVals[idx] + vals[prevIdx];
      }
    }
  }
  const result = backend3.makeTensorInfo($x.shape, resultDtype, vals);
  if (permutation != null) {
    const reversePermutation = exports_backend_util.getUndoAxesPermutation(permutation);
    const reverseTransposedResult = transpose11({ inputs: { x: result }, backend: backend3, attrs: { perm: reversePermutation } });
    backend3.disposeIntermediateTensorInfo(result);
    backend3.disposeIntermediateTensorInfo($x);
    return reverseTransposedResult;
  }
  return result;
}
var cumsumConfig;
var init_Cumsum = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Transpose();
  cumsumConfig = {
    kernelName: Cumsum,
    backendName: "cpu",
    kernelFunc: cumsum5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DenseBincount.js
function denseBincount2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, weights } = inputs;
  const { size, binaryOutput } = attrs;
  if (x.shape.length === 1) {
    const xVals = backend3.data.get(x.dataId).values;
    const weightsVals = backend3.data.get(weights.dataId).values;
    const outVals = bincountImpl(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend3.makeTensorInfo([size], weights.dtype, outVals);
  } else if (x.shape.length === 2) {
    const xBuf = backend3.bufferSync(x);
    const weightsBuf = backend3.bufferSync(weights);
    const outBuf = bincountReduceImpl(xBuf, weightsBuf, size, binaryOutput);
    return backend3.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank` + `${x.shape.length}.`);
}
var denseBincountConfig;
var init_DenseBincount = __esm(() => {
  init_dist();
  init_Bincount_impl();
  denseBincountConfig = {
    kernelName: DenseBincount,
    backendName: "cpu",
    kernelFunc: denseBincount2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthToSpace.js
function depthToSpace2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockSize, dataFormat } = attrs;
  exports_util.assert(dataFormat === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${dataFormat}`);
  const batchSize = x.shape[0];
  const inputHeight = x.shape[1];
  const inputWidth = x.shape[2];
  const inputDepth = x.shape[3];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const xValues = backend3.data.get(x.dataId).values;
  const result = new Float32Array(batchSize * outputHeight * outputWidth * outputDepth);
  let outputIdx = 0;
  for (let b = 0;b < batchSize; ++b) {
    for (let h = 0;h < outputHeight; ++h) {
      const inH = Math.floor(h / blockSize);
      const offsetH = h % blockSize;
      for (let w = 0;w < outputWidth; ++w) {
        const inW = Math.floor(w / blockSize);
        const offsetW = w % blockSize;
        const offsetD = (offsetH * blockSize + offsetW) * outputDepth;
        for (let d = 0;d < outputDepth; ++d) {
          const inD = d + offsetD;
          const inputIdx = inD + inputDepth * (inW + inputWidth * (inH + inputHeight * b));
          result[outputIdx++] = xValues[inputIdx];
        }
      }
    }
  }
  return backend3.makeTensorInfo([batchSize, outputHeight, outputWidth, outputDepth], x.dtype, result);
}
var depthToSpaceConfig;
var init_DepthToSpace = __esm(() => {
  init_dist();
  depthToSpaceConfig = {
    kernelName: DepthToSpace,
    backendName: "cpu",
    kernelFunc: depthToSpace2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNative.js
function depthwiseConv2dNative(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations, dimRoundingMode } = attrs;
  assertNotComplex([x, filter], "depthwiseConv2DNative");
  const xStrides = exports_util.computeStrides(x.shape);
  const filterStrides = exports_util.computeStrides(filter.shape);
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => "Error in depthwiseConv2d: Either strides or dilations must be " + `1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad9, dimRoundingMode, true);
  const { filterHeight, filterWidth, dilationHeight, dilationWidth, padInfo } = convInfo;
  const padLeft = padInfo.left;
  const padTop = padInfo.top;
  const chMul = convInfo.outChannels / convInfo.inChannels;
  const y = new TensorBuffer(convInfo.outShape, x.dtype);
  const xVals = backend3.data.get(x.dataId).values;
  const wVals = backend3.data.get(filter.dataId).values;
  const yVals = y.values;
  for (let b = 0;b < convInfo.batchSize; ++b) {
    const xOffset1 = b * xStrides[0];
    const yOffset1 = b * y.strides[0];
    for (let yR = 0;yR < convInfo.outHeight; ++yR) {
      const yOffset2 = yOffset1 + yR * y.strides[1];
      const xRCorner = yR * convInfo.strideHeight - padTop;
      for (let wR = 0;wR < filterHeight; ++wR) {
        const xR = xRCorner + wR * dilationHeight;
        if (xR < 0 || xR >= convInfo.inHeight) {
          continue;
        }
        const wOffset1 = wR * filterStrides[0];
        const xOffset2 = xOffset1 + xR * xStrides[1];
        for (let yC = 0;yC < convInfo.outWidth; ++yC) {
          const yOffset3 = yOffset2 + yC * y.strides[2];
          const xCCorner = yC * convInfo.strideWidth - padLeft;
          for (let wC = 0;wC < filterWidth; ++wC) {
            const xC = xCCorner + wC * dilationWidth;
            if (xC < 0 || xC >= convInfo.inWidth) {
              continue;
            }
            const wOffset2 = wOffset1 + wC * filterStrides[1];
            const xOffset3 = xOffset2 + xC * convInfo.inChannels;
            let yOffset4 = yOffset3;
            let wOffset3 = wOffset2;
            for (let d1 = 0;d1 < convInfo.inChannels; ++d1) {
              const xVal = xVals[xOffset3 + d1];
              for (let q = 0;q < chMul; ++q) {
                yVals[yOffset4 + q] += xVal * wVals[wOffset3 + q];
              }
              yOffset4 += chMul;
              wOffset3 += chMul;
            }
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(y.shape, y.dtype, y.values);
}
var depthwiseConv2dNativeConfig;
var init_DepthwiseConv2dNative = __esm(() => {
  init_dist();
  init_cpu_util();
  depthwiseConv2dNativeConfig = {
    kernelName: DepthwiseConv2dNative,
    backendName: "cpu",
    kernelFunc: depthwiseConv2dNative
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
function depthwiseConv2dNativeBackpropFilter2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, dilations, pad: pad9, dimRoundingMode, filterShape } = attrs;
  assertNotComplex([x, dy2], "depthwiseConv2dNativeBackpropFilter");
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad9, dimRoundingMode, true);
  const { strideHeight, strideWidth, filterHeight, filterWidth } = convInfo;
  const dW = new TensorBuffer(convInfo.filterShape, "float32");
  const leftPad = convInfo.padInfo.left;
  const topPad = convInfo.padInfo.top;
  const chMul = convInfo.outChannels / convInfo.inChannels;
  const xVals = backend3.data.get(x.dataId).values;
  const xBuf = new TensorBuffer(x.shape, x.dtype, xVals);
  const dyVals = backend3.data.get(dy2.dataId).values;
  const dyBuf = new TensorBuffer(dy2.shape, dy2.dtype, dyVals);
  for (let wR = 0;wR < filterHeight; ++wR) {
    const yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
    const yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
    for (let wC = 0;wC < filterWidth; ++wC) {
      const yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
      const yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
      for (let d2 = 0;d2 < convInfo.outChannels; ++d2) {
        const d1 = Math.trunc(d2 / chMul);
        const dm2 = d2 % chMul;
        let dotProd = 0;
        for (let b = 0;b < convInfo.batchSize; ++b) {
          for (let yR = yRMin;yR < yRMax; ++yR) {
            const xR = wR + yR * strideHeight - topPad;
            for (let yC = yCMin;yC < yCMax; ++yC) {
              const xC = wC + yC * strideWidth - leftPad;
              dotProd += xBuf.get(b, xR, xC, d1) * dyBuf.get(b, yR, yC, d2);
            }
          }
        }
        dW.set(dotProd, wR, wC, d1, dm2);
      }
    }
  }
  return backend3.makeTensorInfo(dW.shape, dW.dtype, dW.values);
}
var depthwiseConv2dNativeBackpropFilterConfig;
var init_DepthwiseConv2dNativeBackpropFilter = __esm(() => {
  init_dist();
  init_cpu_util();
  depthwiseConv2dNativeBackpropFilterConfig = {
    kernelName: DepthwiseConv2dNativeBackpropFilter,
    backendName: "cpu",
    kernelFunc: depthwiseConv2dNativeBackpropFilter2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
function depthwiseConv2dNativeBackpropInput2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { strides, dilations, pad: pad9, dimRoundingMode, inputShape } = attrs;
  assertNotComplex([dy2, filter], "depthwiseConv2DNativeBackpropInput");
  const dyStrides = exports_util.computeStrides(dy2.shape);
  const filterStrides = exports_util.computeStrides(filter.shape);
  const convInfo = exports_backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad9, dimRoundingMode, true);
  const dx = new TensorBuffer(convInfo.inShape, "float32");
  const dxValues = dx.values;
  const [dxS0, dxS1, dxS2] = dx.strides;
  const dyValues = backend3.data.get(dy2.dataId).values;
  const [dyS0, dyS1, dyS2] = dyStrides;
  const fltValues = backend3.data.get(filter.dataId).values;
  const [fltS0, fltS1, fltS2] = filterStrides;
  const { batchSize, filterHeight, filterWidth, inChannels, inHeight, inWidth, outChannels, outHeight, outWidth, strideHeight, strideWidth } = convInfo;
  const topPad = filterHeight - 1 - convInfo.padInfo.top;
  const leftPad = filterWidth - 1 - convInfo.padInfo.left;
  const chMul = outChannels / inChannels;
  for (let b = 0;b < batchSize; ++b) {
    for (let d1 = 0;d1 < inChannels; ++d1) {
      for (let xR = 0;xR < inHeight; ++xR) {
        const xRCorner = xR - topPad;
        const xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
        const yRMax = Math.min(outHeight, (filterHeight + xRCorner) / strideHeight);
        for (let xC = 0;xC < inWidth; ++xC) {
          const xCCorner = xC - leftPad;
          const xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
          const yCMax = Math.min(outWidth, (filterWidth + xCCorner) / strideWidth);
          let dotProd = 0;
          for (let yR = xRMin;yR < yRMax; ++yR) {
            const wR = yR * strideHeight - xRCorner;
            for (let yC = xCMin;yC < yCMax; ++yC) {
              const wC = yC * strideWidth - xCCorner;
              const dyOffset = dyS0 * b + dyS1 * yR + dyS2 * yC;
              const fltOffset = fltS0 * (filterHeight - 1 - wR) + fltS1 * (filterWidth - 1 - wC) + fltS2 * d1;
              for (let dm2 = 0;dm2 < chMul; ++dm2) {
                const d2 = d1 * chMul + dm2;
                const pixel = dyValues[dyOffset + d2];
                const weight = fltValues[fltOffset + dm2];
                dotProd += pixel * weight;
              }
            }
          }
          dxValues[dxS0 * b + dxS1 * xR + dxS2 * xC + d1] = dotProd;
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var depthwiseConv2dNativeBackpropInputConfig;
var init_DepthwiseConv2dNativeBackpropInput = __esm(() => {
  init_dist();
  init_cpu_util();
  depthwiseConv2dNativeBackpropInputConfig = {
    kernelName: DepthwiseConv2dNativeBackpropInput,
    backendName: "cpu",
    kernelFunc: depthwiseConv2dNativeBackpropInput2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Diag.js
function diag2(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  const xSize = exports_util.sizeFromShape(x.shape);
  const xVals = backend3.data.get(x.dataId).values;
  const outBuf = buffer([xSize, xSize], x.dtype);
  const vals = outBuf.values;
  for (let i = 0;i < xVals.length; i++) {
    vals[i * xSize + i] = xVals[i];
  }
  const outShape = [...x.shape, ...x.shape];
  return backend3.makeTensorInfo(outShape, outBuf.dtype, outBuf.values);
}
var diagConfig;
var init_Diag = __esm(() => {
  init_dist();
  diagConfig = {
    kernelName: Diag,
    backendName: "cpu",
    kernelFunc: diag2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2D.js
var dilation2DConfig;
var init_Dilation2D = __esm(() => {
  init_dist();
  dilation2DConfig = {
    kernelName: Dilation2D,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend3, attrs }) => {
      const { x, filter } = inputs;
      const { strides, pad: pad9, dilations } = attrs;
      const cpuBackend = backend3;
      const xVals = cpuBackend.data.get(x.dataId).values;
      const xRank = x.shape.length;
      const filterVals = cpuBackend.data.get(filter.dataId).values;
      const filterRank = filter.shape.length;
      const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
      const outSize = exports_util.sizeFromShape(outShape);
      const outRank = outShape.length;
      const outputVals = exports_util.getArrayFromDType(x.dtype, outSize);
      for (let b = 0;b < batchSize; ++b) {
        for (let hOut = 0;hOut < outHeight; ++hOut) {
          const hBeg = hOut * strideHeight - padInfo.top;
          for (let wOut = 0;wOut < outWidth; ++wOut) {
            const wBeg = wOut * strideWidth - padInfo.left;
            for (let d = 0;d < inChannels; ++d) {
              let curVal = Number.MIN_SAFE_INTEGER;
              for (let h = 0;h < filterHeight; ++h) {
                const hIn = hBeg + h * dilationHeight;
                if (hIn >= 0 && hIn < inHeight) {
                  for (let w = 0;w < filterWidth; ++w) {
                    const wIn = wBeg + w * dilationWidth;
                    if (wIn >= 0 && wIn < inWidth) {
                      const xIndex = exports_util.locToIndex([b, hIn, wIn, d], xRank, exports_util.computeStrides(x.shape));
                      const filterIndex = exports_util.locToIndex([h, w, d], filterRank, exports_util.computeStrides(filter.shape));
                      const val = xVals[xIndex] + filterVals[filterIndex];
                      if (val > curVal) {
                        curVal = val;
                      }
                    }
                  }
                }
              }
              const outputIndex = exports_util.locToIndex([b, hOut, wOut, d], outRank, exports_util.computeStrides(outShape));
              outputVals[outputIndex] = curVal;
            }
          }
        }
      }
      const dataId = cpuBackend.write(exports_util.toTypedArray(outputVals, x.dtype), outShape, x.dtype);
      return { dataId, shape: outShape, dtype: x.dtype };
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2DBackpropFilter.js
var dilation2DBackpropFilterConfig;
var init_Dilation2DBackpropFilter = __esm(() => {
  init_dist();
  dilation2DBackpropFilterConfig = {
    kernelName: Dilation2DBackpropFilter,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend3, attrs }) => {
      const { x, filter, dy: dy2 } = inputs;
      const { strides, pad: pad9, dilations } = attrs;
      const cpuBackend = backend3;
      const $x = exports_util.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);
      const $filter = exports_util.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);
      const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
      exports_util.assert(dy2.rank === outShape.length, () => `Error in ${Dilation2DBackpropFilter}, dy ` + `must have the same rank as output ${outShape.length}, but got ` + `${dy2.rank}`);
      const $dy = exports_util.toNestedArray(outShape, cpuBackend.data.get(dy2.dataId).values);
      const gradients8 = exports_util.makeZerosNestedTypedArray(filter.shape, filter.dtype);
      for (let b = 0;b < batchSize; ++b) {
        for (let hOut = 0;hOut < outHeight; ++hOut) {
          const hBeg = hOut * strideHeight - padInfo.top;
          for (let wOut = 0;wOut < outWidth; ++wOut) {
            const wBeg = wOut * strideWidth - padInfo.left;
            for (let d = 0;d < inChannels; ++d) {
              let curVal = Number.MIN_SAFE_INTEGER;
              let hMax = 0;
              let wMax = 0;
              for (let h = 0;h < filterHeight; ++h) {
                const hIn = hBeg + h * dilationHeight;
                if (hIn >= 0 && hIn < inHeight) {
                  for (let w = 0;w < filterWidth; ++w) {
                    const wIn = wBeg + w * dilationWidth;
                    if (wIn >= 0 && wIn < inWidth) {
                      const val = $x[b][hIn][wIn][d] + $filter[h][w][d];
                      if (val > curVal) {
                        curVal = val;
                        hMax = h;
                        wMax = w;
                      }
                    }
                  }
                }
              }
              gradients8[hMax][wMax][d] += $dy[b][hOut][wOut][d];
            }
          }
        }
      }
      const dataId = cpuBackend.write(exports_util.toTypedArray(gradients8, x.dtype), filter.shape, filter.dtype);
      return { dataId, shape: filter.shape, dtype: filter.dtype };
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Dilation2DBackpropInput.js
var dilation2DBackpropInputConfig;
var init_Dilation2DBackpropInput = __esm(() => {
  init_dist();
  dilation2DBackpropInputConfig = {
    kernelName: Dilation2DBackpropInput,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend3, attrs }) => {
      const { x, filter, dy: dy2 } = inputs;
      const { strides, pad: pad9, dilations } = attrs;
      const cpuBackend = backend3;
      const $x = exports_util.toNestedArray(x.shape, cpuBackend.data.get(x.dataId).values);
      const $filter = exports_util.toNestedArray(filter.shape, cpuBackend.data.get(filter.dataId).values);
      const { batchSize, inHeight, inWidth, inChannels, outHeight, outWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth, outShape } = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
      exports_util.assert(dy2.rank === outShape.length, () => `Error in ${Dilation2DBackpropInput}, dy ` + `must have the same rank as output ${outShape.length}, but got ` + `${dy2.rank}`);
      const $dy = exports_util.toNestedArray(outShape, cpuBackend.data.get(dy2.dataId).values);
      const gradients8 = exports_util.makeZerosNestedTypedArray(x.shape, x.dtype);
      for (let b = 0;b < batchSize; ++b) {
        for (let hOut = 0;hOut < outHeight; ++hOut) {
          const hBeg = hOut * strideHeight - padInfo.top;
          for (let wOut = 0;wOut < outWidth; ++wOut) {
            const wBeg = wOut * strideWidth - padInfo.left;
            for (let d = 0;d < inChannels; ++d) {
              let curVal = Number.MIN_SAFE_INTEGER;
              let hInMax = hBeg < 0 ? 0 : hBeg;
              let wInMax = wBeg < 0 ? 0 : wBeg;
              for (let h = 0;h < filterHeight; ++h) {
                const hIn = hBeg + h * dilationHeight;
                if (hIn >= 0 && hIn < inHeight) {
                  for (let w = 0;w < filterWidth; ++w) {
                    const wIn = wBeg + w * dilationWidth;
                    if (wIn >= 0 && wIn < inWidth) {
                      const val = $x[b][hIn][wIn][d] + $filter[h][w][d];
                      if (val > curVal) {
                        curVal = val;
                        hInMax = hIn;
                        wInMax = wIn;
                      }
                    }
                  }
                }
              }
              gradients8[b][hInMax][wInMax][d] += $dy[b][hOut][wOut][d];
            }
          }
        }
      }
      const dataId = cpuBackend.write(exports_util.toTypedArray(gradients8, x.dtype), x.shape, x.dtype);
      return { dataId, shape: x.shape, dtype: x.dtype };
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Draw.js
function draw2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2 } = inputs;
  const { canvas, options } = attrs;
  const { contextOptions, imageOptions } = options || {};
  const alpha = (imageOptions === null || imageOptions === undefined ? undefined : imageOptions.alpha) || 1;
  const contextType = (contextOptions === null || contextOptions === undefined ? undefined : contextOptions.contextType) || "2d";
  if (contextType !== "2d") {
    throw new Error(`Context type ${contextOptions.contextType} is not supported by the CPU backend.`);
  }
  const ctx = canvas.getContext(contextType, (contextOptions === null || contextOptions === undefined ? undefined : contextOptions.contextAttributes) || {});
  if (ctx == null) {
    throw new Error(`Could not get the context with ${contextType} type.`);
  }
  const [height, width] = image2.shape.slice(0, 2);
  const depth = image2.shape.length === 2 ? 1 : image2.shape[2];
  const data = backend3.data.get(image2.dataId).values;
  const multiplier = image2.dtype === "float32" ? 255 : 1;
  const bytes = new Uint8ClampedArray(width * height * 4);
  for (let i = 0;i < height * width; ++i) {
    const rgba = [0, 0, 0, 255 * alpha];
    for (let d = 0;d < depth; d++) {
      const value = data[i * depth + d];
      if (image2.dtype === "float32") {
        if (value < 0 || value > 1) {
          throw new Error(`Tensor values for a float32 Tensor must be in the ` + `range [0 - 1] but encountered ${value}.`);
        }
      } else if (image2.dtype === "int32") {
        if (value < 0 || value > 255) {
          throw new Error(`Tensor values for a int32 Tensor must be in the ` + `range [0 - 255] but encountered ${value}.`);
        }
      }
      if (depth === 1) {
        rgba[0] = value * multiplier;
        rgba[1] = value * multiplier;
        rgba[2] = value * multiplier;
      } else {
        rgba[d] = value * multiplier;
      }
    }
    const j = i * 4;
    bytes[j + 0] = Math.round(rgba[0]);
    bytes[j + 1] = Math.round(rgba[1]);
    bytes[j + 2] = Math.round(rgba[2]);
    bytes[j + 3] = Math.round(rgba[3]);
  }
  canvas.width = width;
  canvas.height = height;
  const imageData = new ImageData(bytes, width, height);
  ctx.putImageData(imageData, 0, 0);
  return image2;
}
var drawConfig;
var init_Draw = __esm(() => {
  init_dist();
  drawConfig = {
    kernelName: Draw,
    backendName: "cpu",
    kernelFunc: draw2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sum.js
function sum27(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x, "sum");
  let $x;
  if (x.dtype === "bool") {
    $x = cast46({ inputs: { x }, backend: backend3, attrs: { dtype: "int32" } });
  } else {
    $x = identity2({ inputs: { x }, backend: backend3 });
  }
  const xRank = $x.shape.length;
  const axes = exports_util.parseAxisParam(axis, $x.shape);
  const permutation = exports_backend_util.getAxesPermutation(axes, xRank);
  let reductionAxes = axes;
  let permutedX = $x;
  if (permutation != null) {
    permutedX = transpose11({ inputs: { x: $x }, backend: backend3, attrs: { perm: permutation } });
    reductionAxes = exports_backend_util.getInnerMostAxes(reductionAxes.length, xRank);
  }
  exports_backend_util.assertAxesAreInnerMostDims("sum", reductionAxes, permutedX.shape.length);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(permutedX.shape, reductionAxes);
  const resultDtype = exports_backend_util.upcastType(permutedX.dtype, "int32");
  let result = zeros7(backend3, outShape, resultDtype);
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const vals = backend3.data.get(result.dataId).values;
  const aVals = backend3.data.get(permutedX.dataId).values;
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let sum28 = 0;
    for (let j = 0;j < reduceSize; ++j) {
      sum28 += aVals[offset + j];
    }
    vals[i] = sum28;
  }
  if (keepDims) {
    const newShape = exports_backend_util.expandShapeToKeepDim(result.shape, axes);
    const oldResult = result;
    result = reshape77({ inputs: { x: result }, backend: backend3, attrs: { shape: newShape } });
    backend3.disposeIntermediateTensorInfo(oldResult);
  }
  backend3.disposeIntermediateTensorInfo($x);
  if (permutation != null) {
    backend3.disposeIntermediateTensorInfo(permutedX);
  }
  return result;
}
var sumConfig;
var init_Sum = __esm(() => {
  init_dist();
  init_cpu_util();
  init_zeros_impl();
  init_Cast();
  init_Identity();
  init_Reshape();
  init_Transpose();
  sumConfig = {
    kernelName: Sum,
    backendName: "cpu",
    kernelFunc: sum27
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Einsum.js
function einsum3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { equation } = attrs;
  const tensors = inputs;
  const { allDims, summedDims, idDims } = exports_backend_util.decodeEinsumEquation(equation, tensors.length);
  exports_backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);
  const { path, steps } = exports_backend_util.getEinsumComputePath(summedDims, idDims);
  const nSteps = steps.length;
  let out = null;
  let numDimsRemaining = allDims.length;
  const tensorsToDispose = [];
  for (let i = 0;i < nSteps; ++i) {
    for (const idTerm of steps[i]) {
      const { permutationIndices: perm, expandDims: dimsToExpand } = exports_backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
      let x;
      if (exports_backend_util.isIdentityPermutation(perm)) {
        x = tensors[idTerm];
      } else {
        x = transpose11({ inputs: { x: tensors[idTerm] }, backend: backend3, attrs: { perm } });
        tensorsToDispose.push(x);
      }
      const targetShape = x.shape.slice();
      for (let k = 0;k < dimsToExpand.length; ++k) {
        targetShape.splice(dimsToExpand[k], 0, 1);
      }
      if (!exports_util.arraysEqual(x.shape, targetShape)) {
        x = reshape77({ inputs: { x }, backend: backend3, attrs: { shape: targetShape } });
        tensorsToDispose.push(x);
      }
      if (out === null) {
        out = x;
      } else {
        out = multiply2({ inputs: { a: x, b: out }, backend: backend3 });
        tensorsToDispose.push(out);
      }
    }
    if (i < nSteps - 1) {
      if (path[i] >= 0) {
        out = sum27({
          inputs: { x: out },
          backend: backend3,
          attrs: {
            axis: path[i] - (allDims.length - numDimsRemaining),
            keepDims: false
          }
        });
        tensorsToDispose.push(out);
      }
      numDimsRemaining--;
    }
  }
  for (const tensorInfo of tensorsToDispose) {
    if (tensorInfo === out) {
      continue;
    }
    backend3.disposeIntermediateTensorInfo(tensorInfo);
  }
  return out;
}
var einsumConfig;
var init_Einsum = __esm(() => {
  init_dist();
  init_Multiply();
  init_Reshape();
  init_Sum();
  init_Transpose();
  einsumConfig = {
    kernelName: Einsum,
    backendName: "cpu",
    kernelFunc: einsum3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/EluGrad.js
function eluGrad(args) {
  const { inputs, backend: backend3 } = args;
  const { dy: dy2, y } = inputs;
  assertNotComplex([dy2, y], "eluGrad");
  const resultValues = new Float32Array(exports_util.sizeFromShape(y.shape));
  const values = backend3.data.get(y.dataId).values;
  const dyValues = backend3.data.get(dy2.dataId).values;
  for (let i = 0;i < values.length; ++i) {
    const v = values[i];
    if (v >= 0) {
      resultValues[i] = dyValues[i];
    } else {
      resultValues[i] = dyValues[i] * (v + 1);
    }
  }
  return backend3.makeTensorInfo(y.shape, "float32", resultValues);
}
var eluGradConfig2;
var init_EluGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  eluGradConfig2 = {
    kernelName: EluGrad,
    backendName: "cpu",
    kernelFunc: eluGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Erf.js
var p2, a1, a2, a3, a4, a5, erf3, erfConfig;
var init_Erf = __esm(() => {
  init_dist();
  init_unary_utils();
  p2 = exports_backend_util.ERF_P;
  a1 = exports_backend_util.ERF_A1;
  a2 = exports_backend_util.ERF_A2;
  a3 = exports_backend_util.ERF_A3;
  a4 = exports_backend_util.ERF_A4;
  a5 = exports_backend_util.ERF_A5;
  erf3 = unaryKernelFunc(Erf, (xi) => {
    const sign3 = Math.sign(xi);
    const v = Math.abs(xi);
    const t = 1 / (1 + p2 * v);
    return sign3 * (1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-v * v));
  });
  erfConfig = {
    kernelName: Erf,
    backendName: "cpu",
    kernelFunc: erf3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ExpandDims.js
function expandDims3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { input: input2 } = inputs;
  const { dim } = attrs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    exports_util.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape77({ inputs: { x: input2 }, backend: backend3, attrs: { shape: newShape } });
}
var expandDimsConfig;
var init_ExpandDims = __esm(() => {
  init_dist();
  init_Reshape();
  expandDimsConfig = {
    kernelName: ExpandDims,
    backendName: "cpu",
    kernelFunc: expandDims3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RealDiv.js
var realDivImpl, div34, realDivConfig;
var init_RealDiv = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  realDivImpl = createSimpleBinaryKernelImpl((a, b) => a / b);
  div34 = binaryKernelFunc(RealDiv, realDivImpl);
  realDivConfig = {
    kernelName: RealDiv,
    backendName: "cpu",
    kernelFunc: div34
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fft_utils.js
function fftBatch(input2, inverse, cpuBackend) {
  const inputShape = input2.shape;
  const batch = inputShape[0];
  const innerDim = inputShape[1];
  const inputVals = cpuBackend.data.get(input2.dataId);
  const real2D = inputVals.complexTensorInfos.real;
  const imag2D = inputVals.complexTensorInfos.imag;
  const resultShape = [batch, innerDim];
  const resultSize = exports_util.sizeFromShape(resultShape);
  const resultReal = exports_util.getTypedArrayFromDType("float32", resultSize);
  const resultImag = exports_util.getTypedArrayFromDType("float32", resultSize);
  for (let b = 0;b < batch; b++) {
    const r = slice16({
      inputs: { x: real2D },
      backend: cpuBackend,
      attrs: { begin: [b, 0], size: [1, innerDim] }
    });
    const i = slice16({
      inputs: { x: imag2D },
      backend: cpuBackend,
      attrs: { begin: [b, 0], size: [1, innerDim] }
    });
    const input3 = complex8({ inputs: { real: r, imag: i }, backend: cpuBackend });
    const { real: real6, imag: imag6 } = fftImpl(input3, inverse, cpuBackend);
    const res = exports_backend_util.mergeRealAndImagArrays(real6, imag6);
    for (let d = 0;d < innerDim; d++) {
      const c = exports_backend_util.getComplexWithIndex(res, d);
      resultReal[b * innerDim + d] = c.real;
      resultImag[b * innerDim + d] = c.imag;
    }
    cpuBackend.disposeIntermediateTensorInfo(r);
    cpuBackend.disposeIntermediateTensorInfo(i);
    cpuBackend.disposeIntermediateTensorInfo(input3);
  }
  const $realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultReal);
  const $imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", resultImag);
  const result = complex8({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });
  cpuBackend.disposeIntermediateTensorInfo($realInfo);
  cpuBackend.disposeIntermediateTensorInfo($imagInfo);
  return result;
}
function fftImpl(input2, inverse, cpuBackend) {
  const inputSize = exports_util.sizeFromShape(input2.shape);
  const inputVals = cpuBackend.data.get(input2.dataId);
  const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;
  const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;
  if (isExponentOf2(inputSize)) {
    const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);
    const resultShape = [input2.shape[0], input2.shape[1]];
    if (inverse) {
      const realInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.real);
      const imagInfo = cpuBackend.makeTensorInfo(resultShape, "float32", result.imag);
      const sizeInfo = cpuBackend.makeTensorInfo([], "float32", exports_util.createScalarValue(inputSize, "float32"));
      const sizeInfoCopy = identity2({ inputs: { x: sizeInfo }, backend: cpuBackend });
      const divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });
      const divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });
      const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;
      const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;
      cpuBackend.disposeIntermediateTensorInfo(realInfo);
      cpuBackend.disposeIntermediateTensorInfo(imagInfo);
      cpuBackend.disposeIntermediateTensorInfo(sizeInfo);
      cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);
      cpuBackend.disposeIntermediateTensorInfo(divRealInfo);
      cpuBackend.disposeIntermediateTensorInfo(divImagInfo);
      return { real: divRealVals, imag: divImagVals };
    }
    return result;
  } else {
    const data = exports_backend_util.mergeRealAndImagArrays(realVals, imagVals);
    const rawOutput = fourierTransformByMatmul(data, inputSize, inverse);
    return exports_backend_util.splitRealAndImagArrays(rawOutput);
  }
}
function isExponentOf2(size) {
  return (size & size - 1) === 0;
}
function fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {
  if (size === 1) {
    return { real: realVals, imag: imagVals };
  }
  const data = exports_backend_util.mergeRealAndImagArrays(realVals, imagVals);
  const half = size / 2;
  const evenComplex = exports_backend_util.complexWithEvenIndex(data);
  const evenRealVals = evenComplex.real;
  const evenImagVals = evenComplex.imag;
  const evenShape = [evenRealVals.length];
  const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenRealVals);
  const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, "float32", evenImagVals);
  const evenTensorInfo = complex8({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });
  const oddComplex = exports_backend_util.complexWithOddIndex(data);
  const oddRealVals = oddComplex.real;
  const oddImagVals = oddComplex.imag;
  const oddShape = [oddRealVals.length];
  const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddRealVals);
  const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, "float32", oddImagVals);
  const oddTensorInfo = complex8({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });
  const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);
  const $evenRealVals = $evenComplex.real;
  const $evenImagVals = $evenComplex.imag;
  const $evenShape = [$evenRealVals.length];
  const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenRealVals);
  const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, "float32", $evenImagVals);
  const $evenTensorInfo = complex8({
    inputs: { real: $evenRealInfo, imag: $evenImagInfo },
    backend: cpuBackend
  });
  const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);
  const $oddRealVals = $oddComplex.real;
  const $oddImagVals = $oddComplex.imag;
  const $oddShape = [$oddRealVals.length];
  const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddRealVals);
  const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, "float32", $oddImagVals);
  const $oddTensorInfo = complex8({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });
  const e = exports_backend_util.exponents(size, inverse);
  const eShape = [e.real.length];
  const eRealInfo = cpuBackend.makeTensorInfo(eShape, "float32", e.real);
  const eImagInfo = cpuBackend.makeTensorInfo(eShape, "float32", e.imag);
  const complexInfo = complex8({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });
  const exponentInfo = multiply2({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });
  const addPart = add31({
    inputs: { a: $evenTensorInfo, b: exponentInfo },
    backend: cpuBackend
  });
  const subPart = sub33({
    inputs: { a: $evenTensorInfo, b: exponentInfo },
    backend: cpuBackend
  });
  const addPartReal = real5({ inputs: { input: addPart }, backend: cpuBackend });
  const subPartReal = real5({ inputs: { input: subPart }, backend: cpuBackend });
  const addPartImag = imag5({ inputs: { input: addPart }, backend: cpuBackend });
  const subPartImag = imag5({ inputs: { input: subPart }, backend: cpuBackend });
  const $real = concat14({
    inputs: [addPartReal, subPartReal],
    backend: cpuBackend,
    attrs: { axis: 0 }
  });
  const $imag = concat14({
    inputs: [addPartImag, subPartImag],
    backend: cpuBackend,
    attrs: { axis: 0 }
  });
  const $realVals = cpuBackend.data.get($real.dataId).values;
  const $imagVals = cpuBackend.data.get($imag.dataId).values;
  cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);
  cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);
  cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);
  cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);
  cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);
  cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);
  cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);
  cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);
  cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);
  cpuBackend.disposeIntermediateTensorInfo(eRealInfo);
  cpuBackend.disposeIntermediateTensorInfo(eImagInfo);
  cpuBackend.disposeIntermediateTensorInfo(complexInfo);
  cpuBackend.disposeIntermediateTensorInfo(exponentInfo);
  cpuBackend.disposeIntermediateTensorInfo(addPart);
  cpuBackend.disposeIntermediateTensorInfo(subPart);
  cpuBackend.disposeIntermediateTensorInfo(addPartReal);
  cpuBackend.disposeIntermediateTensorInfo(addPartImag);
  cpuBackend.disposeIntermediateTensorInfo(subPartReal);
  cpuBackend.disposeIntermediateTensorInfo(subPartImag);
  cpuBackend.disposeIntermediateTensorInfo($real);
  cpuBackend.disposeIntermediateTensorInfo($imag);
  return { real: $realVals, imag: $imagVals };
}
function fourierTransformByMatmul(data, size, inverse) {
  const ret = new Float32Array(size * 2);
  for (let r = 0;r < size; r++) {
    let real6 = 0;
    let imag6 = 0;
    for (let c = 0;c < size; c++) {
      const e = exports_backend_util.exponent(r * c, size, inverse);
      const term = exports_backend_util.getComplexWithIndex(data, c);
      real6 += term.real * e.real - term.imag * e.imag;
      imag6 += term.real * e.imag + term.imag * e.real;
    }
    if (inverse) {
      real6 /= size;
      imag6 /= size;
    }
    exports_backend_util.assignToTypedArray(ret, real6, imag6, r);
  }
  return ret;
}
var init_fft_utils = __esm(() => {
  init_dist();
  init_Add();
  init_Complex();
  init_Concat();
  init_Identity();
  init_Imag();
  init_Multiply();
  init_Real();
  init_RealDiv();
  init_Slice();
  init_Sub();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FFT.js
function fft5(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const inputSize = exports_util.sizeFromShape(input2.shape);
  const innerDimensionSize = input2.shape[input2.shape.length - 1];
  const batch = inputSize / innerDimensionSize;
  const input2D = reshape77({
    inputs: { x: input2 },
    backend: backend3,
    attrs: { shape: [batch, innerDimensionSize] }
  });
  const result = fftBatch(input2D, false, backend3);
  const resultReshaped = reshape77({ inputs: { x: result }, backend: backend3, attrs: { shape: input2.shape } });
  backend3.disposeIntermediateTensorInfo(input2D);
  backend3.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var fftConfig;
var init_FFT = __esm(() => {
  init_dist();
  init_fft_utils();
  init_Reshape();
  fftConfig = {
    kernelName: FFT,
    backendName: "cpu",
    kernelFunc: fft5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Fill.js
function fill6(args) {
  const { backend: backend3, attrs } = args;
  const { shape, value, dtype } = attrs;
  const $dtype = dtype || exports_util.inferDtype(value);
  const values = exports_util.getArrayFromDType($dtype, exports_util.sizeFromShape(shape));
  fillValues(values, value, $dtype);
  return backend3.makeTensorInfo(shape, $dtype, values);
}
function fillValues(values, value, dtype) {
  if (dtype === "string") {
    values.fill(value);
  } else {
    values.fill(value);
  }
}
var fillConfig;
var init_Fill = __esm(() => {
  init_dist();
  fillConfig = {
    kernelName: Fill,
    backendName: "cpu",
    kernelFunc: fill6
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FlipLeftRight.js
var flipLeftRightConfig;
var init_FlipLeftRight = __esm(() => {
  init_dist();
  flipLeftRightConfig = {
    kernelName: FlipLeftRight,
    backendName: "cpu",
    kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
      const { image: image2 } = inputs;
      const cpuBackend = backend3;
      const output = exports_util.getTypedArrayFromDType(image2.dtype, exports_util.sizeFromShape(image2.shape));
      const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
      const imageVals = cpuBackend.data.get(image2.dataId).values;
      for (let batchIdx = 0;batchIdx < batch; batchIdx++) {
        const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
        for (let row = 0;row < imageHeight; row++) {
          const rowOffset = row * (imageWidth * numChannels);
          for (let col = 0;col < imageWidth; col++) {
            const colOffset = col * numChannels;
            for (let channel = 0;channel < numChannels; channel++) {
              const coordX = Math.round(imageWidth - col - 1);
              const outIdx = batchOffset + rowOffset + colOffset + channel;
              let outputValue = imageVals[outIdx];
              if (coordX >= 0 && coordX < imageWidth) {
                const rotatedColOffset = coordX * numChannels;
                const imageIdx = batchOffset + rowOffset + rotatedColOffset + channel;
                outputValue = imageVals[imageIdx];
              }
              output[outIdx] = outputValue;
            }
          }
        }
      }
      const dataId = cpuBackend.write(output, image2.shape, image2.dtype);
      return { dataId, shape: image2.shape, dtype: image2.dtype };
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FusedConv2D.js
function fusedConv2D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  let result = conv2D({
    inputs: { x, filter },
    backend: backend3,
    attrs: { strides, pad: pad9, dataFormat, dilations, dimRoundingMode }
  });
  if (bias) {
    const resultOld = result;
    if (dataFormat === "NCHW" && bias.shape.length === 1 && bias.shape[0] !== 1) {
      const reshapedBias = reshape77({ inputs: { x: bias }, backend: backend3, attrs: { shape: [bias.shape[0], 1, 1] } });
      result = add31({ inputs: { a: result, b: reshapedBias }, backend: backend3 });
      backend3.disposeIntermediateTensorInfo(reshapedBias);
    } else {
      result = add31({ inputs: { a: result, b: bias }, backend: backend3 });
    }
    backend3.disposeIntermediateTensorInfo(resultOld);
  }
  if (activation2) {
    const resultOld = result;
    if (dataFormat === "NCHW" && activation2 === "prelu" && preluActivationWeights.shape.length === 1 && preluActivationWeights.shape[0] !== 1) {
      const reshapedAlpha = reshape77({
        inputs: { x: preluActivationWeights },
        backend: backend3,
        attrs: { shape: [preluActivationWeights.shape[0], 1, 1] }
      });
      result = applyActivation2(backend3, result, activation2, reshapedAlpha, leakyreluAlpha);
      backend3.disposeIntermediateTensorInfo(reshapedAlpha);
    } else {
      result = applyActivation2(backend3, result, activation2, preluActivationWeights, leakyreluAlpha);
    }
    backend3.disposeIntermediateTensorInfo(resultOld);
  }
  return result;
}
var fusedConv2DConfig;
var init_FusedConv2D = __esm(() => {
  init_dist();
  init_fused_utils();
  init_Add();
  init_Conv2D();
  init_Reshape();
  fusedConv2DConfig = {
    kernelName: FusedConv2D,
    backendName: "cpu",
    kernelFunc: fusedConv2D
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/FusedDepthwiseConv2D.js
function fusedDepthwiseConv2D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  let result = depthwiseConv2dNative({
    inputs: { x, filter },
    backend: backend3,
    attrs: { strides, pad: pad9, dataFormat, dilations, dimRoundingMode }
  });
  if (bias) {
    const oldResult = result;
    result = add31({ inputs: { a: result, b: bias }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(oldResult);
  }
  if (activation2) {
    const oldResult = result;
    result = applyActivation2(backend3, result, activation2, preluActivationWeights, leakyreluAlpha);
    backend3.disposeIntermediateTensorInfo(oldResult);
  }
  return result;
}
var fusedDepthwiseConv2DConfig;
var init_FusedDepthwiseConv2D = __esm(() => {
  init_dist();
  init_fused_utils();
  init_Add();
  init_DepthwiseConv2dNative();
  fusedDepthwiseConv2DConfig = {
    kernelName: FusedDepthwiseConv2D,
    backendName: "cpu",
    kernelFunc: fusedDepthwiseConv2D
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherNd.js
function gatherNd(args) {
  const { inputs, backend: backend3 } = args;
  const { params, indices } = inputs;
  const paramsSize = exports_util.sizeFromShape(params.shape);
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const [resultShape, numSlices, sliceSize, strides] = exports_backend_util.prepareAndValidate(params, indices);
  if (numSlices === 0) {
    return backend3.makeTensorInfo(resultShape, params.dtype, []);
  }
  const indicesData = backend3.data.get(indices.dataId).values;
  const paramsBuf = backend3.bufferSync(params);
  const outBuf = gatherNdImpl(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
  return backend3.makeTensorInfo(resultShape, params.dtype, outBuf.values);
}
var gatherNdConfig;
var init_GatherNd = __esm(() => {
  init_dist();
  init_GatherNd_Impl();
  gatherNdConfig = {
    kernelName: GatherNd,
    backendName: "cpu",
    kernelFunc: gatherNd
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/GatherV2.js
function gatherV2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, indices } = inputs;
  const { axis, batchDims } = attrs;
  assertNotComplex([x, indices], "gatherV2");
  const parsedAxis = exports_util.parseAxisParam(axis, x.shape)[0];
  const indicesVals = backend3.data.get(indices.dataId).values;
  const axisDim = x.shape[parsedAxis];
  for (let i = 0;i < indicesVals.length; ++i) {
    const index = indicesVals[i];
    exports_util.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);
  }
  let $batchDims = batchDims;
  if (batchDims == null) {
    $batchDims = 0;
  }
  const indicesSize = exports_util.sizeFromShape(indices.shape);
  const shapeInfo = exports_backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, $batchDims);
  const flattenX = reshape77({
    inputs: { x },
    backend: backend3,
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    }
  });
  const flattenIndex = reshape77({
    inputs: { x: indices },
    backend: backend3,
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
  });
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  const indicesBuf = backend3.bufferSync(flattenIndex);
  const xBuf = backend3.bufferSync(flattenX);
  const outBuf = gatherV2Impl(xBuf, indicesBuf, flattenOutputShape);
  backend3.disposeIntermediateTensorInfo(flattenX);
  backend3.disposeIntermediateTensorInfo(flattenIndex);
  return backend3.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
}
var gatherV2Config;
var init_GatherV2 = __esm(() => {
  init_dist();
  init_cpu_util();
  init_GatherV2_impl();
  init_Reshape();
  gatherV2Config = {
    kernelName: GatherV2,
    backendName: "cpu",
    kernelFunc: gatherV2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IFFT.js
function ifft5(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const inputSize = exports_util.sizeFromShape(input2.shape);
  const innerDimensionSize = input2.shape[input2.shape.length - 1];
  const batch = inputSize / innerDimensionSize;
  const input2D = reshape77({
    inputs: { x: input2 },
    backend: backend3,
    attrs: { shape: [batch, innerDimensionSize] }
  });
  const result = fftBatch(input2D, true, backend3);
  const resultReshaped = reshape77({ inputs: { x: result }, backend: backend3, attrs: { shape: input2.shape } });
  backend3.disposeIntermediateTensorInfo(input2D);
  backend3.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var ifftConfig;
var init_IFFT = __esm(() => {
  init_dist();
  init_fft_utils();
  init_Reshape();
  ifftConfig = {
    kernelName: IFFT,
    backendName: "cpu",
    kernelFunc: ifft5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IsFinite.js
var isFinite3, isFiniteConfig;
var init_IsFinite = __esm(() => {
  init_dist();
  init_unary_utils();
  isFinite3 = unaryKernelFunc(IsFinite, (xi) => Number.isFinite(xi) ? 1 : 0, "bool");
  isFiniteConfig = {
    kernelName: IsFinite,
    backendName: "cpu",
    kernelFunc: isFinite3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IsInf.js
var isInf2, isInfConfig;
var init_IsInf = __esm(() => {
  init_dist();
  init_unary_utils();
  isInf2 = unaryKernelFunc(IsInf, (xi) => Math.abs(xi) === Infinity ? 1 : 0, "bool");
  isInfConfig = {
    kernelName: IsInf,
    backendName: "cpu",
    kernelFunc: isInf2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/IsNaN.js
var isNaN3, isNaNConfig;
var init_IsNaN = __esm(() => {
  init_dist();
  init_unary_utils();
  isNaN3 = unaryKernelFunc(IsNan, (xi) => Number.isNaN(xi) ? 1 : 0, "bool");
  isNaNConfig = {
    kernelName: IsNan,
    backendName: "cpu",
    kernelFunc: isNaN3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LinSpace.js
function linSpace(args) {
  const { backend: backend3, attrs } = args;
  const { start, stop, num } = attrs;
  const outVals = linSpaceImpl(start, stop, num);
  return backend3.makeTensorInfo([outVals.length], "float32", outVals);
}
var linSpaceConfig;
var init_LinSpace = __esm(() => {
  init_dist();
  init_LinSpace_impl();
  linSpaceConfig = {
    kernelName: LinSpace,
    backendName: "cpu",
    kernelFunc: linSpace
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Log1p.js
var log1p4, log1pConfig;
var init_Log1p = __esm(() => {
  init_dist();
  init_unary_utils();
  log1p4 = unaryKernelFunc(Log1p, (xi) => Math.log1p(xi));
  log1pConfig = {
    kernelName: Log1p,
    backendName: "cpu",
    kernelFunc: log1p4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalAnd.js
var logicalAndImpl, logicalAnd2, logicalAndConfig;
var init_LogicalAnd = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  logicalAndImpl = createSimpleBinaryKernelImpl((a, b) => a && b);
  logicalAnd2 = binaryKernelFunc(LogicalAnd, logicalAndImpl, null, "bool");
  logicalAndConfig = {
    kernelName: LogicalAnd,
    backendName: "cpu",
    kernelFunc: logicalAnd2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalNot.js
var logicalNot2, logicalNotConfig;
var init_LogicalNot = __esm(() => {
  init_dist();
  init_unary_utils();
  logicalNot2 = unaryKernelFunc(LogicalNot, (xi) => xi ? 0 : 1, "bool");
  logicalNotConfig = {
    kernelName: LogicalNot,
    backendName: "cpu",
    kernelFunc: logicalNot2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LogicalOr.js
var logicalOrImpl, logicalOr2, logicalOrConfig;
var init_LogicalOr = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  logicalOrImpl = createSimpleBinaryKernelImpl((a, b) => a || b);
  logicalOr2 = binaryKernelFunc(LogicalOr, logicalOrImpl, null, "bool");
  logicalOrConfig = {
    kernelName: LogicalOr,
    backendName: "cpu",
    kernelFunc: logicalOr2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LRN.js
function lRN(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  assertNotComplex(x, "LRN");
  const channels = x.shape[3];
  const maxD = channels - 1;
  const xValues = backend3.data.get(x.dataId).values;
  const size = exports_util.sizeFromShape(x.shape);
  const result = new Float32Array(size);
  function sumAcrossChannels(offset) {
    const currentChannel = offset % channels;
    let beginSumOffset = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
    const endSumOffset = offset - currentChannel + Math.min(currentChannel + depthRadius, maxD);
    let sum28 = 0;
    for (;beginSumOffset <= endSumOffset; beginSumOffset++) {
      const z = xValues[beginSumOffset];
      sum28 += z * z;
    }
    return sum28;
  }
  for (let offset = 0;offset < size; offset++) {
    const sum28 = sumAcrossChannels(offset);
    const val = xValues[offset] * Math.pow(bias + alpha * sum28, -beta);
    result[offset] = val;
  }
  return backend3.makeTensorInfo(x.shape, x.dtype, result);
}
var LRNConfig;
var init_LRN = __esm(() => {
  init_dist();
  init_cpu_util();
  LRNConfig = {
    kernelName: LRN,
    backendName: "cpu",
    kernelFunc: lRN
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/LRNGrad.js
function lRNGrad(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, y, dy: dy2 } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  assertNotComplex(dy2, "LRNGrad");
  const dySize = exports_util.sizeFromShape(dy2.shape);
  const channels = dy2.shape[3];
  const dyValues = backend3.data.get(dy2.dataId).values;
  const xValues = backend3.data.get(x.dataId).values;
  const yValues = backend3.data.get(y.dataId).values;
  const result = new Float32Array(dySize);
  const size = dySize;
  for (let offset = 0;offset < size; offset++) {
    const currentChannel = offset % channels;
    const depthBegin = offset - currentChannel + Math.max(0, currentChannel - depthRadius);
    const depthEnd = offset - currentChannel + Math.min(channels, currentChannel + depthRadius + 1);
    let norm7 = 0;
    for (let k = depthBegin;k < depthEnd; k++) {
      norm7 += Math.pow(xValues[k], 2);
    }
    norm7 = alpha * norm7 + bias;
    for (let k = depthBegin;k < depthEnd; k++) {
      let dyi = -2 * alpha * beta * xValues[k] * yValues[offset] / norm7;
      if (offset === k) {
        dyi += Math.pow(norm7, -beta);
      }
      dyi *= dyValues[offset];
      result[k] += dyi;
    }
  }
  return backend3.makeTensorInfo(dy2.shape, x.dtype, result);
}
var LRNGradConfig;
var init_LRNGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  LRNGradConfig = {
    kernelName: LRNGrad,
    backendName: "cpu",
    kernelFunc: lRNGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Max.js
function max8(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { reductionIndices, keepDims } = attrs;
  const cpuBackend = backend3;
  let xShape = x.shape;
  const xRank = xShape.length;
  const origAxes = exports_util.parseAxisParam(reductionIndices, xShape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  let xVals = cpuBackend.data.get(x.dataId).values;
  if (permutedAxes != null) {
    const newShape = new Array(xRank);
    for (let i = 0;i < newShape.length; i++) {
      newShape[i] = xShape[permutedAxes[i]];
    }
    xVals = transposeImpl(xVals, xShape, x.dtype, permutedAxes, newShape);
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
    xShape = newShape;
  }
  assertNotComplex(x, "max");
  exports_backend_util.assertAxesAreInnerMostDims("max", axes, xRank);
  const [maxOutShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(xShape, axes);
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const result = maxImpl(xVals, reduceSize, maxOutShape, x.dtype);
  const dataId = cpuBackend.write(result, maxOutShape, x.dtype);
  let outShape = maxOutShape;
  if (keepDims) {
    const newShape = exports_backend_util.expandShapeToKeepDim(maxOutShape, origAxes);
    outShape = newShape;
  }
  return { dataId, shape: outShape, dtype: x.dtype };
}
var maxConfig;
var init_Max = __esm(() => {
  init_dist();
  init_dist();
  init_dist();
  init_cpu_util();
  init_Max_impl();
  init_Transpose_impl();
  maxConfig = {
    kernelName: Max,
    backendName: "cpu",
    kernelFunc: max8
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool.js
function maxPool2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  assertNotComplex(x, "maxPool");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = 1;
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  let res;
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && exports_util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    res = identity2({ inputs: { x }, backend: backend3 });
  } else {
    const xValues = backend3.data.get(x.dataId).values;
    const strides2 = exports_util.computeStrides(x.shape);
    const buffer9 = pool4(xValues, x.shape, x.dtype, strides2, convInfo, "max");
    res = backend3.makeTensorInfo(convInfo.outShape, x.dtype, buffer9.values);
  }
  return res;
}
var maxPoolConfig;
var init_MaxPool = __esm(() => {
  init_dist();
  init_cpu_util();
  init_pool_utils();
  init_Identity();
  maxPoolConfig = {
    kernelName: MaxPool,
    backendName: "cpu",
    kernelFunc: maxPool2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool3D.js
function maxPool3D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode, dataFormat } = attrs;
  assertNotComplex(x, "maxPool3d");
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, 1, pad9, dimRoundingMode, dataFormat);
  const xValues = backend3.data.get(x.dataId).values;
  const outBuf = pool3d2(xValues, x.shape, x.dtype, exports_util.computeStrides(x.shape), convInfo, "max");
  return backend3.makeTensorInfo(outBuf.shape, "float32", outBuf.values);
}
var maxPool3DConfig;
var init_MaxPool3D = __esm(() => {
  init_dist();
  init_cpu_util();
  init_pool_utils();
  maxPool3DConfig = {
    kernelName: MaxPool3D,
    backendName: "cpu",
    kernelFunc: maxPool3D
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPool3DGrad.js
function maxPool3DGrad(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  assertNotComplex([dy2, input2], "maxPool3DGrad");
  const convInfo = exports_backend_util.computePool3DInfo(input2.shape, filterSize, strides, 1, pad9, dimRoundingMode);
  const inputBuf = backend3.bufferSync(input2);
  const maxPosBuf = maxPool3dPositions(inputBuf, convInfo);
  const strideDepth = convInfo.strideDepth;
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationDepth = convInfo.dilationDepth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterDepth = convInfo.effectiveFilterDepth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(input2.shape, "float32");
  const dyBuf = backend3.bufferSync(dy2);
  for (let batch = 0;batch < convInfo.batchSize; ++batch) {
    for (let channel = 0;channel < convInfo.inChannels; ++channel) {
      for (let dxDepth = 0;dxDepth < convInfo.inDepth; ++dxDepth) {
        for (let dxRow = 0;dxRow < convInfo.inHeight; ++dxRow) {
          for (let dxCol = 0;dxCol < convInfo.inWidth; ++dxCol) {
            const dyDepthCorner = dxDepth - padFront;
            const dyRowCorner = dxRow - padTop;
            const dyColCorner = dxCol - padLeft;
            let dotProd = 0;
            for (let wDepth = 0;wDepth < effectiveFilterDepth; wDepth += dilationDepth) {
              const dyDepth = (dyDepthCorner + wDepth) / strideDepth;
              if (dyDepth < 0 || dyDepth >= convInfo.outDepth || Math.floor(dyDepth) !== dyDepth) {
                continue;
              }
              for (let wRow = 0;wRow < effectiveFilterHeight; wRow += dilationHeight) {
                const dyRow = (dyRowCorner + wRow) / strideHeight;
                if (dyRow < 0 || dyRow >= convInfo.outHeight || Math.floor(dyRow) !== dyRow) {
                  continue;
                }
                for (let wCol = 0;wCol < effectiveFilterWidth; wCol += dilationWidth) {
                  const dyCol = (dyColCorner + wCol) / strideWidth;
                  if (dyCol < 0 || dyCol >= convInfo.outWidth || Math.floor(dyCol) !== dyCol) {
                    continue;
                  }
                  const maxPos = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                  const curPos = wDepth * effectiveFilterHeight * effectiveFilterWidth + wRow * effectiveFilterWidth + wCol;
                  const mask = maxPos === curPos ? 1 : 0;
                  if (mask === 0) {
                    continue;
                  }
                  const pixel = dyBuf.get(batch, dyDepth, dyRow, dyCol, channel);
                  dotProd += pixel * mask;
                }
              }
            }
            dx.set(dotProd, batch, dxDepth, dxRow, dxCol, channel);
          }
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var maxPool3DGradConfig2;
var init_MaxPool3DGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  init_pool_utils();
  maxPool3DGradConfig2 = {
    kernelName: MaxPool3DGrad,
    backendName: "cpu",
    kernelFunc: maxPool3DGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolGrad.js
function maxPoolGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2, output } = inputs;
  const x = input2;
  assertNotComplex([input2, output], "maxPoolGrad");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, 1, pad9, dimRoundingMode);
  const xValues = backend3.data.get(x.dataId).values;
  const maxPosBuf = buffer(convInfo.outShape, x.dtype, maxPoolPositions(xValues, x.shape, x.dtype, convInfo).values);
  const strideHeight = convInfo.strideHeight;
  const strideWidth = convInfo.strideWidth;
  const dilationHeight = convInfo.dilationHeight;
  const dilationWidth = convInfo.dilationWidth;
  const effectiveFilterHeight = convInfo.effectiveFilterHeight;
  const effectiveFilterWidth = convInfo.effectiveFilterWidth;
  const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
  const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
  const dx = buffer(x.shape, "float32");
  const dyData = backend3.data.get(dy2.dataId).values;
  const dyBuf = buffer(dy2.shape, "float32", dyData);
  for (let b = 0;b < convInfo.batchSize; ++b) {
    for (let d = 0;d < convInfo.inChannels; ++d) {
      for (let dxR = 0;dxR < convInfo.inHeight; ++dxR) {
        for (let dxC = 0;dxC < convInfo.inWidth; ++dxC) {
          const dyRCorner = dxR - padTop;
          const dyCCorner = dxC - padLeft;
          let dotProd = 0;
          for (let wR = 0;wR < effectiveFilterHeight; wR += dilationHeight) {
            const dyR = (dyRCorner + wR) / strideHeight;
            if (dyR < 0 || dyR >= convInfo.outHeight || Math.floor(dyR) !== dyR) {
              continue;
            }
            for (let wC = 0;wC < effectiveFilterWidth; wC += dilationWidth) {
              const dyC = (dyCCorner + wC) / strideWidth;
              if (dyC < 0 || dyC >= convInfo.outWidth || Math.floor(dyC) !== dyC) {
                continue;
              }
              const maxPos = effectiveFilterHeight * effectiveFilterWidth - 1 - maxPosBuf.get(b, dyR, dyC, d);
              const curPos = wR * effectiveFilterWidth + wC;
              const mask = maxPos === curPos ? 1 : 0;
              if (mask === 0) {
                continue;
              }
              const pixel = dyBuf.get(b, dyR, dyC, d);
              dotProd += pixel * mask;
            }
          }
          dx.set(dotProd, b, dxR, dxC, d);
        }
      }
    }
  }
  return backend3.makeTensorInfo(dx.shape, dx.dtype, dx.values);
}
var maxPoolGradConfig2;
var init_MaxPoolGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  init_pool_utils();
  maxPoolGradConfig2 = {
    kernelName: MaxPoolGrad,
    backendName: "cpu",
    kernelFunc: maxPoolGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolWithArgmax_impl.js
function maxPoolWithArgmaxImpl(xValues, xShape, dtype, includeBatchInIndex, convInfo) {
  const strides = exports_util.computeStrides(xShape);
  const maxPools = pool4(xValues, xShape, dtype, strides, convInfo, "max");
  const maxPositions = maxPoolPositions(xValues, xShape, dtype, convInfo, true, includeBatchInIndex);
  return [maxPools.values, maxPositions.values];
}
var init_MaxPoolWithArgmax_impl = __esm(() => {
  init_dist();
  init_pool_utils();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MaxPoolWithArgmax.js
var maxPoolWithArgmaxConfig;
var init_MaxPoolWithArgmax = __esm(() => {
  init_dist();
  init_dist();
  init_cpu_util();
  init_MaxPoolWithArgmax_impl();
  maxPoolWithArgmaxConfig = {
    kernelName: MaxPoolWithArgmax,
    backendName: "cpu",
    kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
      const { x } = inputs;
      const { filterSize, strides, pad: pad9, includeBatchInIndex } = attrs;
      const cpuBackend = backend3;
      assertNotComplex(x, "MaxPoolWithArgmax");
      const values = cpuBackend.data.get(x.dataId).values;
      const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, [1, 1], pad9);
      const [pooled, indexes] = maxPoolWithArgmaxImpl(values, x.shape, x.dtype, includeBatchInIndex, convInfo);
      const pooledDataId = cpuBackend.write(pooled, convInfo.outShape, x.dtype);
      const indexesDataId = cpuBackend.write(indexes, convInfo.outShape, x.dtype);
      return [
        { dataId: pooledDataId, shape: convInfo.outShape, dtype: x.dtype },
        { dataId: indexesDataId, shape: convInfo.outShape, dtype: "int32" }
      ];
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Mean.js
function mean6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  const axes = exports_util.parseAxisParam(axis, x.shape);
  const shapes = exports_backend_util.computeOutAndReduceShapes(x.shape, axes);
  const reduceShape = shapes[1];
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const toDispose = [];
  const reduceSizeScalar = backend3.makeTensorInfo([], "float32", new Float32Array([reduceSize]));
  toDispose.push(reduceSizeScalar);
  const $x = cast46({ inputs: { x }, backend: backend3, attrs: { dtype: "float32" } });
  toDispose.push($x);
  const res = div34({ inputs: { a: $x, b: reduceSizeScalar }, backend: backend3 });
  toDispose.push(res);
  const result = sum27({ inputs: { x: res }, backend: backend3, attrs: { axis, keepDims } });
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}
var meanConfig;
var init_Mean = __esm(() => {
  init_dist();
  init_Cast();
  init_RealDiv();
  init_Sum();
  meanConfig = {
    kernelName: Mean,
    backendName: "cpu",
    kernelFunc: mean6
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Min.js
function min6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  assertNotComplex(x, "min");
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  if (permutedAxes != null) {
    $x = transpose11({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("min", axes, $x.shape.length);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes($x.shape, axes);
  const reduceSize = exports_util.sizeFromShape(reduceShape);
  const vals = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(outShape), $x.dtype);
  const aVals = backend3.data.get($x.dataId).values;
  for (let i = 0;i < vals.length; ++i) {
    const offset = i * reduceSize;
    let min7 = aVals[offset];
    for (let j = 0;j < reduceSize; ++j) {
      const value = aVals[offset + j];
      if (Number.isNaN(value) || value < min7) {
        min7 = value;
      }
    }
    vals[i] = min7;
  }
  if (permutedAxes != null) {
    backend3.disposeIntermediateTensorInfo($x);
  }
  const result = backend3.makeTensorInfo(outShape, $x.dtype, vals);
  if (keepDims) {
    const expandedShape = exports_backend_util.expandShapeToKeepDim(outShape, origAxes);
    const reshapedResult = reshape77({ inputs: { x: result }, backend: backend3, attrs: { shape: expandedShape } });
    backend3.disposeIntermediateTensorInfo(result);
    return reshapedResult;
  }
  return result;
}
var minConfig;
var init_Min = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Reshape();
  init_Transpose();
  minConfig = {
    kernelName: Min,
    backendName: "cpu",
    kernelFunc: min6
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/MirrorPad.js
function mirrorPad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { paddings, mode } = attrs;
  assertNotComplex(x, "mirrorPad");
  const outShape = paddings.map((p4, i) => p4[0] + x.shape[i] + p4[1]);
  const start = paddings.map((p4) => p4[0]);
  const end = paddings.map((p4, i) => p4[0] + x.shape[i]);
  const offset = mode === "reflect" ? 0 : 1;
  const xVals = backend3.data.get(x.dataId).values;
  const xRank = x.shape.length;
  const xStrides = exports_util.computeStrides(x.shape);
  const resultSize = exports_util.sizeFromShape(outShape);
  const resultRank = outShape.length;
  const resultStrides = exports_util.computeStrides(outShape);
  const resVals = exports_util.getTypedArrayFromDType(x.dtype, resultSize);
  for (let i = 0;i < resultSize; i++) {
    let coords = exports_util.indexToLoc(i, resultRank, resultStrides);
    for (let i3 = 0;i3 < resultRank; i3++) {
      if (coords[i3] < start[i3]) {
        coords[i3] = start[i3] * 2 - coords[i3] - offset;
      } else if (coords[i3] >= end[i3]) {
        coords[i3] = (end[i3] - 1) * 2 - coords[i3] + offset;
      }
    }
    coords = coords.map((c, i3) => c - start[i3]);
    const inIndex = exports_util.locToIndex(coords, xRank, xStrides);
    resVals[i] = xVals[inIndex];
  }
  const outId = backend3.write(resVals, outShape, x.dtype);
  return { dataId: outId, shape: outShape, dtype: x.dtype };
}
var mirrorPadConfig;
var init_MirrorPad = __esm(() => {
  init_dist();
  init_cpu_util();
  mirrorPadConfig = {
    kernelName: MirrorPad,
    backendName: "cpu",
    kernelFunc: mirrorPad2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Mod.js
var modImpl, mod4, modConfig;
var init_Mod = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  modImpl = createSimpleBinaryKernelImpl((aValue, bValue) => {
    const rem = aValue % bValue;
    if (aValue < 0 && bValue < 0 || aValue >= 0 && bValue >= 0) {
      return rem;
    } else {
      return (rem + bValue) % bValue;
    }
  });
  mod4 = binaryKernelFunc(Mod, modImpl);
  modConfig = {
    kernelName: Mod,
    backendName: "cpu",
    kernelFunc: mod4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Softmax.js
function softmax4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { logits } = inputs;
  const { dim } = attrs;
  const logitsRank = logits.shape.length;
  let $dim = dim;
  if ($dim === -1) {
    $dim = logitsRank - 1;
  }
  if ($dim !== logitsRank - 1) {
    throw Error("Softmax along a non-last dimension is not yet supported. " + `Logits was rank ${logitsRank} and dim was ${$dim}`);
  }
  const axes = exports_util.parseAxisParam([$dim], logits.shape);
  const maxLogit = max8({
    inputs: { x: logits },
    backend: backend3,
    attrs: { reductionIndices: axes, keepDims: false }
  });
  const expandedShape = exports_backend_util.expandShapeToKeepDim(maxLogit.shape, axes);
  const maxLogitReshaped = reshape77({ inputs: { x: maxLogit }, backend: backend3, attrs: { shape: expandedShape } });
  const a = sub33({ inputs: { a: logits, b: maxLogitReshaped }, backend: backend3 });
  const b = exp11({ inputs: { x: a }, backend: backend3 });
  const sumExp = sum27({ inputs: { x: b }, backend: backend3, attrs: { axis: axes, keepDims: false } });
  const sumReshaped = reshape77({ inputs: { x: sumExp }, backend: backend3, attrs: { shape: expandedShape } });
  const result = div34({ inputs: { a: b, b: sumReshaped }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(maxLogit);
  backend3.disposeIntermediateTensorInfo(maxLogitReshaped);
  backend3.disposeIntermediateTensorInfo(a);
  backend3.disposeIntermediateTensorInfo(b);
  backend3.disposeIntermediateTensorInfo(sumExp);
  backend3.disposeIntermediateTensorInfo(sumReshaped);
  return result;
}
var softmaxConfig;
var init_Softmax = __esm(() => {
  init_dist();
  init_Exp();
  init_Max();
  init_RealDiv();
  init_Reshape();
  init_Sub();
  init_Sum();
  softmaxConfig = {
    kernelName: Softmax,
    backendName: "cpu",
    kernelFunc: softmax4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Multinomial.js
function multinomial2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { logits } = inputs;
  const { numSamples, seed, normalized } = attrs;
  assertNotComplex(logits, "multinomial");
  const probabilities = normalized ? logits : softmax4({ inputs: { logits }, backend: backend3, attrs: { dim: -1 } });
  const batchSize = probabilities.shape[0];
  const numEvents = probabilities.shape[1];
  const probVals = backend3.data.get(probabilities.dataId).values;
  const resShape = [batchSize, numSamples];
  const resVals = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(resShape), "int32");
  for (let b = 0;b < batchSize; ++b) {
    const offset = b * numEvents;
    const cdf = new Float32Array(numEvents - 1);
    cdf[0] = probVals[offset];
    for (let event = 1;event < cdf.length; ++event) {
      cdf[event] = cdf[event - 1] + probVals[offset + event];
    }
    const random = seedrandom4.alea(seed.toString());
    const outOffset = b * numSamples;
    for (let sampleId = 0;sampleId < numSamples; ++sampleId) {
      const r = random();
      resVals[outOffset + sampleId] = cdf.length;
      for (let event = 0;event < cdf.length; event++) {
        if (r < cdf[event]) {
          resVals[outOffset + sampleId] = event;
          break;
        }
      }
    }
  }
  if (!normalized) {
    backend3.disposeIntermediateTensorInfo(probabilities);
  }
  return backend3.makeTensorInfo(resShape, "int32", resVals);
}
var seedrandom4, multinomialConfig;
var init_Multinomial = __esm(() => {
  init_dist();
  seedrandom4 = __toESM(require_seedrandom2(), 1);
  init_cpu_util();
  init_Softmax();
  multinomialConfig = {
    kernelName: Multinomial,
    backendName: "cpu",
    kernelFunc: multinomial2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV3.js
function nonMaxSuppressionV3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
  assertNotComplex(boxes, "NonMaxSuppression");
  const boxesVals = backend3.data.get(boxes.dataId).values;
  const scoresVals = backend3.data.get(scores.dataId).values;
  const { selectedIndices } = nonMaxSuppressionV3Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  return backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
}
var nonMaxSuppressionV3Impl2, nonMaxSuppressionV3Config;
var init_NonMaxSuppressionV3 = __esm(() => {
  init_dist();
  init_cpu_util();
  nonMaxSuppressionV3Impl2 = exports_kernel_impls.nonMaxSuppressionV3Impl;
  nonMaxSuppressionV3Config = {
    kernelName: NonMaxSuppressionV3,
    backendName: "cpu",
    kernelFunc: nonMaxSuppressionV3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV4.js
function nonMaxSuppressionV4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
  assertNotComplex(boxes, "NonMaxSuppressionPadded");
  const boxesVals = backend3.data.get(boxes.dataId).values;
  const scoresVals = backend3.data.get(scores.dataId).values;
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl2(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
  return [
    backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend3.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
  ];
}
var nonMaxSuppressionV4Impl2, nonMaxSuppressionV4Config;
var init_NonMaxSuppressionV4 = __esm(() => {
  init_dist();
  init_cpu_util();
  nonMaxSuppressionV4Impl2 = exports_kernel_impls.nonMaxSuppressionV4Impl;
  nonMaxSuppressionV4Config = {
    kernelName: NonMaxSuppressionV4,
    backendName: "cpu",
    kernelFunc: nonMaxSuppressionV4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/NonMaxSuppressionV5.js
function nonMaxSuppressionV5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
  assertNotComplex(boxes, "NonMaxSuppressionWithScore");
  const boxesVals = backend3.data.get(boxes.dataId).values;
  const scoresVals = backend3.data.get(scores.dataId).values;
  const maxOutputSizeVal = maxOutputSize;
  const iouThresholdVal = iouThreshold;
  const scoreThresholdVal = scoreThreshold;
  const softNmsSigmaVal = softNmsSigma;
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl2(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
  return [
    backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend3.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
  ];
}
var nonMaxSuppressionV5Impl2, nonMaxSuppressionV5Config;
var init_NonMaxSuppressionV5 = __esm(() => {
  init_dist();
  init_cpu_util();
  nonMaxSuppressionV5Impl2 = exports_kernel_impls.nonMaxSuppressionV5Impl;
  nonMaxSuppressionV5Config = {
    kernelName: NonMaxSuppressionV5,
    backendName: "cpu",
    kernelFunc: nonMaxSuppressionV5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/OneHot.js
function oneHot2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { indices } = inputs;
  const { dtype, depth, onValue, offValue } = attrs;
  assertNotComplex(indices, "oneHot");
  const indicesSize = exports_util.sizeFromShape(indices.shape);
  const res = new Float32Array(indicesSize * depth);
  res.fill(offValue);
  const indicesVal = backend3.data.get(indices.dataId).values;
  for (let event = 0;event < indicesSize; ++event) {
    if (indicesVal[event] >= 0 && indicesVal[event] < depth) {
      res[event * depth + indicesVal[event]] = onValue;
    }
  }
  return backend3.makeTensorInfo([...indices.shape, depth], dtype, res);
}
var oneHotConfig;
var init_OneHot = __esm(() => {
  init_dist();
  init_cpu_util();
  oneHotConfig = {
    kernelName: OneHot,
    backendName: "cpu",
    kernelFunc: oneHot2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ZerosLike.js
function zerosLike2(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (x.dtype === "string") {
    throw new Error("zerosLike is not supported for string tensors");
  } else if (x.dtype === "complex64") {
    const realPart = real5({ inputs: { input: x }, backend: backend3 });
    const r = zerosLike2({ inputs: { x: realPart }, backend: backend3 });
    const imagPart = imag5({ inputs: { input: x }, backend: backend3 });
    const i = zerosLike2({ inputs: { x: imagPart }, backend: backend3 });
    const result = complex8({ inputs: { real: r, imag: i }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(realPart);
    backend3.disposeIntermediateTensorInfo(r);
    backend3.disposeIntermediateTensorInfo(imagPart);
    backend3.disposeIntermediateTensorInfo(i);
    return result;
  } else {
    return fill6({ backend: backend3, attrs: { shape: x.shape, value: 0, dtype: x.dtype } });
  }
}
var zerosLikeConfig;
var init_ZerosLike = __esm(() => {
  init_dist();
  init_Complex();
  init_Fill();
  init_Imag();
  init_Real();
  zerosLikeConfig = {
    kernelName: ZerosLike,
    backendName: "cpu",
    kernelFunc: zerosLike2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/OnesLike.js
function onesLike2(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (x.dtype === "string") {
    throw new Error("onesLike is not supported for string tensors");
  } else if (x.dtype === "complex64") {
    const realPart = real5({ inputs: { input: x }, backend: backend3 });
    const r = onesLike2({ inputs: { x: realPart }, backend: backend3 });
    const imagPart = imag5({ inputs: { input: x }, backend: backend3 });
    const i = zerosLike2({ inputs: { x: imagPart }, backend: backend3 });
    const result = complex8({ inputs: { real: r, imag: i }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(realPart);
    backend3.disposeIntermediateTensorInfo(r);
    backend3.disposeIntermediateTensorInfo(imagPart);
    backend3.disposeIntermediateTensorInfo(i);
    return result;
  } else {
    return fill6({ backend: backend3, attrs: { shape: x.shape, value: 1, dtype: x.dtype } });
  }
}
var onesLikeConfig;
var init_OnesLike = __esm(() => {
  init_dist();
  init_Complex();
  init_Fill();
  init_Imag();
  init_Real();
  init_ZerosLike();
  onesLikeConfig = {
    kernelName: OnesLike,
    backendName: "cpu",
    kernelFunc: onesLike2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Pack.js
function pack(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims3({ inputs: { input: inputs[0] }, backend: backend3, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t) => {
    exports_util.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
    exports_util.assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t) => {
    const expandedT = expandDims3({ inputs: { input: t }, backend: backend3, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat14({ inputs: expandedTensors, backend: backend3, attrs: { axis } });
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}
var packConfig;
var init_Pack = __esm(() => {
  init_dist();
  init_Concat();
  init_ExpandDims();
  packConfig = {
    kernelName: Pack,
    backendName: "cpu",
    kernelFunc: pack
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/PadV2.js
function padV2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { paddings, constantValue } = attrs;
  assertNotComplex(x, "pad");
  const outShape = paddings.map((p4, i) => p4[0] + x.shape[i] + p4[1]);
  const start = paddings.map((p4) => p4[0]);
  const xVals = backend3.data.get(x.dataId).values;
  const xSize = exports_util.sizeFromShape(x.shape);
  const xRank = x.shape.length;
  const xStrides = exports_util.computeStrides(x.shape);
  const resultSize = exports_util.sizeFromShape(outShape);
  const resultRank = outShape.length;
  const resultStrides = exports_util.computeStrides(outShape);
  const resVals = exports_util.getTypedArrayFromDType(x.dtype, resultSize);
  if (constantValue !== 0) {
    resVals.fill(constantValue);
  }
  for (let i = 0;i < xSize; i++) {
    const coords = exports_util.indexToLoc(i, xRank, xStrides);
    const outCoords = coords.map((c, i3) => c + start[i3]);
    const outIndex = exports_util.locToIndex(outCoords, resultRank, resultStrides);
    resVals[outIndex] = xVals[i];
  }
  const outId = backend3.write(resVals, outShape, x.dtype);
  return { dataId: outId, shape: outShape, dtype: x.dtype };
}
var padV2Config;
var init_PadV2 = __esm(() => {
  init_dist();
  init_cpu_util();
  padV2Config = {
    kernelName: PadV2,
    backendName: "cpu",
    kernelFunc: padV2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Pow.js
var powImpl, pow9, powConfig;
var init_Pow = __esm(() => {
  init_dist();
  init_binary_impl();
  init_binary_utils();
  powImpl = createSimpleBinaryKernelImpl((a, b) => Math.pow(a, b));
  pow9 = binaryKernelFunc(Pow, powImpl);
  powConfig = {
    kernelName: Pow,
    backendName: "cpu",
    kernelFunc: pow9
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather.js
function raggedGather2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { paramsNestedSplits, paramsDenseValues, indices } = inputs;
  const { outputRaggedRank } = attrs;
  const $paramsNestedSplits = paramsNestedSplits.map((t) => backend3.data.get(t.dataId).values);
  const $paramsNestedSplitsShapes = paramsNestedSplits.map((t) => t.shape);
  const $paramsDenseValues = backend3.data.get(paramsDenseValues.dataId).values;
  const $indices = backend3.data.get(indices.dataId).values;
  const [outputNestedSplits, outputDenseValues, outputDenseValuesShape] = raggedGatherImpl($paramsNestedSplits, $paramsNestedSplitsShapes, $paramsDenseValues, paramsDenseValues.shape, paramsDenseValues.dtype, $indices, indices.shape, outputRaggedRank);
  const outputNestedSplitsTensors = outputNestedSplits.map((splits) => backend3.makeTensorInfo([splits.length], "int32", splits));
  const outputDenseValuesTensor = backend3.makeTensorInfo(outputDenseValuesShape, paramsDenseValues.dtype, outputDenseValues);
  return outputNestedSplitsTensors.concat([outputDenseValuesTensor]);
}
var raggedGatherConfig;
var init_RaggedGather = __esm(() => {
  init_dist();
  init_RaggedGather_impl();
  raggedGatherConfig = {
    kernelName: RaggedGather,
    backendName: "cpu",
    kernelFunc: raggedGather2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange.js
function raggedRange2(args) {
  const { inputs, backend: backend3 } = args;
  const { starts, limits, deltas } = inputs;
  const $starts = backend3.data.get(starts.dataId).values;
  const $limits = backend3.data.get(limits.dataId).values;
  const $deltas = backend3.data.get(deltas.dataId).values;
  const [rtNestedSplitsData, rtDenseValuesData] = raggedRangeImpl($starts, starts.shape, starts.dtype, $limits, limits.shape, $deltas, deltas.shape);
  const rtNestedSplits = backend3.makeTensorInfo([rtNestedSplitsData.length], "int32", rtNestedSplitsData);
  const rtDenseValues = backend3.makeTensorInfo([rtDenseValuesData.length], starts.dtype, rtDenseValuesData);
  return [rtNestedSplits, rtDenseValues];
}
var raggedRangeConfig;
var init_RaggedRange = __esm(() => {
  init_dist();
  init_RaggedRange_impl();
  raggedRangeConfig = {
    kernelName: RaggedRange,
    backendName: "cpu",
    kernelFunc: raggedRange2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor.js
function raggedTensorToTensor2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { shape, values, defaultValue, rowPartitionTensors } = inputs;
  const { rowPartitionTypes } = attrs;
  const $shape = backend3.data.get(shape.dataId).values;
  const $values = backend3.data.get(values.dataId).values;
  const $defaultValue = backend3.data.get(defaultValue.dataId).values;
  const $rowPartitionValues = rowPartitionTensors.map((t) => backend3.data.get(t.dataId).values);
  const rowPartitionValuesShapes = rowPartitionTensors.map((t) => t.shape);
  const [outputShape, output] = raggedTensorToTensorImpl($shape, shape.shape, $values, values.shape, values.dtype, $defaultValue, defaultValue.shape, $rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes);
  return backend3.makeTensorInfo(outputShape, values.dtype, output);
}
var raggedTensorToTensorConfig;
var init_RaggedTensorToTensor = __esm(() => {
  init_dist();
  init_RaggedTensorToTensor_impl();
  raggedTensorToTensorConfig = {
    kernelName: RaggedTensorToTensor,
    backendName: "cpu",
    kernelFunc: raggedTensorToTensor2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range.js
function range5(args) {
  const { backend: backend3, attrs } = args;
  const { start, stop, dtype, step: step7 } = attrs;
  const values = rangeImpl(start, stop, step7, dtype);
  return backend3.makeTensorInfo([values.length], dtype, values);
}
var rangeConfig;
var init_Range = __esm(() => {
  init_dist();
  init_Range_impl();
  rangeConfig = {
    kernelName: Range,
    backendName: "cpu",
    kernelFunc: range5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Reciprocal.js
var reciprocal3, reciprocalConfig;
var init_Reciprocal = __esm(() => {
  init_dist();
  init_unary_utils();
  reciprocal3 = unaryKernelFunc(Reciprocal, (xi) => 1 / xi);
  reciprocalConfig = {
    kernelName: Reciprocal,
    backendName: "cpu",
    kernelFunc: reciprocal3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinear.js
function resizeBilinear3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size } = attrs;
  assertNotComplex(images, "resizeBilinear");
  const imagesStrides = exports_util.computeStrides(images.shape);
  const [newHeight, newWidth] = size;
  const [batch, oldHeight, oldWidth, numChannels] = images.shape;
  const xValues = backend3.data.get(images.dataId).values;
  const result = new Float32Array(exports_util.sizeFromShape([batch, newHeight, newWidth, numChannels]));
  const effectiveInputSize = [
    alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
    alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
  ];
  const effectiveOutputSize = [
    alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
    alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
  ];
  let outputIdx = 0;
  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
  for (let b = 0;b < batch; b++) {
    for (let r = 0;r < newHeight; r++) {
      let sourceFracRow;
      if (halfPixelCenters) {
        sourceFracRow = effectiveRowSizeRatio * (r + 0.5) - 0.5;
      } else {
        sourceFracRow = effectiveRowSizeRatio * r;
      }
      const sourceRowFloor = Math.max(0, Math.floor(sourceFracRow));
      const rowFrac = sourceFracRow - sourceRowFloor;
      const sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
      const topRowOffset = b * imagesStrides[0] + sourceRowFloor * imagesStrides[1];
      const botRowOffset = b * imagesStrides[0] + sourceRowCeil * imagesStrides[1];
      for (let c = 0;c < newWidth; c++) {
        let sourceFracCol;
        if (halfPixelCenters) {
          sourceFracCol = effectiveColSizeRatio * (c + 0.5) - 0.5;
        } else {
          sourceFracCol = effectiveColSizeRatio * c;
        }
        const sourceColFloor = Math.max(0, Math.floor(sourceFracCol));
        const colFrac = sourceFracCol - sourceColFloor;
        const sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
        const topLeftOffest = topRowOffset + sourceColFloor * imagesStrides[2];
        const botLeftOffset = botRowOffset + sourceColFloor * imagesStrides[2];
        const topRightOffset = topRowOffset + sourceColCeil * imagesStrides[2];
        const botRightOffest = botRowOffset + sourceColCeil * imagesStrides[2];
        for (let d = 0;d < numChannels; d++) {
          const topLeft = xValues[topLeftOffest + d];
          const bottomLeft = xValues[botLeftOffset + d];
          const topRight = xValues[topRightOffset + d];
          const bottomRight = xValues[botRightOffest + d];
          const top = topLeft + (topRight - topLeft) * colFrac;
          const bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
          const newValue = top + (bottom - top) * rowFrac;
          result[outputIdx++] = newValue;
        }
      }
    }
  }
  return backend3.makeTensorInfo([batch, newHeight, newWidth, numChannels], "float32", result);
}
var resizeBilinearConfig;
var init_ResizeBilinear = __esm(() => {
  init_dist();
  init_cpu_util();
  resizeBilinearConfig = {
    kernelName: ResizeBilinear,
    backendName: "cpu",
    kernelFunc: resizeBilinear3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeBilinearGrad.js
function resizeBilinearGrad(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images, dy: dy2 } = inputs;
  const { alignCorners } = attrs;
  assertNotComplex([dy2, images], "resizeBilinearGrad");
  const imagesStrides = exports_util.computeStrides(images.shape);
  const [batch, xHeight, xWidth, depth] = images.shape;
  const [, yHeight, yWidth] = dy2.shape;
  const output = new Float32Array(batch * xHeight * xWidth * depth);
  const effectiveXSize = [
    alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
    alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
  ];
  const effectiveYSize = [
    alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
    alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
  ];
  const heightScale = effectiveXSize[0] / effectiveYSize[0];
  const widthScale = effectiveXSize[1] / effectiveYSize[1];
  const dyValues = backend3.data.get(dy2.dataId).values;
  let offset = 0;
  for (let b = 0;b < batch; b++) {
    const bOffset = b * imagesStrides[0];
    for (let r = 0;r < yHeight; r++) {
      const dxR = r * heightScale;
      const topDxRIndex = Math.floor(dxR);
      const bottomDxRIndex = Math.min(Math.ceil(dxR), xHeight - 1);
      const topDxROffset = bOffset + topDxRIndex * imagesStrides[1];
      const bottomDxROffset = bOffset + bottomDxRIndex * imagesStrides[1];
      const dxRLerp = dxR - topDxRIndex;
      const inverseDxRLerp = 1 - dxRLerp;
      for (let c = 0;c < yWidth; c++) {
        const dxC = c * widthScale;
        const leftDxCIndex = Math.floor(dxC);
        const rightDxCIndex = Math.min(Math.ceil(dxC), xWidth - 1);
        const dxCLerp = dxC - leftDxCIndex;
        const inverseDxCLerp = 1 - dxCLerp;
        const topLeftRCOffset = topDxROffset + leftDxCIndex * imagesStrides[2];
        const topRightRCOffset = topDxROffset + rightDxCIndex * imagesStrides[2];
        const bottomLeftRCOffset = bottomDxROffset + leftDxCIndex * imagesStrides[2];
        const bottomRightRCOffset = bottomDxROffset + rightDxCIndex * imagesStrides[2];
        const inverseDxRLerpTimesInverseDxCLerp = inverseDxRLerp * inverseDxCLerp;
        const inverseDxRLerpTimesDxCLerp = inverseDxRLerp * dxCLerp;
        const dxRLerpTimesInverseDxCLerp = dxRLerp * inverseDxCLerp;
        const dxRLerpTimesDxCLerp = dxRLerp * dxCLerp;
        for (let d = 0;d < depth; d++) {
          const dyVal = dyValues[offset++];
          output[topLeftRCOffset + d] += dyVal * inverseDxRLerpTimesInverseDxCLerp;
          output[topRightRCOffset + d] += dyVal * inverseDxRLerpTimesDxCLerp;
          output[bottomLeftRCOffset + d] += dyVal * dxRLerpTimesInverseDxCLerp;
          output[bottomRightRCOffset + d] += dyVal * dxRLerpTimesDxCLerp;
        }
      }
    }
  }
  return backend3.makeTensorInfo([batch, xWidth, xHeight, depth], "float32", output);
}
var resizeBilinearGradConfig2;
var init_ResizeBilinearGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  resizeBilinearGradConfig2 = {
    kernelName: ResizeBilinearGrad,
    backendName: "cpu",
    kernelFunc: resizeBilinearGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighbor.js
function resizeNearestNeighbor2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size } = attrs;
  assertNotComplex(images, "resizeNearestNeighbor");
  const imagesStrides = exports_util.computeStrides(images.shape);
  const [newHeight, newWidth] = size;
  const [batch, oldHeight, oldWidth, numChannels] = images.shape;
  const xValues = backend3.data.get(images.dataId).values;
  const output = new Float32Array(batch * newHeight * newWidth * numChannels);
  const effectiveInputSize = [
    alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
    alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
  ];
  const effectiveOutputSize = [
    alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
    alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
  ];
  const effectiveRowSizeRatio = effectiveInputSize[0] / effectiveOutputSize[0];
  const effectiveColSizeRatio = effectiveInputSize[1] / effectiveOutputSize[1];
  let outputOffset = 0;
  for (let b = 0;b < batch; b++) {
    const batchOffset = b * imagesStrides[0];
    for (let r = 0;r < newHeight; r++) {
      const sourceFracRow = halfPixelCenters ? effectiveRowSizeRatio * (r + 0.5) : effectiveRowSizeRatio * r;
      let sourceNearestRow = Math.min(oldHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
      if (halfPixelCenters) {
        sourceNearestRow = Math.max(0, sourceNearestRow);
      }
      const rowOffset = batchOffset + sourceNearestRow * imagesStrides[1];
      for (let c = 0;c < newWidth; c++) {
        const sourceFracCol = halfPixelCenters ? effectiveColSizeRatio * (c + 0.5) : effectiveColSizeRatio * c;
        let sourceNearestCol = Math.min(oldWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
        if (halfPixelCenters) {
          sourceNearestCol = Math.max(0, sourceNearestCol);
        }
        const colOffset = rowOffset + sourceNearestCol * imagesStrides[2];
        for (let d = 0;d < numChannels; d++) {
          const newVal = xValues[colOffset + d];
          output[outputOffset++] = newVal;
        }
      }
    }
  }
  return backend3.makeTensorInfo([batch, newHeight, newWidth, numChannels], images.dtype, output);
}
var resizeNearestNeighborConfig;
var init_ResizeNearestNeighbor = __esm(() => {
  init_dist();
  init_cpu_util();
  resizeNearestNeighborConfig = {
    kernelName: ResizeNearestNeighbor,
    backendName: "cpu",
    kernelFunc: resizeNearestNeighbor2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ResizeNearestNeighborGrad.js
function resizeNearestNeighborGrad(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images, dy: dy2 } = inputs;
  const { alignCorners } = attrs;
  assertNotComplex([dy2, images], "resizeNearestNeighborGrad");
  const imagesStrides = exports_util.computeStrides(images.shape);
  const dyStrides = exports_util.computeStrides(dy2.shape);
  const [batch, xHeight, xWidth, depth] = images.shape;
  const [, yHeight, yWidth] = dy2.shape;
  const output = new Float32Array(batch * xHeight * xWidth * depth);
  const dyValues = backend3.data.get(dy2.dataId).values;
  const effectiveXSize = [
    alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
    alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
  ];
  const effectiveYSize = [
    alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
    alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
  ];
  const heightScale = effectiveXSize[0] / effectiveYSize[0];
  const widthScale = effectiveXSize[1] / effectiveYSize[1];
  const invHeightScale = 1 / heightScale;
  const invWidthScale = 1 / widthScale;
  const winHeight = Math.ceil(invHeightScale) * 2 + 2;
  const winWidth = Math.ceil(invWidthScale) * 2 + 2;
  for (let b = 0;b < batch; b++) {
    const batchOffset = b * imagesStrides[0];
    for (let r = 0;r < xHeight; r++) {
      const rowOffset = batchOffset + r * imagesStrides[1];
      const startRLerp = Math.floor(r * invHeightScale);
      const startDyR = Math.floor(startRLerp - winHeight / 2);
      for (let c = 0;c < xWidth; c++) {
        const colOffset = rowOffset + c * imagesStrides[2];
        const startCLerp = Math.floor(c * invWidthScale);
        const startDyC = Math.floor(startCLerp - winWidth / 2);
        for (let d = 0;d < depth; d++) {
          let accum = 0;
          for (let dyRIndex = 0;dyRIndex < winHeight; dyRIndex++) {
            const dyR = dyRIndex + startDyR;
            if (dyR < 0 || dyR >= yHeight) {
              continue;
            }
            const dyROffset = batchOffset + dyR * dyStrides[1];
            const sourceFracRow = dyR * heightScale;
            const sourceNearestRow = Math.min(xHeight - 1, alignCorners ? Math.round(sourceFracRow) : Math.floor(sourceFracRow));
            if (r !== sourceNearestRow) {
              continue;
            }
            for (let dyCIndex = 0;dyCIndex < winWidth; dyCIndex++) {
              const dyC = dyCIndex + startDyC;
              if (dyC < 0 || dyC >= yWidth) {
                continue;
              }
              const dyCOffset = dyROffset + dyC * dyStrides[2];
              const sourceFracCol = dyC * widthScale;
              const sourceNearestCol = Math.min(xWidth - 1, alignCorners ? Math.round(sourceFracCol) : Math.floor(sourceFracCol));
              if (c === sourceNearestCol) {
                accum += dyValues[dyCOffset + d];
              }
            }
          }
          output[colOffset + d] = accum;
        }
      }
    }
  }
  return backend3.makeTensorInfo(images.shape, images.dtype, output);
}
var resizeNearestNeighborGradConfig2;
var init_ResizeNearestNeighborGrad = __esm(() => {
  init_dist();
  init_cpu_util();
  resizeNearestNeighborGradConfig2 = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: "cpu",
    kernelFunc: resizeNearestNeighborGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Reverse.js
function reverse10(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { dims } = attrs;
  assertNotComplex(x, "reverse");
  const xRank = x.shape.length;
  const $dims = exports_util.parseAxisParam(dims, x.shape);
  if (xRank === 0) {
    return identity2({ inputs: { x }, backend: backend3 });
  }
  const outBuf = new TensorBuffer(x.shape, x.dtype);
  const xBuf = backend3.bufferSync(x);
  for (let i = 0;i < outBuf.size; i++) {
    const outLoc = outBuf.indexToLoc(i);
    const inLoc = outLoc.slice();
    $dims.forEach((d) => inLoc[d] = x.shape[d] - 1 - inLoc[d]);
    outBuf.set(xBuf.get(...inLoc), ...outLoc);
  }
  return backend3.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
var reverseConfig;
var init_Reverse = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Identity();
  reverseConfig = {
    kernelName: Reverse,
    backendName: "cpu",
    kernelFunc: reverse10
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RotateWithOffset.js
var rotateWithOffsetConfig;
var init_RotateWithOffset = __esm(() => {
  init_dist();
  rotateWithOffsetConfig = {
    kernelName: RotateWithOffset,
    backendName: "cpu",
    kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
      const { image: image2 } = inputs;
      const { radians, fillValue, center } = attrs;
      const cpuBackend = backend3;
      const output = exports_util.getTypedArrayFromDType(image2.dtype, exports_util.sizeFromShape(image2.shape));
      const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
      const [centerX, centerY] = exports_backend_util.getImageCenter(center, imageHeight, imageWidth);
      const fullOpacityValue = 255;
      const sinFactor = Math.sin(radians);
      const cosFactor = Math.cos(radians);
      const imageVals = cpuBackend.data.get(image2.dataId).values;
      for (let batchIdx = 0;batchIdx < batch; batchIdx++) {
        const batchOffset = batchIdx * imageWidth * imageHeight * numChannels;
        for (let row = 0;row < imageHeight; row++) {
          const rowOffset = row * (imageWidth * numChannels);
          for (let col = 0;col < imageWidth; col++) {
            const colOffset = col * numChannels;
            for (let channel = 0;channel < numChannels; channel++) {
              const coords = [batch, row, col, channel];
              const x = coords[2];
              const y = coords[1];
              let coordX = (x - centerX) * cosFactor - (y - centerY) * sinFactor;
              let coordY = (x - centerX) * sinFactor + (y - centerY) * cosFactor;
              coordX = Math.round(coordX + centerX);
              coordY = Math.round(coordY + centerY);
              let outputValue = fillValue;
              if (typeof fillValue !== "number") {
                if (channel === 3) {
                  outputValue = fullOpacityValue;
                } else {
                  outputValue = fillValue[channel];
                }
              }
              if (coordX >= 0 && coordX < imageWidth && coordY >= 0 && coordY < imageHeight) {
                const rotatedRowOffset = coordY * (imageWidth * numChannels);
                const rotatedColOffset = coordX * numChannels;
                const imageIdx = batchOffset + rotatedRowOffset + rotatedColOffset + channel;
                outputValue = imageVals[imageIdx];
              }
              const outIdx = batchOffset + rowOffset + colOffset + channel;
              output[outIdx] = outputValue;
            }
          }
        }
      }
      const dataId = cpuBackend.write(output, image2.shape, image2.dtype);
      return { dataId, shape: image2.shape, dtype: image2.dtype };
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Round.js
var round5, roundConfig;
var init_Round = __esm(() => {
  init_dist();
  init_unary_utils();
  round5 = unaryKernelFunc(Round, (xi) => {
    const base3 = Math.floor(xi);
    if (xi - base3 < 0.5) {
      return Math.floor(xi);
    } else if (xi - base3 > 0.5) {
      return Math.ceil(xi);
    } else {
      if (base3 % 2 === 0) {
        return base3;
      } else {
        return base3 + 1;
      }
    }
  });
  roundConfig = {
    kernelName: Round,
    backendName: "cpu",
    kernelFunc: round5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/ScatterNd.js
function scatterNd(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(updates, indices, shape);
  const sumDupeIndices = true;
  const indicesBuf = backend3.bufferSync(indices);
  const updatesBuf = backend3.bufferSync(updates);
  const outBuf = scatterImpl(indicesBuf, updatesBuf, shape, outputSize, sliceSize, numUpdates, sliceRank, strides, 0, sumDupeIndices);
  return backend3.makeTensorInfo(shape, outBuf.dtype, outBuf.values);
}
var scatterNdConfig;
var init_ScatterNd = __esm(() => {
  init_dist();
  init_Scatter_impl();
  scatterNdConfig = {
    kernelName: ScatterNd,
    backendName: "cpu",
    kernelFunc: scatterNd
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SearchSorted_impl.js
function lowerBound2(array2, value) {
  let left = 0;
  let right = array2.length;
  let mid = 0;
  while (left < right) {
    mid = Math.floor((left + right) / 2);
    if (array2[mid] < value) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  return right;
}
function upperBound2(array2, value) {
  let left = 0;
  let right = array2.length;
  let mid = 0;
  while (left < right) {
    mid = Math.floor((left + right) / 2);
    if (array2[mid] <= value) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  return right;
}
function searchSortedImpl(sortedInputs, values, batchSize, numInputs, numValues, side) {
  const output = exports_util.getArrayFromDType("int32", batchSize * numValues);
  for (let b = 0;b < batchSize; ++b) {
    const sortedInputsSlice = sortedInputs.slice(b * numInputs, (b + 1) * numInputs);
    const outputOffset = b * numValues;
    for (let i = 0;i < numValues; ++i) {
      output[outputOffset + i] = side === "left" ? lowerBound2(sortedInputsSlice, values[i + outputOffset]) : upperBound2(sortedInputsSlice, values[i + outputOffset]);
    }
  }
  return output;
}
var init_SearchSorted_impl = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SearchSorted.js
function searchSorted2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { sortedSequence, values } = inputs;
  const { side } = attrs;
  const $sortedSequence = backend3.data.get(sortedSequence.dataId).values;
  const $values = backend3.data.get(values.dataId).values;
  const output = searchSortedImpl($sortedSequence, $values, sortedSequence.shape[0], sortedSequence.shape[1], values.shape[1], side);
  return backend3.makeTensorInfo(values.shape, "int32", output);
}
var searchSortedConfig;
var init_SearchSorted = __esm(() => {
  init_dist();
  init_SearchSorted_impl();
  searchSortedConfig = {
    kernelName: SearchSorted,
    backendName: "cpu",
    kernelFunc: searchSorted2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Select.js
function select2(args) {
  const { inputs, backend: backend3 } = args;
  const { condition, t, e } = inputs;
  assertNotComplex([condition, t, e], "select");
  const conditionRank = condition.shape.length;
  const values = backend3.data.get(condition.dataId).values;
  const tValues = backend3.data.get(t.dataId).values;
  const eValues = backend3.data.get(e.dataId).values;
  const resultDtype = upcastType(t.dtype, e.dtype);
  const newValues = exports_util.makeZerosTypedArray(exports_util.sizeFromShape(t.shape), resultDtype);
  let index = 0;
  const offset = conditionRank === 0 || conditionRank > 1 || t.shape.length === 1 ? 1 : exports_util.sizeFromShape(t.shape.slice(1));
  for (let i = 0;i < values.length; i++) {
    for (let j = 0;j < offset; j++) {
      if (values[i] === 1) {
        newValues[index++] = tValues[i];
      } else {
        newValues[index++] = eValues[i];
      }
    }
  }
  return backend3.makeTensorInfo(t.shape, resultDtype, newValues);
}
var selectConfig;
var init_Select = __esm(() => {
  init_dist();
  init_cpu_util();
  selectConfig = {
    kernelName: Select,
    backendName: "cpu",
    kernelFunc: select2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Selu.js
var scaleAlpha, scale, selu4, seluConfig;
var init_Selu = __esm(() => {
  init_dist();
  init_unary_utils();
  scaleAlpha = exports_backend_util.SELU_SCALEALPHA;
  scale = exports_backend_util.SELU_SCALE;
  selu4 = unaryKernelFunc(Selu, (xi) => {
    if (xi >= 0) {
      return scale * xi;
    } else {
      return scaleAlpha * (Math.exp(xi) - 1);
    }
  });
  seluConfig = {
    kernelName: Selu,
    backendName: "cpu",
    kernelFunc: selu4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sign.js
var sign3, signConfig;
var init_Sign = __esm(() => {
  init_dist();
  init_unary_utils();
  sign3 = unaryKernelFunc(Sign, (xi) => {
    if (xi < 0) {
      return -1;
    } else if (xi > 0) {
      return 1;
    } else {
      return 0;
    }
  });
  signConfig = {
    kernelName: Sign,
    backendName: "cpu",
    kernelFunc: sign3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sin.js
var sin4, sinConfig;
var init_Sin = __esm(() => {
  init_dist();
  init_unary_utils();
  sin4 = unaryKernelFunc(Sin, (xi) => Math.sin(xi));
  sinConfig = {
    kernelName: Sin,
    backendName: "cpu",
    kernelFunc: sin4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Sinh.js
var sinh4, sinhConfig;
var init_Sinh = __esm(() => {
  init_dist();
  init_unary_utils();
  sinh4 = unaryKernelFunc(Sinh, (xi) => Math.sinh(xi));
  sinhConfig = {
    kernelName: Sinh,
    backendName: "cpu",
    kernelFunc: sinh4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Softplus.js
var epsilon2 = 0.00000011920928955078125, threshold3, softplus4, softplusConfig;
var init_Softplus = __esm(() => {
  init_dist();
  init_unary_utils();
  threshold3 = Math.log(epsilon2) + 2;
  softplus4 = unaryKernelFunc(Softplus, (xi) => {
    const tooLarge = xi > -threshold3;
    const tooSmall = xi < threshold3;
    const expX = Math.exp(xi);
    let result;
    if (tooSmall) {
      result = expX;
    } else if (tooLarge) {
      result = xi;
    } else {
      result = Math.log(1 + expX);
    }
    return result;
  });
  softplusConfig = {
    kernelName: Softplus,
    backendName: "cpu",
    kernelFunc: softplus4
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SpaceToBatchND.js
function spaceToBatchND2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockShape, paddings } = attrs;
  assertNotComplex([x], "spaceToBatchND");
  const prod5 = exports_util.sizeFromShape(blockShape);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i = 1 + blockShape.length;i < x.shape.length; ++i) {
    completePaddings.push([0, 0]);
  }
  const paddedX = padV2Config.kernelFunc({
    inputs: { x },
    backend: backend3,
    attrs: { paddings: completePaddings, constantValue: 0 }
  });
  const reshapedPaddedShape = exports_backend_util.getReshaped(paddedX.shape, blockShape, prod5, false);
  const permutedReshapedPaddedPermutation = exports_backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = exports_backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod5, false);
  const reshapeInputs = { x: paddedX };
  const reshapeAttrs = { shape: reshapedPaddedShape };
  const paddedXReshaped = reshape77({ inputs: reshapeInputs, backend: backend3, attrs: reshapeAttrs });
  const transposeInputs = { x: paddedXReshaped };
  const transposeAttrs = { perm: permutedReshapedPaddedPermutation };
  const paddedXT = transpose11({ inputs: transposeInputs, backend: backend3, attrs: transposeAttrs });
  const resultReshapeInputs = { x: paddedXT };
  const resultReshapeAttrs = { shape: flattenShape };
  const result = reshape77({ inputs: resultReshapeInputs, backend: backend3, attrs: resultReshapeAttrs });
  backend3.disposeIntermediateTensorInfo(paddedX);
  backend3.disposeIntermediateTensorInfo(paddedXReshaped);
  backend3.disposeIntermediateTensorInfo(paddedXT);
  return result;
}
var spaceToBatchNDConfig;
var init_SpaceToBatchND = __esm(() => {
  init_dist();
  init_cpu_util();
  init_PadV2();
  init_Reshape();
  init_Transpose();
  spaceToBatchNDConfig = {
    kernelName: SpaceToBatchND,
    backendName: "cpu",
    kernelFunc: spaceToBatchND2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseFillEmptyRows.js
function sparseFillEmptyRows2(args) {
  const { inputs, backend: backend3 } = args;
  const { indices, values, denseShape, defaultValue } = inputs;
  if (denseShape.shape.length !== 1) {
    throw new Error(`Dense shape must be a vector, saw:
        ${denseShape.shape}`);
  }
  if (indices.shape.length !== 2) {
    throw new Error(`Indices must be a matrix, saw:
        ${indices.shape}`);
  }
  if (values.shape.length !== 1) {
    throw new Error(`Values must be a vector, saw:
        ${values.shape}`);
  }
  if (defaultValue.shape.length !== 0) {
    throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
  }
  const $indices = backend3.data.get(indices.dataId).values;
  const $values = backend3.data.get(values.dataId).values;
  const $denseShape = backend3.data.get(denseShape.dataId).values;
  const $defaultValue = backend3.data.get(defaultValue.dataId).values[0];
  const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImpl($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
  return [
    backend3.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
    backend3.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
    backend3.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
    backend3.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
  ];
}
var sparseFillEmptyRowsConfig;
var init_SparseFillEmptyRows = __esm(() => {
  init_dist();
  init_SparseFillEmptyRows_impl();
  sparseFillEmptyRowsConfig = {
    kernelName: SparseFillEmptyRows,
    backendName: "cpu",
    kernelFunc: sparseFillEmptyRows2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseReshape.js
function sparseReshape2(args) {
  const { inputs, backend: backend3 } = args;
  const { inputIndices, inputShape, newShape } = inputs;
  if (inputIndices.shape.length !== 2) {
    throw new Error(`Input indices should be a matrix but received shape
        ${inputIndices.shape}`);
  }
  if (inputShape.shape.length !== 1) {
    throw new Error(`Input shape should be a vector but received shape
        ${inputShape.shape}`);
  }
  if (newShape.shape.length !== 1) {
    throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
  }
  const $inputShape = Array.from(backend3.data.get(inputShape.dataId).values);
  const $inputIndices = backend3.data.get(inputIndices.dataId).values;
  const targetShape = Array.from(backend3.data.get(newShape.dataId).values);
  const [newIndices, indicesShape, outputShape] = sparseReshapeImpl($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
  return [
    backend3.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
    backend3.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
  ];
}
var sparseReshapeConfig;
var init_SparseReshape = __esm(() => {
  init_dist();
  init_SparseReshape_impl();
  sparseReshapeConfig = {
    kernelName: SparseReshape,
    backendName: "cpu",
    kernelFunc: sparseReshape2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentMean.js
function sparseSegmentMean2(args) {
  const { inputs, backend: backend3 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
          ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
          ${segmentIds.shape}`);
  }
  if (indices.shape[0] !== segmentIds.shape[0]) {
    throw new Error(`segmentIds and indices should have same size.`);
  }
  const $data = backend3.data.get(data.dataId).values;
  const $indices = backend3.data.get(indices.dataId).values;
  const $segmentIds = backend3.data.get(segmentIds.dataId).values;
  const [outputData, outputDataShape] = sparseSegmentReductionImpl($data, data.shape, data.dtype, $indices, $segmentIds, true);
  return backend3.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentMeanConfig;
var init_SparseSegmentMean = __esm(() => {
  init_dist();
  init_SparseSegmentReduction_impl();
  sparseSegmentMeanConfig = {
    kernelName: SparseSegmentMean,
    backendName: "cpu",
    kernelFunc: sparseSegmentMean2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseSegmentSum.js
function sparseSegmentSum2(args) {
  const { inputs, backend: backend3 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
         ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
         ${segmentIds.shape}`);
  }
  if (indices.shape[0] !== segmentIds.shape[0]) {
    throw new Error(`segmentIds and indices should have same size.`);
  }
  const $data = backend3.data.get(data.dataId).values;
  const $indices = backend3.data.get(indices.dataId).values;
  const $segmentIds = backend3.data.get(segmentIds.dataId).values;
  const [outputData, outputDataShape] = sparseSegmentReductionImpl($data, data.shape, data.dtype, $indices, $segmentIds);
  return backend3.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentSumConfig;
var init_SparseSegmentSum = __esm(() => {
  init_dist();
  init_SparseSegmentReduction_impl();
  sparseSegmentSumConfig = {
    kernelName: SparseSegmentSum,
    backendName: "cpu",
    kernelFunc: sparseSegmentSum2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SparseToDense.js
function sparseToDense2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { sparseIndices, sparseValues, defaultValue } = inputs;
  const { outputShape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);
  const sumDupeIndices = false;
  const indicesBuf = backend3.bufferSync(sparseIndices);
  let outBuf;
  switch (sparseValues.dtype) {
    case "bool": {
      const updatesBuf = backend3.bufferSync(sparseValues);
      const $defaultValue = Boolean(backend3.data.get(defaultValue.dataId).values[0]);
      outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
      break;
    }
    case "float32": {
      const updatesBuf = backend3.bufferSync(sparseValues);
      const $defaultValue = backend3.data.get(defaultValue.dataId).values[0];
      outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
      break;
    }
    case "int32": {
      const updatesBuf = backend3.bufferSync(sparseValues);
      const $defaultValue = backend3.data.get(defaultValue.dataId).values[0];
      outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
      break;
    }
    case "string": {
      const updatesBuf = backend3.bufferSync(sparseValues);
      const $defaultValue = exports_util.decodeString(backend3.data.get(defaultValue.dataId).values[0]);
      outBuf = scatterImpl(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
      break;
    }
    default:
      throw new Error(`Unsupported type ${sparseValues.dtype}`);
  }
  return backend3.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
}
var sparseToDenseConfig;
var init_SparseToDense = __esm(() => {
  init_dist();
  init_Scatter_impl();
  sparseToDenseConfig = {
    kernelName: SparseToDense,
    backendName: "cpu",
    kernelFunc: sparseToDense2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/SplitV.js
function splitV(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = exports_util.parseAxisParam(axis, x.shape)[0];
  const splitSizes = exports_backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);
  const begin = new Array(x.shape.length).fill(0);
  const size = x.shape.slice();
  return splitSizes.map((s) => {
    const sliceSize = [...size];
    sliceSize[$axis] = s;
    const sliceT = slice16({ inputs: { x }, backend: backend3, attrs: { begin, size: sliceSize } });
    begin[$axis] += s;
    return sliceT;
  });
}
var splitVConfig;
var init_SplitV = __esm(() => {
  init_dist();
  init_dist();
  init_Slice();
  splitVConfig = {
    kernelName: SplitV,
    backendName: "cpu",
    kernelFunc: splitV
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Square.js
var squareConfig;
var init_Square = __esm(() => {
  init_dist();
  init_cpu_util();
  squareConfig = {
    kernelName: Square,
    backendName: "cpu",
    kernelFunc: ({ inputs, backend: backend3 }) => {
      const { x } = inputs;
      const cpuBackend = backend3;
      assertNotComplex(x, "square");
      const values = cpuBackend.data.get(x.dataId).values;
      const newValues = new Float32Array(values.length);
      for (let i = 0;i < values.length; ++i) {
        const value = values[i];
        newValues[i] = value * value;
      }
      const dataId = cpuBackend.write(newValues, x.shape, x.dtype);
      return { dataId, shape: x.shape, dtype: x.dtype };
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Step.js
var step7, stepConfig;
var init_Step = __esm(() => {
  init_dist();
  init_unary_utils();
  step7 = unaryKernelFunc(Step, (xi, attrs) => {
    const stepAttrs = attrs;
    if (isNaN(xi)) {
      return NaN;
    } else {
      return xi > 0 ? 1 : stepAttrs.alpha;
    }
  });
  stepConfig = {
    kernelName: Step,
    backendName: "cpu",
    kernelFunc: step7
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StridedSlice.js
function stridedSlice2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  assertNotComplex(x, "stridedSlice");
  const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = exports_slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  let result;
  if (isIdentity) {
    result = reshape77({ inputs: { x }, backend: backend3, attrs: { shape: finalShape } });
  } else if (sliceDim0 || isSimpleSlice) {
    exports_util.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);
    const size = exports_slice_util.computeOutShape($begin, $end, $strides);
    const sliced = slice16({ inputs: { x }, backend: backend3, attrs: { begin: $begin, size } });
    result = reshape77({ inputs: { x: sliced }, backend: backend3, attrs: { shape: finalShape } });
    backend3.disposeIntermediateTensorInfo(sliced);
  } else {
    const xBuf = backend3.bufferSync(x);
    const outBuf = stridedSliceImpl(finalShapeSparse, xBuf, $strides, $begin);
    result = backend3.makeTensorInfo(finalShape, outBuf.dtype, outBuf.values);
  }
  return result;
}
var stridedSliceConfig;
var init_StridedSlice = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Reshape();
  init_Slice();
  init_StridedSlice_impl();
  stridedSliceConfig = {
    kernelName: StridedSlice,
    backendName: "cpu",
    kernelFunc: stridedSlice2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringNGrams.js
function stringNGrams2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
  const { data, dataSplits } = inputs;
  const $data = backend3.data.get(data.dataId).values;
  const $dataSplits = backend3.data.get(dataSplits.dataId).values;
  const [nGrams, nGramsSplits] = stringNGramsImpl($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
  return [
    backend3.makeTensorInfo([nGrams.length], "string", nGrams),
    backend3.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
  ];
}
var stringNGramsConfig;
var init_StringNGrams = __esm(() => {
  init_dist();
  init_StringNGrams_impl();
  stringNGramsConfig = {
    kernelName: StringNGrams,
    backendName: "cpu",
    kernelFunc: stringNGrams2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringSplit.js
function stringSplit2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { skipEmpty } = attrs;
  const { input: input2, delimiter } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (input2.shape.length !== 1) {
    throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
  }
  if (delimiter.shape.length !== 0) {
    throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
  }
  const $input = backend3.data.get(input2.dataId).values;
  const $delimiter = backend3.data.get(delimiter.dataId).values[0];
  const [indices, values, shape] = stringSplitImpl($input, $delimiter, skipEmpty);
  const outputSize = values.length;
  return [
    backend3.makeTensorInfo([outputSize, 2], "int32", indices),
    backend3.makeTensorInfo([outputSize], "string", values),
    backend3.makeTensorInfo([2], "int32", new Int32Array(shape))
  ];
}
var stringSplitConfig;
var init_StringSplit = __esm(() => {
  init_dist();
  init_StringSplit_impl();
  stringSplitConfig = {
    kernelName: StringSplit,
    backendName: "cpu",
    kernelFunc: stringSplit2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/StringToHashBucketFast.js
function stringToHashBucketFast2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { numBuckets } = attrs;
  const { input: input2 } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const $input = backend3.data.get(input2.dataId).values;
  const output = stringToHashBucketFastImpl($input, numBuckets);
  return backend3.makeTensorInfo(input2.shape, "int32", output);
}
var stringToHashBucketFastConfig;
var init_StringToHashBucketFast = __esm(() => {
  init_dist();
  init_StringToHashBucketFast_impl();
  stringToHashBucketFastConfig = {
    kernelName: StringToHashBucketFast,
    backendName: "cpu",
    kernelFunc: stringToHashBucketFast2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tan.js
var tan3, tanConfig;
var init_Tan = __esm(() => {
  init_dist();
  init_unary_utils();
  tan3 = unaryKernelFunc(Tan, (xi) => Math.tan(xi));
  tanConfig = {
    kernelName: Tan,
    backendName: "cpu",
    kernelFunc: tan3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tanh.js
var tanh5, tanhConfig;
var init_Tanh = __esm(() => {
  init_dist();
  init_unary_utils();
  tanh5 = unaryKernelFunc(Tanh, (xi) => Math.tanh(xi));
  tanhConfig = {
    kernelName: Tanh,
    backendName: "cpu",
    kernelFunc: tanh5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TensorScatterUpdate.js
function tensorScatterUpdate2(args) {
  const { inputs, backend: backend3 } = args;
  const { tensor: tensor153, indices, updates } = inputs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(updates, indices, tensor153.shape);
  const sumDupeIndices = false;
  const indicesBuf = backend3.bufferSync(indices);
  const updatesBuf = backend3.bufferSync(updates);
  const tensorBuf = backend3.bufferSync(tensor153);
  const outBuf = scatterImpl(indicesBuf, updatesBuf, tensor153.shape, outputSize, sliceSize, numUpdates, sliceRank, strides, tensorBuf, sumDupeIndices);
  return backend3.makeTensorInfo(tensor153.shape, outBuf.dtype, outBuf.values);
}
var tensorScatterUpdateConfig;
var init_TensorScatterUpdate = __esm(() => {
  init_dist();
  init_Scatter_impl();
  tensorScatterUpdateConfig = {
    kernelName: TensorScatterUpdate,
    backendName: "cpu",
    kernelFunc: tensorScatterUpdate2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Tile.js
function tile8(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { reps } = attrs;
  assertNotComplex(x, "tile");
  const outBuf = tileImpl(backend3.bufferSync(x), reps);
  return backend3.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
}
var tileConfig;
var init_Tile = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Tile_impl();
  tileConfig = {
    kernelName: Tile,
    backendName: "cpu",
    kernelFunc: tile8
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/TopK.js
function topK(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { k, sorted } = attrs;
  assertNotComplex(x, "topk");
  const xVals = backend3.data.get(x.dataId).values;
  const [allTopKVals, allTopKIndices] = topKImpl(xVals, x.shape, x.dtype, k, sorted);
  return [
    backend3.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
    backend3.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
  ];
}
var topKConfig;
var init_TopK = __esm(() => {
  init_dist();
  init_cpu_util();
  init_TopK_impl();
  topKConfig = {
    kernelName: TopK,
    backendName: "cpu",
    kernelFunc: topK
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Transform.js
function transform3(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { image: image2, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [batch, outHeight, outWidth, numChannels];
  const inStrides = exports_util.computeStrides(image2.shape);
  const batchInStride = inStrides[0];
  const rowInStride = inStrides[1];
  const colInStride = inStrides[2];
  const outStrides = exports_util.computeStrides(outShape);
  const batchOutStride = outStrides[0];
  const rowOutStride = outStrides[1];
  const colOutStride = outStrides[2];
  const outVals = exports_util.getTypedArrayFromDType(image2.dtype, exports_util.sizeFromShape(outShape));
  outVals.fill(fillValue);
  const imageVals = backend3.data.get(image2.dataId).values;
  const transformVals = backend3.data.get(transforms.dataId).values;
  for (let b = 0;b < batch; ++b) {
    const transform4 = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);
    for (let outY = 0;outY < outHeight; ++outY) {
      for (let outX = 0;outX < outWidth; ++outX) {
        for (let channel = 0;channel < numChannels; ++channel) {
          let val;
          const projection = transform4[6] * outX + transform4[7] * outY + 1;
          if (projection === 0) {
            continue;
          }
          const inX = (transform4[0] * outX + transform4[1] * outY + transform4[2]) / projection;
          const inY = (transform4[3] * outX + transform4[4] * outY + transform4[5]) / projection;
          const x = mapCoord(inX, imageWidth, fillMode);
          const y = mapCoord(inY, imageHeight, fillMode);
          switch (interpolation) {
            case "nearest":
              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);
              break;
            case "bilinear":
              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);
              break;
            default:
              throw new Error(`Error in Transform: Expect 'nearest' or ` + `'bilinear', but got ${interpolation}`);
          }
          const ind = b * batchOutStride + outY * rowOutStride + outX * colOutStride + channel;
          outVals[ind] = val;
        }
      }
    }
    return backend3.makeTensorInfo(outShape, image2.dtype, outVals);
  }
  const dataId = backend3.write(outVals, outShape, image2.dtype);
  return { dataId, shape: image2.shape, dtype: image2.dtype };
}
function mapCoord(outCoord, len, mode) {
  switch (mode) {
    case "reflect":
      return mapCoordReflect(outCoord, len);
    case "wrap":
      return mapCoordWrap(outCoord, len);
    case "nearest":
      return mapCoordNearest(outCoord, len);
    case "constant":
    default:
      return mapCoordConstant(outCoord, len);
  }
}
function mapCoordReflect(outCoord, len) {
  let inCoord = outCoord;
  if (inCoord < 0) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz2 = 2 * len;
      if (inCoord < sz2) {
        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;
      }
      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;
    }
  } else if (inCoord > len - 1) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz2 = 2 * len;
      inCoord -= sz2 * Math.trunc(inCoord / sz2);
      if (inCoord >= len) {
        inCoord = sz2 - inCoord - 1;
      }
    }
  }
  return exports_util.clamp(0, inCoord, len - 1);
}
function mapCoordWrap(outCoord, len) {
  let inCoord = outCoord;
  if (inCoord < 0) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz = len - 1;
      inCoord += len * (Math.trunc(-inCoord / sz) + 1);
    }
  } else if (inCoord > len - 1) {
    if (len <= 1) {
      inCoord = 0;
    } else {
      const sz = len - 1;
      inCoord -= len * Math.trunc(inCoord / sz);
    }
  }
  return exports_util.clamp(0, inCoord, len - 1);
}
function mapCoordConstant(outCoord, len) {
  return outCoord;
}
function mapCoordNearest(outCoord, len) {
  return exports_util.clamp(0, outCoord, len - 1);
}
function readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
  const ind = batch * batchStride + y * rowStride + x * colStride + channel;
  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {
    return imageVals[ind];
  } else {
    return fillValue;
  }
}
function nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
  const $y = Math.round(y);
  const $x = Math.round(x);
  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);
}
function bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {
  const yFloor = Math.floor(y);
  const xFloor = Math.floor(x);
  const yCeil = yFloor + 1;
  const xCeil = xFloor + 1;
  const valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);
  const valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);
  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;
}
var transformConfig;
var init_Transform = __esm(() => {
  init_dist();
  transformConfig = {
    kernelName: Transform,
    backendName: "cpu",
    kernelFunc: transform3
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unique.js
function unique5(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { axis } = attrs;
  const { x } = inputs;
  assertNotComplex(x, "unique");
  const values = backend3.data.get(x.dataId).values;
  const { outputValues, outputShape, indices } = uniqueImpl(values, axis, x.shape, x.dtype);
  return [
    backend3.makeTensorInfo(outputShape, x.dtype, outputValues),
    backend3.makeTensorInfo([indices.length], "int32", indices)
  ];
}
var uniqueConfig;
var init_Unique = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Unique_impl();
  uniqueConfig = {
    kernelName: Unique,
    backendName: "cpu",
    kernelFunc: unique5
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Unpack.js
function unpack(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const valueRank = value.shape.length;
  const num = value.shape[axis];
  const outShape = new Array(valueRank - 1);
  let outIndex = 0;
  for (let i = 0;i < valueRank; i++) {
    if (i !== axis) {
      outShape[outIndex++] = value.shape[i];
    }
  }
  const begin = new Array(valueRank).fill(0);
  const size = value.shape.slice();
  size[axis] = 1;
  const res = new Array(num);
  for (let i = 0;i < res.length; i++) {
    begin[axis] = i;
    const tempRes = slice16({ inputs: { x: value }, backend: backend3, attrs: { begin, size } });
    res[i] = reshape77({ inputs: { x: tempRes }, backend: backend3, attrs: { shape: outShape } });
    backend3.disposeIntermediateTensorInfo(tempRes);
  }
  return res;
}
var unpackConfig;
var init_Unpack = __esm(() => {
  init_dist();
  init_Reshape();
  init_Slice();
  unpackConfig = {
    kernelName: Unpack,
    backendName: "cpu",
    kernelFunc: unpack
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/UnsortedSegmentSum.js
function unsortedSegmentSum2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, segmentIds } = inputs;
  const { numSegments } = attrs;
  assertNotComplex(x, "unsortedSegmentSum");
  const xRank = x.shape.length;
  const segmentIdsRank = segmentIds.shape.length;
  const res = [];
  const intermediates = [];
  const numIters = xRank - segmentIdsRank;
  let $segmentIds = segmentIds;
  for (let i = 0;i < numIters; ++i) {
    const expanded = expandDims3({ inputs: { input: $segmentIds }, backend: backend3, attrs: { dim: i + 1 } });
    $segmentIds = expanded;
    intermediates.push(expanded);
  }
  for (let i = 0;i < numSegments; ++i) {
    const scalarValue = exports_util.createScalarValue(i, "int32");
    const segmentId = backend3.makeTensorInfo([], "int32", scalarValue);
    const mask = equal6({ inputs: { a: segmentId, b: $segmentIds }, backend: backend3 });
    const maskCasted = cast46({ inputs: { x: mask }, backend: backend3, attrs: { dtype: "float32" } });
    const mul65 = multiply2({ inputs: { a: maskCasted, b: x }, backend: backend3 });
    const sumTensorInfo = sum27({ inputs: { x: mul65 }, backend: backend3, attrs: { axis: 0, keepDims: false } });
    res.push(sumTensorInfo);
    intermediates.push(segmentId);
    intermediates.push(mask);
    intermediates.push(maskCasted);
    intermediates.push(mul65);
    intermediates.push(sumTensorInfo);
  }
  const result = pack({ inputs: res, backend: backend3, attrs: { axis: 0 } });
  intermediates.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}
var unsortedSegmentSumConfig;
var init_UnsortedSegmentSum = __esm(() => {
  init_dist();
  init_cpu_util();
  init_Cast();
  init_Equal();
  init_ExpandDims();
  init_Multiply();
  init_Pack();
  init_Sum();
  unsortedSegmentSumConfig = {
    kernelName: UnsortedSegmentSum,
    backendName: "cpu",
    kernelFunc: unsortedSegmentSum2
  };
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/register_all_kernels.js
var kernelConfigs;
var init_register_all_kernels = __esm(() => {
  init_dist();
  init__FusedMatMul();
  init_Abs();
  init_Acos();
  init_Acosh();
  init_Add();
  init_AddN();
  init_All();
  init_Any();
  init_ArgMax();
  init_ArgMin();
  init_Asin();
  init_Asinh();
  init_Atan();
  init_Atan2();
  init_Atanh();
  init_AvgPool();
  init_AvgPool3D();
  init_AvgPool3DGrad();
  init_AvgPoolGrad();
  init_BatchMatMul();
  init_BatchNorm();
  init_BatchToSpaceND();
  init_Bincount();
  init_BitwiseAnd();
  init_BroadcastArgs();
  init_Cast();
  init_Ceil();
  init_ClipByValue();
  init_Complex();
  init_ComplexAbs();
  init_Concat();
  init_Conv2D();
  init_Conv2DBackpropFilter();
  init_Conv2DBackpropInput();
  init_Conv3D();
  init_Conv3DBackpropFilterV2();
  init_Conv3DBackpropInputV2();
  init_Cos();
  init_Cosh();
  init_CropAndResize();
  init_Cumprod();
  init_Cumsum();
  init_DenseBincount();
  init_DepthToSpace();
  init_DepthwiseConv2dNative();
  init_DepthwiseConv2dNativeBackpropFilter();
  init_DepthwiseConv2dNativeBackpropInput();
  init_Diag();
  init_Dilation2D();
  init_Dilation2DBackpropFilter();
  init_Dilation2DBackpropInput();
  init_Draw();
  init_Einsum();
  init_Elu();
  init_EluGrad();
  init_Equal();
  init_Erf();
  init_Exp();
  init_ExpandDims();
  init_Expm1();
  init_FFT();
  init_Fill();
  init_FlipLeftRight();
  init_Floor();
  init_FloorDiv();
  init_FusedConv2D();
  init_FusedDepthwiseConv2D();
  init_GatherNd();
  init_GatherV2();
  init_Greater();
  init_GreaterEqual();
  init_Identity();
  init_IFFT();
  init_Imag();
  init_IsFinite();
  init_IsInf();
  init_IsNaN();
  init_LeakyRelu();
  init_Less();
  init_LessEqual();
  init_LinSpace();
  init_Log();
  init_Log1p();
  init_LogicalAnd();
  init_LogicalNot();
  init_LogicalOr();
  init_LRN();
  init_LRNGrad();
  init_Max();
  init_Maximum();
  init_MaxPool();
  init_MaxPool3D();
  init_MaxPool3DGrad();
  init_MaxPoolGrad();
  init_MaxPoolWithArgmax();
  init_Mean();
  init_Min();
  init_Minimum();
  init_MirrorPad();
  init_Mod();
  init_Multinomial();
  init_Multiply();
  init_Neg();
  init_NonMaxSuppressionV3();
  init_NonMaxSuppressionV4();
  init_NonMaxSuppressionV5();
  init_NotEqual();
  init_OneHot();
  init_OnesLike();
  init_Pack();
  init_PadV2();
  init_Pow();
  init_Prelu();
  init_Prod();
  init_RaggedGather();
  init_RaggedRange();
  init_RaggedTensorToTensor();
  init_Range();
  init_Real();
  init_RealDiv();
  init_Reciprocal();
  init_Relu();
  init_Relu6();
  init_Reshape();
  init_ResizeBilinear();
  init_ResizeBilinearGrad();
  init_ResizeNearestNeighbor();
  init_ResizeNearestNeighborGrad();
  init_Reverse();
  init_RotateWithOffset();
  init_Round();
  init_Rsqrt();
  init_ScatterNd();
  init_SearchSorted();
  init_Select();
  init_Selu();
  init_Sigmoid();
  init_Sign();
  init_Sin();
  init_Sinh();
  init_Slice();
  init_Softmax();
  init_Softplus();
  init_SpaceToBatchND();
  init_SparseFillEmptyRows();
  init_SparseReshape();
  init_SparseSegmentMean();
  init_SparseSegmentSum();
  init_SparseToDense();
  init_SplitV();
  init_Sqrt();
  init_Square();
  init_SquaredDifference();
  init_StaticRegexReplace();
  init_Step();
  init_StridedSlice();
  init_StringNGrams();
  init_StringSplit();
  init_StringToHashBucketFast();
  init_Sub();
  init_Sum();
  init_Tan();
  init_Tanh();
  init_TensorScatterUpdate();
  init_Tile();
  init_TopK();
  init_Transform();
  init_Transpose();
  init_Unique();
  init_Unpack();
  init_UnsortedSegmentSum();
  init_ZerosLike();
  kernelConfigs = [
    _fusedMatMulConfig,
    absConfig,
    acosConfig,
    acoshConfig,
    addConfig,
    addNConfig,
    allConfig,
    anyConfig,
    argMaxConfig,
    argMinConfig,
    asinConfig,
    asinhConfig,
    atanConfig,
    atan2Config,
    atanhConfig,
    avgPoolConfig,
    avgPool3DConfig,
    avgPool3DGradConfig2,
    avgPoolGradConfig2,
    batchMatMulConfig,
    batchNormConfig,
    batchToSpaceNDConfig,
    bincountConfig,
    bitwiseAndConfig,
    broadcastArgsConfig,
    castConfig,
    ceilConfig,
    clipByValueConfig,
    complexConfig,
    complexAbsConfig,
    concatConfig,
    conv2DConfig,
    conv2DBackpropFilterConfig,
    conv2DBackpropInputConfig,
    conv3DConfig,
    conv3DBackpropFilterV2Config,
    conv3DBackpropInputV2Config,
    cosConfig,
    coshConfig,
    cropAndResizeConfig,
    cumprodConfig,
    cumsumConfig,
    denseBincountConfig,
    depthToSpaceConfig,
    depthwiseConv2dNativeConfig,
    depthwiseConv2dNativeBackpropFilterConfig,
    depthwiseConv2dNativeBackpropInputConfig,
    diagConfig,
    dilation2DConfig,
    dilation2DBackpropFilterConfig,
    dilation2DBackpropInputConfig,
    drawConfig,
    einsumConfig,
    eluConfig,
    eluGradConfig2,
    equalConfig,
    erfConfig,
    expConfig,
    expandDimsConfig,
    expm1Config,
    fftConfig,
    fillConfig,
    flipLeftRightConfig,
    floorConfig,
    floorDivConfig,
    fusedConv2DConfig,
    fusedDepthwiseConv2DConfig,
    gatherNdConfig,
    gatherV2Config,
    greaterConfig,
    greaterEqualConfig,
    identityConfig,
    ifftConfig,
    imagConfig,
    isFiniteConfig,
    isInfConfig,
    isNaNConfig,
    leakyReluConfig,
    lessConfig,
    lessEqualConfig,
    linSpaceConfig,
    logConfig,
    log1pConfig,
    logicalAndConfig,
    logicalNotConfig,
    logicalOrConfig,
    LRNConfig,
    LRNGradConfig,
    maxConfig,
    maximumConfig,
    maxPoolConfig,
    maxPool3DConfig,
    maxPool3DGradConfig2,
    maxPoolGradConfig2,
    maxPoolWithArgmaxConfig,
    meanConfig,
    minConfig,
    minimumConfig,
    mirrorPadConfig,
    modConfig,
    multinomialConfig,
    multiplyConfig,
    negConfig,
    nonMaxSuppressionV3Config,
    nonMaxSuppressionV4Config,
    nonMaxSuppressionV5Config,
    notEqualConfig,
    oneHotConfig,
    onesLikeConfig,
    packConfig,
    padV2Config,
    powConfig,
    preluConfig,
    prodConfig,
    raggedGatherConfig,
    raggedRangeConfig,
    raggedTensorToTensorConfig,
    rangeConfig,
    realConfig,
    realDivConfig,
    reciprocalConfig,
    reluConfig,
    relu6Config,
    reshapeConfig,
    resizeBilinearConfig,
    resizeBilinearGradConfig2,
    resizeNearestNeighborConfig,
    resizeNearestNeighborGradConfig2,
    reverseConfig,
    rotateWithOffsetConfig,
    roundConfig,
    rsqrtConfig,
    scatterNdConfig,
    searchSortedConfig,
    selectConfig,
    seluConfig,
    sigmoidConfig,
    signConfig,
    sinConfig,
    sinhConfig,
    sliceConfig,
    softmaxConfig,
    softplusConfig,
    spaceToBatchNDConfig,
    sparseFillEmptyRowsConfig,
    sparseReshapeConfig,
    sparseSegmentMeanConfig,
    sparseSegmentSumConfig,
    sparseToDenseConfig,
    splitVConfig,
    sqrtConfig,
    squareConfig,
    squaredDifferenceConfig,
    staticRegexReplaceConfig,
    stepConfig,
    stridedSliceConfig,
    stringNGramsConfig,
    stringSplitConfig,
    stringToHashBucketFastConfig,
    subConfig,
    sumConfig,
    tanConfig,
    tanhConfig,
    tensorScatterUpdateConfig,
    tileConfig,
    topKConfig,
    transformConfig,
    transposeConfig,
    uniqueConfig,
    unpackConfig,
    unsortedSegmentSumConfig,
    zerosLikeConfig
  ];
  for (const kernelConfig of kernelConfigs) {
    registerKernel(kernelConfig);
  }
});

// node_modules/@tensorflow/tfjs-backend-cpu/dist/index.js
var init_dist5 = __esm(() => {
  init_base2();
  init_register_all_kernels();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js
function setWebGLContext(webGLVersion, gl) {
  contexts[webGLVersion] = gl;
}
function getWebGLContext(webGLVersion, customCanvas) {
  if (!(webGLVersion in contexts) || customCanvas != null) {
    const newCtx = getWebGLRenderingContext(webGLVersion, customCanvas);
    if (newCtx !== null) {
      contexts[webGLVersion] = newCtx;
    } else {
      console.log("Could not get context for WebGL version", webGLVersion);
      return null;
    }
  }
  const gl = contexts[webGLVersion];
  if (gl == null || gl.isContextLost()) {
    delete contexts[webGLVersion];
    return getWebGLContext(webGLVersion);
  }
  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.STENCIL_TEST);
  gl.disable(gl.BLEND);
  gl.disable(gl.DITHER);
  gl.disable(gl.POLYGON_OFFSET_FILL);
  gl.disable(gl.SAMPLE_COVERAGE);
  gl.enable(gl.SCISSOR_TEST);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return contexts[webGLVersion];
}
function createCanvas(webGLVersion) {
  if (!env().getBool("IS_SAFARI") && typeof OffscreenCanvas !== "undefined" && webGLVersion === 2) {
    return new OffscreenCanvas(300, 150);
  } else if (typeof document !== "undefined") {
    return document.createElement("canvas");
  } else {
    throw new Error("Cannot create a canvas in this context");
  }
}
function getWebGLRenderingContext(webGLVersion, customCanvas) {
  if (webGLVersion !== 1 && webGLVersion !== 2) {
    throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
  }
  const canvas = customCanvas == null ? createCanvas(webGLVersion) : customCanvas;
  canvas.addEventListener("webglcontextlost", (ev) => {
    ev.preventDefault();
    delete contexts[webGLVersion];
  }, false);
  if (env().getBool("SOFTWARE_WEBGL_ENABLED")) {
    WEBGL_ATTRIBUTES.failIfMajorPerformanceCaveat = false;
  }
  if (webGLVersion === 1) {
    return canvas.getContext("webgl", WEBGL_ATTRIBUTES) || canvas.getContext("experimental-webgl", WEBGL_ATTRIBUTES);
  }
  return canvas.getContext("webgl2", WEBGL_ATTRIBUTES);
}
var contexts, WEBGL_ATTRIBUTES;
var init_canvas_util = __esm(() => {
  init_dist();
  contexts = {};
  WEBGL_ATTRIBUTES = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: true
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
  return [columns, rows];
}
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
  return matrixSize * channelsPerTexture;
}
function getDenseTexShape(shape) {
  const size = exports_util.sizeFromShape(shape);
  const texelsNeeded = Math.ceil(size / 4);
  return exports_util.sizeToSquarishShape(texelsNeeded);
}
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
  return [
    Math.max(1, Math.ceil(columns / 2)),
    Math.max(1, Math.ceil(rows / 2))
  ];
}
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
  const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
  return w * h * 4;
}
function getTextureConfig(gl, textureHalfFloatExtension) {
  const glany = gl;
  let internalFormatFloat;
  let internalFormatHalfFloat;
  let internalFormatPackedHalfFloat;
  let internalFormatPackedFloat;
  let textureFormatFloat;
  let downloadTextureFormat;
  let downloadUnpackNumChannels;
  let defaultNumChannels;
  let textureTypeHalfFloat;
  let textureTypeFloat;
  if (env().getNumber("WEBGL_VERSION") === 2) {
    internalFormatFloat = glany.R32F;
    internalFormatHalfFloat = glany.R16F;
    internalFormatPackedHalfFloat = glany.RGBA16F;
    internalFormatPackedFloat = glany.RGBA32F;
    textureFormatFloat = glany.RED;
    downloadUnpackNumChannels = 4;
    defaultNumChannels = 1;
    textureTypeHalfFloat = glany.HALF_FLOAT;
    textureTypeFloat = glany.FLOAT;
    downloadTextureFormat = glany.RGBA8;
  } else {
    internalFormatFloat = gl.RGBA;
    internalFormatHalfFloat = gl.RGBA;
    internalFormatPackedHalfFloat = gl.RGBA;
    internalFormatPackedFloat = glany.RGBA;
    textureFormatFloat = gl.RGBA;
    downloadUnpackNumChannels = 4;
    defaultNumChannels = 4;
    textureTypeHalfFloat = textureHalfFloatExtension != null ? textureHalfFloatExtension.HALF_FLOAT_OES : null;
    textureTypeFloat = gl.FLOAT;
    downloadTextureFormat = gl.RGBA;
  }
  return {
    internalFormatFloat,
    internalFormatHalfFloat,
    internalFormatPackedHalfFloat,
    internalFormatPackedFloat,
    textureFormatFloat,
    downloadTextureFormat,
    downloadUnpackNumChannels,
    defaultNumChannels,
    textureTypeHalfFloat,
    textureTypeFloat
  };
}
var PackingScheme, TextureUsage, PhysicalTextureType;
var init_tex_util = __esm(() => {
  init_dist();
  (function(PackingScheme2) {
    PackingScheme2[PackingScheme2["DENSE"] = 0] = "DENSE";
    PackingScheme2[PackingScheme2["SHARED_BATCH"] = 1] = "SHARED_BATCH";
  })(PackingScheme || (PackingScheme = {}));
  (function(TextureUsage2) {
    TextureUsage2[TextureUsage2["RENDER"] = 0] = "RENDER";
    TextureUsage2[TextureUsage2["UPLOAD"] = 1] = "UPLOAD";
    TextureUsage2[TextureUsage2["PIXELS"] = 2] = "PIXELS";
    TextureUsage2[TextureUsage2["DOWNLOAD"] = 3] = "DOWNLOAD";
  })(TextureUsage || (TextureUsage = {}));
  (function(PhysicalTextureType2) {
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16";
    PhysicalTextureType2[PhysicalTextureType2["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32";
    PhysicalTextureType2[PhysicalTextureType2["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
  })(PhysicalTextureType || (PhysicalTextureType = {}));
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js
var exports_webgl_util = {};
__export(exports_webgl_util, {
  validateTextureSize: () => validateTextureSize,
  validateProgram: () => validateProgram,
  validateFramebuffer: () => validateFramebuffer,
  unbindTextureUnit: () => unbindTextureUnit,
  unbindColorTextureFromFramebuffer: () => unbindColorTextureFromFramebuffer,
  resetMaxTexturesInShader: () => resetMaxTexturesInShader,
  resetMaxTextureSize: () => resetMaxTextureSize,
  logShaderSourceAndInfoLog: () => logShaderSourceAndInfoLog,
  linkProgram: () => linkProgram,
  isWebGLVersionEnabled: () => isWebGLVersionEnabled,
  isWebGLFenceEnabled: () => isWebGLFenceEnabled,
  isReshapeFree: () => isReshapeFree,
  isDownloadFloatTextureEnabled: () => isDownloadFloatTextureEnabled,
  isCapableOfRenderingToFloatTexture: () => isCapableOfRenderingToFloatTexture,
  hasExtension: () => hasExtension,
  getWebGLMaxTextureSize: () => getWebGLMaxTextureSize,
  getWebGLErrorMessage: () => getWebGLErrorMessage,
  getWebGLDisjointQueryTimerVersion: () => getWebGLDisjointQueryTimerVersion,
  getTextureShapeFromLogicalShape: () => getTextureShapeFromLogicalShape,
  getShapeAs3D: () => getShapeAs3D,
  getRowsCols: () => getRowsCols,
  getProgramUniformLocationOrThrow: () => getProgramUniformLocationOrThrow,
  getProgramUniformLocation: () => getProgramUniformLocation,
  getNumChannels: () => getNumChannels,
  getMaxTexturesInShader: () => getMaxTexturesInShader,
  getFramebufferErrorMessage: () => getFramebufferErrorMessage,
  getExtensionOrThrow: () => getExtensionOrThrow,
  getBatchDim: () => getBatchDim,
  createVertexShader: () => createVertexShader,
  createTexture: () => createTexture,
  createStaticVertexBuffer: () => createStaticVertexBuffer,
  createStaticIndexBuffer: () => createStaticIndexBuffer,
  createProgram: () => createProgram,
  createFramebuffer: () => createFramebuffer,
  createFragmentShader: () => createFragmentShader,
  canBeRepresented: () => canBeRepresented,
  callAndCheck: () => callAndCheck,
  bindVertexBufferToProgramAttribute: () => bindVertexBufferToProgramAttribute,
  bindTextureUnit: () => bindTextureUnit,
  bindTextureToProgramUniformSampler: () => bindTextureToProgramUniformSampler,
  bindColorTextureToFramebuffer: () => bindColorTextureToFramebuffer,
  bindCanvasToFramebuffer: () => bindCanvasToFramebuffer,
  assertNotComplex: () => assertNotComplex2
});
function callAndCheck(gl, func2) {
  const returnValue = func2();
  if (env().getBool("DEBUG")) {
    checkWebGLError(gl);
  }
  return returnValue;
}
function checkWebGLError(gl) {
  const error = gl.getError();
  if (error !== gl.NO_ERROR) {
    throw new Error("WebGL Error: " + getWebGLErrorMessage(gl, error));
  }
}
function canBeRepresented(num) {
  if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {
    return true;
  }
  return false;
}
function getWebGLErrorMessage(gl, status) {
  switch (status) {
    case gl.NO_ERROR:
      return "NO_ERROR";
    case gl.INVALID_ENUM:
      return "INVALID_ENUM";
    case gl.INVALID_VALUE:
      return "INVALID_VALUE";
    case gl.INVALID_OPERATION:
      return "INVALID_OPERATION";
    case gl.INVALID_FRAMEBUFFER_OPERATION:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case gl.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case gl.CONTEXT_LOST_WEBGL:
      return "CONTEXT_LOST_WEBGL";
    default:
      return `Unknown error code ${status}`;
  }
}
function getExtensionOrThrow(gl, extensionName) {
  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension "' + extensionName + '" not supported on this browser.');
}
function createVertexShader(gl, vertexShaderSource) {
  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));
  callAndCheck(gl, () => gl.compileShader(vertexShader));
  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
    console.log(gl.getShaderInfoLog(vertexShader));
    throw new Error("Failed to compile vertex shader.");
  }
  return vertexShader;
}
function createFragmentShader(gl, fragmentShaderSource) {
  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));
  callAndCheck(gl, () => gl.compileShader(fragmentShader));
  if (env().get("ENGINE_COMPILE_ONLY")) {
    return fragmentShader;
  }
  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
    throw new Error("Failed to compile fragment shader.");
  }
  return fragmentShader;
}
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
  if (lineNumberRegexResult == null) {
    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);
    console.log(shaderSource);
    return;
  }
  const lineNumber = +lineNumberRegexResult[1];
  const shaderLines = shaderSource.split("\n");
  const pad9 = shaderLines.length.toString().length + 2;
  const linesWithLineNumbers = shaderLines.map((line, lineNumber2) => exports_util.rightPad((lineNumber2 + 1).toString(), pad9) + line);
  let maxLineLength = 0;
  for (let i = 0;i < linesWithLineNumbers.length; i++) {
    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
  }
  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);
  console.log(beforeErrorLines.join("\n"));
  console.log(shaderInfoLog.split("\n")[0]);
  console.log(`%c ${exports_util.rightPad(errorLine[0], maxLineLength)}`, "border:1px solid red; background-color:#e3d2d2; color:#a61717");
  console.log(afterErrorLines.join("\n"));
}
function createProgram(gl) {
  return throwIfNull(gl, () => gl.createProgram(), "Unable to create WebGLProgram.");
}
function linkProgram(gl, program) {
  callAndCheck(gl, () => gl.linkProgram(program));
  if (env().get("ENGINE_COMPILE_ONLY")) {
    return;
  }
  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
    console.log(gl.getProgramInfoLog(program));
    throw new Error("Failed to link vertex and fragment shaders.");
  }
}
function validateProgram(gl, program) {
  callAndCheck(gl, () => gl.validateProgram(program));
  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
    console.log(gl.getProgramInfoLog(program));
    throw new Error("Shader program validation failed.");
  }
}
function createStaticVertexBuffer(gl, data) {
  const buffer9 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer9));
  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));
  return buffer9;
}
function createStaticIndexBuffer(gl, data) {
  const buffer9 = throwIfNull(gl, () => gl.createBuffer(), "Unable to create WebGLBuffer");
  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer9));
  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));
  return buffer9;
}
function getNumChannels() {
  if (env().getNumber("WEBGL_VERSION") === 2) {
    return 1;
  }
  return 4;
}
function createTexture(gl) {
  return throwIfNull(gl, () => gl.createTexture(), "Unable to create WebGLTexture.");
}
function validateTextureSize(width, height) {
  const maxTextureSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  if (width <= 0 || height <= 0) {
    const requested = `[${width}x${height}]`;
    throw new Error("Requested texture size " + requested + " is invalid.");
  }
  if (width > maxTextureSize || height > maxTextureSize) {
    const requested = `[${width}x${height}]`;
    const max9 = `[${maxTextureSize}x${maxTextureSize}]`;
    throw new Error("Requested texture size " + requested + " greater than WebGL maximum on this browser / GPU " + max9 + ".");
  }
}
function createFramebuffer(gl) {
  return throwIfNull(gl, () => gl.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer9, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
  const loc = gl.getAttribLocation(program, attribute);
  if (loc === -1) {
    return false;
  }
  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer9));
  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));
  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));
  return true;
}
function bindTextureUnit(gl, texture, textureUnit) {
  validateTextureUnit(gl, textureUnit);
  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
}
function unbindTextureUnit(gl, textureUnit) {
  validateTextureUnit(gl, textureUnit);
  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform "' + uniformName + '" not present in program.');
}
function getProgramUniformLocation(gl, program, uniformName) {
  return gl.getUniformLocation(program, uniformName);
}
function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {
  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));
  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));
}
function bindCanvasToFramebuffer(gl) {
  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));
  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));
}
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));
}
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));
  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));
}
function validateFramebuffer(gl) {
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    throw new Error("Error binding framebuffer: " + getFramebufferErrorMessage(gl, status));
  }
}
function getFramebufferErrorMessage(gl, status) {
  switch (status) {
    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case gl.FRAMEBUFFER_UNSUPPORTED:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return `unknown error ${status}`;
  }
}
function throwIfNull(gl, returnTOrNull, failureMessage) {
  const tOrNull = callAndCheck(gl, () => returnTOrNull());
  if (tOrNull == null) {
    throw new Error(failureMessage);
  }
  return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
  const glTextureUnit = textureUnit + gl.TEXTURE0;
  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;
    throw new Error(`textureUnit must be in ${textureUnitRange}.`);
  }
}
function getBatchDim(shape, dimsToSkip = 2) {
  return exports_util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));
}
function getRowsCols(shape) {
  if (shape.length === 0) {
    throw Error("Cannot get rows and columns of an empty shape array.");
  }
  return [
    shape.length > 1 ? shape[shape.length - 2] : 1,
    shape[shape.length - 1]
  ];
}
function getShapeAs3D(shape) {
  let shapeAs3D = [1, 1, 1];
  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;
  if (!isScalar) {
    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];
  }
  return shapeAs3D;
}
function getTextureShapeFromLogicalShape(logShape, isPacked = false) {
  let maxTexSize = env().getNumber("WEBGL_MAX_TEXTURE_SIZE");
  let maxSizeForNarrowTex = env().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
  if (maxSizeForNarrowTex === Infinity && env().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")) {
    maxSizeForNarrowTex = maxTexSize / 2;
  }
  if (isPacked) {
    maxTexSize = maxTexSize * 2;
    maxSizeForNarrowTex = maxSizeForNarrowTex * 2;
    logShape = logShape.map((d, i) => i >= logShape.length - 2 ? exports_util.nearestLargerEven(logShape[i]) : logShape[i]);
    if (logShape.length === 1) {
      logShape = [2, logShape[0]];
    }
  }
  if (logShape.length !== 2) {
    const squeezeResult = exports_util.squeezeShape(logShape);
    logShape = squeezeResult.newShape;
  }
  let size = exports_util.sizeFromShape(logShape);
  let textureShape = null;
  if (logShape.length <= 1 && size <= maxTexSize) {
    textureShape = [1, size];
  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {
    textureShape = logShape;
  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {
    textureShape = [logShape[0] * logShape[1], logShape[2]];
  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {
    textureShape = [logShape[0], logShape[1] * logShape[2]];
  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {
    textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];
  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
    textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];
  }
  const isLongNarrowTex = textureShape != null && Math.max(...textureShape) > maxSizeForNarrowTex && Math.min(...textureShape) <= (isPacked ? 2 : 1) && Math.min(...textureShape) > 0;
  if (textureShape == null || isLongNarrowTex) {
    if (isPacked) {
      const batchDim = getBatchDim(logShape);
      let rows = 2, cols = 2;
      if (logShape.length) {
        [rows, cols] = getRowsCols(logShape);
      }
      size = batchDim * (rows / 2) * (cols / 2);
      textureShape = exports_util.sizeToSquarishShape(size).map((d) => d * 2);
    } else {
      textureShape = exports_util.sizeToSquarishShape(size);
    }
  }
  return textureShape;
}
function isEven(n) {
  return n % 2 === 0;
}
function isReshapeFree(shape1, shape2) {
  shape1 = shape1.slice(-2);
  shape2 = shape2.slice(-2);
  if (exports_util.arraysEqual(shape1, shape2)) {
    return true;
  }
  if (!shape1.length || !shape2.length) {
    return true;
  }
  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {
    return true;
  }
  if (shape1.length !== shape2.length) {
    const shape1Cols = shape1[shape1.length - 1];
    const shape2Cols = shape2[shape2.length - 1];
    if (shape1Cols === shape2Cols) {
      return true;
    }
    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {
      return true;
    }
  }
  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);
}
function getWebGLMaxTextureSize(webGLVersion) {
  if (MAX_TEXTURE_SIZE == null) {
    const gl = getWebGLContext(webGLVersion);
    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  }
  return MAX_TEXTURE_SIZE;
}
function resetMaxTextureSize() {
  MAX_TEXTURE_SIZE = null;
}
function resetMaxTexturesInShader() {
  MAX_TEXTURES_IN_SHADER = null;
}
function getMaxTexturesInShader(webGLVersion) {
  if (MAX_TEXTURES_IN_SHADER == null) {
    const gl = getWebGLContext(webGLVersion);
    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  }
  return Math.min(16, MAX_TEXTURES_IN_SHADER);
}
function getWebGLDisjointQueryTimerVersion(webGLVersion) {
  if (webGLVersion === 0) {
    return 0;
  }
  let queryTimerVersion;
  const gl = getWebGLContext(webGLVersion);
  if (hasExtension(gl, "EXT_disjoint_timer_query_webgl2") && webGLVersion === 2) {
    queryTimerVersion = 2;
  } else if (hasExtension(gl, "EXT_disjoint_timer_query")) {
    queryTimerVersion = 1;
  } else {
    queryTimerVersion = 0;
  }
  return queryTimerVersion;
}
function hasExtension(gl, extensionName) {
  const ext = gl.getExtension(extensionName);
  return ext != null;
}
function isWebGLVersionEnabled(webGLVersion) {
  try {
    const gl = getWebGLContext(webGLVersion);
    if (gl != null) {
      return true;
    }
  } catch (e) {
    console.log("Error when getting WebGL context: ", e);
    return false;
  }
  return false;
}
function isCapableOfRenderingToFloatTexture(webGLVersion) {
  if (webGLVersion === 0) {
    return false;
  }
  const gl = getWebGLContext(webGLVersion);
  if (webGLVersion === 1) {
    if (!hasExtension(gl, "OES_texture_float")) {
      return false;
    }
  } else {
    if (!hasExtension(gl, "EXT_color_buffer_float")) {
      return false;
    }
  }
  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
  return isFrameBufferComplete;
}
function isDownloadFloatTextureEnabled(webGLVersion) {
  if (webGLVersion === 0) {
    return false;
  }
  const gl = getWebGLContext(webGLVersion);
  if (webGLVersion === 1) {
    if (!hasExtension(gl, "OES_texture_float")) {
      return false;
    }
    if (!hasExtension(gl, "WEBGL_color_buffer_float")) {
      return false;
    }
  } else {
    if (hasExtension(gl, "EXT_color_buffer_float")) {
      return createFloatTextureAndBindToFramebuffer(gl);
    }
    const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {
      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);
    }
    return false;
  }
  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);
  return isFrameBufferComplete;
}
function createFloatTextureAndBindToFramebuffer(gl) {
  const texConfig = getTextureConfig(gl);
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  const width = 1;
  const height = 1;
  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteTexture(texture);
  gl.deleteFramebuffer(frameBuffer);
  return isFrameBufferComplete;
}
function createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension) {
  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  const width = 1;
  const height = 1;
  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteTexture(texture);
  gl.deleteFramebuffer(frameBuffer);
  return isFrameBufferComplete;
}
function isWebGLFenceEnabled(webGLVersion) {
  if (webGLVersion !== 2) {
    return false;
  }
  const gl = getWebGLContext(webGLVersion);
  const isEnabled = gl.fenceSync != null;
  return isEnabled;
}
function assertNotComplex2(tensor153, opName) {
  if (!Array.isArray(tensor153)) {
    tensor153 = [tensor153];
  }
  tensor153.forEach((t) => {
    if (t != null) {
      exports_util.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors ` + "in the WebGL backend.");
    }
  });
}
var MIN_FLOAT16 = 0.0000000596, MAX_FLOAT16 = 65504, lineNumberRegex, MAX_TEXTURE_SIZE, MAX_TEXTURES_IN_SHADER;
var init_webgl_util = __esm(() => {
  init_dist();
  init_canvas_util();
  init_tex_util();
  lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js
var ENV5;
var init_flags_webgl = __esm(() => {
  init_dist();
  init_webgl_util();
  ENV5 = env();
  ENV5.registerFlag("HAS_WEBGL", () => ENV5.getNumber("WEBGL_VERSION") > 0);
  ENV5.registerFlag("WEBGL_VERSION", () => {
    if (isWebGLVersionEnabled(2)) {
      return 2;
    } else if (isWebGLVersionEnabled(1)) {
      return 1;
    }
    return 0;
  });
  ENV5.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false);
  ENV5.registerFlag("WEBGL_BUFFER_SUPPORTED", () => ENV5.get("WEBGL_VERSION") === 2);
  ENV5.registerFlag("WEBGL_CPU_FORWARD", () => true);
  ENV5.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => false);
  ENV5.registerFlag("WEBGL_PACK", () => ENV5.getBool("HAS_WEBGL"));
  ENV5.registerFlag("WEBGL_PACK_NORMALIZATION", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_CLIP", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_REDUCE", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_LAZILY_UNPACK", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_CONV_IM2COL", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => ENV5.getBool("WEBGL_PACK"));
  ENV5.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => getWebGLMaxTextureSize(ENV5.getNumber("WEBGL_VERSION")));
  ENV5.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => getMaxTexturesInShader(ENV5.getNumber("WEBGL_VERSION")));
  ENV5.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    const webGLVersion = ENV5.getNumber("WEBGL_VERSION");
    if (webGLVersion === 0) {
      return 0;
    }
    return getWebGLDisjointQueryTimerVersion(webGLVersion);
  });
  ENV5.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => ENV5.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !exports_device_util.isMobile());
  ENV5.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => isCapableOfRenderingToFloatTexture(ENV5.getNumber("WEBGL_VERSION")));
  ENV5.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => {
    return ENV5.getBool("WEBGL_FORCE_F16_TEXTURES") ? false : ENV5.getBool("WEBGL_RENDER_FLOAT32_CAPABLE");
  });
  ENV5.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => isDownloadFloatTextureEnabled(ENV5.getNumber("WEBGL_VERSION")));
  ENV5.registerFlag("WEBGL_FENCE_API_ENABLED", () => isWebGLFenceEnabled(ENV5.getNumber("WEBGL_VERSION")));
  ENV5.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => {
    const useUniforms = ENV5.getBool("WEBGL_RENDER_FLOAT32_ENABLED");
    return useUniforms ? 4 : 0;
  });
  ENV5.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => {
    return -1;
  }, (threshold4) => {
    if (!(typeof threshold4 === "number")) {
      throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but " + `got ${threshold4}.`);
    }
    if (threshold4 < 0 && threshold4 !== -1) {
      throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` + `delete) or at least 0, but got ${threshold4}.`);
    }
  });
  ENV5.registerFlag("WEBGL_FLUSH_THRESHOLD", () => {
    return exports_device_util.isMobile() ? 1 : -1;
  }, (threshold4) => {
    if (!(typeof threshold4 === "number")) {
      throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got " + `${threshold4}.`);
    }
    if (threshold4 < 0 && threshold4 !== -1) {
      throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never ` + `manual flush) or at least 0, but got ${threshold4}.`);
    }
  });
  ENV5.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128);
  ENV5.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => false);
  ENV5.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5);
  ENV5.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128);
  ENV5.registerFlag("WEBGL_EXP_CONV", () => false);
  ENV5.registerFlag("SOFTWARE_WEBGL_ENABLED", () => ENV5.getBool("IS_TEST"));
  ENV5.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => Infinity);
  ENV5.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false);
  ENV5.registerFlag("WEBGL2_ISNAN_CUSTOM", () => false);
  ENV5.registerFlag("ENGINE_COMPILE_ONLY", () => false);
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js
function getGlslDifferences() {
  let version9;
  let attribute;
  let varyingVs;
  let varyingFs;
  let texture2D;
  let output;
  let defineOutput;
  let defineSpecialNaN;
  let defineSpecialInf;
  let defineRound;
  if (env().getNumber("WEBGL_VERSION") === 2) {
    version9 = "#version 300 es";
    attribute = "in";
    varyingVs = "out";
    varyingFs = "in";
    texture2D = "texture";
    output = "outputColor";
    defineOutput = "out vec4 outputColor;";
    defineSpecialNaN = env().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "";
    defineSpecialInf = ``;
    defineRound = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
  } else {
    version9 = "";
    attribute = "attribute";
    varyingVs = "varying";
    varyingFs = "varying";
    texture2D = "texture2D";
    output = "gl_FragColor";
    defineOutput = "";
    defineSpecialNaN = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `;
    defineSpecialInf = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `;
    defineRound = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `;
  }
  return {
    version: version9,
    attribute,
    varyingVs,
    varyingFs,
    texture2D,
    output,
    defineOutput,
    defineSpecialNaN,
    defineSpecialInf,
    defineRound
  };
}
var init_glsl_version = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js
function getLogicalCoordinatesFromFlatIndex(coords, shape, index = "index") {
  const strides = exports_util.computeStrides(shape);
  return strides.map((stride, i) => {
    const line1 = `int ${coords[i]} = ${index} / ${stride}`;
    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;
    return `${line1}; ${line2};`;
  }).join("");
}
function getOutputLogicalCoordinatesFromFlatIndexByUniform(coords, shape, index = "index") {
  const strides = exports_util.computeStrides(shape);
  return strides.map((_, i) => {
    const line1 = `int ${coords[i]} = ${index} / outShapeStrides[${i}]`;
    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * outShapeStrides[${i}]` : `index -= ${coords[i]} * outShapeStrides[${i}]`;
    return `${line1}; ${line2};`;
  }).join("");
}
function symbolicallyComputeStrides(indicesArr, variableName) {
  const numCoords = indicesArr.length;
  const shape = indicesArr.map((d) => `${variableName}[${d}]`);
  const strides = new Array(numCoords - 1);
  strides[numCoords - 2] = shape[numCoords - 1];
  for (let i = numCoords - 3;i >= 0; --i) {
    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;
  }
  return strides;
}
function getLogicalCoordinatesFromFlatIndexByUniform(coords, variableName, index = "index") {
  const indicesArray = coords.map((_, i) => i);
  const strides = symbolicallyComputeStrides(indicesArray, variableName);
  return strides.map((_, i) => {
    const line1 = `int ${coords[i]} = ${index} / ${strides[i]}`;
    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${strides[i]}` : `index -= ${coords[i]} * ${strides[i]}`;
    return `${line1}; ${line2};`;
  }).join("");
}
function getFlatIndexFrom3D(shape) {
  const strides = exports_util.computeStrides(shape).map((d) => d.toString());
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;
  }
`;
}
function getFlatIndexFrom3DOutput() {
  return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`;
}
var ENCODE_FLOAT_SNIPPET = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;
var init_shader_compiler_util = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js
function makeShader(inputsInfo, outputShape, program) {
  const prefixSnippets = [];
  inputsInfo.forEach((x) => {
    const size = exports_util.sizeFromShape(x.shapeInfo.logicalShape);
    if (x.shapeInfo.isUniform) {
      prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ""};`);
    } else {
      prefixSnippets.push(`uniform sampler2D ${x.name};`);
      prefixSnippets.push(`uniform int offset${x.name};`);
    }
    if (program.enableShapeUniforms) {
      const { uniformShape } = getUniformInfoFromShape(program.packedInputs, x.shapeInfo.logicalShape, x.shapeInfo.texShape);
      switch (uniformShape.length) {
        case 1:
          prefixSnippets.push(`uniform int ${x.name}Shape;`);
          break;
        case 2:
          prefixSnippets.push(`uniform ivec2 ${x.name}Shape;`);
          break;
        case 3:
          prefixSnippets.push(`uniform ivec3 ${x.name}Shape;`);
          break;
        case 4:
          prefixSnippets.push(`uniform ivec4 ${x.name}Shape;`);
          break;
        default:
          break;
      }
      prefixSnippets.push(`uniform ivec2 ${x.name}TexShape;`);
    }
  });
  if (program.enableShapeUniforms) {
    switch (outputShape.logicalShape.length) {
      case 1:
        prefixSnippets.push(`uniform int outShape;`);
        break;
      case 2:
        prefixSnippets.push(`uniform ivec2 outShape;`);
        prefixSnippets.push(`uniform int outShapeStrides;`);
        break;
      case 3:
        prefixSnippets.push(`uniform ivec3 outShape;`);
        prefixSnippets.push(`uniform ivec2 outShapeStrides;`);
        break;
      case 4:
        prefixSnippets.push(`uniform ivec4 outShape;`);
        prefixSnippets.push(`uniform ivec3 outShapeStrides;`);
        break;
      default:
        break;
    }
    prefixSnippets.push(`uniform ivec2 outTexShape;`);
  }
  if (program.customUniforms) {
    program.customUniforms.forEach((d) => {
      prefixSnippets.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ""};`);
    });
  }
  const inputPrefixSnippet = prefixSnippets.join("\n");
  const inputSamplingSnippet = inputsInfo.map((x) => getInputSamplingSnippet(x, outputShape, program.packedInputs, program.enableShapeUniforms)).join("\n");
  const outTexShape = outputShape.texShape;
  const glsl = getGlslDifferences();
  const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);
  let outputSamplingSnippet;
  let floatTextureSetOutputSnippet;
  let shaderPrefix = getShaderPrefix(glsl);
  if (outputShape.isPacked) {
    outputSamplingSnippet = getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
    floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);
  } else {
    outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape, program.enableShapeUniforms);
    floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);
  }
  if (program.packedInputs) {
    shaderPrefix += SHADER_PACKED_PREFIX;
  }
  const source = [
    shaderPrefix,
    floatTextureSampleSnippet,
    floatTextureSetOutputSnippet,
    inputPrefixSnippet,
    outputSamplingSnippet,
    inputSamplingSnippet,
    program.userCode
  ].join("\n");
  return source;
}
function getSamplerFromInInfo(inInfo, enableShapeUniforms = false) {
  const shape = inInfo.shapeInfo.logicalShape;
  switch (shape.length) {
    case 0:
      return getSamplerScalar(inInfo, enableShapeUniforms);
    case 1:
      return getSampler1D(inInfo, enableShapeUniforms);
    case 2:
      return getSampler2D(inInfo, enableShapeUniforms);
    case 3:
      return getSampler3D(inInfo, enableShapeUniforms);
    case 4:
      return getSampler4D(inInfo, enableShapeUniforms);
    case 5:
      return getSampler5D(inInfo);
    case 6:
      return getSampler6D(inInfo);
    default:
      throw new Error(`${shape.length}-D input sampling` + ` is not yet supported`);
  }
}
function getPackedSamplerFromInInfo(inInfo, enableShapeUniforms) {
  const shape = inInfo.shapeInfo.logicalShape;
  switch (shape.length) {
    case 0:
      return getPackedSamplerScalar(inInfo);
    case 1:
      return getPackedSampler1D(inInfo, enableShapeUniforms);
    case 2:
      return getPackedSampler2D(inInfo, enableShapeUniforms);
    case 3:
      return getPackedSampler3D(inInfo, enableShapeUniforms);
    default:
      return getPackedSamplerND(inInfo, enableShapeUniforms);
  }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false, enableShapeUniforms) {
  let res = "";
  if (usesPackedTextures) {
    res += getPackedSamplerFromInInfo(inInfo, enableShapeUniforms);
  } else {
    res += getSamplerFromInInfo(inInfo, enableShapeUniforms);
  }
  const inShape = inInfo.shapeInfo.logicalShape;
  const outShape = outShapeInfo.logicalShape;
  if (inShape.length <= outShape.length) {
    if (usesPackedTextures) {
      res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);
    } else {
      res += getSamplerAtOutputCoords(inInfo, outShapeInfo);
    }
  }
  return res;
}
function getPackedOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
  switch (outShape.length) {
    case 0:
      return getOutputScalarCoords();
    case 1:
      return getOutputPacked1DCoords(outShape, outTexShape, enableShapeUniforms);
    case 2:
      return getOutputPacked2DCoords(outShape, outTexShape, enableShapeUniforms);
    case 3:
      return getOutputPacked3DCoords(outShape, outTexShape, enableShapeUniforms);
    default:
      return getOutputPackedNDCoords(outShape, outTexShape, enableShapeUniforms);
  }
}
function getOutputSamplingSnippet(outShape, outTexShape, enableShapeUniforms) {
  switch (outShape.length) {
    case 0:
      return getOutputScalarCoords();
    case 1:
      return getOutput1DCoords(outShape, outTexShape, enableShapeUniforms);
    case 2:
      return getOutput2DCoords(outShape, outTexShape, enableShapeUniforms);
    case 3:
      return getOutput3DCoords(outShape, outTexShape, enableShapeUniforms);
    case 4:
      return getOutput4DCoords(outShape, outTexShape, enableShapeUniforms);
    case 5:
      return getOutput5DCoords(outShape, outTexShape);
    case 6:
      return getOutput6DCoords(outShape, outTexShape);
    default:
      throw new Error(`${outShape.length}-D output sampling is not yet supported`);
  }
}
function getFloatTextureSampleSnippet(glsl) {
  return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${glsl.texture2D}(textureSampler, uv).r;
    }
  `;
}
function getFloatTextureSetRSnippet(glsl) {
  return `
    void setOutput(float val) {
      ${glsl.output} = vec4(val, 0, 0, 0);
    }
  `;
}
function getFloatTextureSetRGBASnippet(glsl) {
  return `
    void setOutput(vec4 val) {
      ${glsl.output} = val;
    }
  `;
}
function getShaderPrefix(glsl) {
  const SHADER_PREFIX = `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFs} vec2 resultUV;
    ${glsl.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${glsl.defineSpecialNaN}
    ${glsl.defineSpecialInf}
    ${glsl.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `;
  return SHADER_PREFIX;
}
function getOutputScalarCoords() {
  return `
    int getOutputCoords() {
      return 0;
    }
  `;
}
function getOutputPacked1DCoords(shape, texShape, enableShapeUniforms) {
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  if (packedTexShape[0] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);
      }
    `;
  }
  if (packedTexShape[1] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `;
  }
  return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);
    }
  `;
}
function getOutput1DCoords(shape, texShape, enableShapeUniforms) {
  if (texShape[0] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return int(resultUV.x * ${texShape[1]}.0);
      }
    `;
  }
  if (texShape[1] === 1) {
    if (enableShapeUniforms) {
      return `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `;
    }
    return `
      int getOutputCoords() {
        return int(resultUV.y * ${texShape[0]}.0);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `;
  }
  return `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      return resTexRC.x * ${texShape[1]} + resTexRC.y;
    }
  `;
}
function getOutputPacked3DCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const texelsInLogicalRow = Math.ceil(shape[2] / 2);
  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec3(b, r, c);
    }
  `;
}
function getOutput3DCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], shape);
    return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${coordsFromIndexSnippet2}
    return ivec3(r, c, d);
  }
`;
  }
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
  return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}
function getOutputPackedNDCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);
  const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);
  let texelsInBatchN = texelsInBatch;
  let batches = ``;
  let coords = "b, r, c";
  for (let b = 2;b < shape.length - 1; b++) {
    texelsInBatchN *= shape[shape.length - b - 1];
    batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
    coords = `b${b}, ` + coords;
  }
  return `
    ivec${shape.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;

      ${batches}

      int b = index / ${texelsInBatch};
      index -= b * ${texelsInBatch};

      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec${shape.length}(${coords});
    }
  `;
}
function getOutput4DCoords(shape, texShape, enableShapeUniforms) {
  if (enableShapeUniforms) {
    const coordsFromIndexSnippet2 = getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d", "d2"], shape);
    return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${coordsFromIndexSnippet2}
      return ivec4(r, c, d, d2);
    }
  `;
  }
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2"], shape);
  return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      ${coordsFromIndexSnippet}
      return ivec4(r, c, d, d2);
    }
  `;
}
function getOutput5DCoords(shape, texShape) {
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3"], shape);
  return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},
                             ${texShape[1]}));

      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
}
function getOutput6DCoords(shape, texShape) {
  const coordsFromIndexSnippet = getLogicalCoordinatesFromFlatIndex(["r", "c", "d", "d2", "d3", "d4"], shape);
  return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;

      ${coordsFromIndexSnippet}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
}
function getOutputPacked2DCoords(shape, texShape, enableShapeUniforms) {
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  if (exports_util.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
      }
    `;
  }
  const texelsInLogicalRow = Math.ceil(shape[1] / 2);
  if (enableShapeUniforms) {
    return `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `;
  }
  return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;
      int r = 2 * (index / ${texelsInLogicalRow});
      int c = imod(index, ${texelsInLogicalRow}) * 2;

      return ivec2(r, c);
    }
  `;
}
function getOutput2DCoords(shape, texShape, enableShapeUniforms) {
  if (exports_util.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));
      }
    `;
  }
  if (shape[1] === 1) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `;
  }
  if (shape[0] === 1) {
    if (enableShapeUniforms) {
      return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `;
    }
    return `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${texShape[0]}, ${texShape[1]}));
        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `;
  }
  return `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${texShape[0]}, ${texShape[1]}));
      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;
      int r = index / ${shape[1]};
      int c = index - r * ${shape[1]};
      return ivec2(r, c);
    }
  `;
}
function getFlatOffsetUniformName(texName) {
  return `offset${texName}`;
}
function getPackedSamplerScalar(inputInfo) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const glsl = getGlslDifferences();
  return `
    vec4 ${funcName}() {
      return ${glsl.texture2D}(${texName}, halfCR);
    }
  `;
}
function getSamplerScalar(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  if (inputInfo.shapeInfo.isUniform) {
    return `float ${funcName}() {return ${texName};}`;
  }
  const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;
  if (texNumR === 1 && texNumC === 1) {
    return `
      float ${funcName}() {
        return sampleTexture(${texName}, halfCR);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (enableShapeUniforms) {
    return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;
  return `
    float ${funcName}() {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getPackedSampler1D(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  const glsl = getGlslDifferences();
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  return `
    vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
        ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler1D(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int index) {
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const texShape = inputInfo.shapeInfo.texShape;
  const tNumR = texShape[0];
  const tNumC = texShape[1];
  if (tNumC === 1 && tNumR === 1) {
    return `
      float ${funcName}(int index) {
        return sampleTexture(${texName}, halfCR);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (tNumC === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (tNumR === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int index) {
        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  return `
    float ${funcName}(int index) {
      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getPackedSampler2D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const glsl = getGlslDifferences();
  if (texShape != null && exports_util.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
    }
    return `
      vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);

        return ${glsl.texture2D}(${texName}, uv);
      }
    `;
  }
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const valuesPerRow = Math.ceil(shape[1] / 2);
  return `
    vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler2D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  if (texShape != null && exports_util.arraysEqual(shape, texShape)) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    const texNumR2 = texShape[0];
    const texNumC2 = texShape[1];
    return `
    float ${funcName}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC2}.0, ${texNumR2}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  const { newShape, keptDims } = exports_util.squeezeShape(shape);
  const squeezedShape = newShape;
  if (squeezedShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
    const params = ["row", "col"];
    return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const offset = getFlatOffsetUniformName(texName);
  if (texNumC === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${texName}TexShape[0]));
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  if (texNumR === 1) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col) {
        float index = dot(vec3(row, col, ${offset}), vec3(${texName}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${texName}TexShape[1]), 0.5);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int row, int col) {
      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  if (enableShapeUniforms) {
    return `
      float ${funcName}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${texName}Shape[1] + col + ${offset};
        vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  return `
  float ${funcName}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${shape[1]} + col + ${offset};
    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
    return sampleTexture(${texName}, uv);
  }
`;
}
function getPackedSampler3D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const texShape = inputInfo.shapeInfo.texShape;
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  if (shape[0] === 1) {
    const squeezedShape = shape.slice(1);
    const keptDims = [1, 2];
    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
    const params = ["b", "row", "col"];
    return `
        ${getPackedSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        vec4 ${funcName}(int b, int row, int col) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
  }
  const glsl = getGlslDifferences();
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${texName}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const texNumR = packedTexShape[0];
  const texNumC = packedTexShape[1];
  const valuesPerRow = Math.ceil(shape[2] / 2);
  const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);
  return `
    vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler3D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const stride0 = shape[1] * shape[2];
  const stride1 = shape[2];
  const { newShape, keptDims } = exports_util.squeezeShape(shape);
  const squeezedShape = newShape;
  if (squeezedShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
    const params = ["row", "col", "depth"];
    return `
        ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
        float ${funcName}(int row, int col, int depth) {
          return ${funcName}(${getSqueezedParams(params, keptDims)});
        }
      `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${stride0}, ${stride1}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  if (texNumC === stride0 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth) {
        int stride1 = ${texName}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
        float ${funcName}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${texNumC}.0, ${texNumR}.0);
          return sampleTexture(${texName}, uv);
        }
      `;
  }
  if (texNumC === stride1 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${texName}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
    float ${funcName}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (enableShapeUniforms) {
    return `
    float ${funcName}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${texName}Shape[1] * ${texName}Shape[2];
      int stride1 = ${texName}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${offset};
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index);
      return sampleTexture(${texName}, uv);
    }
    `;
  }
  return `
      float ${funcName}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};
        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
        return sampleTexture(${texName}, uv);
      }
  `;
}
function getPackedSamplerND(inputInfo, enableShapeUniforms) {
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const glsl = getGlslDifferences();
  if (enableShapeUniforms) {
    return `
    vec4 ${funcName}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${texName}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${texName}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${texName}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${texName}TexShape[0]) / 2.0), ceil(float(${texName}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${glsl.texture2D}(${texName}, uv);
    }
  `;
  }
  const shape = inputInfo.shapeInfo.logicalShape;
  const rank = shape.length;
  const texShape = inputInfo.shapeInfo.texShape;
  const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];
  const texNumR = packedTexShape[0];
  const texNumC = packedTexShape[1];
  const valuesPerRow = Math.ceil(shape[rank - 1] / 2);
  let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);
  let params = `int b, int row, int col`;
  let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
  for (let b = 2;b < rank - 1; b++) {
    params = `int b${b}, ` + params;
    texelsInBatch *= shape[rank - b - 1];
    index = `b${b} * ${texelsInBatch} + ` + index;
  }
  return `
    vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${texName}, uv);
    }
  `;
}
function getSampler4D(inputInfo, enableShapeUniforms) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const stride2 = shape[3];
  const stride1 = shape[2] * stride2;
  const stride0 = shape[1] * stride1;
  const { newShape, keptDims } = exports_util.squeezeShape(shape);
  if (newShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, newShape);
    const params = ["row", "col", "depth", "depth2"];
    return `
      ${getSamplerFromInInfo(newInputInfo, enableShapeUniforms)}
      float ${funcName}(int row, int col, int depth, int depth2) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  const stride2Str = `int stride2 = ${texName}Shape[3];`;
  const stride1Str = `int stride1 = ${texName}Shape[2] * stride2;`;
  const stride0Str = `int stride0 = ${texName}Shape[1] * stride1;`;
  if (texNumC === stride0 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        ${stride2Str}
        ${stride1Str}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${stride1}, ${stride2}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (texNumC === stride2 && flatOffset == null) {
    if (enableShapeUniforms) {
      return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${texName}Shape[1] * ${texName}Shape[2], ${texName}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texName}TexShape[1], ${texName}TexShape[0]);
        return sampleTexture(${texName}, uv);
      }
    `;
    }
    return `
      float ${funcName}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  if (enableShapeUniforms) {
    return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${stride2Str}
      ${stride1Str}
      ${stride0Str}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${texName}TexShape[0], ${texName}TexShape[1], index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
  }
  return `
    float ${funcName}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} +
          depth * ${stride2} + depth2;
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getSampler5D(inputInfo) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const stride3 = shape[4];
  const stride2 = shape[3] * stride3;
  const stride1 = shape[2] * stride2;
  const stride0 = shape[1] * stride1;
  const { newShape, keptDims } = exports_util.squeezeShape(shape);
  if (newShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, newShape);
    const params = ["row", "col", "depth", "depth2", "depth3"];
    return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          depth3;
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  if (texNumC === stride0 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${stride1}, ${stride2}, ${stride3}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (texNumC === stride3 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3]},
               ${shape[2] * shape[3]}, ${shape[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  return `
    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getSampler6D(inputInfo) {
  const shape = inputInfo.shapeInfo.logicalShape;
  const texName = inputInfo.name;
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const { newShape, keptDims } = exports_util.squeezeShape(shape);
  if (newShape.length < shape.length) {
    const newInputInfo = squeezeInputInfo(inputInfo, newShape);
    const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
    return `
      ${getSamplerFromInInfo(newInputInfo)}
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      }
    `;
  }
  const stride4 = shape[5];
  const stride3 = shape[4] * stride4;
  const stride2 = shape[3] * stride3;
  const stride1 = shape[2] * stride2;
  const stride0 = shape[1] * stride1;
  if (inputInfo.shapeInfo.isUniform) {
    return `
      float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +
          dot(
            vec2(depth3, depth4),
            vec2(${stride4}, 1)));
        ${getUniformSampler(inputInfo)}
      }
    `;
  }
  const flatOffset = inputInfo.shapeInfo.flatOffset;
  const texShape = inputInfo.shapeInfo.texShape;
  const texNumR = texShape[0];
  const texNumC = texShape[1];
  if (texNumC === stride0 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  if (texNumC === stride4 && flatOffset == null) {
    return `
      float ${funcName}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},
               ${shape[2] * shape[3] * shape[4]},
               ${shape[3] * shape[4]},
               ${shape[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${texNumC}.0, ${texNumR}.0);
        return sampleTexture(${texName}, uv);
      }
    `;
  }
  const offset = getFlatOffsetUniformName(texName);
  return `
    float ${funcName}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};
      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
      return sampleTexture(${texName}, uv);
    }
  `;
}
function getUniformSampler(inputInfo) {
  const texName = inputInfo.name;
  const inSize = exports_util.sizeFromShape(inputInfo.shapeInfo.logicalShape);
  if (inSize < 2) {
    return `return ${texName};`;
  }
  return `
    for (int i = 0; i < ${inSize}; i++) {
      if (i == index) {
        return ${texName}[i];
      }
    }
  `;
}
function getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {
  const texName = inputInfo.name;
  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
  const funcName = "get" + texFuncSnippet + "AtOutCoords";
  const inRank = inputInfo.shapeInfo.logicalShape.length;
  const outRank = outShapeInfo.logicalShape.length;
  const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
  const type = getCoordsDataType(outRank);
  const rankDiff = outRank - inRank;
  let coordsSnippet;
  const fields = ["x", "y", "z", "w", "u", "v"];
  if (inRank === 0) {
    coordsSnippet = "";
  } else if (outRank < 2 && broadcastDims.length >= 1) {
    coordsSnippet = "coords = 0;";
  } else {
    coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
  }
  let unpackedCoordsSnippet = "";
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
  }
  let output = `return outputValue;`;
  const inSize = exports_util.sizeFromShape(inputInfo.shapeInfo.logicalShape);
  const isInputScalar = inSize === 1;
  const outSize = exports_util.sizeFromShape(outShapeInfo.logicalShape);
  const isOutputScalar = outSize === 1;
  if (inRank === 1 && !isInputScalar && !isOutputScalar) {
    output = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
  } else if (isInputScalar && !isOutputScalar) {
    if (outRank === 1) {
      output = `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `;
    } else {
      output = `
        return vec4(outputValue.x);
      `;
    }
  } else if (broadcastDims.length) {
    const rows = inRank - 2;
    const cols = inRank - 1;
    if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
      output = `return vec4(outputValue.x);`;
    } else if (broadcastDims.indexOf(rows) > -1) {
      output = `return vec4(outputValue.x, outputValue.y, ` + `outputValue.x, outputValue.y);`;
    } else if (broadcastDims.indexOf(cols) > -1) {
      output = `return vec4(outputValue.xx, outputValue.zz);`;
    }
  }
  return `
    vec4 ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});
      ${output}
    }
  `;
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo) {
  const texName = inputInfo.name;
  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
  const funcName = "get" + texFuncSnippet + "AtOutCoords";
  const outTexShape = outShapeInfo.texShape;
  const inTexShape = inputInfo.shapeInfo.texShape;
  const inRank = inputInfo.shapeInfo.logicalShape.length;
  const outRank = outShapeInfo.logicalShape.length;
  if (!inputInfo.shapeInfo.isUniform && inRank === outRank && inputInfo.shapeInfo.flatOffset == null && exports_util.arraysEqual(inTexShape, outTexShape)) {
    return `
      float ${funcName}() {
        return sampleTexture(${texName}, resultUV);
      }
    `;
  }
  const type = getCoordsDataType(outRank);
  const broadcastDims = getBroadcastDims2(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
  const rankDiff = outRank - inRank;
  let coordsSnippet;
  const fields = ["x", "y", "z", "w", "u", "v"];
  if (inRank === 0) {
    coordsSnippet = "";
  } else if (outRank < 2 && broadcastDims.length >= 1) {
    coordsSnippet = "coords = 0;";
  } else {
    coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
  }
  let unpackedCoordsSnippet = "";
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape.map((s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
  }
  return `
    float ${funcName}() {
      ${type} coords = getOutputCoords();
      ${coordsSnippet}
      return get${texFuncSnippet}(${unpackedCoordsSnippet});
    }
  `;
}
function getCoordsDataType(rank) {
  if (rank <= 1) {
    return "int";
  } else if (rank === 2) {
    return "ivec2";
  } else if (rank === 3) {
    return "ivec3";
  } else if (rank === 4) {
    return "ivec4";
  } else if (rank === 5) {
    return "ivec5";
  } else if (rank === 6) {
    return "ivec6";
  } else {
    throw Error(`GPU for rank ${rank} is not yet supported`);
  }
}
function getUniformInfoFromShape(isPacked, shape, texShape) {
  const { newShape, keptDims } = exports_util.squeezeShape(shape);
  const rank = shape.length;
  const useSqueezePackedShape = isPacked && rank === 3 && shape[0] === 1;
  const squeezeShape2 = useSqueezePackedShape ? shape.slice(1) : newShape;
  const useSqueezeShape = !isPacked && rank > 1 && !exports_util.arraysEqual(shape, texShape) && newShape.length < rank || useSqueezePackedShape;
  const uniformShape = useSqueezeShape ? squeezeShape2 : shape;
  return { useSqueezeShape, uniformShape, keptDims };
}
function squeezeInputInfo(inInfo, squeezedShape) {
  const newInputInfo = JSON.parse(JSON.stringify(inInfo));
  newInputInfo.shapeInfo.logicalShape = squeezedShape;
  return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
  return keptDims.map((d) => params[d]).join(", ");
}
var getBroadcastDims2, SAMPLE_1D_SNIPPET = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, SAMPLE_2D_SNIPPET = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, SAMPLE_3D_SNIPPET = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, SHADER_PACKED_PREFIX = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;
var init_shader_compiler = __esm(() => {
  init_dist();
  init_glsl_version();
  init_shader_compiler_util();
  ({ getBroadcastDims: getBroadcastDims2 } = exports_backend_util);
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js
function compileProgram(gpgpu, program, inputs, output) {
  const inputInfos = inputs.map((input2, i) => {
    const shapeInfo = {
      logicalShape: input2.shape,
      texShape: input2.isUniform ? null : input2.texData.texShape,
      isUniform: input2.isUniform,
      isPacked: input2.isUniform ? false : input2.texData.isPacked,
      flatOffset: null
    };
    if (input2.texData != null && input2.texData.slice != null && input2.texData.slice.flatOffset > 0) {
      shapeInfo.flatOffset = input2.texData.slice.flatOffset;
    }
    return { name: program.variableNames[i], shapeInfo };
  });
  const inShapeInfos = inputInfos.map((x) => x.shapeInfo);
  const outShapeInfo = {
    logicalShape: output.shape,
    texShape: output.texData.texShape,
    isUniform: false,
    isPacked: output.texData.isPacked,
    flatOffset: null
  };
  const source = makeShader(inputInfos, outShapeInfo, program);
  const fragmentShader = createFragmentShader(gpgpu.gl, source);
  const webGLProgram = gpgpu.createProgram(fragmentShader);
  if (!env().get("ENGINE_COMPILE_ONLY")) {
    gpgpu.buildVao(webGLProgram);
    return Object.assign({
      program,
      fragmentShader,
      source,
      webGLProgram,
      inShapeInfos,
      outShapeInfo
    }, getUniformLocations(gpgpu, program, webGLProgram));
  } else {
    return {
      program,
      fragmentShader,
      source,
      webGLProgram,
      inShapeInfos,
      outShapeInfo,
      variablesLocations: null,
      customUniformLocations: null,
      infLoc: null,
      nanLoc: null,
      outShapeLocation: null,
      outShapeStridesLocation: null,
      outTexShapeLocation: null
    };
  }
}
function getUniformLocations(gpgpu, program, webGLProgram) {
  const variablesLocations = [];
  const customUniformLocations = [];
  let outShapeLocation;
  let outTexShapeLocation;
  let outShapeStridesLocation;
  let infLoc = null;
  let nanLoc = null;
  nanLoc = gpgpu.getUniformLocation(webGLProgram, "NAN", false);
  if (env().getNumber("WEBGL_VERSION") === 1) {
    infLoc = gpgpu.getUniformLocation(webGLProgram, "INFINITY", false);
  }
  const shouldThrow = false;
  for (const varName of program.variableNames) {
    const varLocs = {
      name: varName,
      uniform: gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow),
      offset: gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow)
    };
    if (program.enableShapeUniforms) {
      varLocs.shape = gpgpu.getUniformLocation(webGLProgram, `${varName}Shape`, shouldThrow);
      varLocs.texShape = gpgpu.getUniformLocation(webGLProgram, `${varName}TexShape`, shouldThrow);
    }
    variablesLocations.push(varLocs);
  }
  if (program.enableShapeUniforms) {
    outShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outShape", shouldThrow);
    outShapeStridesLocation = gpgpu.getUniformLocation(webGLProgram, "outShapeStrides", shouldThrow);
    outTexShapeLocation = gpgpu.getUniformLocation(webGLProgram, "outTexShape", shouldThrow);
  }
  if (program.customUniforms) {
    for (const d of program.customUniforms) {
      customUniformLocations.push(gpgpu.getUniformLocation(webGLProgram, d.name, shouldThrow));
    }
  }
  return {
    variablesLocations,
    customUniformLocations,
    infLoc,
    nanLoc,
    outShapeLocation,
    outShapeStridesLocation,
    outTexShapeLocation
  };
}
function validateBinaryAndProgram(shapeInfos, inputs) {
  if (shapeInfos.length !== inputs.length) {
    throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` + `was executed with ${inputs.length} inputs`);
  }
  shapeInfos.forEach((s, i) => {
    const shapeA = s.logicalShape;
    const input2 = inputs[i];
    const shapeB = input2.shape;
    if (!exports_util.arraysEqual(shapeA, shapeB)) {
      throw Error(`Binary was compiled with different shapes than ` + `the current args. Shapes ${shapeA} and ${shapeB} must match`);
    }
    if (s.isUniform && input2.isUniform) {
      return;
    }
    const texShapeA = s.texShape;
    const texShapeB = input2.isUniform ? null : input2.texData.texShape;
    if (!exports_util.arraysEqual(texShapeA, texShapeB)) {
      throw Error(`Binary was compiled with different texture shapes than the` + ` current args. Shape ${texShapeA} and ${texShapeB} must match`);
    }
  });
}
function runProgram(gpgpu, binary, inputs, output, customUniformValues) {
  if (!binary.program.enableShapeUniforms) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
  }
  const outTex = output.texData.texture;
  const outTexShape = output.texData.texShape;
  if (output.texData.isPacked) {
    gpgpu.setOutputPackedMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
  } else {
    gpgpu.setOutputMatrixTexture(outTex.texture, outTexShape[0], outTexShape[1]);
  }
  gpgpu.setProgram(binary.webGLProgram);
  gpgpu.bindVertexArray(binary.webGLProgram.vao);
  if (env().getNumber("WEBGL_VERSION") === 1) {
    if (binary.infLoc !== null) {
      gpgpu.gl.uniform1f(binary.infLoc, Infinity);
    }
  }
  if (binary.nanLoc !== null) {
    gpgpu.gl.uniform1f(binary.nanLoc, NaN);
  }
  for (let i = 0;i < inputs.length; ++i) {
    const input2 = inputs[i];
    const { uniform: varLoc, offset: varOffsetLoc, shape: varShapeLoc, texShape: varTexShapeLoc } = binary.variablesLocations[i];
    if (varShapeLoc) {
      const { uniformShape } = getUniformInfoFromShape(binary.program.packedInputs, input2.shape, input2.texData.texShape);
      switch (uniformShape.length) {
        case 1:
          gpgpu.gl.uniform1iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        case 2:
          gpgpu.gl.uniform2iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        case 3:
          gpgpu.gl.uniform3iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        case 4:
          gpgpu.gl.uniform4iv(varShapeLoc, new Int32Array(uniformShape));
          break;
        default:
          break;
      }
    }
    if (varTexShapeLoc) {
      gpgpu.gl.uniform2i(varTexShapeLoc, input2.texData.texShape[0], input2.texData.texShape[1]);
    }
    if (varLoc == null) {
      continue;
    }
    if (input2.isUniform) {
      if (exports_util.sizeFromShape(input2.shape) < 2) {
        gpgpu.gl.uniform1f(varLoc, input2.uniformValues[0]);
      } else {
        let vals = input2.uniformValues;
        if (!(vals instanceof Float32Array)) {
          vals = new Float32Array(vals);
        }
        gpgpu.gl.uniform1fv(varLoc, vals);
      }
      continue;
    }
    if (input2.texData.slice != null && varOffsetLoc != null) {
      gpgpu.gl.uniform1i(varOffsetLoc, input2.texData.slice.flatOffset);
    }
    gpgpu.setInputMatrixTexture(input2.texData.texture.texture, varLoc, i);
  }
  const outShapeLoc = binary.outShapeLocation;
  if (outShapeLoc) {
    switch (output.shape.length) {
      case 1:
        gpgpu.gl.uniform1iv(outShapeLoc, new Int32Array(output.shape));
        break;
      case 2:
        gpgpu.gl.uniform2iv(outShapeLoc, new Int32Array(output.shape));
        break;
      case 3:
        gpgpu.gl.uniform3iv(outShapeLoc, new Int32Array(output.shape));
        break;
      case 4:
        gpgpu.gl.uniform4iv(outShapeLoc, new Int32Array(output.shape));
        break;
      default:
        break;
    }
  }
  if (binary.outShapeStridesLocation) {
    const strides = exports_util.computeStrides(output.shape);
    switch (output.shape.length) {
      case 2:
        gpgpu.gl.uniform1iv(binary.outShapeStridesLocation, new Int32Array(strides));
        break;
      case 3:
        gpgpu.gl.uniform2iv(binary.outShapeStridesLocation, new Int32Array(strides));
        break;
      case 4:
        gpgpu.gl.uniform3iv(binary.outShapeStridesLocation, new Int32Array(strides));
        break;
      default:
        break;
    }
  }
  if (binary.outTexShapeLocation) {
    gpgpu.gl.uniform2i(binary.outTexShapeLocation, output.texData.texShape[0], output.texData.texShape[1]);
  }
  if (binary.program.customUniforms && customUniformValues) {
    for (let i = 0;i < binary.program.customUniforms.length; ++i) {
      const d = binary.program.customUniforms[i];
      const customLoc = binary.customUniformLocations[i];
      const customValue = customUniformValues[i];
      if (d.type === "float") {
        gpgpu.gl.uniform1fv(customLoc, customValue);
      } else if (d.type === "vec2") {
        gpgpu.gl.uniform2fv(customLoc, customValue);
      } else if (d.type === "vec3") {
        gpgpu.gl.uniform3fv(customLoc, customValue);
      } else if (d.type === "vec4") {
        gpgpu.gl.uniform4fv(customLoc, customValue);
      } else if (d.type === "int") {
        gpgpu.gl.uniform1iv(customLoc, customValue);
      } else if (d.type === "ivec2") {
        gpgpu.gl.uniform2iv(customLoc, customValue);
      } else if (d.type === "ivec3") {
        gpgpu.gl.uniform3iv(customLoc, customValue);
      } else if (d.type === "ivec4") {
        gpgpu.gl.uniform4iv(customLoc, customValue);
      } else {
        throw Error(`uniform type ${d.type} is not supported yet.`);
      }
    }
  }
  gpgpu.executeProgram();
}
function makeShaderKey(program, inputs, output) {
  let keyInputs = "";
  inputs.concat(output).forEach((x) => {
    const hasOffset = x.texData != null && x.texData.slice != null && x.texData.slice.flatOffset > 0;
    if (program.enableShapeUniforms && !x.isUniform) {
      const xTexShape = x.texData.texShape;
      const { useSqueezeShape, uniformShape, keptDims } = getUniformInfoFromShape(program.packedInputs, x.shape, xTexShape);
      let rank1 = "", rank2 = "", rank34 = "";
      if (uniformShape.length === 1 && program.packedInputs) {
        const packedTexShape = [Math.ceil(xTexShape[0] / 2), Math.ceil(xTexShape[1] / 2)];
        rank1 = `${packedTexShape[0] > 1}_${packedTexShape[1] > 1}`;
      } else if (uniformShape.length === 2 && !program.packedInputs) {
        rank2 = `${uniformShape[0] > 1}_${uniformShape[1] > 1}`;
      } else if (uniformShape.length > 2 && !program.packedInputs) {
        const strides = exports_util.computeStrides(uniformShape);
        rank34 = `${strides[0] === xTexShape[1]}_${strides[strides.length - 1] === xTexShape[1]}`;
      }
      const xRank = x.shape.length;
      const isLogicalShapTexShapeEqual = uniformShape.length === 2 && exports_util.arraysEqual(x.shape, xTexShape);
      const isScalar = exports_util.sizeFromShape(x.shape) === 1;
      const broadcastDims = exports_backend_util.getBroadcastDims(x.shape, output.shape);
      const isInOutTexShapeEqual = !program.packedInputs && xRank === output.shape.length && exports_util.arraysEqual(xTexShape, output.texData.texShape);
      const isTexShapeGreaterThanOne = program.packedInputs || uniformShape.length > 2 ? "" : `${xTexShape[0] > 1}_${xTexShape[1] > 1}`;
      keyInputs += `${xRank}_${isInOutTexShapeEqual}_${useSqueezeShape ? keptDims : ""}_${uniformShape.length}_${isScalar}_${broadcastDims}_${isLogicalShapTexShapeEqual}_${rank1}_${rank2}_${rank34}_${isTexShapeGreaterThanOne}_${hasOffset}`;
    } else {
      const texShape = x.isUniform ? "uniform" : x.texData.texShape;
      keyInputs += `${x.shape}_${texShape}_${hasOffset}`;
    }
  });
  const keyUserCode = program.userCode;
  let key = program.constructor.name;
  key += "_" + keyInputs + "_" + keyUserCode + `${env().getNumber("WEBGL_VERSION")}`;
  return key;
}
function useShapeUniforms(rank) {
  return env().getBool("WEBGL_USE_SHAPES_UNIFORMS") && rank <= 4;
}
var init_gpgpu_math = __esm(() => {
  init_dist();
  init_shader_compiler();
  init_webgl_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js
class DecodeMatrixProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.outPackingScheme = PackingScheme.DENSE;
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${glsl.output} = result;
      }
    `;
  }
}
var init_decode_matrix_gpu = __esm(() => {
  init_glsl_version();
  init_gpgpu_math();
  init_shader_compiler_util();
  init_tex_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js
class DecodeMatrixPackedProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outPackingScheme = PackingScheme.DENSE;
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? getOutputLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], outputShape) : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], outputShape)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${glsl.output} = result;
      }
    `;
  }
}
var init_decode_matrix_packed_gpu = __esm(() => {
  init_glsl_version();
  init_gpgpu_math();
  init_shader_compiler_util();
  init_tex_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js
class EncodeFloatProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.outTexUsage = TextureUsage.DOWNLOAD;
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${glsl.output} = encode_float(x);
      }
    `;
  }
}
var init_encode_float_gpu = __esm(() => {
  init_glsl_version();
  init_shader_compiler_util();
  init_tex_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js
class EncodeFloatPackedProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = false;
    this.outTexUsage = TextureUsage.DOWNLOAD;
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.userCode = `
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${glsl.output} = encode_float(x);
      }
    `;
  }
}
var init_encode_float_packed_gpu = __esm(() => {
  init_glsl_version();
  init_shader_compiler_util();
  init_tex_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js
class EncodeMatrixProgram {
  constructor(outputShape, inputIsUnsignedByte = false, usedChannels = "RGBA") {
    this.variableNames = ["A"];
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    let output = `result`;
    if (inputIsUnsignedByte) {
      output = `floor(result * 255. + 0.5)`;
    }
    let mainLoop = "";
    for (let usedChannelIndex = 0;usedChannelIndex < usedChannels.length; usedChannelIndex++) {
      const curChannel = usedChannels[usedChannelIndex];
      mainLoop += `
          if(offset == ${usedChannelIndex}) {
            result = values[${CHANNEL_CHAR_TO_INDEX_MAP[curChannel]}];
          }`;
    }
    this.userCode = `
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${usedChannels.length});

        flatIndex = idiv(flatIndex, ${usedChannels.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${glsl.texture2D}(A, uv);
          ${mainLoop}
        }
        ${glsl.output} = vec4(${output}, 0., 0., 0.);
      }
    `;
  }
}
var CHANNEL_CHAR_TO_INDEX_MAP;
var init_encode_matrix_gpu = __esm(() => {
  init_glsl_version();
  init_gpgpu_math();
  init_shader_compiler_util();
  CHANNEL_CHAR_TO_INDEX_MAP = {
    R: 0,
    G: 1,
    B: 2,
    A: 3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js
class EncodeMatrixPackedProgram {
  constructor(outputShape, inputIsUnsignedByte = false) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.customUniforms = [{ name: "texShape", type: "ivec2" }];
    const glsl = getGlslDifferences();
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    let mainLoop = "";
    let output = "result";
    if (inputIsUnsignedByte) {
      output = "floor(result * 255. + 0.5)";
    }
    for (let row = 0;row <= 1; row++) {
      for (let col = 0;col <= 1; col++) {
        const channel = row * 2 + col;
        mainLoop += `
          localCoords = coords;
          if(localCoords[2] + ${col} < ${this.enableShapeUniforms ? "outShape[2]" : `${outputShape[2]}`}) {
          localCoords[2] += ${col};
          if (localCoords[1] + ${row} < ${this.enableShapeUniforms ? "outShape[1]" : `${outputShape[1]}`}) {
            localCoords[1] += ${row};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${glsl.texture2D}(A, uv);

            if (offset == 0) {
              result[${channel}] = values[0];
            } else if (offset == 1) {
              result[${channel}] = values[1];
            } else if (offset == 2) {
              result[${channel}] = values[2];
            } else {
              result[${channel}] = values[3];
            }
          }
        }
        `;
      }
    }
    this.userCode = `
        ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${mainLoop}

          ${glsl.output} = ${output};
        }
    `;
  }
}
var init_encode_matrix_packed_gpu = __esm(() => {
  init_glsl_version();
  init_gpgpu_math();
  init_shader_compiler_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js
var exports_gpgpu_util = {};
__export(exports_gpgpu_util, {
  uploadPixelDataToTexture: () => uploadPixelDataToTexture,
  uploadDenseMatrixToTexture: () => uploadDenseMatrixToTexture,
  getInternalFormatForUnsignedBytesMatrixTexture: () => getInternalFormatForUnsignedBytesMatrixTexture,
  getInternalFormatForPackedMatrixTexture: () => getInternalFormatForPackedMatrixTexture,
  getInternalFormatForFloat32MatrixTexture: () => getInternalFormatForFloat32MatrixTexture,
  getInternalFormatForFloat16PackedMatrixTexture: () => getInternalFormatForFloat16PackedMatrixTexture,
  getInternalFormatForFloat16MatrixTexture: () => getInternalFormatForFloat16MatrixTexture,
  downloadPackedMatrixFromBuffer: () => downloadPackedMatrixFromBuffer,
  downloadMatrixFromPackedOutputTexture: () => downloadMatrixFromPackedOutputTexture,
  downloadFloat32MatrixFromBuffer: () => downloadFloat32MatrixFromBuffer,
  downloadByteEncodedFloatMatrixFromOutputTexture: () => downloadByteEncodedFloatMatrixFromOutputTexture,
  createVertexShader: () => createVertexShader2,
  createVertexBuffer: () => createVertexBuffer,
  createUnsignedBytesMatrixTexture: () => createUnsignedBytesMatrixTexture,
  createPackedMatrixTexture: () => createPackedMatrixTexture,
  createIndexBuffer: () => createIndexBuffer,
  createFloat32MatrixTexture: () => createFloat32MatrixTexture,
  createFloat16PackedMatrixTexture: () => createFloat16PackedMatrixTexture,
  createFloat16MatrixTexture: () => createFloat16MatrixTexture,
  createBufferFromOutputTexture: () => createBufferFromOutputTexture,
  bindVertexProgramAttributeStreams: () => bindVertexProgramAttributeStreams
});
function createVertexShader2(gl) {
  const glsl = getGlslDifferences();
  const vertexShaderSource = `${glsl.version}
    precision highp float;
    ${glsl.attribute} vec3 clipSpacePos;
    ${glsl.attribute} vec2 uv;
    ${glsl.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;
  return createVertexShader(gl, vertexShaderSource);
}
function createVertexBuffer(gl) {
  const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
  return createStaticVertexBuffer(gl, vertexArray);
}
function createIndexBuffer(gl) {
  const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
  return createStaticIndexBuffer(gl, triangleVertexIndices);
}
function createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {
  validateTextureSize(width, height);
  const texture = createTexture(gl);
  const tex2d = gl.TEXTURE_2D;
  callAndCheck(gl, () => gl.bindTexture(tex2d, texture));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));
  callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));
  if (env().getNumber("WEBGL_VERSION") === 1) {
    callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));
  } else {
    callAndCheck(gl, () => gl.texStorage2D(tex2d, 1, internalFormat, width, height));
  }
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
  return { texture, texShape: [height, width] };
}
function getInternalFormatForFloat32MatrixTexture(textureConfig) {
  return textureConfig.internalFormatFloat;
}
function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);
}
function getInternalFormatForFloat16MatrixTexture(textureConfig) {
  return textureConfig.internalFormatHalfFloat;
}
function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);
}
function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {
  return textureConfig.downloadTextureFormat;
}
function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);
}
function getInternalFormatForPackedMatrixTexture(textureConfig) {
  return textureConfig.internalFormatPackedFloat;
}
function createPackedMatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);
}
function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {
  return textureConfig.internalFormatPackedHalfFloat;
}
function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {
  const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
  return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);
}
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
  const posOffset = 0;
  const uvOffset = 3 * 4;
  const stride = 3 * 4 + 2 * 4;
  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));
  const success = bindVertexBufferToProgramAttribute(gl, program, "clipSpacePos", vertexBuffer, 3, stride, posOffset);
  return success && bindVertexBufferToProgramAttribute(gl, program, "uv", vertexBuffer, 2, stride, uvOffset);
}
function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
  let dataForUpload, texelDataType, internalFormat;
  if (data instanceof Uint8Array) {
    dataForUpload = new Uint8Array(width * height * 4);
    texelDataType = gl.UNSIGNED_BYTE;
    internalFormat = gl.RGBA;
  } else {
    dataForUpload = new Float32Array(width * height * 4);
    texelDataType = gl.FLOAT;
    internalFormat = textureConfig.internalFormatPackedFloat;
  }
  dataForUpload.set(data);
  if (env().getNumber("WEBGL_VERSION") === 2) {
    callAndCheck(gl, () => gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, gl.RGBA, texelDataType, dataForUpload));
  } else {
    callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));
  }
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function uploadPixelDataToTexture(gl, texture, pixels) {
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));
  if (pixels.data instanceof Uint8Array) {
    if (env().getNumber("WEBGL_VERSION") === 2) {
      callAndCheck(gl, () => gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, pixels.width, pixels.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
    } else {
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));
    }
  } else {
    if (env().getNumber("WEBGL_VERSION") === 2) {
      callAndCheck(gl, () => gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
    } else {
      callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));
    }
  }
  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));
}
function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {
  const buffer9 = gl2.createBuffer();
  callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer9));
  const bytesPerFloat = 4;
  const valuesPerTexel = 4;
  const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;
  callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));
  callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));
  callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));
  return buffer9;
}
function downloadFloat32MatrixFromBuffer(gl, buffer9, size) {
  const gl2 = gl;
  const downloadTarget = new Float32Array(size);
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer9);
  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
  return downloadTarget;
}
function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {
  const [w, h] = getUnpackedMatrixTextureShapeWidthHeight(rows, columns);
  const numChannels = 4;
  const downloadTarget = new Uint8Array(getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));
  callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));
  return new Float32Array(downloadTarget.buffer);
}
function downloadPackedMatrixFromBuffer(gl, buffer9, batch, rows, cols, physicalRows, physicalCols, textureConfig) {
  const gl2 = gl;
  const downloadTarget = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer9);
  gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);
  gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);
  return downloadTarget;
}
function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {
  const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);
  callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));
  return packedRGBA;
}
var init_gpgpu_util = __esm(() => {
  init_dist();
  init_glsl_version();
  init_tex_util();
  init_webgl_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js
function linearSearchLastTrue(arr) {
  let i = 0;
  for (;i < arr.length; ++i) {
    const isDone = arr[i]();
    if (!isDone) {
      break;
    }
  }
  return i - 1;
}

class GPGPUContext {
  constructor(gl) {
    this.outputTexture = null;
    this.program = null;
    this.disposed = false;
    this.itemsToPoll = [];
    const glVersion = env().getNumber("WEBGL_VERSION");
    if (gl != null) {
      this.gl = gl;
      setWebGLContext(glVersion, gl);
    } else {
      this.gl = getWebGLContext(glVersion);
    }
    gl = this.gl;
    if (env().getNumber("WEBGL_VERSION") === 2) {
      const gl2 = gl;
      this.createVertexArray = () => {
        return callAndCheck(gl2, () => gl2.createVertexArray());
      };
      this.bindVertexArray = (vao) => {
        return callAndCheck(gl2, () => gl2.bindVertexArray(vao));
      };
      this.deleteVertexArray = (vao) => {
        return callAndCheck(gl2, () => gl2.deleteVertexArray(vao));
      };
      this.getVertexArray = () => {
        return callAndCheck(gl2, () => gl2.getParameter(gl2.VERTEX_ARRAY_BINDING));
      };
    } else if (gl != null) {
      const ext = gl.getExtension("OES_vertex_array_object");
      if (ext == null) {
        throw new Error("All WebGL1 implementations are expected to offer" + " OES_vertex_array_object.");
      }
      this.createVertexArray = () => {
        return callAndCheck(gl, () => ext.createVertexArrayOES());
      };
      this.bindVertexArray = (vao) => {
        return callAndCheck(gl, () => ext.bindVertexArrayOES(vao));
      };
      this.deleteVertexArray = (vao) => {
        return callAndCheck(gl, () => ext.deleteVertexArrayOES(vao));
      };
      this.getVertexArray = () => {
        return callAndCheck(gl, () => gl.getParameter(ext.VERTEX_ARRAY_BINDING_OES));
      };
    }
    let COLOR_BUFFER_FLOAT = "WEBGL_color_buffer_float";
    const COLOR_BUFFER_HALF_FLOAT = "EXT_color_buffer_half_float";
    this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile");
    if (env().getNumber("WEBGL_VERSION") === 1) {
      const TEXTURE_FLOAT = "OES_texture_float";
      const TEXTURE_HALF_FLOAT = "OES_texture_half_float";
      this.textureFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_FLOAT);
      if (hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {
        this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);
      } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
        throw new Error("GL context does not support half float textures, yet the " + "environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      }
      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
      if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
        this.colorBufferHalfFloatExtension = getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);
      } else if (env().get("WEBGL_FORCE_F16_TEXTURES")) {
        throw new Error("GL context does not support color renderable half floats, yet " + "the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      }
    } else {
      COLOR_BUFFER_FLOAT = "EXT_color_buffer_float";
      if (hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {
        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);
      } else if (hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {
        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);
      } else {
        throw new Error("GL context does not support color renderable floats");
      }
    }
    this.vertexBuffer = createVertexBuffer(this.gl);
    this.indexBuffer = createIndexBuffer(this.gl);
    this.framebuffer = createFramebuffer(this.gl);
    this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);
  }
  get debug() {
    return env().getBool("DEBUG");
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    if (this.program != null) {
      console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram." + " This is probably a resource leak, delete the program with " + "GPGPUContext.deleteProgram before disposing.");
    }
    if (this.outputTexture != null) {
      console.warn("Disposing a GPGPUContext that still has a bound output matrix " + "texture.  This is probably a resource leak, delete the output " + "matrix texture with GPGPUContext.deleteMatrixTexture before " + "disposing.");
    }
    const gl = this.gl;
    callAndCheck(gl, () => gl.finish());
    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));
    callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));
    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));
    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));
    callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));
    this.disposed = true;
  }
  createFloat32MatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  createFloat16MatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  createUnsignedBytesMatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  uploadPixelDataToTexture(texture, pixels) {
    this.throwIfDisposed();
    uploadPixelDataToTexture(this.gl, texture, pixels);
  }
  uploadDenseMatrixToTexture(texture, width, height, data) {
    this.throwIfDisposed();
    uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);
  }
  createFloat16PackedMatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  createPackedMatrixTexture(rows, columns) {
    this.throwIfDisposed();
    return createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);
  }
  deleteMatrixTexture(texture) {
    this.throwIfDisposed();
    if (this.outputTexture === texture) {
      unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
      this.outputTexture = null;
    }
    callAndCheck(this.gl, () => this.gl.deleteTexture(texture));
  }
  downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {
    return this.downloadMatrixDriver(texture, () => downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));
  }
  downloadPackedMatrixFromBuffer(buffer9, batch, rows, columns, physicalRows, physicalCols) {
    return downloadPackedMatrixFromBuffer(this.gl, buffer9, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);
  }
  downloadFloat32MatrixFromBuffer(buffer9, size) {
    return downloadFloat32MatrixFromBuffer(this.gl, buffer9, size);
  }
  createBufferFromTexture(texture, rows, columns) {
    this.bindTextureToFrameBuffer(texture);
    const result = createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);
    this.unbindTextureToFrameBuffer();
    return result;
  }
  createAndWaitForFence() {
    const fenceContext = this.createFence(this.gl);
    return this.pollFence(fenceContext);
  }
  createFence(gl) {
    let query;
    let isFencePassed;
    if (env().getBool("WEBGL_FENCE_API_ENABLED")) {
      const gl2 = gl;
      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
      gl.flush();
      isFencePassed = () => {
        const status = gl2.clientWaitSync(sync, 0, 0);
        return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
      };
      query = sync;
    } else if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0) {
      query = this.beginQuery();
      this.endQuery();
      isFencePassed = () => this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    } else {
      isFencePassed = () => true;
    }
    return { query, isFencePassed };
  }
  downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {
    return this.downloadMatrixDriver(texture, () => downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));
  }
  createProgram(fragmentShader) {
    this.throwIfDisposed();
    const gl = this.gl;
    if (this.vertexShader == null) {
      this.vertexShader = createVertexShader2(gl);
    }
    const program = createProgram(gl);
    callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));
    callAndCheck(gl, () => gl.attachShader(program, fragmentShader));
    linkProgram(gl, program);
    const program2 = Object.assign(program, { vao: this.createVertexArray() });
    if (this.debug) {
      validateProgram(gl, program2);
    }
    return program2;
  }
  buildVao(program) {
    this.setProgram(program);
    this.bindVertexArray(program.vao);
    const gl = this.gl;
    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer));
    bindVertexProgramAttributeStreams(gl, program, this.vertexBuffer);
  }
  deleteProgram(program) {
    this.throwIfDisposed();
    if (program === this.program) {
      this.program = null;
    }
    if (program != null) {
      callAndCheck(this.gl, () => this.gl.deleteProgram(program));
      this.deleteVertexArray(program.vao);
    }
  }
  setProgram(program) {
    this.throwIfDisposed();
    this.program = program;
    if (this.program != null) {
      if (this.debug) {
        validateProgram(this.gl, this.program);
      }
    }
    callAndCheck(this.gl, () => this.gl.useProgram(program));
  }
  getUniformLocation(program, uniformName, shouldThrow = true) {
    this.throwIfDisposed();
    if (shouldThrow) {
      return getProgramUniformLocationOrThrow(this.gl, program, uniformName);
    } else {
      return getProgramUniformLocation(this.gl, program, uniformName);
    }
  }
  getAttributeLocation(program, attribute) {
    this.throwIfDisposed();
    return callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));
  }
  getUniformLocationNoThrow(program, uniformName) {
    this.throwIfDisposed();
    return this.gl.getUniformLocation(program, uniformName);
  }
  setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {
    this.throwIfDisposed();
    this.throwIfNoProgram();
    bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);
  }
  setOutputMatrixTexture(outputMatrixTexture, rows, columns) {
    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
  }
  setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {
    this.throwIfDisposed();
    const [width, height] = getPackedMatrixTextureShapeWidthHeight(rows, columns);
    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
  }
  setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
  }
  setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  debugValidate() {
    if (this.program != null) {
      validateProgram(this.gl, this.program);
    }
    validateFramebuffer(this.gl);
  }
  executeProgram() {
    this.throwIfDisposed();
    this.throwIfNoProgram();
    const gl = this.gl;
    if (this.debug) {
      const boundVao = this.getVertexArray();
      console.assert(boundVao === this.program.vao, "VAO changed between setProgram and executeProgram!");
      this.debugValidate();
    }
    callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));
  }
  blockUntilAllProgramsCompleted() {
    this.throwIfDisposed();
    callAndCheck(this.gl, () => this.gl.finish());
  }
  getQueryTimerExtension() {
    if (this.disjointQueryTimerExtension == null) {
      this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query");
    }
    return this.disjointQueryTimerExtension;
  }
  getQueryTimerExtensionWebGL2() {
    return this.getQueryTimerExtension();
  }
  getQueryTimerExtensionWebGL1() {
    return this.getQueryTimerExtension();
  }
  beginQuery() {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const gl2 = this.gl;
      const ext2 = this.getQueryTimerExtensionWebGL2();
      const query2 = gl2.createQuery();
      gl2.beginQuery(ext2.TIME_ELAPSED_EXT, query2);
      return query2;
    }
    const ext = this.getQueryTimerExtensionWebGL1();
    const query = ext.createQueryEXT();
    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
    return query;
  }
  endQuery() {
    if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const gl2 = this.gl;
      const ext2 = this.getQueryTimerExtensionWebGL2();
      gl2.endQuery(ext2.TIME_ELAPSED_EXT);
      return;
    }
    const ext = this.getQueryTimerExtensionWebGL1();
    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
  }
  async waitForQueryAndGetTime(query) {
    await exports_util.repeatedTry(() => this.disposed || this.isQueryAvailable(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
    return this.getQueryTime(query, env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
  }
  getQueryTime(query, queryTimerVersion) {
    if (queryTimerVersion === 0) {
      return null;
    }
    if (queryTimerVersion === 2) {
      const gl2 = this.gl;
      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
      return timeElapsedNanos / 1e6;
    } else {
      const ext = this.getQueryTimerExtensionWebGL1();
      const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
      return timeElapsedNanos / 1e6;
    }
  }
  isQueryAvailable(query, queryTimerVersion) {
    if (queryTimerVersion === 0) {
      return true;
    }
    if (queryTimerVersion === 2) {
      const gl2 = this.gl;
      const ext = this.getQueryTimerExtensionWebGL2();
      const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
      if (this.disjoint == null) {
        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
      }
      return available && !this.disjoint;
    } else {
      const ext = this.getQueryTimerExtensionWebGL1();
      const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
      if (this.disjoint == null) {
        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
      }
      return available && !this.disjoint;
    }
  }
  pollFence(fenceContext) {
    return new Promise((resolve) => {
      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
    });
  }
  pollItems() {
    const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
    for (let i = 0;i <= index; ++i) {
      const { resolveFn } = this.itemsToPoll[i];
      resolveFn();
    }
    this.itemsToPoll = this.itemsToPoll.slice(index + 1);
  }
  addItemToPoll(isDoneFn, resolveFn) {
    this.itemsToPoll.push({ isDoneFn, resolveFn });
    if (this.itemsToPoll.length > 1) {
      return;
    }
    let scheduleFn = undefined;
    if ("setTimeoutCustom" in env().platform) {
      scheduleFn = env().platform.setTimeoutCustom.bind(env().platform);
    }
    exports_util.repeatedTry(() => {
      this.pollItems();
      return this.itemsToPoll.length === 0;
    }, () => 0, null, scheduleFn);
  }
  bindTextureToFrameBuffer(texture) {
    this.throwIfDisposed();
    bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
    if (this.debug) {
      validateFramebuffer(this.gl);
    }
  }
  unbindTextureToFrameBuffer() {
    if (this.outputTexture != null) {
      bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
      if (this.debug) {
        validateFramebuffer(this.gl);
      }
    } else {
      unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
    }
  }
  downloadMatrixDriver(texture, downloadAndDecode) {
    this.bindTextureToFrameBuffer(texture);
    const result = downloadAndDecode();
    this.unbindTextureToFrameBuffer();
    return result;
  }
  setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {
    this.throwIfDisposed();
    const gl = this.gl;
    bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
    if (this.debug) {
      validateFramebuffer(gl);
    }
    this.outputTexture = outputMatrixTextureMaybePacked;
    callAndCheck(gl, () => gl.viewport(0, 0, width, height));
    callAndCheck(gl, () => gl.scissor(0, 0, width, height));
  }
  setOutputMatrixWriteRegionDriver(x, y, width, height) {
    this.throwIfDisposed();
    callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));
  }
  throwIfDisposed() {
    if (this.disposed) {
      throw new Error("Attempted to use disposed GPGPUContext.");
    }
  }
  throwIfNoProgram() {
    if (this.program == null) {
      throw new Error("No GPU program is currently set.");
    }
  }
}
var init_gpgpu_context = __esm(() => {
  init_dist();
  init_canvas_util();
  init_gpgpu_util();
  init_tex_util();
  init_webgl_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/shared.js
var addImplCPU, bincountImplCPU, bincountReduceImplCPU, bitwiseAndImplCPU, castImplCPU, ceilImplCPU, concatImplCPU, equalImplCPU, expImplCPU, expm1ImplCPU, floorImplCPU, gatherNdImplCPU, gatherV2ImplCPU, greaterImplCPU, greaterEqualImplCPU, lessImplCPU, lessEqualImplCPU, linSpaceImplCPU, logImplCPU, maxImplCPU, maximumImplCPU, minimumImplCPU, multiplyImplCPU, negImplCPU, notEqualImplCPU, prodImplCPU, raggedGatherImplCPU, raggedRangeImplCPU, raggedTensorToTensorImplCPU, rangeImplCPU, rsqrtImplCPU, scatterImplCPU, sigmoidImplCPU, simpleAbsImplCPU, sliceImplCPU, sparseFillEmptyRowsImplCPU, sparseReshapeImplCPU, sparseSegmentReductionImplCPU, sqrtImplCPU, staticRegexReplaceImplCPU, stridedSliceImplCPU, stringNGramsImplCPU, stringSplitImplCPU, stringToHashBucketFastImplCPU, subImplCPU, tileImplCPU, topKImplCPU, transposeImplCPU, uniqueImplCPU;
var init_shared2 = __esm(() => {
  init_shared();
  ({ addImpl: addImplCPU, bincountImpl: bincountImplCPU, bincountReduceImpl: bincountReduceImplCPU, bitwiseAndImpl: bitwiseAndImplCPU, castImpl: castImplCPU, ceilImpl: ceilImplCPU, concatImpl: concatImplCPU, equalImpl: equalImplCPU, expImpl: expImplCPU, expm1Impl: expm1ImplCPU, floorImpl: floorImplCPU, gatherNdImpl: gatherNdImplCPU, gatherV2Impl: gatherV2ImplCPU, greaterImpl: greaterImplCPU, greaterEqualImpl: greaterEqualImplCPU, lessImpl: lessImplCPU, lessEqualImpl: lessEqualImplCPU, linSpaceImpl: linSpaceImplCPU, logImpl: logImplCPU, maxImpl: maxImplCPU, maximumImpl: maximumImplCPU, minimumImpl: minimumImplCPU, multiplyImpl: multiplyImplCPU, negImpl: negImplCPU, notEqualImpl: notEqualImplCPU, prodImpl: prodImplCPU, raggedGatherImpl: raggedGatherImplCPU, raggedRangeImpl: raggedRangeImplCPU, raggedTensorToTensorImpl: raggedTensorToTensorImplCPU, rangeImpl: rangeImplCPU, rsqrtImpl: rsqrtImplCPU, scatterImpl: scatterImplCPU, sigmoidImpl: sigmoidImplCPU, simpleAbsImpl: simpleAbsImplCPU, sliceImpl: sliceImplCPU, sparseFillEmptyRowsImpl: sparseFillEmptyRowsImplCPU, sparseReshapeImpl: sparseReshapeImplCPU, sparseSegmentReductionImpl: sparseSegmentReductionImplCPU, sqrtImpl: sqrtImplCPU, staticRegexReplaceImpl: staticRegexReplaceImplCPU, stridedSliceImpl: stridedSliceImplCPU, stringNGramsImpl: stringNGramsImplCPU, stringSplitImpl: stringSplitImplCPU, stringToHashBucketFastImpl: stringToHashBucketFastImplCPU, subImpl: subImplCPU, tileImpl: tileImplCPU, topKImpl: topKImplCPU, transposeImpl: transposeImplCPU, uniqueImpl: uniqueImplCPU } = exports_shared);
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js
function getVecChannels(name, rank) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, rank).map((d) => `${name}.${d}`);
}
function getChannels(name, rank) {
  if (rank === 1) {
    return [name];
  }
  return getVecChannels(name, rank);
}
function getSourceCoords(rank, dims) {
  if (rank === 1) {
    return "rc";
  }
  let coords = "";
  for (let i = 0;i < rank; i++) {
    coords += dims[i];
    if (i < rank - 1) {
      coords += ",";
    }
  }
  return coords;
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js
class PackProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    if (this.rank === 0) {
      this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;
    } else {
      const channels = getChannels("rc", this.rank);
      const dtype = getCoordsDataType(this.rank);
      const outOfBoundsCondition = this.getOutOfBoundsCondition(channels);
      const setup = this.getSetup(channels);
      const output = this.getOutput(channels);
      this.userCode = `
        void main() {
          ${dtype} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            setOutput(vec4(0));
          } else {
            ${setup}

            setOutput(vec4(${output}));
          }
        }
      `;
    }
  }
  getSourceCoordsArr(dims) {
    const coords = [];
    for (let row = 0;row <= 1; row++) {
      for (let col = 0;col <= 1; col++) {
        let coord = `${row === 0 ? "r" : "rp1"}, ${col === 0 ? "c" : "cp1"}`;
        for (let d = 2;d < this.rank; d++) {
          coord = `${dims[dims.length - 1 - d]},` + coord;
        }
        coords.push(coord);
      }
    }
    return coords;
  }
  getOutOfBoundsCondition(dims) {
    if (this.rank === 1) {
      return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
    }
    let cond = "";
    for (let i = this.rank - 2;i < this.rank; i++) {
      cond += `${dims[i]} >= ${this.enableShapeUniforms ? `outShape[${i}]` : this.outputShape[i]}`;
      if (i < this.rank - 1) {
        cond += "||";
      }
    }
    return cond;
  }
  getSetup(dims) {
    if (this.rank === 1) {
      return "";
    }
    const innerDims = dims.slice(-2);
    const col = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1];
    const row = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
    return `
      int r = ${innerDims[0]};
      int c = ${innerDims[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${col};
      bool rEdge = rp1 >= ${row};
    `;
  }
  getOutput(dims) {
    const sourceCoords = this.getSourceCoordsArr(dims);
    if (this.rank === 1) {
      const outShape = this.enableShapeUniforms ? "outShape" : this.outputShape[0];
      return `getA(rc), (rc + 1 >= ${outShape} ? 0. : getA(rc + 1)), 0, 0`;
    }
    return `getA(${sourceCoords[0]}),
            cEdge ? 0. : getA(${sourceCoords[1]}),
            rEdge ? 0. : getA(${sourceCoords[2]}),
            rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;
  }
}
var init_pack_gpu = __esm(() => {
  init_gpgpu_math();
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js
function getReshapedInputCoords(shape, enableShapeUniforms) {
  const coordsFromIndexSnippet = enableShapeUniforms ? getLogicalCoordinatesFromFlatIndexByUniform(["r", "c", "d"], "inputShape") : getLogicalCoordinatesFromFlatIndex(["r", "c", "d"], shape);
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(r, c, d);
    }
  `;
}

class ReshapePackedProgram {
  constructor(outputShape, inputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{ name: "inputShape", type: "ivec3" }];
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    let mainLoop = ``;
    for (let i = 0;i < 4; i++) {
      let thisRC = `thisRC = rc;`;
      if (i % 2 === 1) {
        thisRC += `thisRC.z += 1;`;
      }
      if (i > 1) {
        thisRC += `thisRC.y += 1;`;
      }
      mainLoop += `
        ${thisRC}
        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i > 0 ? "}" : ""}
      `;
    }
    this.userCode = `
      ${getReshapedInputCoords(inputShape, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? getFlatIndexFrom3DOutput() : getFlatIndexFrom3D(outputShape)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : outputShape[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : outputShape[2]};

        ${mainLoop}

        setOutput(result);
      }
    `;
  }
}
var init_reshape_packed_gpu = __esm(() => {
  init_gpgpu_math();
  init_shader_compiler_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js
function numBytesForInternalFormat(gl, internalFormat) {
  const glany = gl;
  if (internalFormat === glany.R32F) {
    return 4;
  } else if (internalFormat === glany.R16F) {
    return 2;
  } else if (internalFormat === glany.RGBA32F) {
    return 16;
  } else if (internalFormat === gl.RGBA) {
    return 16;
  } else if (internalFormat === glany.RGBA16F) {
    return 8;
  } else if (internalFormat === glany.RGBA8) {
    return 4;
  }
  throw new Error(`Unknown internal format ${internalFormat}`);
}
function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {
  const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);
  let numElements;
  if (isPacked) {
    const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
    numElements = packedWidth * packedHeight;
  } else {
    const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);
    numElements = width * height;
  }
  const bytesPerElement2 = numBytesForInternalFormat(gl, internalFormat);
  return numElements * bytesPerElement2;
}
function internalFormatForPhysicalTexType(physicalTexType, textureConfig) {
  switch (physicalTexType) {
    case PhysicalTextureType.PACKED_2X2_FLOAT32:
      return getInternalFormatForPackedMatrixTexture(textureConfig);
    case PhysicalTextureType.PACKED_2X2_FLOAT16:
      return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);
    case PhysicalTextureType.UNPACKED_FLOAT32:
      return getInternalFormatForFloat32MatrixTexture(textureConfig);
    case PhysicalTextureType.UNPACKED_FLOAT16:
      return getInternalFormatForFloat16MatrixTexture(textureConfig);
    case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:
      return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);
    default:
      throw new Error(`Unknown physical texture type ${physicalTexType}`);
  }
}
function getPhysicalTextureForRendering(isPacked) {
  if (env().getBool("WEBGL_RENDER_FLOAT32_ENABLED")) {
    if (isPacked) {
      return PhysicalTextureType.PACKED_2X2_FLOAT32;
    }
    return PhysicalTextureType.UNPACKED_FLOAT32;
  }
  if (isPacked) {
    return PhysicalTextureType.PACKED_2X2_FLOAT16;
  }
  return PhysicalTextureType.UNPACKED_FLOAT16;
}
function getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {
  if (logicalTexType === TextureUsage.UPLOAD) {
    return PhysicalTextureType.PACKED_2X2_FLOAT32;
  } else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {
    return getPhysicalTextureForRendering(isPacked);
  } else if (logicalTexType === TextureUsage.DOWNLOAD || logicalTexType === TextureUsage.PIXELS) {
    return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;
  }
  throw new Error(`Unknown logical texture type ${logicalTexType}`);
}
function getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {
  return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;
}

class TextureManager {
  constructor(gpgpu) {
    this.gpgpu = gpgpu;
    this.numUsedTextures = 0;
    this.numFreeTextures = 0;
    this._numBytesAllocated = 0;
    this._numBytesFree = 0;
    this.freeTextures = {};
    this.usedTextures = {};
    this.logEnabled = false;
  }
  acquireTexture(shapeRC, usage, isPacked) {
    const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);
    const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);
    if (!(shapeKey in this.freeTextures)) {
      this.freeTextures[shapeKey] = [];
    }
    if (!(shapeKey in this.usedTextures)) {
      this.usedTextures[shapeKey] = [];
    }
    const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
    if (this.freeTextures[shapeKey].length > 0) {
      this.numFreeTextures--;
      this.numUsedTextures++;
      this._numBytesFree -= texBytes;
      this.log();
      const newTexture2 = this.freeTextures[shapeKey].pop();
      this.usedTextures[shapeKey].push(newTexture2);
      return newTexture2;
    }
    let newTexture;
    if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {
      newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {
      newTexture = this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {
      newTexture = this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {
      newTexture = this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);
    } else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {
      newTexture = this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);
    }
    this.usedTextures[shapeKey].push(newTexture);
    this.numUsedTextures++;
    this._numBytesAllocated += texBytes;
    this.log();
    return newTexture;
  }
  releaseTexture(texture, shape, logicalTexType, isPacked) {
    if (this.freeTextures == null) {
      return;
    }
    const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);
    const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);
    if (!(shapeKey in this.freeTextures)) {
      this.freeTextures[shapeKey] = [];
    }
    const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);
    const deleteTexThreshold = env().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
    if (deleteTexThreshold !== -1 && this._numBytesAllocated > deleteTexThreshold) {
      this.gpgpu.deleteMatrixTexture(texture.texture);
      this._numBytesAllocated -= texBytes;
    } else {
      this.freeTextures[shapeKey].push(texture);
      this.numFreeTextures++;
      this._numBytesFree += texBytes;
    }
    this.numUsedTextures--;
    const texList = this.usedTextures[shapeKey];
    const texIndex = texList && texList.indexOf(texture);
    if (texIndex == null || texIndex < 0) {
      throw new Error("Cannot release a texture that was never provided by this " + "texture manager");
    }
    texList[texIndex] = texList[texList.length - 1];
    texList.pop();
    this.log();
  }
  log() {
    if (!this.logEnabled) {
      return;
    }
    const total = this.numFreeTextures + this.numUsedTextures;
    console.log("Free/Used", `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);
    const freeRatio = this._numBytesFree / this._numBytesAllocated;
    console.log(`Bytes allocated: ${this._numBytesAllocated}`);
    console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);
  }
  get numBytesAllocated() {
    return this._numBytesAllocated;
  }
  get numBytesFree() {
    return this._numBytesFree;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    if (this.freeTextures == null) {
      return;
    }
    for (const texShape in this.freeTextures) {
      this.freeTextures[texShape].forEach((tex) => {
        this.gpgpu.deleteMatrixTexture(tex.texture);
      });
    }
    for (const texShape in this.usedTextures) {
      this.usedTextures[texShape].forEach((tex) => {
        this.gpgpu.deleteMatrixTexture(tex.texture);
      });
    }
    this.freeTextures = null;
    this.usedTextures = null;
    this.numUsedTextures = 0;
    this.numFreeTextures = 0;
    this._numBytesAllocated = 0;
    this._numBytesFree = 0;
  }
}
var init_texture_manager = __esm(() => {
  init_dist();
  init_gpgpu_util();
  init_tex_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js
class UnaryOpProgram {
  constructor(aShape, opSnippet) {
    this.variableNames = ["A"];
    this.outputShape = aShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      float unaryOperation(float x) {
        ${opSnippet}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
}
var CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`, LINEAR = `return x;`, ABS = `return abs(x);`, ELU2 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`, RELU, RELU6, CLONE = "return x;", SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;
var init_unaryop_gpu = __esm(() => {
  init_gpgpu_math();
  RELU = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
  RELU6 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js
class UnaryOpPackedProgram {
  constructor(aShape, opSnippet) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = aShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${opSnippet}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
  }
}
var LINEAR2 = `return x;`, ELU3 = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, RELU2 = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, RELU62 = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, SIGMOID2 = `return 1.0 / (1.0 + exp(-1.0 * x));`;
var init_unaryop_packed_gpu = __esm(() => {
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js
class UnpackProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = false;
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const rank = outputShape.length;
    const channels = getChannels("rc", rank);
    const dtype = getCoordsDataType(rank);
    const sourceCoords = getSourceCoords(rank, channels);
    const innerDims = channels.slice(-2);
    const coords = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
    this.userCode = `
      void main() {
        ${dtype} rc = getOutputCoords();
        vec4 packedInput = getA(${sourceCoords});

        setOutput(getChannel(packedInput, ${coords}));
      }
    `;
  }
}
var init_unpack_gpu = __esm(() => {
  init_gpgpu_math();
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js
function getBinaryCache(webGLVersion) {
  if (webGLVersion in binaryCaches) {
    return binaryCaches[webGLVersion];
  }
  binaryCaches[webGLVersion] = {};
  return binaryCaches[webGLVersion];
}
function numMBBeforeWarning() {
  if (env().global.screen == null) {
    return 1024;
  }
  return env().global.screen.height * env().global.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT / 1024 / 1024;
}
function float32ToTypedArray(a, dtype) {
  if (dtype === "float32" || dtype === "complex64") {
    return a;
  } else if (dtype === "int32" || dtype === "bool") {
    const result = dtype === "int32" ? new Int32Array(a.length) : new Uint8Array(a.length);
    for (let i = 0;i < result.length; ++i) {
      result[i] = Math.round(a[i]);
    }
    return result;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
var whereImpl3, EPSILON_FLOAT322 = 0.0000001, EPSILON_FLOAT162 = 0.0001, binaryCaches, CPU_HANDOFF_SIZE_THRESHOLD, BEFORE_PAGING_CONSTANT = 600, MathBackendWebGL;
var init_backend_webgl = __esm(() => {
  init_flags_webgl();
  init_dist();
  init_canvas_util();
  init_decode_matrix_gpu();
  init_decode_matrix_packed_gpu();
  init_encode_float_gpu();
  init_encode_float_packed_gpu();
  init_encode_matrix_gpu();
  init_encode_matrix_packed_gpu();
  init_gpgpu_context();
  init_gpgpu_math();
  init_gpgpu_math();
  init_shared2();
  init_pack_gpu();
  init_reshape_packed_gpu();
  init_tex_util();
  init_tex_util();
  init_texture_manager();
  init_unaryop_gpu();
  init_unaryop_gpu();
  init_unaryop_packed_gpu();
  init_unpack_gpu();
  init_webgl_util();
  whereImpl3 = exports_kernel_impls.whereImpl;
  binaryCaches = {};
  CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
  MathBackendWebGL = class MathBackendWebGL extends KernelBackend {
    nextDataId() {
      return MathBackendWebGL.nextDataId++;
    }
    constructor(gpuResource) {
      super();
      this.pendingRead = new WeakMap;
      this.pendingDisposal = new WeakSet;
      this.dataRefCount = new WeakMap;
      this.numBytesInGPU = 0;
      this.uploadWaitMs = 0;
      this.downloadWaitMs = 0;
      this.lastGlFlushTime = 0;
      this.warnedAboutMemory = false;
      this.pendingDeletes = 0;
      this.disposed = false;
      if (!env().getBool("HAS_WEBGL")) {
        throw new Error("WebGL is not supported on this device");
      }
      let newGPGPU;
      if (gpuResource != null) {
        if (gpuResource instanceof GPGPUContext) {
          newGPGPU = gpuResource;
        } else {
          const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"), gpuResource);
          newGPGPU = new GPGPUContext(gl);
        }
        this.binaryCache = {};
        this.gpgpuCreatedLocally = false;
      } else {
        const gl = getWebGLContext(env().getNumber("WEBGL_VERSION"));
        newGPGPU = new GPGPUContext(gl);
        this.binaryCache = getBinaryCache(env().getNumber("WEBGL_VERSION"));
        this.gpgpuCreatedLocally = true;
      }
      this.gpgpu = newGPGPU;
      this.canvas = this.gpgpu.gl.canvas;
      this.textureManager = new TextureManager(this.gpgpu);
      this.numMBBeforeWarning = numMBBeforeWarning();
      this.texData = new DataStorage(this, engine7());
    }
    numDataIds() {
      return this.texData.numDataIds() - this.pendingDeletes;
    }
    writeTexture(texture, shape, dtype, texHeight, texWidth, channels) {
      const input2 = this.makeTensorInfo(shape, dtype);
      const inData = this.texData.get(input2.dataId);
      inData.isPacked = false;
      inData.texture = { texture, texShape: [texHeight, texWidth] };
      inData.texShape = [texHeight, texWidth];
      const shapeAs3D = getShapeAs3D(shape);
      const program = new EncodeMatrixProgram(shapeAs3D, false, channels);
      const output = this.runWebGLProgram(program, [input2], dtype, [[texHeight, texWidth]]);
      output.shape = shape;
      inData.texture = null;
      this.disposeIntermediateTensorInfo(input2);
      return output.dataId;
    }
    write(values, shape, dtype) {
      if (env().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || env().getBool("DEBUG")) {
        this.checkNumericalProblems(values);
      }
      if (dtype === "complex64" && values != null) {
        throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);
      }
      const dataId = { id: this.nextDataId() };
      this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });
      return dataId;
    }
    refCount(dataId) {
      if (this.texData.has(dataId)) {
        const tensorData = this.texData.get(dataId);
        return tensorData.refCount;
      }
      return 0;
    }
    incRef(dataId) {
      const texData = this.texData.get(dataId);
      texData.refCount++;
    }
    decRef(dataId) {
      if (this.texData.has(dataId)) {
        const texData = this.texData.get(dataId);
        texData.refCount--;
      }
    }
    move(dataId, values, shape, dtype, refCount) {
      if (env().getBool("DEBUG")) {
        this.checkNumericalProblems(values);
      }
      if (dtype === "complex64") {
        throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);
      }
      this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });
    }
    disposeIntermediateTensorInfo(tensorInfo) {
      this.disposeData(tensorInfo.dataId);
    }
    readSync(dataId) {
      const texData = this.texData.get(dataId);
      const { values, dtype, complexTensorInfos, slice: slice17, shape, isPacked } = texData;
      if (slice17 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.readSync(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (dtype === "string") {
        return values;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = exports_util.now();
      }
      let result;
      if (dtype === "complex64") {
        const realValues = this.readSync(complexTensorInfos.real.dataId);
        const imagValues = this.readSync(complexTensorInfos.imag.dataId);
        result = exports_backend_util.mergeRealAndImagArrays(realValues, imagValues);
      } else {
        result = this.getValuesFromTexture(dataId);
      }
      if (shouldTimeProgram) {
        this.downloadWaitMs += exports_util.now() - start;
      }
      return this.convertAndCacheOnCPU(dataId, result);
    }
    async read(dataId) {
      if (this.pendingRead.has(dataId)) {
        const subscribers2 = this.pendingRead.get(dataId);
        return new Promise((resolve) => subscribers2.push(resolve));
      }
      const texData = this.texData.get(dataId);
      const { values, shape, slice: slice17, dtype, complexTensorInfos, isPacked } = texData;
      if (slice17 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const data = this.read(res.dataId);
        this.disposeIntermediateTensorInfo(res);
        return data;
      }
      if (values != null) {
        return this.convertAndCacheOnCPU(dataId);
      }
      if (env().getBool("DEBUG")) {
        if (!env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && env().getNumber("WEBGL_VERSION") === 2) {
          throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` + `WEBGL_VERSION=2 not yet supported.`);
        }
      }
      let buffer9 = null;
      let tmpDownloadTarget;
      if (dtype !== "complex64" && env().get("WEBGL_BUFFER_SUPPORTED")) {
        tmpDownloadTarget = this.decode(dataId);
        const tmpData = this.texData.get(tmpDownloadTarget.dataId);
        buffer9 = this.gpgpu.createBufferFromTexture(tmpData.texture.texture, ...getDenseTexShape(shape));
      }
      this.pendingRead.set(dataId, []);
      if (dtype !== "complex64") {
        await this.gpgpu.createAndWaitForFence();
      }
      let vals;
      if (dtype === "complex64") {
        const ps = await Promise.all([
          this.read(complexTensorInfos.real.dataId),
          this.read(complexTensorInfos.imag.dataId)
        ]);
        const realValues = ps[0];
        const imagValues = ps[1];
        vals = exports_backend_util.mergeRealAndImagArrays(realValues, imagValues);
      } else if (buffer9 == null) {
        vals = this.getValuesFromTexture(dataId);
      } else {
        const size = exports_util.sizeFromShape(shape);
        vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer9, size);
      }
      if (tmpDownloadTarget != null) {
        this.disposeIntermediateTensorInfo(tmpDownloadTarget);
      }
      if (buffer9 != null) {
        const gl = this.gpgpu.gl;
        callAndCheck(gl, () => gl.deleteBuffer(buffer9));
      }
      const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);
      const subscribers = this.pendingRead.get(dataId);
      this.pendingRead.delete(dataId);
      subscribers.forEach((resolve) => resolve(dTypeVals));
      if (this.pendingDisposal.has(dataId)) {
        this.pendingDisposal.delete(dataId);
        if (this.disposeData(dataId)) {
          engine7().removeDataId(dataId, this);
        }
        this.pendingDeletes--;
      }
      return dTypeVals;
    }
    readToGPU(dataId, options = {}) {
      const texData = this.texData.get(dataId);
      const { values, shape, slice: slice17, dtype, isPacked, texture } = texData;
      if (dtype === "complex64") {
        throw new Error("Does not support reading texture for complex64 dtype.");
      }
      if (slice17 != null) {
        let program;
        if (isPacked) {
          program = new UnaryOpPackedProgram(shape, CLONE);
        } else {
          program = new UnaryOpProgram(shape, CLONE);
        }
        const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);
        const gpuResouorce = this.readToGPU(res, options);
        this.disposeIntermediateTensorInfo(res);
        return gpuResouorce;
      }
      if (texture == null) {
        if (values != null) {
          throw new Error("Data is not on GPU but on CPU.");
        } else {
          throw new Error("There is no data on GPU or CPU.");
        }
      }
      const tmpTarget = this.decode(dataId, options.customTexShape);
      const tensorRef = engine7().makeTensorFromTensorInfo(tmpTarget);
      const tmpData = this.texData.get(tmpTarget.dataId);
      return Object.assign({ tensorRef }, tmpData.texture);
    }
    bufferSync(t) {
      const data = this.readSync(t.dataId);
      if (t.dtype === "string") {
        try {
          const strings = data.map((d) => exports_util.decodeString(d));
          return buffer(t.shape, t.dtype, strings);
        } catch (_a) {
          throw new Error("Failed to decode encoded string bytes into utf-8");
        }
      }
      return buffer(t.shape, t.dtype, data);
    }
    checkNumericalProblems(values) {
      if (values == null) {
        return;
      }
      for (let i = 0;i < values.length; i++) {
        const num = values[i];
        if (!canBeRepresented(num)) {
          if (env().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) {
            throw Error(`The value ${num} cannot be represented with your ` + `current settings. Consider enabling float32 rendering: ` + `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);
          }
          throw Error(`The value ${num} cannot be represented on this device.`);
        }
      }
    }
    getValuesFromTexture(dataId) {
      const { shape, dtype, isPacked } = this.texData.get(dataId);
      const size = exports_util.sizeFromShape(shape);
      if (env().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
        const tmpTarget = this.decode(dataId);
        const tmpData2 = this.texData.get(tmpTarget.dataId);
        const vals2 = this.gpgpu.downloadMatrixFromPackedTexture(tmpData2.texture.texture, ...getDenseTexShape(shape)).subarray(0, size);
        this.disposeIntermediateTensorInfo(tmpTarget);
        return vals2;
      }
      const shouldUsePackedProgram = env().getBool("WEBGL_PACK") && isPacked === true;
      const outputShape = shouldUsePackedProgram ? getShapeAs3D(shape) : shape;
      const program = shouldUsePackedProgram ? new EncodeFloatPackedProgram(outputShape) : new EncodeFloatProgram(outputShape);
      const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], "float32");
      const tmpData = this.texData.get(output.dataId);
      const vals = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture.texture, tmpData.texShape[0], tmpData.texShape[1]).subarray(0, size);
      this.disposeIntermediateTensorInfo(output);
      return vals;
    }
    timerAvailable() {
      return env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(f) {
      const oldActiveTimers = this.activeTimers;
      const newActiveTimers = [];
      let outerMostTime = false;
      if (this.programTimersStack == null) {
        this.programTimersStack = newActiveTimers;
        outerMostTime = true;
      } else {
        this.activeTimers.push(newActiveTimers);
      }
      this.activeTimers = newActiveTimers;
      f();
      const flattenedActiveTimerQueries = exports_util.flatten(this.activeTimers.map((d) => d.query)).filter((d) => d != null);
      const flattenedActiveTimerNames = exports_util.flatten(this.activeTimers.map((d) => d.name)).filter((d) => d != null);
      this.activeTimers = oldActiveTimers;
      if (outerMostTime) {
        this.programTimersStack = null;
      }
      const res = {
        uploadWaitMs: this.uploadWaitMs,
        downloadWaitMs: this.downloadWaitMs,
        kernelMs: null,
        wallMs: null
      };
      return (async () => {
        if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
          const kernelMs = await Promise.all(flattenedActiveTimerQueries);
          res["kernelMs"] = exports_util.sum(kernelMs);
          res["getExtraProfileInfo"] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d })).map((d) => `${d.name}: ${d.ms}`).join(", ");
        } else {
          res["kernelMs"] = {
            error: "WebGL query timers are not supported in this environment."
          };
        }
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        return res;
      })();
    }
    memory() {
      return {
        unreliable: false,
        numBytesInGPU: this.numBytesInGPU,
        numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
        numBytesInGPUFree: this.textureManager.numBytesFree
      };
    }
    startTimer() {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.beginQuery();
      }
      return { startMs: exports_util.now(), endMs: null };
    }
    endTimer(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        this.gpgpu.endQuery();
        return query;
      }
      query.endMs = exports_util.now();
      return query;
    }
    async getQueryTime(query) {
      if (env().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        return this.gpgpu.waitForQueryAndGetTime(query);
      }
      const timerQuery = query;
      return timerQuery.endMs - timerQuery.startMs;
    }
    disposeData(dataId, force = false) {
      if (this.pendingDisposal.has(dataId)) {
        return false;
      }
      if (!this.texData.has(dataId)) {
        return true;
      }
      if (force) {
        this.texData.get(dataId).refCount = 0;
      } else {
        this.texData.get(dataId).refCount--;
      }
      if (!force && this.texData.get(dataId).refCount > 0) {
        return false;
      }
      if (this.pendingRead.has(dataId)) {
        this.pendingDisposal.add(dataId);
        this.pendingDeletes++;
        return false;
      }
      this.releaseGPUData(dataId);
      const { complexTensorInfos } = this.texData.get(dataId);
      if (complexTensorInfos != null) {
        this.disposeData(complexTensorInfos.real.dataId, force);
        this.disposeData(complexTensorInfos.imag.dataId, force);
      }
      this.texData.delete(dataId);
      return true;
    }
    releaseGPUData(dataId) {
      const { texture, dtype, texShape, usage, isPacked, slice: slice17 } = this.texData.get(dataId);
      const key = slice17 && slice17.origDataId || dataId;
      const refCount = this.dataRefCount.get(key);
      if (refCount > 1) {
        this.dataRefCount.set(key, refCount - 1);
      } else {
        this.dataRefCount.delete(key);
        if (texture != null) {
          this.numBytesInGPU -= this.computeBytes(texShape, dtype);
          this.textureManager.releaseTexture(texture, texShape, usage, isPacked);
        }
      }
      const texData = this.texData.get(dataId);
      texData.texture = null;
      texData.texShape = null;
      texData.isPacked = false;
      texData.slice = null;
    }
    getTexture(dataId) {
      this.uploadToGPU(dataId);
      return this.texData.get(dataId).texture.texture;
    }
    getDataInfo(dataId) {
      return this.texData.get(dataId);
    }
    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {
      return env().getBool("WEBGL_CPU_FORWARD") && inputs.every((input2) => this.texData.get(input2.dataId).texture == null && exports_util.sizeFromShape(input2.shape) < sizeThreshold);
    }
    getGPGPUContext() {
      return this.gpgpu;
    }
    where(condition) {
      exports_backend_util.warn("tf.where() in webgl locks the UI thread. " + "Call tf.whereAsync() instead");
      const condVals = condition.dataSync();
      return whereImpl3(condition.shape, condVals);
    }
    packedUnaryOp(x, op2, dtype) {
      const program = new UnaryOpPackedProgram(x.shape, op2);
      const outInfo = this.compileAndRun(program, [x], dtype);
      return engine7().makeTensorFromTensorInfo(outInfo);
    }
    abs(x) {
      if (this.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
        const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);
        return this.makeOutput(x.shape, x.dtype, outValues);
      }
      if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
        return this.packedUnaryOp(x, ABS, x.dtype);
      }
      const program = new UnaryOpProgram(x.shape, ABS);
      const outInfo = this.compileAndRun(program, [x]);
      return engine7().makeTensorFromTensorInfo(outInfo);
    }
    makeTensorInfo(shape, dtype, values) {
      let dataId;
      if (dtype === "string" && values != null && values.length > 0 && exports_util.isString(values[0])) {
        const encodedValues = values.map((d) => exports_util.encodeString(d));
        dataId = this.write(encodedValues, shape, dtype);
      } else {
        dataId = this.write(values, shape, dtype);
      }
      this.texData.get(dataId).usage = null;
      return { dataId, shape, dtype };
    }
    makeOutput(shape, dtype, values) {
      return engine7().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);
    }
    unpackTensor(input2) {
      const program = new UnpackProgram(input2.shape);
      return this.runWebGLProgram(program, [input2], input2.dtype);
    }
    packTensor(input2) {
      const program = new PackProgram(input2.shape);
      const preventEagerUnpackingOutput = true;
      return this.runWebGLProgram(program, [input2], input2.dtype, null, preventEagerUnpackingOutput);
    }
    packedReshape(input2, afterShape) {
      const input3DShape = [
        getBatchDim(input2.shape),
        ...getRowsCols(input2.shape)
      ];
      const input3D = {
        dtype: input2.dtype,
        shape: input3DShape,
        dataId: input2.dataId
      };
      const afterShapeAs3D = [
        getBatchDim(afterShape),
        ...getRowsCols(afterShape)
      ];
      const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
      const preventEagerUnpackingOfOutput = true;
      const customValues = [input3DShape];
      const output = this.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
      return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
    }
    decode(dataId, customTexShape) {
      const texData = this.texData.get(dataId);
      const { isPacked, shape, dtype } = texData;
      if (customTexShape != null) {
        const size = exports_util.sizeFromShape(shape);
        const texSize = customTexShape[0] * customTexShape[1] * 4;
        exports_util.assert(size <= texSize, () => "customTexShape is too small. " + "Row * Column * 4 should be equal or larger than the " + "size of the tensor data.");
      }
      const shapeAs3D = getShapeAs3D(shape);
      let program;
      if (isPacked) {
        program = new DecodeMatrixPackedProgram(shapeAs3D);
      } else {
        program = new DecodeMatrixProgram(shapeAs3D);
      }
      const preventEagerUnpackingOfOutput = true;
      const customValues = [customTexShape != null ? customTexShape : getDenseTexShape(shapeAs3D)];
      const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, customValues, preventEagerUnpackingOfOutput, customTexShape);
      return { dtype, shape, dataId: out.dataId };
    }
    runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false, customTexShape) {
      const output = this.makeTensorInfo(program.outputShape, outputDtype);
      const outData = this.texData.get(output.dataId);
      if (program.packedOutput) {
        outData.isPacked = true;
      }
      if (program.outPackingScheme === PackingScheme.DENSE) {
        const texelShape = customTexShape != null ? customTexShape : getDenseTexShape(program.outputShape);
        outData.texShape = texelShape.map((d) => d * 2);
      }
      if (program.outTexUsage != null) {
        outData.usage = program.outTexUsage;
      }
      if (exports_util.sizeFromShape(output.shape) === 0) {
        outData.values = exports_util.getTypedArrayFromDType(output.dtype, 0);
        return output;
      }
      const dataToDispose = [];
      const inputsData = inputs.map((input2) => {
        if (input2.dtype === "complex64") {
          throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` + `dtypes, please separate the program into real and imaginary ` + `parts.`);
        }
        let texData = this.texData.get(input2.dataId);
        if (texData.texture == null) {
          if (!program.packedInputs && exports_util.sizeFromShape(input2.shape) <= env().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) {
            return {
              shape: input2.shape,
              texData: null,
              isUniform: true,
              uniformValues: texData.values
            };
          }
          if (program.packedInputs) {
            texData.isPacked = true;
            texData.shape = input2.shape;
          }
        }
        this.uploadToGPU(input2.dataId);
        if (!!texData.isPacked !== !!program.packedInputs) {
          input2 = texData.isPacked ? this.unpackTensor(input2) : this.packTensor(input2);
          dataToDispose.push(input2);
          texData = this.texData.get(input2.dataId);
        } else if (texData.isPacked && !isReshapeFree(texData.shape, input2.shape)) {
          const savedInput = input2;
          const targetShape = input2.shape;
          input2.shape = texData.shape;
          input2 = this.packedReshape(input2, targetShape);
          dataToDispose.push(input2);
          texData = this.texData.get(input2.dataId);
          savedInput.shape = targetShape;
        }
        return { shape: input2.shape, texData, isUniform: false };
      });
      this.uploadToGPU(output.dataId);
      const outputData = { shape: output.shape, texData: outData, isUniform: false };
      const key = makeShaderKey(program, inputsData, outputData);
      const binary = this.getAndSaveBinary(key, () => {
        return compileProgram(this.gpgpu, program, inputsData, outputData);
      });
      const shouldTimeProgram = this.activeTimers != null;
      let query;
      if (shouldTimeProgram) {
        query = this.startTimer();
      }
      if (!env().get("ENGINE_COMPILE_ONLY")) {
        runProgram(this.gpgpu, binary, inputsData, outputData, customUniformValues);
      }
      dataToDispose.forEach((info) => this.disposeIntermediateTensorInfo(info));
      if (shouldTimeProgram) {
        query = this.endTimer(query);
        this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });
      }
      const glFlushThreshold = env().getNumber("WEBGL_FLUSH_THRESHOLD");
      if (glFlushThreshold > 0) {
        const time2 = exports_util.now();
        if (time2 - this.lastGlFlushTime > glFlushThreshold) {
          this.gpgpu.gl.flush();
          this.lastGlFlushTime = time2;
        }
      }
      if (!env().getBool("WEBGL_LAZILY_UNPACK") && outData.isPacked && preventEagerUnpackingOfOutput === false) {
        const unpacked = this.unpackTensor(output);
        this.disposeIntermediateTensorInfo(output);
        return unpacked;
      }
      return output;
    }
    compileAndRun(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput = false) {
      outputDtype = outputDtype || inputs[0].dtype;
      const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customUniformValues, preventEagerUnpackingOfOutput);
      return outInfo;
    }
    getAndSaveBinary(key, getBinary) {
      if (!(key in this.binaryCache)) {
        this.binaryCache[key] = getBinary();
      }
      return this.binaryCache[key];
    }
    getTextureManager() {
      return this.textureManager;
    }
    dispose() {
      if (this.disposed) {
        return;
      }
      if (!env().getBool("IS_TEST")) {
        const allKeys = Object.keys(this.binaryCache);
        allKeys.forEach((key) => {
          this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
          delete this.binaryCache[key];
        });
      }
      this.textureManager.dispose();
      if (this.canvas != null && (typeof HTMLCanvasElement !== "undefined" && this.canvas instanceof HTMLCanvasElement)) {
        this.canvas.remove();
      } else {
        this.canvas = null;
      }
      if (this.gpgpuCreatedLocally) {
        this.gpgpu.program = null;
        this.gpgpu.dispose();
      }
      this.disposed = true;
    }
    floatPrecision() {
      if (this.floatPrecisionValue == null) {
        this.floatPrecisionValue = tidy(() => {
          if (!env().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
            const debugFlag = env().getBool("DEBUG");
            env().set("DEBUG", false);
            const underflowCheckValue = this.abs(scalar(0.00000001)).dataSync()[0];
            env().set("DEBUG", debugFlag);
            if (underflowCheckValue > 0) {
              return 32;
            }
          }
          return 16;
        });
      }
      return this.floatPrecisionValue;
    }
    epsilon() {
      return this.floatPrecision() === 32 ? EPSILON_FLOAT322 : EPSILON_FLOAT162;
    }
    uploadToGPU(dataId) {
      const texData = this.texData.get(dataId);
      const { shape, dtype, values, texture, usage, isPacked } = texData;
      if (texture != null) {
        return;
      }
      const shouldTimeProgram = this.activeTimers != null;
      let start;
      if (shouldTimeProgram) {
        start = exports_util.now();
      }
      let texShape = texData.texShape;
      if (texShape == null) {
        texShape = getTextureShapeFromLogicalShape(shape, isPacked);
        texData.texShape = texShape;
      }
      if (values != null) {
        const shapeAs3D = getShapeAs3D(shape);
        let program;
        let width = texShape[1], height = texShape[0];
        const isByteArray = values instanceof Uint8Array || values instanceof Uint8ClampedArray;
        if (isPacked || !isByteArray) {
          [width, height] = getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);
        }
        if (isPacked) {
          program = new EncodeMatrixPackedProgram(shapeAs3D, isByteArray);
        } else {
          program = new EncodeMatrixProgram(shapeAs3D, isByteArray);
        }
        const tempDenseInputTexShape = isByteArray ? [height, width] : texShape;
        const tempDenseInputHandle = this.makeTensorInfo(tempDenseInputTexShape, dtype);
        const tempDenseInputTexData = this.texData.get(tempDenseInputHandle.dataId);
        if (isByteArray) {
          tempDenseInputTexData.usage = TextureUsage.PIXELS;
        } else {
          tempDenseInputTexData.usage = TextureUsage.UPLOAD;
        }
        tempDenseInputTexData.texShape = tempDenseInputTexShape;
        this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);
        const customValues = [[height, width]];
        const preventEagerUnpacking = true;
        const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, customValues, preventEagerUnpacking);
        const outputTexData = this.texData.get(encodedOutputTarget.dataId);
        texData.texShape = outputTexData.texShape;
        texData.isPacked = outputTexData.isPacked;
        texData.usage = outputTexData.usage;
        if (!env().get("ENGINE_COMPILE_ONLY")) {
          texData.texture = outputTexData.texture;
          texData.values = null;
          this.texData.delete(encodedOutputTarget.dataId);
        } else {
          this.disposeData(encodedOutputTarget.dataId);
        }
        this.disposeIntermediateTensorInfo(tempDenseInputHandle);
        if (shouldTimeProgram) {
          this.uploadWaitMs += exports_util.now() - start;
        }
      } else {
        const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);
        texData.texture = newTexture;
      }
    }
    convertAndCacheOnCPU(dataId, float32Values) {
      const texData = this.texData.get(dataId);
      const { dtype } = texData;
      if (float32Values != null) {
        texData.values = float32ToTypedArray(float32Values, dtype);
      }
      return texData.values;
    }
    acquireTexture(texShape, texType, dtype, isPacked) {
      this.numBytesInGPU += this.computeBytes(texShape, dtype);
      if (!this.warnedAboutMemory && this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {
        const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
        this.warnedAboutMemory = true;
        console.warn(`High memory usage in GPU: ${mb} MB, ` + `most likely due to a memory leak`);
      }
      return this.textureManager.acquireTexture(texShape, texType, isPacked);
    }
    computeBytes(shape, dtype) {
      return shape[0] * shape[1] * exports_util.bytesPerElement(dtype);
    }
    checkCompileCompletion() {
      for (const [, binary] of Object.entries(this.binaryCache)) {
        this.checkCompletion_(binary);
      }
    }
    async checkCompileCompletionAsync() {
      const ps = [];
      if (this.gpgpu.parallelCompilationExtension) {
        for (const [, binary] of Object.entries(this.binaryCache)) {
          ps.push(this.checkCompletionAsync_(binary));
        }
        return Promise.all(ps);
      } else {
        for (const [, binary] of Object.entries(this.binaryCache)) {
          const p4 = new Promise((resolve) => {
            try {
              this.checkCompletion_(binary);
              resolve(true);
            } catch (error) {
              throw error;
            }
          });
          ps.push(p4);
        }
        return Promise.all(ps);
      }
    }
    async checkCompletionAsync_(binary) {
      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
        return this.checkCompletion_(binary);
      } else {
        await nextFrame();
        return this.checkCompletionAsync_(binary);
      }
    }
    checkCompletion_(binary) {
      if (this.gpgpu.gl.getProgramParameter(binary.webGLProgram, this.gpgpu.gl.LINK_STATUS) === false) {
        console.log(this.gpgpu.gl.getProgramInfoLog(binary.webGLProgram));
        if (this.gpgpu.gl.getShaderParameter(binary.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === false) {
          logShaderSourceAndInfoLog(binary.source, this.gpgpu.gl.getShaderInfoLog(binary.fragmentShader));
          throw new Error("Failed to compile fragment shader.");
        }
        throw new Error("Failed to link vertex and fragment shaders.");
      }
      return true;
    }
    getUniformLocations() {
      for (const binary of Object.values(this.binaryCache)) {
        this.gpgpu.buildVao(binary.webGLProgram);
        const { variablesLocations, customUniformLocations, infLoc, nanLoc, outShapeLocation, outShapeStridesLocation, outTexShapeLocation } = getUniformLocations(this.gpgpu, binary.program, binary.webGLProgram);
        binary.variablesLocations = variablesLocations;
        binary.customUniformLocations = customUniformLocations;
        binary.infLoc = infLoc;
        binary.nanLoc = nanLoc;
        binary.outShapeLocation = outShapeLocation;
        binary.outShapeStridesLocation = outShapeStridesLocation;
        binary.outTexShapeLocation = outTexShapeLocation;
      }
    }
    createTensorFromGPUData(values, shape, dtype) {
      values.channels = values.channels || "RGBA";
      const { texture, height, width, channels } = values;
      const backend3 = engine7().backend;
      if (!backend3.gpgpu.gl.isTexture(texture)) {
        throw new Error(`The texture is invalid. Also, please make sure the texture and ` + `the TFJS WebGL backend are using the same canvas. If you want to ` + `use your own custom canvas, you have to create and use the custom ` + `TFJS WebGL backend created from the canvas through ` + `'new tf.MathBackendWebGL(customCanvas)'.`);
      }
      const dataId = backend3.writeTexture(texture, shape, dtype, height, width, channels);
      return engine7().makeTensorFromDataId(dataId, shape, dtype, backend3);
    }
  };
  MathBackendWebGL.nextDataId = 0;
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/version.js
var version9 = "4.22.0";
var init_version6 = () => {
};

// node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl.js
function forceHalfFloat() {
  env().set("WEBGL_FORCE_F16_TEXTURES", true);
}
var init_webgl = __esm(() => {
  init_dist();
  init_gpgpu_util();
  init_webgl_util();
  init_backend_webgl();
  init_canvas_util();
  init_gpgpu_context();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js
var webgl3;
var init_base3 = __esm(() => {
  init_dist();
  init_backend_webgl();
  init_version6();
  init_webgl();
  init_webgl();
  if (exports_device_util.isBrowser()) {
    registerBackend("webgl", () => new MathBackendWebGL, 2);
  }
  webgl3 = { forceHalfFloat };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js
class BinaryOpProgram {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["A", "B"];
    this.outputShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    this.userCode = `
      float binaryOperation(float a, float b) {
        ${op2}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
  }
}
var CHECK_NAN_SNIPPET2 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;
var init_binaryop_gpu = __esm(() => {
  init_dist();
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js
class BinaryOpPackedProgram {
  constructor(op2, aShape, bShape, checkOutOfBounds = false) {
    this.variableNames = ["A", "B"];
    this.supportsBroadcasting = true;
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    const rank = this.outputShape.length;
    this.enableShapeUniforms = useShapeUniforms(rank);
    let checkOutOfBoundsString = "";
    if (checkOutOfBounds) {
      if (rank === 0 || exports_util.sizeFromShape(this.outputShape) === 1) {
        checkOutOfBoundsString = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;
      } else {
        const dtype = getCoordsDataType(rank);
        checkOutOfBoundsString = `
          ${dtype} coords = getOutputCoords();
        `;
        if (rank === 1) {
          if (this.enableShapeUniforms) {
            checkOutOfBoundsString += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
          } else {
            checkOutOfBoundsString += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;
          }
        } else {
          const channels = getChannels("coords", rank);
          if (this.enableShapeUniforms) {
            checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= outShape[${rank} - 2];
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= outShape[${rank} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
          } else {
            checkOutOfBoundsString += `
            bool nextRowOutOfBounds =
              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};
            bool nextColOutOfBounds =
              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
          }
        }
      }
    }
    this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${op2}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${checkOutOfBoundsString}

        setOutput(result);
      }
    `;
  }
}
var CHECK_NAN_SNIPPET_PACKED = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;
var init_binaryop_packed_gpu = __esm(() => {
  init_dist();
  init_gpgpu_math();
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Identity.js
function identity3(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  backend3.incRef(x.dataId);
  return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
}
var identityConfig2;
var init_Identity2 = __esm(() => {
  init_dist();
  identityConfig2 = {
    kernelName: Identity,
    backendName: "webgl",
    kernelFunc: identity3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Complex.js
function complex9(args) {
  const { inputs, backend: backend3 } = args;
  const { real: real6, imag: imag6 } = inputs;
  const complexInfo = backend3.makeTensorInfo(real6.shape, "complex64");
  const complex10 = backend3.texData.get(complexInfo.dataId);
  const realTensorInfo = identity3({ inputs: { x: real6 }, backend: backend3 });
  const imagTensorInfo = identity3({ inputs: { x: imag6 }, backend: backend3 });
  complex10.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
  return complexInfo;
}
var complexConfig2;
var init_Complex2 = __esm(() => {
  init_dist();
  init_Identity2();
  complexConfig2 = {
    kernelName: Complex,
    backendName: "webgl",
    kernelFunc: complex9
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LeakyRelu.js
function leakyRelu3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { alpha } = attrs;
  const $alpha = backend3.makeTensorInfo([], "float32", exports_util.createScalarValue(alpha, "float32"));
  const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(LEAKYRELU_PACKED, x.shape, $alpha.shape) : new BinaryOpProgram(LEAKYRELU, x.shape, $alpha.shape);
  const result = backend3.runWebGLProgram(program, [x, $alpha], "float32");
  backend3.disposeIntermediateTensorInfo($alpha);
  return result;
}
var LEAKYRELU = `return (a < 0.) ? b * a : a;`, LEAKYRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`, leakyReluConfig2;
var init_LeakyRelu2 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  leakyReluConfig2 = {
    kernelName: LeakyRelu,
    backendName: "webgl",
    kernelFunc: leakyRelu3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prelu.js
function prelu7(args) {
  const { inputs, backend: backend3 } = args;
  const { x, alpha } = inputs;
  const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(PRELU_PACKED, x.shape, alpha.shape) : new BinaryOpProgram(PRELU, x.shape, alpha.shape);
  return backend3.runWebGLProgram(program, [x, alpha], "float32");
}
var PRELU = `return (a < 0.) ? b * a : a;`, PRELU_PACKED = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`, preluConfig2;
var init_Prelu2 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  preluConfig2 = {
    kernelName: Prelu,
    backendName: "webgl",
    kernelFunc: prelu7
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/kernel_funcs_utils.js
function unaryKernelFunc2({ opSnippet, packedOpSnippet, cpuKernelImpl, dtype }) {
  return ({ inputs, backend: backend3 }) => {
    const { x } = inputs;
    const webglBackend = backend3;
    const $dtype = dtype || x.dtype;
    if (webglBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {
      const xData = webglBackend.texData.get(x.dataId);
      const outValues = cpuKernelImpl(xData.values, $dtype);
      return webglBackend.makeTensorInfo(x.shape, $dtype, outValues);
    }
    const shouldUsePackedProgram = env().getBool("WEBGL_PACK_UNARY_OPERATIONS") && packedOpSnippet != null;
    let program;
    if (shouldUsePackedProgram) {
      program = new UnaryOpPackedProgram(x.shape, packedOpSnippet);
    } else {
      program = new UnaryOpProgram(x.shape, opSnippet);
    }
    return webglBackend.runWebGLProgram(program, [x], $dtype);
  };
}
function binaryKernelFunc2({ opSnippet, packedOpSnippet, checkOutOfBounds = false, supportsComplex = false, cpuKernelImpl, dtype }) {
  return ({ inputs, backend: backend3 }) => {
    const { a, b } = inputs;
    const webglBackend = backend3;
    if (supportsComplex && a.dtype === "complex64") {
      const aData = webglBackend.texData.get(a.dataId);
      const bData = webglBackend.texData.get(b.dataId);
      const [real6, imag6] = [
        [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
        [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
      ].map((complexParts) => {
        const [aPart, bPart] = complexParts;
        const aHandle = {
          dataId: aPart.dataId,
          dtype: aPart.dtype,
          shape: a.shape
        };
        const bHandle = {
          dataId: bPart.dataId,
          dtype: bPart.dtype,
          shape: b.shape
        };
        const program2 = new BinaryOpProgram(opSnippet, a.shape, b.shape);
        return webglBackend.runWebGLProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
      });
      const complexOutput = complex9({ inputs: { real: real6, imag: imag6 }, backend: webglBackend });
      webglBackend.disposeIntermediateTensorInfo(real6);
      webglBackend.disposeIntermediateTensorInfo(imag6);
      return complexOutput;
    }
    const $dtype = dtype || upcastType(a.dtype, b.dtype);
    if ((a.dtype === "string" || b.dtype === "string" || webglBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {
      const aVals = webglBackend.texData.get(a.dataId).values;
      const bVals = webglBackend.texData.get(b.dataId).values;
      const decodedAVals = a.dtype === "string" ? exports_backend_util.fromUint8ToStringArray(aVals) : aVals;
      const decodedBVals = a.dtype === "string" ? exports_backend_util.fromUint8ToStringArray(bVals) : bVals;
      const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
      const out = webglBackend.makeTensorInfo(outShape, $dtype);
      const outData = webglBackend.texData.get(out.dataId);
      outData.values = outValues;
      return out;
    }
    const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") && packedOpSnippet != null;
    let program;
    if (shouldUsePackedProgram) {
      program = new BinaryOpPackedProgram(packedOpSnippet, a.shape, b.shape, checkOutOfBounds);
    } else {
      program = new BinaryOpProgram(opSnippet, a.shape, b.shape);
    }
    return webglBackend.runWebGLProgram(program, [a, b], $dtype);
  };
}
function mapActivationToShaderProgram(activation2, packed = false) {
  if (activation2 === "linear") {
    if (packed) {
      return LINEAR2;
    }
    return LINEAR;
  } else if (activation2 === "relu") {
    if (packed) {
      return RELU2;
    }
    return RELU;
  } else if (activation2 === "elu") {
    if (packed) {
      return ELU3;
    }
    return ELU2;
  } else if (activation2 === "relu6") {
    if (packed) {
      return RELU62;
    }
    return RELU6;
  } else if (activation2 === "prelu") {
    if (packed) {
      return PRELU_PACKED;
    }
    return PRELU;
  } else if (activation2 === "leakyrelu") {
    if (packed) {
      return LEAKYRELU_PACKED;
    }
    return LEAKYRELU;
  } else if (activation2 === "sigmoid") {
    if (packed) {
      return SIGMOID2;
    }
    return SIGMOID;
  }
  throw new Error(`Activation ${activation2} has not been implemented for the WebGL backend.`);
}
var CHECK_NAN_SNIPPET_UNARY = `if (isnan(x)) return x;`;
var init_kernel_funcs_utils = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  init_Complex2();
  init_LeakyRelu2();
  init_Prelu2();
  init_unaryop_gpu();
  init_unaryop_gpu();
  init_unaryop_packed_gpu();
  init_unaryop_packed_gpu();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js
class MatMulPackedProgram {
  constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyreluActivation = false) {
    this.variableNames = ["matrixA", "matrixB"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const sharedDim = transposeA ? aShape[1] : aShape[2];
    const sharedDimensionPacked = Math.ceil(sharedDim / 2);
    const aSample = transposeA ? "i * 2, rc.y" : "rc.y, i * 2";
    const bSample = transposeB ? "rc.z, i * 2" : "i * 2, rc.z";
    const aSwizzle = transposeA ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"];
    const bSwizzle = transposeB ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyreluActivation) {
      this.variableNames.push("leakyreluAlpha");
    }
    let batchASnippet = "rc.x";
    let batchBSnippet = "rc.x";
    if (aShape[0] < bShape[0]) {
      batchASnippet = `imod(rc.x, ${aShape[0]})`;
    } else if (bShape[0] < aShape[0]) {
      batchBSnippet = `imod(rc.x, ${bShape[0]})`;
    }
    this.userCode = `
      ${activationSnippet}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${sharedDimensionPacked}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${batchASnippet};
        int batchB = ${batchBSnippet};
        for (int i = 0; i < ${sharedDimensionPacked}; i++) {
          vec4 a = getMatrixA(batchA, ${aSample});
          vec4 b = getMatrixB(batchB, ${bSample});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${aSwizzle[0]} * ${bSwizzle[0]});
          result += (${aSwizzle[1]} * ${bSwizzle[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${addBiasSnippet}

        ${applyActivationSnippet}

        setOutput(result);
      }
    `;
  }
}
var init_mulmat_packed_gpu = __esm(() => {
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js
class BinaryOpComplexProgram {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
    this.outputShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${op2}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
  }
}
var COMPLEX_MULTIPLY;
var init_binaryop_complex_gpu = __esm(() => {
  init_dist();
  COMPLEX_MULTIPLY = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multiply.js
function multiply3(args) {
  const { inputs, backend: backend3 } = args;
  const { a, b } = inputs;
  const dtype = exports_backend_util.upcastType(a.dtype, b.dtype);
  if (a.dtype === "complex64") {
    const aData = backend3.texData.get(a.dataId);
    const bData = backend3.texData.get(b.dataId);
    const realProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, a.shape, b.shape);
    const imagProgram = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, a.shape, b.shape);
    const inputs2 = [
      {
        dataId: aData.complexTensorInfos.real.dataId,
        dtype: aData.complexTensorInfos.real.dtype,
        shape: a.shape
      },
      {
        dataId: aData.complexTensorInfos.imag.dataId,
        dtype: aData.complexTensorInfos.imag.dtype,
        shape: a.shape
      },
      {
        dataId: bData.complexTensorInfos.real.dataId,
        dtype: bData.complexTensorInfos.real.dtype,
        shape: b.shape
      },
      {
        dataId: bData.complexTensorInfos.imag.dataId,
        dtype: bData.complexTensorInfos.imag.dtype,
        shape: b.shape
      }
    ];
    const realPart = backend3.runWebGLProgram(realProgram, inputs2, "float32");
    const imagPart = backend3.runWebGLProgram(imagProgram, inputs2, "float32");
    const complexOutput = complex9({ inputs: { real: realPart, imag: imagPart }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(realPart);
    backend3.disposeIntermediateTensorInfo(imagPart);
    return complexOutput;
  }
  if (backend3.shouldExecuteOnCPU([a, b])) {
    const aData = backend3.texData.get(a.dataId);
    const bData = backend3.texData.get(b.dataId);
    const [outValues, outShape] = multiplyImplCPU(a.shape, b.shape, aData.values, bData.values, dtype);
    const out = backend3.makeTensorInfo(outShape, dtype);
    const outData = backend3.texData.get(out.dataId);
    outData.values = outValues;
    return out;
  }
  let program;
  if (env().getBool("WEBGL_PACK_BINARY_OPERATIONS")) {
    program = new BinaryOpPackedProgram(MUL, a.shape, b.shape);
  } else {
    program = new BinaryOpProgram(MUL, a.shape, b.shape);
  }
  return backend3.runWebGLProgram(program, [a, b], dtype);
}
var MUL = "return a * b;", multiplyConfig2;
var init_Multiply2 = __esm(() => {
  init_dist();
  init_binaryop_complex_gpu();
  init_binaryop_complex_gpu();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  init_shared2();
  init_Complex2();
  multiplyConfig2 = {
    kernelName: Multiply,
    backendName: "webgl",
    kernelFunc: multiply3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reshape.js
function packedReshape(input2, afterShape, backend3) {
  const input3DShape = [
    getBatchDim(input2.shape),
    ...getRowsCols(input2.shape)
  ];
  const input3D = {
    dtype: input2.dtype,
    shape: input3DShape,
    dataId: input2.dataId
  };
  const afterShapeAs3D = [
    getBatchDim(afterShape),
    ...getRowsCols(afterShape)
  ];
  const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);
  const preventEagerUnpackingOfOutput = true;
  const customValues = [input3DShape];
  const output = backend3.runWebGLProgram(program, [input3D], input2.dtype, customValues, preventEagerUnpackingOfOutput);
  return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };
}
var init_reshape3 = __esm(() => {
  init_reshape_packed_gpu();
  init_webgl_util();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reshape.js
function reshape79(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { shape } = attrs;
  const webglBackend = backend3;
  const xSize = exports_util.sizeFromShape(x.shape);
  const $shape = exports_util.inferFromImplicitShape(shape, xSize);
  const $xSize = exports_util.sizeFromShape($shape);
  exports_util.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old ` + `shape (${x.shape}) has ${xSize} elements. The new shape and old ` + `shape must have the same number of elements.`);
  const xTexData = webglBackend.texData.get(x.dataId);
  if (xTexData.isPacked && !isReshapeFree(x.shape, $shape) && !(xTexData.texture !== null && isReshapeFree(xTexData.shape, $shape))) {
    return packedReshape(x, $shape, webglBackend);
  }
  webglBackend.incRef(x.dataId);
  return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
}
var reshapeConfig2;
var init_Reshape2 = __esm(() => {
  init_dist();
  init_reshape3();
  init_webgl_util();
  reshapeConfig2 = {
    kernelName: Reshape,
    backendName: "webgl",
    kernelFunc: reshape79
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js
class MeanProgram {
  constructor(reduceInfo, divisor) {
    this.variableNames = ["x"];
    const { windowSize, batchSize, inSize, outSize } = reduceInfo;
    this.outputShape = [batchSize, outSize];
    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
    const windowSizeVec4Remainder = windowSize % 4;
    let updateSnippet = `sumValue += dot(values, ones);`;
    if (divisor != null) {
      const denominator = 1 / divisor;
      updateSnippet = `sumValue += dot(values * ${exports_util.isInt(denominator) ? denominator.toPrecision(2) : denominator}, ones);`;
    }
    let checkOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return 0.0;
        }
      `;
    }
    this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${updateSnippet}
        }
        setOutput(sumValue);
      }
    `;
  }
}
var init_mean_gpu = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js
class ReduceProgram {
  constructor(reduceInfo, reduceType) {
    this.variableNames = ["x"];
    const { windowSize, batchSize, inSize, outSize } = reduceInfo;
    this.outputShape = [batchSize, outSize];
    let initializationValue = "0.0";
    let compareOp = ``;
    if (reduceType === "prod") {
      initializationValue = "1.0";
    } else if (reduceType === "min") {
      initializationValue = "1.0 / 1e-20";
      compareOp = `min`;
    } else if (reduceType === "max") {
      initializationValue = "-1.0 / 1e-20";
      compareOp = `max`;
    }
    let returnValue = `${reduceType}(${reduceType}(${reduceType}(` + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    if (reduceType === "sum") {
      returnValue = `sumValue`;
    } else if (reduceType === "prod") {
      returnValue = `prodValue`;
    } else if (reduceType === "all") {
      returnValue = `allValue`;
    } else if (reduceType === "any") {
      returnValue = `anyValue`;
    }
    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
    const windowSizeVec4Remainder = windowSize % 4;
    let updateSnippet = `
      if (${reduceType === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${reduceType === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
        if (${reduceType === "min"} || ${reduceType === "max"}) {
          minMaxValue = ${compareOp}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `;
    let vecType = `vec4`;
    if (reduceType === "all") {
      initializationValue = "1.0";
      updateSnippet = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `;
      vecType = `bvec4`;
    } else if (reduceType === "any") {
      initializationValue = "0.0";
      updateSnippet = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `;
      vecType = `bvec4`;
    }
    let checkOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
    }
    this.userCode = `
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${checkOutOfBounds}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        vec4 minMaxValue = vec4(${initializationValue});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          ${vecType} values = ${vecType}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/reduce.js
function getReductionStages(inShape) {
  const stages = [];
  while (stages.length === 0 || stages[stages.length - 1].outSize !== 1) {
    const outSize = stages.length ? stages[stages.length - 1].outSize : inShape[1];
    const windowSize = exports_backend_util.computeOptimalWindowSize(outSize);
    stages.push({
      inSize: outSize,
      windowSize,
      outSize: Math.ceil(outSize / windowSize)
    });
  }
  return stages;
}
function reduce(x, dtype, reductionType, backend3) {
  const reductionStages = getReductionStages(x.shape);
  let result = x;
  for (let i = 0;i < reductionStages.length; i++) {
    const { inSize, windowSize, outSize } = reductionStages[i];
    let program;
    let previousResult;
    if (reductionType === "mean") {
      program = i === 0 ? new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, inSize) : new MeanProgram({ windowSize, inSize, batchSize: x.shape[0], outSize });
    } else {
      program = new ReduceProgram({ windowSize, inSize, batchSize: x.shape[0], outSize }, reductionType);
    }
    previousResult = result;
    result = backend3.runWebGLProgram(program, [result], dtype);
    if (previousResult.dataId !== x.dataId) {
      backend3.disposeIntermediateTensorInfo(previousResult);
    }
  }
  return result;
}
var init_reduce = __esm(() => {
  init_dist();
  init_mean_gpu();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js
function getSwitchedCoords(newDim) {
  const rank = newDim.length;
  if (rank > 6) {
    throw Error(`Transpose for rank ${rank} is not yet supported`);
  }
  const originalOrder = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"];
  const switchedCoords = new Array(rank);
  for (let i = 0;i < newDim.length; i++) {
    switchedCoords[newDim[i]] = originalOrder[i];
  }
  return switchedCoords.join();
}

class TransposeProgram {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    const outputShape = new Array(aShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = aShape[newDim[i]];
    }
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    const dtype = getCoordsDataType(this.rank);
    const switched = getSwitchedCoords(newDim);
    this.userCode = `
    void main() {
      ${dtype} resRC = getOutputCoords();
      setOutput(getA(${switched}));
    }
    `;
  }
}
var init_transpose_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js
class TransposePackedProgram {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    const outputShape = new Array(aShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = aShape[newDim[i]];
    }
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    if (this.rank > 6) {
      throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
    }
    const dtype = getCoordsDataType(this.rank);
    const outputOrder = getVecChannels("rc", this.rank);
    const switchedOrder = new Array(this.rank);
    for (let i = 0;i < newDim.length; i++) {
      switchedOrder[newDim[i]] = outputOrder[i];
    }
    const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;
    const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;
    const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;
    this.userCode = `
    void main() {
      ${dtype} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${getc};
      if(${nextColumn}) {
        result[1] = ${getc};
      }
      --${outputOrder[this.rank - 1]};
      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {
        result[2] = ${getc};
        if(${nextColumn}) {
          result[3] = ${getc};
        }
      }
      setOutput(result);
    }
    `;
  }
}
var init_transpose_packed_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose_impl.js
function transposeImpl2(x, perm, backend3) {
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new TransposePackedProgram(x.shape, perm) : new TransposeProgram(x.shape, perm);
  return backend3.runWebGLProgram(program, [x], x.dtype);
}
var init_Transpose_impl2 = __esm(() => {
  init_dist();
  init_shared2();
  init_transpose_gpu();
  init_transpose_packed_gpu();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum_impl.js
function sumImpl(x, axis, keepDims, backend3) {
  const reductionIndices = axis;
  const xRank = x.shape.length;
  const origAxes = exports_util.parseAxisParam(reductionIndices, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  const sumInputIsTransposed = permutedAxes != null;
  let sumInput = x;
  if (sumInputIsTransposed) {
    sumInput = transposeImpl2(x, permutedAxes, backend3);
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
  }
  exports_backend_util.assertAxesAreInnerMostDims("sum", axes, xRank);
  const [sumOutShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(sumInput.shape, axes);
  let outShape = sumOutShape;
  if (keepDims) {
    outShape = exports_backend_util.expandShapeToKeepDim(sumOutShape, origAxes);
  }
  const inSize = exports_util.sizeFromShape(reduceShape);
  const xSize = exports_util.sizeFromShape(x.shape);
  const batchSize = xSize / inSize;
  const reshapedInput = reshape79({ inputs: { x: sumInput }, attrs: { shape: [batchSize, inSize] }, backend: backend3 });
  const outType = sumOutType(x.dtype);
  const reduced = reduce(reshapedInput, outType, "sum", backend3);
  const out = reshape79({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(reshapedInput);
  backend3.disposeIntermediateTensorInfo(reduced);
  if (sumInputIsTransposed) {
    backend3.disposeIntermediateTensorInfo(sumInput);
  }
  return out;
}
var init_Sum_impl = __esm(() => {
  init_dist();
  init_reduce();
  init_Reshape2();
  init_Transpose_impl2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sum.js
function sum28(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  return sumImpl(x, axis, keepDims, backend3);
}
var sumConfig2;
var init_Sum2 = __esm(() => {
  init_dist();
  init_Sum_impl();
  sumConfig2 = {
    kernelName: Sum,
    backendName: "webgl",
    kernelFunc: sum28
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transpose.js
function transpose12(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { perm } = attrs;
  const webglBackend = backend3;
  const xRank = x.shape.length;
  const newShape = new Array(xRank);
  for (let i = 0;i < newShape.length; i++) {
    newShape[i] = x.shape[perm[i]];
  }
  let out;
  if (webglBackend.shouldExecuteOnCPU([x])) {
    const xTexData = webglBackend.texData.get(x.dataId);
    const values = xTexData.values;
    const outValues = transposeImplCPU(values, x.shape, x.dtype, perm, newShape);
    out = webglBackend.makeTensorInfo(newShape, x.dtype);
    const outData = webglBackend.texData.get(out.dataId);
    outData.values = outValues;
  } else {
    out = transposeImpl2(x, perm, webglBackend);
  }
  return out;
}
var transposeConfig2;
var init_Transpose2 = __esm(() => {
  init_dist();
  init_Transpose_impl2();
  init_Transpose_impl2();
  transposeConfig2 = {
    kernelName: Transpose,
    backendName: "webgl",
    kernelFunc: transpose12
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul_impl.js
function batchMatMulImpl({ a, b, transposeA, transposeB, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const aRank = a.shape.length;
  const bRank = b.shape.length;
  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
  const outerDimsA = a.shape.slice(0, -2);
  const outerDimsB = b.shape.slice(0, -2);
  const batchDimA = exports_util.sizeFromShape(outerDimsA);
  const batchDimB = exports_util.sizeFromShape(outerDimsB);
  const outShapeOuterDims = exports_broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  exports_util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape79({ inputs: { x: a }, backend: backend3, attrs: { shape: a3dShape } });
  const b3d = reshape79({ inputs: { x: b }, backend: backend3, attrs: { shape: b3dShape } });
  const intermediates = [a3d, b3d];
  const batchDim = Math.max(batchDimA, batchDimB);
  const sharedDim = transposeA ? a3d.shape[1] : a3d.shape[2];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  const fusedActivation = activation2 != null ? mapActivationToShaderProgram(activation2, true) : null;
  const containsFusedOps = hasBias || hasPreluActivationWeights || hasLeakyreluAlpha || fusedActivation != null;
  let out;
  if ((outerShapeA === 1 || outerShapeB === 1) && sharedDim > MATMUL_SHARED_DIM_THRESHOLD && containsFusedOps === false) {
    let aVec = a3d;
    let bVec = b3d;
    if (transposeA) {
      aVec = transpose12({ inputs: { x: a3d }, backend: backend3, attrs: { perm: [0, 2, 1] } });
      intermediates.push(aVec);
    }
    if (transposeB) {
      bVec = transpose12({ inputs: { x: b3d }, backend: backend3, attrs: { perm: [0, 2, 1] } });
      intermediates.push(bVec);
    }
    const shouldReshapeA = outerShapeB !== 1;
    const shouldReshapeB = outerShapeB === 1;
    let aVec3d = aVec;
    if (shouldReshapeA) {
      aVec3d = reshape79({
        inputs: { x: aVec },
        backend: backend3,
        attrs: { shape: [batchDim, sharedDim, 1] }
      });
      intermediates.push(aVec3d);
    }
    const axis = outerShapeB === 1 ? 2 : 1;
    let bVec3d = bVec;
    if (shouldReshapeB) {
      bVec3d = reshape79({
        inputs: { x: bVec },
        backend: backend3,
        attrs: { shape: [batchDim, 1, sharedDim] }
      });
      intermediates.push(bVec3d);
    }
    const product = multiply3({ inputs: { a: aVec3d, b: bVec3d }, backend: backend3 });
    out = sum28({ inputs: { x: product }, backend: backend3, attrs: { axis, keepDims: true } });
    intermediates.push(product);
  } else {
    const dtype = upcastType(a.dtype, b.dtype);
    const program = new MatMulPackedProgram(a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs = [a3d, b3d];
    if (bias != null) {
      inputs.push(bias);
    }
    if (hasPreluActivationWeights) {
      inputs.push(preluActivationWeights);
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend3.makeTensorInfo([], "float32", exports_util.createScalarValue(leakyreluAlpha, "float32"));
      inputs.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    out = backend3.runWebGLProgram(program, inputs, dtype);
  }
  const outReshaped = reshape79({ inputs: { x: out }, backend: backend3, attrs: { shape: outShape } });
  intermediates.push(out);
  for (const i of intermediates) {
    backend3.disposeIntermediateTensorInfo(i);
  }
  return outReshaped;
}
var MATMUL_SHARED_DIM_THRESHOLD = 1000;
var init_BatchMatMul_impl = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_mulmat_packed_gpu();
  init_Multiply2();
  init_Reshape2();
  init_Sum2();
  init_Transpose2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/_FusedMatMul.js
function _fusedMatMul2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { a, b, bias, preluActivationWeights } = inputs;
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  return batchMatMulImpl({
    a,
    b,
    transposeA,
    transposeB,
    backend: backend3,
    bias,
    preluActivationWeights,
    leakyreluAlpha,
    activation: activation2
  });
}
var _fusedMatMulConfig2;
var init__FusedMatMul2 = __esm(() => {
  init_dist();
  init_BatchMatMul_impl();
  _fusedMatMulConfig2 = {
    kernelName: _FusedMatMul,
    backendName: "webgl",
    kernelFunc: _fusedMatMul2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Abs.js
function abs9(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (backend3.shouldExecuteOnCPU([x]) && x.dtype !== "complex64") {
    const xData = backend3.texData.get(x.dataId);
    const outValues = simpleAbsImplCPU(xData.values);
    return backend3.makeTensorInfo(x.shape, x.dtype, outValues);
  }
  let program;
  if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
    program = new UnaryOpPackedProgram(x.shape, ABS2);
  } else {
    program = new UnaryOpProgram(x.shape, ABS2);
  }
  return backend3.runWebGLProgram(program, [x], x.dtype);
}
var ABS2 = `return abs(x);`, absConfig2;
var init_Abs2 = __esm(() => {
  init_dist();
  init_shared2();
  init_unaryop_gpu();
  init_unaryop_packed_gpu();
  absConfig2 = {
    kernelName: Abs,
    backendName: "webgl",
    kernelFunc: abs9
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acos.js
var ACOS, acos4, acosConfig2;
var init_Acos2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  ACOS = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`;
  acos4 = unaryKernelFunc2({ opSnippet: ACOS });
  acosConfig2 = {
    kernelName: Acos,
    backendName: "webgl",
    kernelFunc: acos4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Acosh.js
var ACOSH, acosh4, acoshConfig2;
var init_Acosh2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  ACOSH = CHECK_NAN_SNIPPET + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`;
  acosh4 = unaryKernelFunc2({ opSnippet: ACOSH });
  acoshConfig2 = {
    kernelName: Acosh,
    backendName: "webgl",
    kernelFunc: acosh4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Add.js
var ADD = "return a + b;", addKernelFunc, addConfig2;
var init_Add2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  addKernelFunc = binaryKernelFunc2({
    opSnippet: ADD,
    packedOpSnippet: ADD,
    supportsComplex: true,
    cpuKernelImpl: addImplCPU
  });
  addConfig2 = {
    kernelName: Add,
    backendName: "webgl",
    kernelFunc: addKernelFunc
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js
class AddNProgram {
  constructor(outputShape, shapes) {
    this.outputShape = [];
    this.outputShape = outputShape;
    this.variableNames = shapes.map((_, i) => `T${i}`);
    const snippets = [];
    this.variableNames.forEach((variable2) => {
      snippets.push(`float v${variable2} = get${variable2}AtOutCoords();`);
    });
    const operation235 = this.variableNames.map((variable2) => {
      return `v${variable2}`;
    }).join(" + ");
    this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        float result = ${operation235};
        setOutput(result);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js
class AddNPackedProgram {
  constructor(outputShape, shapes) {
    this.outputShape = [];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = outputShape;
    this.variableNames = shapes.map((_, i) => `T${i}`);
    const snippets = [];
    this.variableNames.forEach((variable2) => {
      snippets.push(`vec4 v${variable2} = get${variable2}AtOutCoords();`);
    });
    const operation235 = this.variableNames.map((variable2) => {
      return `v${variable2}`;
    }).join(" + ");
    this.userCode = `
      void main() {
        ${snippets.join("\n        ")}

        vec4 result = ${operation235};
        setOutput(result);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AddN.js
function addN3(args) {
  const { inputs, backend: backend3 } = args;
  const tensors = inputs;
  if (tensors.length === 1) {
    return identity3({ inputs: { x: tensors[0] }, backend: backend3 });
  }
  if (tensors.length > env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    const midIndex = Math.floor(tensors.length / 2);
    const leftSide = addN3({ inputs: tensors.slice(0, midIndex), backend: backend3 });
    const rightSide = addN3({ inputs: tensors.slice(midIndex), backend: backend3 });
    return addN3({ inputs: [leftSide, rightSide], backend: backend3 });
  }
  const dtype = tensors.map((t) => t.dtype).reduce((d1, d2) => upcastType(d1, d2));
  const shapes = tensors.map((t) => t.shape);
  const usePackedOp = env().getBool("WEBGL_PACK");
  const program = usePackedOp ? new AddNPackedProgram(tensors[0].shape, shapes) : new AddNProgram(tensors[0].shape, shapes);
  return backend3.runWebGLProgram(program, tensors, dtype);
}
var addNConfig2;
var init_AddN2 = __esm(() => {
  init_dist();
  init_Identity2();
  addNConfig2 = {
    kernelName: AddN,
    backendName: "webgl",
    kernelFunc: addN3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/All.js
function all5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x.shape.length;
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  let permutedX = x;
  if (permutedAxes != null) {
    permutedX = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
  }
  exports_backend_util.assertAxesAreInnerMostDims("all", axes, xRank);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
  const inSize = exports_util.sizeFromShape(reduceShape);
  const a2D = reshape79({ inputs: { x: permutedX }, backend: backend3, attrs: { shape: [-1, inSize] } });
  const reduced = reduce(a2D, a2D.dtype, "all", backend3);
  let res;
  if (keepDims) {
    const newShape = exports_backend_util.expandShapeToKeepDim(outShape, origAxes);
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: newShape } });
  } else {
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: outShape } });
  }
  backend3.disposeIntermediateTensorInfo(a2D);
  backend3.disposeIntermediateTensorInfo(reduced);
  if (permutedAxes != null) {
    backend3.disposeIntermediateTensorInfo(permutedX);
  }
  return res;
}
var allConfig2;
var init_All2 = __esm(() => {
  init_dist();
  init_reduce();
  init_Reshape2();
  init_Transpose2();
  allConfig2 = {
    kernelName: All,
    backendName: "webgl",
    kernelFunc: all5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Any.js
function any5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x.shape.length;
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  let permutedX = x;
  if (permutedAxes != null) {
    permutedX = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
  }
  exports_backend_util.assertAxesAreInnerMostDims("any", axes, xRank);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
  const inSize = exports_util.sizeFromShape(reduceShape);
  const a2D = reshape79({ inputs: { x: permutedX }, backend: backend3, attrs: { shape: [-1, inSize] } });
  const reduced = reduce(a2D, a2D.dtype, "any", backend3);
  let res;
  if (keepDims) {
    const newShape = exports_backend_util.expandShapeToKeepDim(outShape, origAxes);
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: newShape } });
  } else {
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: outShape } });
  }
  backend3.disposeIntermediateTensorInfo(a2D);
  backend3.disposeIntermediateTensorInfo(reduced);
  if (permutedAxes != null) {
    backend3.disposeIntermediateTensorInfo(permutedX);
  }
  return res;
}
var anyConfig2;
var init_Any2 = __esm(() => {
  init_dist();
  init_reduce();
  init_Reshape2();
  init_Transpose2();
  anyConfig2 = {
    kernelName: Any,
    backendName: "webgl",
    kernelFunc: any5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js
class ArgMinMaxProgram {
  constructor(reduceInfo, op2, firstPass) {
    this.variableNames = ["A"];
    const { windowSize, batchSize, outSize } = reduceInfo;
    if (!firstPass) {
      this.variableNames.push("bestIndicesA");
    }
    this.outputShape = [batchSize, outSize];
    const compOp = op2 === "max" ? ">" : "<";
    const indexSnippet = firstPass ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${windowSize};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${windowSize}; i++) {
          int inIdx = ${indexSnippet};
          float candidate = getA(batch, inIdx);
          if (candidate ${compOp} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js
class ArgMinMaxPackedProgram {
  constructor(shape, windowSize, op2, firstPass) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    exports_util.assert(shape.length > 2, () => `Packed arg${op2.charAt(0).toUpperCase() + op2.slice(1)} supports only inputs with rank above 2.`);
    const inSize = shape[shape.length - 1];
    const outSize = Math.ceil(inSize / windowSize);
    this.outputShape = shape.slice(0, -1);
    if (outSize > 1) {
      this.outputShape.push(outSize);
    }
    if (!firstPass) {
      this.variableNames.push("bestIndicesA");
    }
    const outShape = this.outputShape;
    const rank = outShape.length;
    const dtype = getCoordsDataType(rank);
    const coords = getChannels("coords", rank);
    let sourceLocSetup;
    let sourceRank;
    if (outSize === 1) {
      sourceRank = rank + 1;
      const sourceLocDType = getCoordsDataType(sourceRank);
      sourceLocSetup = `
        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);
        ++${coords[rank - 1]};
        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);
        ++${coords[rank - 2]};
        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);
        --${coords[rank - 1]};
        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);
        --${coords[rank - 2]};`;
    } else {
      sourceRank = rank;
      sourceLocSetup = `
        ${dtype} sourceLocR = coords;
        ++${coords[rank - 1]};
        ${dtype} sourceLocG = coords;
        ++${coords[rank - 2]};
        ${dtype} sourceLocA = coords;
        --${coords[rank - 1]};
        ${dtype} sourceLocB = coords;
        --${coords[rank - 2]};`;
    }
    const channels = ["x", "y", "z", "w", "u", "v"].slice(0, sourceRank);
    const inChannel = "." + channels[sourceRank - 1];
    const intChannels = channels.map((x) => "int " + x);
    const srcRCoords = getChannels("sourceLocR", sourceRank - 1).concat("inIdx.r");
    const srcGCoords = getChannels("sourceLocG", sourceRank - 1).concat("inIdx.g");
    const srcBCoords = getChannels("sourceLocB", sourceRank - 1).concat("inIdx.b");
    const srcACoords = getChannels("sourceLocA", sourceRank - 1).concat("inIdx.a");
    const compOp = op2 === "max" ? "greaterThan" : "lessThan";
    const fetchCandidateIdx = firstPass ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),
                             getBestIndicesAChannel(${srcGCoords.join()}),
                             getBestIndicesAChannel(${srcBCoords.join()}),
                             getBestIndicesAChannel(${srcACoords.join()})));`;
    const fetchValue = `vec4(
            getAChannel(${srcRCoords.join()}),
            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,
            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;
    const getBestIndicesAChannelSnippet = firstPass ? "" : `
      float getBestIndicesAChannel(${intChannels.join()}) {
        return getChannel(getBestIndicesA(${channels.join()}),
                                          vec2(${channels.slice(-2).join()}));
      }`;
    this.userCode = `
      float getAChannel(${intChannels.join()}) {
        return getChannel(getA(${channels.join()}),
                               vec2(${channels.slice(-2).join()}));
      }
      ${getBestIndicesAChannelSnippet}
      void main() {
        ${dtype} coords = getOutputCoords();
        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};
        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};
        ${sourceLocSetup}
        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},
          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${fetchValue};

        for (int i = 0; i < ${windowSize}; i++) {
          inIdx = srcIdx;
          ${fetchCandidateIdx}
          vec4 candidate = ${fetchValue};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
  }
}
var init_argminmax_packed_gpu = __esm(() => {
  init_dist();
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/arg_min_max.js
function argReduce(backend3, x, reduceType, bestIndicesA = null) {
  let batchSize = x.shape[0];
  let inSize = x.shape[1];
  if (bestIndicesA != null) {
    batchSize = bestIndicesA.shape[0];
    inSize = bestIndicesA.shape[1];
  }
  const windowSize = exports_backend_util.computeOptimalWindowSize(inSize);
  const reduceInfo = { windowSize, inSize, batchSize, outSize: Math.ceil(inSize / windowSize) };
  const program = new ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
  const inputs = [x];
  if (bestIndicesA != null) {
    inputs.push(bestIndicesA);
  }
  const output = backend3.runWebGLProgram(program, inputs, "int32");
  if (output.shape[1] === 1) {
    return output;
  }
  const result = argReduce(backend3, x, reduceType, output);
  backend3.disposeIntermediateTensorInfo(output);
  return result;
}
function argReducePacked(backend3, x, reduceType, bestIndicesA = null) {
  const inShape = bestIndicesA != null ? bestIndicesA.shape : x.shape;
  const inSize = inShape[inShape.length - 1];
  const windowSize = exports_backend_util.computeOptimalWindowSize(inSize);
  const program = new ArgMinMaxPackedProgram(inShape, windowSize, reduceType, bestIndicesA == null);
  const inputs = bestIndicesA == null ? [x] : [x, bestIndicesA];
  const output = backend3.runWebGLProgram(program, inputs, "int32");
  if (output.shape.length === x.shape.length) {
    const result = argReducePacked(backend3, x, reduceType, output);
    backend3.disposeIntermediateTensorInfo(output);
    return result;
  }
  return output;
}
function argMinMaxReduce(backend3, x, axis, reduceType) {
  const axes = [axis];
  exports_backend_util.assertAxesAreInnerMostDims("arg" + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes, x.shape.length);
  if (!env().getBool("WEBGL_PACK_REDUCE") || x.shape.length <= 2) {
    const intermediateTensorInfos = [];
    const xtexData = backend3.texData.get(x.dataId);
    const xIsPacked = xtexData !== null && xtexData.isPacked;
    let xUnPacked = x;
    if (xIsPacked) {
      xUnPacked = backend3.unpackTensor(x);
      intermediateTensorInfos.push(xUnPacked);
    }
    const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(xUnPacked.shape, axes);
    const inSize = exports_util.sizeFromShape(reduceShape);
    const a2D = reshape79({ inputs: { x: xUnPacked }, backend: backend3, attrs: { shape: [-1, inSize] } });
    intermediateTensorInfos.push(a2D);
    const reduced = argReduce(backend3, a2D, reduceType);
    intermediateTensorInfos.push(reduced);
    const reshaped = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: outShape } });
    intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
    return reshaped;
  }
  return argReducePacked(backend3, x, reduceType);
}
var init_arg_min_max = __esm(() => {
  init_dist();
  init_argminmax_packed_gpu();
  init_Reshape2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMax.js
function argMax3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis } = attrs;
  let axes = exports_util.parseAxisParam(axis, x.shape);
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = exports_backend_util.getInnerMostAxes(axes.length, $x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
  const out = argMinMaxReduce(backend3, $x, axes[0], "max");
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return out;
}
var argMaxConfig2;
var init_ArgMax2 = __esm(() => {
  init_dist();
  init_arg_min_max();
  init_Transpose2();
  argMaxConfig2 = {
    kernelName: ArgMax,
    backendName: "webgl",
    kernelFunc: argMax3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ArgMin.js
function argMin3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis } = attrs;
  let axes = exports_util.parseAxisParam(axis, x.shape);
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = exports_backend_util.getInnerMostAxes(axes.length, $x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
  const out = argMinMaxReduce(backend3, $x, axes[0], "min");
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return out;
}
var argMinConfig2;
var init_ArgMin2 = __esm(() => {
  init_dist();
  init_arg_min_max();
  init_Transpose2();
  argMinConfig2 = {
    kernelName: ArgMin,
    backendName: "webgl",
    kernelFunc: argMin3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asin.js
var ASIN, asin4, asinConfig2;
var init_Asin2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  ASIN = CHECK_NAN_SNIPPET + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`;
  asin4 = unaryKernelFunc2({ opSnippet: ASIN });
  asinConfig2 = {
    kernelName: Asin,
    backendName: "webgl",
    kernelFunc: asin4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Asinh.js
var ASINH, asinh4, asinhConfig2;
var init_Asinh2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  ASINH = CHECK_NAN_SNIPPET + `return log(x + sqrt(x * x + 1.0));`;
  asinh4 = unaryKernelFunc2({ opSnippet: ASINH });
  asinhConfig2 = {
    kernelName: Asinh,
    backendName: "webgl",
    kernelFunc: asinh4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan.js
var ATAN, atan6, atanConfig2;
var init_Atan3 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  ATAN = CHECK_NAN_SNIPPET + `
  return atan(x);
`;
  atan6 = unaryKernelFunc2({ opSnippet: ATAN });
  atanConfig2 = {
    kernelName: Atan,
    backendName: "webgl",
    kernelFunc: atan6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atan2.js
var ATAN2, ATAN2_PACKED, atan25, atan2Config2;
var init_Atan22 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  ATAN2 = CHECK_NAN_SNIPPET2 + `
  return atan(a, b);
`;
  ATAN2_PACKED = `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  atan25 = binaryKernelFunc2({ opSnippet: ATAN2, packedOpSnippet: ATAN2_PACKED });
  atan2Config2 = {
    kernelName: Atan2,
    backendName: "webgl",
    kernelFunc: atan25
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Atanh.js
var ATANH, atanh4, atanhConfig2;
var init_Atanh2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  ATANH = CHECK_NAN_SNIPPET + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`;
  atanh4 = unaryKernelFunc2({ opSnippet: ATANH });
  atanhConfig2 = {
    kernelName: Atanh,
    backendName: "webgl",
    kernelFunc: atanh4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js
class Pool2DProgram {
  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
    this.variableNames = ["x"];
    if (poolType === "avg" && computePositions) {
      throw new Error("Cannot compute positions for average pool.");
    }
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    this.outputShape = convInfo.outShape;
    const isAvgPool = poolType === "avg";
    const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
    const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;
    let initializationValue = "0.0";
    if (!isAvgPool) {
      initializationValue = "-1.0 / 1e-20";
    }
    if (computePositions) {
      const compareOp2 = ">=";
      this.userCode = `
        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
        const ivec2 pads = ivec2(${padTop}, ${padLeft});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${compareOp2} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${flattenPositions ? includeBatchInIndex ? batchFlattenPositionStr : flattenPositionStr : `wR * ${effectiveFilterWidth} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const compareOp = "max";
    let returnValue = `${poolType}(${poolType}(${poolType}(` + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    if (poolType === "avg") {
      returnValue = `avgValue / max(count, 1.0)`;
    }
    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
    const filterWidthVec4Remainder = filterWidth % 4;
    const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
            int xC = xCCorner + wC * ${dilationWidth};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)
            );

            ${updateSnippet}
          }

          int xC = xCCorner + ${filterWidthNearestVec4};
          if (${filterWidthVec4Remainder === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              initializationValue,
              initializationValue
            );

            ${updateSnippet}
          } else if (${filterWidthVec4Remainder === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${dilationWidth}, d),
              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),
              initializationValue
            );

            ${updateSnippet}
          }
        }
        setOutput(${returnValue});
      }
    `;
  }
}

class Pool3DProgram {
  constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {
    this.variableNames = ["x"];
    if (poolType === "avg" && computePositions) {
      throw new Error("Cannot compute positions for average pool.");
    }
    const filterWidth = convInfo.filterWidth;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    this.outputShape = convInfo.outShape;
    const isAvgPool = poolType === "avg";
    let initializationValue = "0.0";
    if (!isAvgPool) {
      initializationValue = "-1.0 / 1e-20";
    }
    if (computePositions) {
      const compareOp2 = ">=";
      this.userCode = `
        const ivec3 strides =
            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${effectiveFilterDepth};
              wD += ${dilationDepth}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${convInfo.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${effectiveFilterHeight};
                wR += ${dilationHeight}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${effectiveFilterWidth};
                  wC += ${dilationWidth}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${compareOp2} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${flattenPositions ? includeBatchInIndex ? `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` : `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                      wR * ${effectiveFilterWidth} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;
      return;
    }
    const compareOp = "max";
    let returnValue = `${poolType}(${poolType}(${poolType}(` + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    if (poolType === "avg") {
      returnValue = `avgValue / max(count, 1.0)`;
    }
    const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
    const filterWidthVec4Remainder = filterWidth % 4;
    const updateSnippet = `
      if (${isAvgPool}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${compareOp}(values, minMaxValue);
      }
    `;
    this.userCode = `
      const ivec3 strides =
        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float initializationValue = ${initializationValue};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${convInfo.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${initializationValue});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {
              int xC = xCCorner + wC * ${dilationWidth};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)
              );

              ${updateSnippet}
            }

            int xC = xCCorner + ${filterWidthNearestVec4};
            if (${filterWidthVec4Remainder === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                initializationValue,
                initializationValue
              );

              ${updateSnippet}
            } else if (${filterWidthVec4Remainder === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),
                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),
                initializationValue
              );

              ${updateSnippet}
            }
          }
        }
        setOutput(${returnValue});
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool.js
function avgPool3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  assertNotComplex2(x, "avgPool");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = 1;
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in avgPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && exports_util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    return identity3({ inputs: { x }, backend: backend3 });
  }
  const avgPoolProgram = new Pool2DProgram(convInfo, "avg", false);
  return backend3.runWebGLProgram(avgPoolProgram, [x], "float32");
}
var avgPoolConfig2;
var init_AvgPool2 = __esm(() => {
  init_dist();
  init_webgl_util();
  init_Identity2();
  avgPoolConfig2 = {
    kernelName: AvgPool,
    backendName: "webgl",
    kernelFunc: avgPool3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3D.js
function avgPool3D2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode, dataFormat } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode, dataFormat);
  const avgPoolProgram = new Pool3DProgram(convInfo, "avg", false);
  return backend3.runWebGLProgram(avgPoolProgram, [x], "float32");
}
var avgPool3DConfig2;
var init_AvgPool3D2 = __esm(() => {
  init_dist();
  avgPool3DConfig2 = {
    kernelName: AvgPool3D,
    backendName: "webgl",
    kernelFunc: avgPool3D2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js
class AvgPool2DBackpropProgram {
  constructor(convInfo) {
    this.variableNames = ["dy"];
    this.outputShape = convInfo.inShape;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const avgMultiplier = 1 / (filterHeight * filterWidth);
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
            wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth};
            wC+= ${dilationWidth}) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

class AvgPool3DBackpropProgram {
  constructor(convInfo) {
    this.variableNames = ["dy"];
    this.outputShape = convInfo.inShape;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);
    this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});
      const float avgMultiplier = float(${avgMultiplier});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
            wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPool3DGrad.js
function avgPool3DGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  const avgPoolBackpropProgram = new AvgPool3DBackpropProgram(convInfo);
  return backend3.runWebGLProgram(avgPoolBackpropProgram, [dy2], x.dtype);
}
var avgPool3DGradConfig3;
var init_AvgPool3DGrad2 = __esm(() => {
  init_dist();
  avgPool3DGradConfig3 = {
    kernelName: AvgPool3DGrad,
    backendName: "webgl",
    kernelFunc: avgPool3DGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/AvgPoolGrad.js
function avgPoolGrad3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  assertNotComplex2([dy2, input2], "avgPoolGrad");
  const { filterSize, strides, pad: pad9 } = attrs;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, 1, pad9);
  const avgPoolBackpropProgram = new AvgPool2DBackpropProgram(convInfo);
  return backend3.runWebGLProgram(avgPoolBackpropProgram, [dy2], x.dtype);
}
var avgPoolGradConfig3;
var init_AvgPoolGrad2 = __esm(() => {
  init_dist();
  init_webgl_util();
  avgPoolGradConfig3 = {
    kernelName: AvgPoolGrad,
    backendName: "webgl",
    kernelFunc: avgPoolGrad3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchMatMul.js
function batchMatMul2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { a, b } = inputs;
  const { transposeA, transposeB } = attrs;
  return batchMatMulImpl({ a, b, transposeA, transposeB, backend: backend3 });
}
var batchMatMulConfig2;
var init_BatchMatMul2 = __esm(() => {
  init_dist();
  init_BatchMatMul_impl();
  batchMatMulConfig2 = {
    kernelName: BatchMatMul,
    backendName: "webgl",
    kernelFunc: batchMatMul2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js
class BatchNormProgram {
  constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
    this.outputShape = [];
    this.variableNames = ["x", "mean", "variance"];
    exports_backend_util.assertAndGetBroadcastShape(xShape, meanShape);
    exports_backend_util.assertAndGetBroadcastShape(xShape, varianceShape);
    let offsetSnippet = "0.0";
    if (offsetShape != null) {
      exports_backend_util.assertAndGetBroadcastShape(xShape, offsetShape);
      this.variableNames.push("offset");
      offsetSnippet = "getOffsetAtOutCoords()";
    }
    let scaleSnippet = "1.0";
    if (scaleShape != null) {
      exports_backend_util.assertAndGetBroadcastShape(xShape, scaleShape);
      this.variableNames.push("scale");
      scaleSnippet = "getScaleAtOutCoords()";
    }
    this.outputShape = xShape;
    this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${offsetSnippet};
        float scale = ${scaleSnippet};
        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
  }
}
var init_batchnorm_gpu = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js
class BatchNormPackedProgram {
  constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
    this.packedInputs = true;
    this.packedOutput = true;
    this.variableNames = ["x", "mean", "variance"];
    exports_backend_util.assertAndGetBroadcastShape(xShape, meanShape);
    exports_backend_util.assertAndGetBroadcastShape(xShape, varianceShape);
    let offsetSnippet = "vec4(0.0)";
    if (offsetShape != null) {
      exports_backend_util.assertAndGetBroadcastShape(xShape, offsetShape);
      this.variableNames.push("offset");
      offsetSnippet = "getOffsetAtOutCoords()";
    }
    let scaleSnippet = "vec4(1.0)";
    if (scaleShape != null) {
      exports_backend_util.assertAndGetBroadcastShape(xShape, scaleShape);
      this.variableNames.push("scale");
      scaleSnippet = "getScaleAtOutCoords()";
    }
    this.outputShape = xShape;
    this.userCode = `
      void main() {
        vec4 offset = ${offsetSnippet};
        vec4 scale = ${scaleSnippet};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));

        setOutput((x - mean) * inv + offset);
      }
    `;
  }
}
var init_batchnorm_packed_gpu = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchNorm.js
var batchNorm3 = ({ inputs, backend: backend3, attrs }) => {
  const { x, mean: mean7, variance, offset, scale: scale2 } = inputs;
  exports_util.assert(mean7.shape.length === variance.shape.length, () => "Batch normalization gradient requires mean and variance to have " + "equal ranks.");
  exports_util.assert(offset == null || mean7.shape.length === offset.shape.length, () => "Batch normalization gradient requires mean and offset to have " + "equal ranks.");
  exports_util.assert(scale2 == null || mean7.shape.length === scale2.shape.length, () => "Batch normalization gradient requires mean and scale to have " + "equal ranks.");
  let { varianceEpsilon } = attrs;
  if (varianceEpsilon == null) {
    varianceEpsilon = 0.001;
  }
  const finalInputs = [x, mean7, variance];
  let offsetShape = null;
  if (offset != null) {
    offsetShape = offset.shape;
    finalInputs.push(offset);
  }
  let scaleShape = null;
  if (scale2 != null) {
    scaleShape = scale2.shape;
    finalInputs.push(scale2);
  }
  const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new BatchNormPackedProgram(x.shape, mean7.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon) : new BatchNormProgram(x.shape, mean7.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
  const output = backend3.runWebGLProgram(program, finalInputs, finalInputs[0].dtype);
  return output;
}, batchNormConfig2;
var init_BatchNorm2 = __esm(() => {
  init_dist();
  init_batchnorm_gpu();
  init_batchnorm_packed_gpu();
  batchNormConfig2 = {
    kernelName: FusedBatchNorm,
    backendName: "webgl",
    kernelFunc: batchNorm3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js
function getCoords(rank) {
  if (rank === 1) {
    return "sourceLoc";
  } else if (rank <= 6) {
    return coords.slice(0, rank).map((x) => "sourceLoc." + x).join(",");
  } else {
    throw Error(`Slicing for rank ${rank} is not yet supported`);
  }
}

class SliceProgram {
  constructor(destSize) {
    this.variableNames = ["source"];
    this.outputShape = destSize;
    this.rank = destSize.length;
    const dtype = getCoordsDataType(this.rank);
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const sourceCoords = getCoords(this.rank);
    let body;
    const coordSum = destSize.map((_, i) => {
      return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;
    });
    body = `
        ${dtype} sourceLoc;
        ${dtype} coords = getOutputCoords();
        ${coordSum.join("\n")}
      `;
    this.userCode = `
      void main() {
        ${body}
        setOutput(getSource(${sourceCoords}));
      }
    `;
  }
}
var coords;
var init_slice_gpu = __esm(() => {
  init_shader_compiler();
  coords = ["x", "y", "z", "w", "u", "v"];
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js
class SlicePackedProgram {
  constructor(destSize) {
    this.variableNames = ["source"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = destSize;
    this.rank = destSize.length;
    this.customUniforms = [{ name: "start", arrayIndex: this.rank, type: "int" }];
    const dtype = getCoordsDataType(this.rank);
    const coords2 = getChannels("coords", this.rank);
    const sourceLoc = getChannels("sourceLoc", this.rank);
    const innerDims = this.rank === 1 ? "sourceLoc" : `vec2(${sourceLoc.slice(-2).join()})`;
    const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;
    const upperRow = `
      result.x = ${getChannel};
      if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
        ++${sourceLoc[this.rank - 1]};
        result.y = ${getChannel};
        --${sourceLoc[this.rank - 1]};
      }
    `;
    const lowerRow = this.rank === 1 ? "" : `
      --${coords2[this.rank - 1]};
      if (++${coords2[this.rank - 2]} < ${destSize[this.rank - 2]}) {
        ++${sourceLoc[this.rank - 2]};
        result.z = ${getChannel};
        if (++${coords2[this.rank - 1]} < ${destSize[this.rank - 1]}) {
          ++${sourceLoc[this.rank - 1]};
          result.w = ${getChannel};
        }
      }
    `;
    const sourceLocSetup = this.rank <= 4 ? `sourceLoc = coords +
            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` : destSize.map((_, i) => `${sourceLoc[i]} = ${coords2[i]} + start[${i}];`).join("\n");
    this.userCode = `
      void main() {
        ${dtype} coords = getOutputCoords();
        ${dtype} sourceLoc;
        ${sourceLocSetup}
        vec4 result = vec4(0.);
        ${upperRow}
        ${lowerRow}
        setOutput(result);
      }
    `;
  }
}
var init_slice_packed_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Slice.js
function shallowSlice(x, begin, size, backend3) {
  const xTexData = backend3.texData.get(x.dataId);
  const t = backend3.makeTensorInfo(size, x.dtype);
  const newTexData = backend3.texData.get(t.dataId);
  Object.assign(newTexData, xTexData);
  newTexData.refCount = 1;
  newTexData.shape = size;
  newTexData.dtype = x.dtype;
  let flatOffset = exports_slice_util.computeFlatOffset(begin, exports_util.computeStrides(x.shape));
  if (xTexData.slice) {
    flatOffset += xTexData.slice.flatOffset;
  }
  newTexData.slice = {
    flatOffset,
    origDataId: xTexData.slice && xTexData.slice.origDataId || x.dataId
  };
  const refCount = backend3.dataRefCount.get(newTexData.slice.origDataId) || 1;
  backend3.dataRefCount.set(newTexData.slice.origDataId, refCount + 1);
  return t;
}
function slice17(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { begin, size } = attrs;
  const [$begin, $size] = exports_slice_util.parseSliceParams(x, begin, size);
  exports_slice_util.assertParamsValid(x, $begin, $size);
  if (exports_util.sizeFromShape($size) === 0) {
    return backend3.makeTensorInfo($size, x.dtype, []);
  }
  if (backend3.shouldExecuteOnCPU([x]) || x.dtype === "string") {
    const xTexData = backend3.texData.get(x.dataId);
    const outValues = sliceImplCPU(xTexData.values, $begin, $size, x.shape, x.dtype);
    return backend3.makeTensorInfo($size, x.dtype, outValues);
  }
  const { isPacked } = backend3.texData.get(x.dataId);
  const isContinous = exports_slice_util.isSliceContinous(x.shape, $begin, $size);
  if (isPacked || !isContinous) {
    const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new SlicePackedProgram($size) : new SliceProgram($size);
    const customValues = [$begin];
    return backend3.runWebGLProgram(program, [x], x.dtype, customValues);
  }
  backend3.uploadToGPU(x.dataId);
  return shallowSlice(x, $begin, $size, backend3);
}
var sliceConfig2;
var init_Slice2 = __esm(() => {
  init_dist();
  init_shared2();
  init_slice_gpu();
  init_slice_packed_gpu();
  sliceConfig2 = {
    kernelName: Slice,
    backendName: "webgl",
    kernelFunc: slice17
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BatchToSpaceND.js
var batchToSpaceND3 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockShape, crops } = attrs;
  exports_util.assert(x.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not " + "implemented yet");
  const prod5 = blockShape.reduce((a, b) => a * b);
  const reshaped = exports_backend_util.getReshaped(x.shape, blockShape, prod5);
  const permuted = exports_backend_util.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = exports_backend_util.getReshapedPermuted(x.shape, blockShape, prod5);
  const sliceBeginCoords = exports_backend_util.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = exports_backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const toDispose = [];
  const reshapedIntermediate = reshape79({ inputs: { x }, backend: backend3, attrs: { shape: reshaped } });
  const transposedIntermediate = transpose12({ inputs: { x: reshapedIntermediate }, backend: backend3, attrs: { perm: permuted } });
  const reshapedIntermediate2 = reshape79({
    inputs: { x: transposedIntermediate },
    backend: backend3,
    attrs: { shape: reshapedPermuted }
  });
  const sliced = slice17({
    inputs: { x: reshapedIntermediate2 },
    backend: backend3,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  toDispose.push(reshapedIntermediate);
  toDispose.push(transposedIntermediate);
  toDispose.push(reshapedIntermediate2);
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return sliced;
}, batchToSpaceNDConfig2;
var init_BatchToSpaceND2 = __esm(() => {
  init_dist();
  init_Reshape2();
  init_Slice2();
  init_Transpose2();
  batchToSpaceNDConfig2 = {
    kernelName: BatchToSpaceND,
    backendName: "webgl",
    kernelFunc: batchToSpaceND3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Bincount.js
function bincount4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, weights } = inputs;
  const { size } = attrs;
  const xVals = backend3.readSync(x.dataId);
  const weightsVals = backend3.readSync(weights.dataId);
  const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
  return backend3.makeTensorInfo([size], weights.dtype, outVals);
}
var bincountConfig2;
var init_Bincount2 = __esm(() => {
  init_dist();
  init_shared2();
  bincountConfig2 = {
    kernelName: Bincount,
    backendName: "webgl",
    kernelFunc: bincount4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BitwiseAnd.js
function bitwiseAnd3(args) {
  const { inputs, backend: backend3 } = args;
  const { a, b } = inputs;
  const shouldUsePackedProgram = env().getBool("WEBGL_PACK_BINARY_OPERATIONS");
  const versionNumber = env().getNumber("WEBGL_VERSION");
  if (backend3.shouldExecuteOnCPU([a, b]) || versionNumber === 1) {
    const aVals = backend3.texData.get(a.dataId).values;
    const bVals = backend3.texData.get(b.dataId).values;
    const [outValues, outShape] = bitwiseAndImplCPU(a.shape, b.shape, aVals, bVals, a.dtype);
    const out = backend3.makeTensorInfo(outShape, a.dtype);
    const outData = backend3.texData.get(out.dataId);
    outData.values = outValues;
    return out;
  }
  let program;
  if (shouldUsePackedProgram) {
    program = new BinaryOpPackedProgram(BITWISEAND, a.shape, b.shape, false);
  } else {
    program = new BinaryOpProgram(BITWISEAND_UNPACKED, a.shape, b.shape);
  }
  return backend3.runWebGLProgram(program, [a, b], a.dtype);
}
var BITWISEAND = `
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`, BITWISEAND_UNPACKED = `
  return float(int(a.r) & int(b.r));
`, bitwiseAndConfig2;
var init_BitwiseAnd2 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  init_shared2();
  bitwiseAndConfig2 = {
    kernelName: BitwiseAnd,
    backendName: "webgl",
    kernelFunc: bitwiseAnd3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/BroadcastArgs.js
function broadcastArgs3(args) {
  const { inputs, backend: backend3 } = args;
  const { s0, s1 } = inputs;
  const s0Vals = backend3.readSync(s0.dataId);
  const s1Vals = backend3.readSync(s1.dataId);
  const broadcastShape = exports_backend_util.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
  return backend3.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
}
var broadcastArgsConfig2;
var init_BroadcastArgs2 = __esm(() => {
  init_dist();
  broadcastArgsConfig2 = {
    kernelName: BroadcastArgs,
    backendName: "webgl",
    kernelFunc: broadcastArgs3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NotEqual.js
var NOT_EQUAL = `return float(a != b);`, notEqual3, notEqualConfig2;
var init_NotEqual2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  notEqual3 = binaryKernelFunc2({ opSnippet: NOT_EQUAL, cpuKernelImpl: notEqualImplCPU, dtype: "bool" });
  notEqualConfig2 = {
    kernelName: NotEqual,
    backendName: "webgl",
    kernelFunc: notEqual3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Real.js
function real6(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const inputData = backend3.texData.get(input2.dataId);
  return identity3({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend3 });
}
var realConfig2;
var init_Real2 = __esm(() => {
  init_dist();
  init_Identity2();
  realConfig2 = {
    kernelName: Real,
    backendName: "webgl",
    kernelFunc: real6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernel_utils/int.js
function int(input2, backend3) {
  const program = new UnaryOpProgram(input2.shape, TO_INT);
  const output = backend3.runWebGLProgram(program, [input2], "int32");
  return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
}
var TO_INT = `return float(int(x));`;
var init_int = __esm(() => {
  init_unaryop_gpu();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cast.js
function cast47(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { dtype } = attrs;
  if (dtype === "complex64") {
    if (x.dtype === "complex64") {
      return identity3({ inputs: { x }, backend: backend3 });
    }
    const zerosTensor = zeros(x.shape);
    const floatX = cast47({ inputs: { x }, backend: backend3, attrs: { dtype: "float32" } });
    const result = complex9({ inputs: { real: floatX, imag: zerosTensor }, backend: backend3 });
    zerosTensor.dispose();
    backend3.disposeIntermediateTensorInfo(floatX);
    return result;
  }
  if (x.dtype === "complex64") {
    const realPart = real6({ inputs: { input: x }, backend: backend3 });
    const result = cast47({ inputs: { x: realPart }, backend: backend3, attrs: { dtype } });
    backend3.disposeIntermediateTensorInfo(realPart);
    return result;
  }
  if (!exports_util.hasEncodingLoss(x.dtype, dtype)) {
    const result = identity3({ inputs: { x }, backend: backend3 });
    return { dataId: result.dataId, shape: result.shape, dtype };
  }
  if (backend3.shouldExecuteOnCPU([x])) {
    const values = backend3.texData.get(x.dataId).values;
    const [resultShape, resultType, resultData] = castImplCPU(values, x.shape, x.dtype, dtype);
    return backend3.makeTensorInfo(resultShape, resultType, resultData);
  }
  if (dtype === "int32") {
    return int(x, backend3);
  }
  if (dtype === "bool") {
    const zerosTensorInfo = backend3.makeTensorInfo([], "bool", exports_util.getTypedArrayFromDType("bool", 1));
    const binaryInputs = { a: x, b: zerosTensorInfo };
    const result = notEqual3({ inputs: binaryInputs, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(zerosTensorInfo);
    return result;
  }
  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
}
var castConfig2;
var init_Cast2 = __esm(() => {
  init_dist();
  init_dist();
  init_shared2();
  init_Complex2();
  init_Identity2();
  init_NotEqual2();
  init_Real2();
  init_int();
  castConfig2 = {
    kernelName: Cast,
    backendName: "webgl",
    kernelFunc: cast47
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Ceil.js
var CEIL = `return ceil(x);`, ceil4, ceilConfig2;
var init_Ceil2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  ceil4 = unaryKernelFunc2({ opSnippet: CEIL, packedOpSnippet: CEIL, cpuKernelImpl: ceilImplCPU });
  ceilConfig2 = {
    kernelName: Ceil,
    backendName: "webgl",
    kernelFunc: ceil4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js
class ClipProgram {
  constructor(aShape) {
    this.variableNames = ["A"];
    this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ];
    this.outputShape = aShape;
    this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js
class ClipPackedProgram {
  constructor(aShape) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "minVal", type: "float" },
      { name: "maxVal", type: "float" }
    ];
    this.outputShape = aShape;
    this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ClipByValue.js
function clipByValue3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { clipValueMin, clipValueMax } = attrs;
  let program;
  if (env().getBool("WEBGL_PACK_CLIP")) {
    program = new ClipPackedProgram(x.shape);
  } else {
    program = new ClipProgram(x.shape);
  }
  const customValues = [[clipValueMin], [clipValueMax]];
  return backend3.runWebGLProgram(program, [x], x.dtype, customValues);
}
var clipByValueConfig2;
var init_ClipByValue2 = __esm(() => {
  init_dist();
  clipByValueConfig2 = {
    kernelName: ClipByValue,
    backendName: "webgl",
    kernelFunc: clipByValue3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js
class ComplexAbsProgram {
  constructor(shape) {
    this.variableNames = ["real", "imag"];
    this.outputShape = shape;
    this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ComplexAbs.js
function makeComplexComponentTensorInfo(complexTensor, complexPart) {
  return {
    dataId: complexPart.dataId,
    dtype: complexPart.dtype,
    shape: complexTensor.shape
  };
}
function complexAbs2(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  const xData = backend3.texData.get(x.dataId);
  const program = new ComplexAbsProgram(x.shape);
  const programInputs = [
    makeComplexComponentTensorInfo(x, xData.complexTensorInfos.real),
    makeComplexComponentTensorInfo(x, xData.complexTensorInfos.imag)
  ];
  return backend3.runWebGLProgram(program, programInputs, programInputs[0].dtype);
}
var complexAbsConfig2;
var init_ComplexAbs2 = __esm(() => {
  init_dist();
  complexAbsConfig2 = {
    kernelName: ComplexAbs,
    backendName: "webgl",
    kernelFunc: complexAbs2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js
class ConcatProgram {
  constructor(shapes) {
    this.outputShape = [];
    this.outputShape = exports_backend_util.computeOutShape(shapes, 1);
    this.variableNames = shapes.map((_, i) => `T${i}`);
    const offsets = new Array(shapes.length - 1);
    offsets[0] = shapes[0][1];
    for (let i = 1;i < offsets.length; i++) {
      offsets[i] = offsets[i - 1] + shapes[i][1];
    }
    const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];
    for (let i = 1;i < offsets.length; i++) {
      const shift = offsets[i - 1];
      snippets.push(`else if (yC < ${offsets[i]}) ` + `setOutput(getT${i}(yR, yC-${shift}));`);
    }
    const lastIndex = offsets.length;
    const lastShift = offsets[offsets.length - 1];
    snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${snippets.join("\n        ")}
      }
    `;
  }
}
var init_concat_gpu = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js
function shiftedChannels(channels, channel, shift) {
  const channelIdx = channels.indexOf(channel);
  const res = channels.map((c, idx) => {
    if (idx === channelIdx) {
      return `${c} - ${shift}`;
    } else {
      return c;
    }
  });
  return res.join();
}

class ConcatPackedProgram {
  constructor(shapes, axis) {
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    this.outputShape = exports_backend_util.computeOutShape(shapes, axis);
    const shape = this.outputShape;
    const rank = shape.length;
    const dtype = getCoordsDataType(rank);
    const coords2 = getChannels("coords", rank);
    const channels = ["x", "y", "z", "w", "u", "v"].slice(0, rank);
    this.variableNames = shapes.map((_, i) => `T${i}`);
    const offsets = new Array(shapes.length - 1);
    offsets[0] = shapes[0][axis];
    for (let i = 1;i < offsets.length; i++) {
      offsets[i] = offsets[i - 1] + shapes[i][axis];
    }
    const channel = channels[axis];
    const lastChannels = channels.slice(-2);
    const allChannels = channels.join();
    let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getT0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
    for (let i = 1;i < offsets.length; i++) {
      const shift2 = offsets[i - 1];
      getValueSnippet += `
        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
          return getChannel(
            getT${i}(${shiftedChannels(channels, channel, shift2)}),
            vec2(${shiftedChannels(lastChannels, channel, shift2)}));
        }`;
    }
    const lastIndex = offsets.length;
    const shift = offsets[offsets.length - 1];
    getValueSnippet += `
        return getChannel(
          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),
          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;
    this.userCode = `
      float getValue(${channels.map((x) => "int " + x)}) {
        ${getValueSnippet}
      }

      void main() {
        ${dtype} coords = getOutputCoords();
        vec4 result = vec4(getValue(${coords2}), 0., 0., 0.);

        ${coords2[rank - 1]} = ${coords2[rank - 1]} + 1;
        if (${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.g = getValue(${coords2});
        }

        ${coords2[rank - 2]} = ${coords2[rank - 2]} + 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]}) {
          result.a = getValue(${coords2});
        }

        ${coords2[rank - 1]} = ${coords2[rank - 1]} - 1;
        if (${coords2[rank - 2]} < ${shape[rank - 2]} &&
            ${coords2[rank - 1]} < ${shape[rank - 1]}) {
          result.b = getValue(${coords2});
        }
        setOutput(result);
      }
    `;
  }
}
var init_concat_packed_gpu = __esm(() => {
  init_dist();
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Imag.js
function imag6(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const inputData = backend3.texData.get(input2.dataId);
  return identity3({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend3 });
}
var imagConfig2;
var init_Imag2 = __esm(() => {
  init_dist();
  init_Identity2();
  imagConfig2 = {
    kernelName: Imag,
    backendName: "webgl",
    kernelFunc: imag6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat_impl.js
function concatImpl2(inputs, axis, backend3) {
  const dtype = inputs[0].dtype;
  if (dtype === "complex64") {
    const reals = inputs.map((t) => real6({ inputs: { input: t }, backend: backend3 }));
    const imags = inputs.map((t) => imag6({ inputs: { input: t }, backend: backend3 }));
    const realConcated = concatImpl2(reals, axis, backend3);
    const imagConcated = concatImpl2(imags, axis, backend3);
    const result2 = complex9({ inputs: { real: realConcated, imag: imagConcated }, backend: backend3 });
    reals.forEach((r) => backend3.disposeIntermediateTensorInfo(r));
    imags.forEach((i) => backend3.disposeIntermediateTensorInfo(i));
    backend3.disposeIntermediateTensorInfo(realConcated);
    backend3.disposeIntermediateTensorInfo(imagConcated);
    return result2;
  }
  let runOnCpu = backend3.shouldExecuteOnCPU(inputs);
  if (dtype === "string") {
    runOnCpu = true;
  }
  if (runOnCpu) {
    const tensors2D2 = inputs.map((t) => {
      const innerSize = exports_util.sizeFromShape(t.shape.slice(axis));
      const shape = [-1, innerSize];
      return reshape79({ inputs: { x: t }, backend: backend3, attrs: { shape } });
    });
    const inputsValShapes = tensors2D2.map((t) => {
      return { vals: backend3.readSync(t.dataId), shape: t.shape };
    });
    const outShape2 = exports_backend_util.computeOutShape(tensors2D2.map((t) => t.shape), 1);
    const simplyConcat = tensors2D2[0].shape[0] === 1;
    const outVals = concatImplCPU(inputsValShapes, outShape2, dtype, simplyConcat);
    const finalOutShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), axis);
    const outInfo = backend3.makeTensorInfo(finalOutShape, dtype, outVals);
    tensors2D2.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
    return outInfo;
  }
  const $inputs = inputs.filter((t) => exports_util.sizeFromShape(t.shape) > 0);
  const shouldPack = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && $inputs[0].shape.length > 1;
  if ($inputs.length === 1) {
    const program2 = shouldPack ? new UnaryOpProgram(inputs[0].shape, CLONE) : new UnaryOpPackedProgram(inputs[0].shape, CLONE);
    return backend3.runWebGLProgram(program2, inputs, dtype);
  }
  const maxTexturesInShader = env().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
  if ($inputs.length > maxTexturesInShader) {
    const reducedInputs = [];
    for (let i = 0;i < $inputs.length; i += maxTexturesInShader) {
      const subArray = $inputs.slice(i, i + maxTexturesInShader);
      reducedInputs.push(concatImpl2(subArray, axis, backend3));
    }
    const result2 = concatImpl2(reducedInputs, axis, backend3);
    for (const i of reducedInputs) {
      backend3.disposeIntermediateTensorInfo(i);
    }
    return result2;
  }
  if (shouldPack) {
    const program2 = new ConcatPackedProgram($inputs.map((t) => t.shape), axis);
    return backend3.runWebGLProgram(program2, $inputs, dtype);
  }
  const { tensors2D, outShape } = computeTensors2D($inputs, axis, backend3);
  const program = new ConcatProgram(tensors2D.map((t) => t.shape));
  const result = backend3.runWebGLProgram(program, tensors2D, dtype);
  tensors2D.forEach((r) => backend3.disposeIntermediateTensorInfo(r));
  const reshapedResult = reshape79({ inputs: { x: result }, attrs: { shape: outShape }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(result);
  return reshapedResult;
}
function computeTensors2D(inputs, axis, backend3) {
  const outShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), axis);
  const tensors2D = inputs.map((x) => reshape79({
    inputs: { x },
    attrs: { shape: [-1, exports_util.sizeFromShape(x.shape.slice(axis))] },
    backend: backend3
  }));
  return { tensors2D, outShape };
}
var init_Concat_impl2 = __esm(() => {
  init_dist();
  init_concat_gpu();
  init_concat_packed_gpu();
  init_shared2();
  init_unaryop_gpu();
  init_unaryop_packed_gpu();
  init_Complex2();
  init_Imag2();
  init_Real2();
  init_Reshape2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Concat.js
function concat15(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { axis } = attrs;
  const $axis = exports_util.parseAxisParam(axis, inputs[0].shape)[0];
  const shapes = inputs.map((t) => t.shape);
  exports_backend_util.assertParamsConsistent(shapes, $axis);
  const outShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), $axis);
  if (exports_util.sizeFromShape(outShape) === 0) {
    return backend3.makeTensorInfo(outShape, inputs[0].dtype, []);
  }
  const $inputs = inputs.filter((t) => exports_util.sizeFromShape(t.shape) > 0);
  if ($inputs.length === 1) {
    return identity3({ inputs: { x: $inputs[0] }, backend: backend3 });
  }
  return concatImpl2($inputs, $axis, backend3);
}
var concatConfig2;
var init_Concat2 = __esm(() => {
  init_dist();
  init_Concat_impl2();
  init_Identity2();
  concatConfig2 = {
    kernelName: Concat,
    backendName: "webgl",
    kernelFunc: concat15
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js
class Conv2DProgram {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.outputShape = convInfo.outShape;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
    const inputDepthVec4Remainder = convInfo.inChannels % 4;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const rowDim = isChannelsLast ? 1 : 2;
    const colDim = isChannelsLast ? 2 : 3;
    const channelDim = isChannelsLast ? 3 : 1;
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivationWeights) {
        activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyreluAlpha) {
        activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyreluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${activationSnippet}

      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${channelDim}];

        ivec2 xRCCorner =
            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * ${dilationHeight};

          if (xR < 0 || xR >= ${convInfo.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * ${dilationWidth};

            if (xC < 0 || xC >= ${convInfo.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${isChannelsLast}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${inputDepthVec4Remainder === 1}) {

              if (${isChannelsLast}) {
                dotProd +=
                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              } else {
                dotProd +=
                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *
                    getW(wR, wC, ${inputDepthNearestVec4}, d2);
              }

            } else if (${inputDepthVec4Remainder === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)
              );

              if (${isChannelsLast}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${inputDepthVec4Remainder === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${inputDepthNearestVec4}, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),
                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)
              );

              if (${isChannelsLast}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${inputDepthNearestVec4}, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),
                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
  }
}

class Conv3DProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.outputShape = convInfo.outShape;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
    const inputDepthVec4Remainder = convInfo.inChannels % 4;
    this.userCode = `
      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          int xF = xFCorner + wF * ${dilationDepth};

          if (xF < 0 || xF >= ${convInfo.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            int xR = xRCorner + wR * ${dilationHeight};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              int xC = xCCorner + wC * ${dilationWidth};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${inputDepthVec4Remainder === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);
              } else if (${inputDepthVec4Remainder === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${inputDepthVec4Remainder === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),
                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),
                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu.js
class Conv2DPackedProgram {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ];
    this.outputShape = convInfo.outShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const padLeft = convInfo.padInfo.left;
    const strideWidth = convInfo.strideWidth;
    const dilationWidth = convInfo.dilationWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const texelsAcross = filterWidth;
    let mainLoop = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
    for (let c = 0;c < filterWidth; c++) {
      mainLoop += `
           vec4 xTexelC${c * 2};
           int xTexelC${c * 2}Ready;
           vec4 xTexelC${c * 2 + 1};
           int xTexelC${c * 2 + 1}Ready;
           vec4 xC${c};`;
    }
    mainLoop += `
     for (int r = 0; r < ${filterHeight}; r++) {
      for (int d1 = 0; d1 < ${convInfo.inChannels}; d1 += 2) {
       `;
    for (let c = 0;c < filterWidth; c++) {
      mainLoop += `
           xTexelC${c * 2} = vec4(0.0);
           xTexelC${c * 2}Ready = 0;
           xTexelC${c * 2 + 1} = vec4(0.0);
           xTexelC${c * 2 + 1}Ready = 0;
           xC${c} = vec4(0.0);`;
    }
    mainLoop += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
    for (let texelC = 0;texelC < (texelsAcross + 1) / 2; texelC++) {
      const colIndex = texelC * 2;
      mainLoop += `
           xC = xCCorner + ${colIndex * dilationWidth};
           `;
      if (strideWidth === 1) {
        if (colIndex < filterWidth) {
          if (padLeft % 2 === 1) {
            mainLoop += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }
               `;
            if (dilationWidth === 1 && colIndex > 0) {
              mainLoop += `
                 xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                 `;
            } else {
              mainLoop += `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                   } else {
                     xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                   }
                   `;
            }
          } else {
            mainLoop += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 xC${colIndex} = xTexelC${colIndex};
                 `;
          }
          if (colIndex + 1 < filterWidth) {
            const nextTexelOffset = padLeft % 2 === 0 ? exports_util.nearestLargerEven(dilationWidth) : dilationWidth;
            if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
              mainLoop += `
                   xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                     xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${colIndex + 1}.zw = vec2(0.0);
                     }
                     xTexelC${colIndex + 1}Ready = 1;
                   }
                   `;
              if (dilationWidth > 1) {
                mainLoop += `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);
                     } else {
                      xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);
                     }
                     `;
              } else {
                mainLoop += `
                     xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                     `;
              }
            } else {
              if (nextTexelOffset === 1) {
                mainLoop += `
                     xC${colIndex + 1} = xTexelC${colIndex};
                     `;
              } else {
                mainLoop += `
                     xCOffset = xC + ${nextTexelOffset};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                       xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${colIndex + 1}.zw = vec2(0.0);
                       }
                       xTexelC${colIndex + 1}Ready = 1;
                     }

                     xC${colIndex + 1} = xTexelC${colIndex + 1};
                     `;
              }
            }
          }
        }
      } else {
        if (colIndex < filterWidth) {
          if (padLeft % 2 === 1) {
            mainLoop += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                   xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${colIndex + 1}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex + 1}Ready = 1;
                 }

                 xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
               `;
            if (colIndex + 1 < filterWidth) {
              mainLoop += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                 `;
            }
          } else {
            mainLoop += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                   xTexelC${colIndex} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${colIndex}.zw = vec2(0.0);
                   }
                   xTexelC${colIndex}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                   xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${colIndex + 1}.zw = vec2(0.);
                   }
                   xTexelC${colIndex + 1}Ready = 1;
                 }

                 xC${colIndex} = vec4(
                   xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
               `;
            if (colIndex + 1 < filterWidth) {
              mainLoop += `
                   xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                 `;
            }
          }
        }
      }
      if (colIndex < filterWidth) {
        mainLoop += `
             wTexel = getW(r, ${colIndex}, d1, d2);
             dotProd += xC${colIndex}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${convInfo.inChannels}) {
               dotProd += xC${colIndex}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `;
        if (colIndex + 1 < filterWidth) {
          mainLoop += `
               wTexel = getW(r, ${colIndex + 1}, d1, d2);
               dotProd += xC${colIndex + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${convInfo.inChannels}) {
                 dotProd += xC${colIndex + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `;
        }
      }
    }
    mainLoop += `
     }
   `;
    mainLoop += `
     }
   `;
    mainLoop += `
     }
   `;
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${activation2}
         }`;
      } else if (hasLeakyReluAlpha) {
        activationSnippet = `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${activation2}
         }`;
      } else {
        activationSnippet = `vec4 activation(vec4 x) {
           ${activation2}
         }`;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyReluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
       ${activationSnippet}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${mainLoop}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${addBiasSnippet}
         ${applyActivationSnippet}
         setOutput(result);
       }
     `;
  }
}
var init_conv_packed_gpu = __esm(() => {
  init_dist();
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js
class Im2ColPackedProgram {
  constructor(outputShape, convInfo) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "inputShape", type: "ivec4" },
      { name: "pad", type: "ivec2" },
      { name: "stride", type: "ivec2" },
      { name: "dilation", type: "ivec2" },
      { name: "inChannels", type: "int" },
      { name: "itemsPerBlockRow", type: "int" },
      { name: "outWidth", type: "int" }
    ];
    this.outputShape = outputShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const { dataFormat } = convInfo;
    const glsl = getGlslDifferences();
    const isChannelsLast = dataFormat === "channelsLast";
    const rowDim = isChannelsLast ? 1 : 2;
    const colDim = isChannelsLast ? 2 : 3;
    const boundsCheckingSnippet = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${outputShape[2]} && pos < ${outputShape[1]}) {`;
    let unrolled = ``;
    for (let row = 0;row <= 1; row++) {
      for (let col = 0;col <= 1; col++) {
        unrolled += `
          blockIndex = rc.z + ${col};
          pos = rc.y + ${row};

          ${boundsCheckingSnippet}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${rowDim}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${colDim}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${isChannelsLast}) {
                  innerDims = vec2(d1, ch);
                  result[${row * 2 + col}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${row * 2 + col}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
      }
    }
    this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${unrolled}

        ${glsl.output} = result;
      }
    `;
  }
}
var init_im2col_packed_gpu = __esm(() => {
  init_glsl_version();
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D_impl.js
function getShapeForBatchMatMul(shape, isChannelsLast) {
  const length = shape.length;
  if (length >= 3) {
    return isChannelsLast ? [
      ...shape.slice(0, -3),
      shape[length - 3] * shape[length - 2],
      shape[length - 1]
    ] : [
      ...shape.slice(0, -3),
      shape[length - 3],
      shape[length - 2] * shape[length - 1]
    ];
  } else if (!isChannelsLast && length === 1 && shape[0] > 1) {
    return [shape[0], 1];
  } else {
    return null;
  }
}
function conv2dByMatMul({ x, filter, convInfo, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const xShape = x.shape;
  const xTexData = backend3.texData.get(x.dataId);
  const sharedMatMulDim = convInfo.inChannels;
  const outerShapeX = xShape[0] * xShape[1] * xShape[2];
  const outerShapeFilter = convInfo.outChannels;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const transposeA = false;
  const transposeB = false;
  let out;
  const intermediates = [];
  if (preluActivationWeights != null) {
    const targetShape = getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);
    if (targetShape != null) {
      preluActivationWeights = reshape79({
        inputs: { x: preluActivationWeights },
        backend: backend3,
        attrs: { shape: targetShape }
      });
      intermediates.push(preluActivationWeights);
    }
  }
  if (bias != null) {
    const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);
    if (targetShape != null) {
      bias = reshape79({ inputs: { x: bias }, backend: backend3, attrs: { shape: targetShape } });
      intermediates.push(bias);
    }
  }
  const batchMatMulWillBeUnpacked = (outerShapeX === 1 || outerShapeFilter === 1) && sharedMatMulDim > MATMUL_SHARED_DIM_THRESHOLD;
  const canOptimize = !batchMatMulWillBeUnpacked && xTexData.isPacked && isChannelsLast && xTexData.texture != null && xShape[2] % 2 !== 0 && exports_util.arraysEqual(xTexData.shape.slice(-3), xShape.slice(-3));
  if (canOptimize) {
    const targetShape = xShape[0] * xShape[1] * (xShape[2] + 1);
    const xReshaped = {
      dataId: x.dataId,
      shape: [1, targetShape, convInfo.inChannels],
      dtype: x.dtype
    };
    const originalXTexDataShape = xTexData.shape;
    xTexData.shape = xTexData.shape.slice();
    xTexData.shape[xTexData.shape.length - 2]++;
    exports_util.assert(isReshapeFree(xTexData.shape, xReshaped.shape), () => `packed reshape ${xTexData.shape} to ${xReshaped.shape} isn't free`);
    const filterReshaped = reshape79({
      inputs: { x: filter },
      backend: backend3,
      attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
    });
    intermediates.push(filterReshaped);
    const pointwiseConv = batchMatMulImpl({
      a: xReshaped,
      b: filterReshaped,
      backend: backend3,
      transposeA,
      transposeB,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
    const pointwiseConvTexData = backend3.texData.get(pointwiseConv.dataId);
    exports_util.assert(pointwiseConvTexData.isPacked, () => "batchMatMul result is expected to be packed");
    xTexData.shape = originalXTexDataShape;
    pointwiseConvTexData.shape = convInfo.outShape;
    out = identity3({ inputs: { x: pointwiseConv }, backend: backend3 });
    out.shape = convInfo.outShape;
    intermediates.push(pointwiseConv);
  } else {
    const numCols = convInfo.outHeight * convInfo.outWidth;
    const xReshaped = reshape79({
      inputs: { x },
      backend: backend3,
      attrs: {
        shape: isChannelsLast ? [convInfo.batchSize, numCols, convInfo.inChannels] : [convInfo.batchSize, convInfo.inChannels, numCols]
      }
    });
    const filterReshaped = reshape79({
      inputs: { x: filter },
      backend: backend3,
      attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
    });
    const result = batchMatMulImpl({
      a: isChannelsLast ? xReshaped : filterReshaped,
      b: isChannelsLast ? filterReshaped : xReshaped,
      transposeA: !isChannelsLast,
      transposeB,
      backend: backend3,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
    out = reshape79({ inputs: { x: result }, backend: backend3, attrs: { shape: convInfo.outShape } });
    intermediates.push(xReshaped);
    intermediates.push(filterReshaped);
    intermediates.push(result);
  }
  for (const i of intermediates) {
    backend3.disposeIntermediateTensorInfo(i);
  }
  return out;
}
function conv2dWithIm2Row({ x, filter, convInfo, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const { filterWidth, filterHeight, inChannels, outWidth, outHeight, dataFormat } = convInfo;
  const isChannelsLast = dataFormat === "channelsLast";
  const sharedDim = filterWidth * filterHeight * inChannels;
  const numCols = outHeight * outWidth;
  const x2ColShape = [convInfo.batchSize, sharedDim, numCols];
  const transposeA = true;
  const transposeB = false;
  const intermediates = [];
  if (preluActivationWeights != null) {
    const targetShape = getShapeForBatchMatMul(preluActivationWeights.shape, isChannelsLast);
    if (targetShape != null) {
      preluActivationWeights = reshape79({
        inputs: { x: preluActivationWeights },
        backend: backend3,
        attrs: { shape: targetShape }
      });
      intermediates.push(preluActivationWeights);
    }
  }
  if (bias != null) {
    const targetShape = getShapeForBatchMatMul(bias.shape, isChannelsLast);
    if (targetShape != null) {
      bias = reshape79({ inputs: { x: bias }, backend: backend3, attrs: { shape: targetShape } });
      intermediates.push(bias);
    }
  }
  const w2Row = reshape79({
    inputs: { x: filter },
    backend: backend3,
    attrs: { shape: [1, sharedDim, exports_util.sizeFromShape(filter.shape) / sharedDim] }
  });
  intermediates.push(w2Row);
  const im2ColProgram = new Im2ColPackedProgram(x2ColShape, convInfo);
  const customValues = [
    x.shape,
    [convInfo.padInfo.top, convInfo.padInfo.left],
    [convInfo.strideHeight, convInfo.strideWidth],
    [convInfo.dilationHeight, convInfo.dilationWidth],
    [convInfo.inChannels],
    [convInfo.filterWidth * convInfo.inChannels],
    [convInfo.outWidth]
  ];
  const im2Col = backend3.runWebGLProgram(im2ColProgram, [x], "float32", customValues);
  const im2ColReshaped = reshape79({ inputs: { x: im2Col }, backend: backend3, attrs: { shape: x2ColShape } });
  intermediates.push(im2Col);
  intermediates.push(im2ColReshaped);
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
  const matmulProgram = new MatMulPackedProgram(isChannelsLast ? im2ColReshaped.shape : w2Row.shape, isChannelsLast ? w2Row.shape : im2ColReshaped.shape, isChannelsLast ? [convInfo.batchSize, numCols, convInfo.outChannels] : [convInfo.batchSize, convInfo.outChannels, numCols], transposeA, transposeB, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
  const inputs = isChannelsLast ? [im2ColReshaped, w2Row] : [w2Row, im2ColReshaped];
  if (bias) {
    inputs.push(bias);
  }
  if (hasPreluActivationWeights) {
    inputs.push(preluActivationWeights);
  }
  if (hasLeakyreluAlpha) {
    const $leakyreluAlpha = backend3.makeTensorInfo([], "float32", exports_util.createScalarValue(leakyreluAlpha, "float32"));
    inputs.push($leakyreluAlpha);
    intermediates.push($leakyreluAlpha);
  }
  const product = backend3.runWebGLProgram(matmulProgram, inputs, "float32");
  const out = reshape79({ inputs: { x: product }, backend: backend3, attrs: { shape: convInfo.outShape } });
  intermediates.push(product);
  for (const i of intermediates) {
    backend3.disposeIntermediateTensorInfo(i);
  }
  return out;
}
var init_Conv2D_impl = __esm(() => {
  init_dist();
  init_im2col_packed_gpu();
  init_kernel_funcs_utils();
  init_mulmat_packed_gpu();
  init_webgl_util();
  init_BatchMatMul_impl();
  init_Identity2();
  init_Reshape2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2D.js
function conv2d11(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad9, dimRoundingMode, false, $dataFormat);
  let out;
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
    out = conv2dByMatMul({ x, filter, convInfo, backend: backend3 });
  } else if (convInfo.strideWidth <= 2 && $dataFormat === "channelsLast" && env().getBool("WEBGL_EXP_CONV")) {
    const program = new Conv2DPackedProgram(convInfo);
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    out = backend3.runWebGLProgram(program, [x, filter], "float32", customValues);
  } else if (env().getBool("WEBGL_CONV_IM2COL")) {
    out = conv2dWithIm2Row({ x, filter, convInfo, backend: backend3 });
  } else {
    const program = new Conv2DProgram(convInfo);
    out = backend3.runWebGLProgram(program, [x, filter], "float32");
  }
  const outReshaped = reshape79({ inputs: { x: out }, backend: backend3, attrs: { shape: convInfo.outShape } });
  backend3.disposeIntermediateTensorInfo(out);
  return outReshaped;
}
var conv2DConfig2;
var init_Conv2D2 = __esm(() => {
  init_dist();
  init_conv_packed_gpu();
  init_Conv2D_impl();
  init_Reshape2();
  conv2DConfig2 = {
    kernelName: Conv2D,
    backendName: "webgl",
    kernelFunc: conv2d11
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js
class Conv2DDerFilterProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.outputShape = convInfo.filterShape;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              ${isChannelsLast ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

class Conv2DDerInputProgram {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.outputShape = convInfo.inShape;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const isChannelsLast = convInfo.dataFormat === "channelsLast";
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    const rowDim = isChannelsLast ? 1 : 2;
    const colDim = isChannelsLast ? 2 : 3;
    const channelDim = isChannelsLast ? 3 : 1;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${channelDim}];

        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {

              if (${isChannelsLast}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

class Conv3DDerFilterProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.outputShape = convInfo.filterShape;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padFront = convInfo.padInfo.front;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {
            int xF = wF + yF * ${strideDepth} - ${padFront};

            if (xF < 0 || xF >= ${convInfo.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
              int xR = wR + yR * ${strideHeight} - ${padTop};

              if (xR < 0 || xR >= ${convInfo.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
                int xC = wC + yC * ${strideWidth} - ${padLeft};

                if (xC < 0 || xC >= ${convInfo.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

class Conv3DDerInputProgram {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.outputShape = convInfo.inShape;
    const filterDepth = convInfo.filterDepth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padFront = filterDepth - 1 - convInfo.padInfo.front;
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${filterDepth}; wF++) {
          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;

          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${filterDepth} - 1 - wF;

          for (int wR = 0; wR < ${filterHeight}; wR++) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${filterHeight} - 1 - wR;

            for (int wC = 0; wC < ${filterWidth}; wC++) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${filterWidth} - 1 - wC;

              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropFilter.js
function conv2DBackpropFilter3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, pad: pad9, dataFormat, dimRoundingMode, filterShape } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1, pad9, dimRoundingMode, false, $dataFormat);
  const program = new Conv2DDerFilterProgram(convInfo);
  return backend3.runWebGLProgram(program, [x, dy2], "float32");
}
var conv2DBackpropFilterConfig2;
var init_Conv2DBackpropFilter2 = __esm(() => {
  init_dist();
  conv2DBackpropFilterConfig2 = {
    kernelName: Conv2DBackpropFilter,
    backendName: "webgl",
    kernelFunc: conv2DBackpropFilter3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_packed_gpu.js
class Conv2DDerInputPackedProgram {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "strides", type: "vec2" }
    ];
    this.outputShape = convInfo.inShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int wCPerm = ${filterWidth} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${convInfo.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${convInfo.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
  }
}
var init_conv_backprop_packed_gpu = __esm(() => {
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv2DBackpropInput.js
function conv2DBackpropInput3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { inputShape, strides, pad: pad9, dataFormat, dimRoundingMode } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad9, dimRoundingMode, false, $dataFormat);
  if (env().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && $dataFormat === "channelsLast") {
    const customValues = [
      [convInfo.strideHeight, convInfo.strideWidth]
    ];
    const program = new Conv2DDerInputPackedProgram(convInfo);
    return backend3.runWebGLProgram(program, [dy2, filter], "float32", customValues);
  } else {
    const program = new Conv2DDerInputProgram(convInfo);
    return backend3.runWebGLProgram(program, [dy2, filter], "float32");
  }
}
var conv2DBackpropInputConfig2;
var init_Conv2DBackpropInput2 = __esm(() => {
  init_dist();
  init_conv_backprop_packed_gpu();
  conv2DBackpropInputConfig2 = {
    kernelName: Conv2DBackpropInput,
    backendName: "webgl",
    kernelFunc: conv2DBackpropInput3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3D.js
function conv3D2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  const convInfo = exports_backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad9);
  const program = new Conv3DProgram(convInfo);
  return backend3.runWebGLProgram(program, [x, filter], "float32");
}
var conv3DConfig2;
var init_Conv3D2 = __esm(() => {
  init_dist();
  conv3DConfig2 = {
    kernelName: Conv3D,
    backendName: "webgl",
    kernelFunc: conv3D2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropFilterV2.js
function conv3DBackpropFilterV22(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, pad: pad9, filterShape } = attrs;
  const convInfo = exports_backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1, pad9);
  const program = new Conv3DDerFilterProgram(convInfo);
  return backend3.runWebGLProgram(program, [x, dy2], "float32");
}
var conv3DBackpropFilterV2Config2;
var init_Conv3DBackpropFilterV22 = __esm(() => {
  init_dist();
  conv3DBackpropFilterV2Config2 = {
    kernelName: Conv3DBackpropFilterV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropFilterV22
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Conv3DBackpropInputV2.js
function conv3DBackpropInput2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { pad: pad9, strides, inputShape } = attrs;
  const convInfo = exports_backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad9);
  const program = new Conv3DDerInputProgram(convInfo);
  return backend3.runWebGLProgram(program, [dy2, filter], "float32");
}
var conv3DBackpropInputConfig;
var init_Conv3DBackpropInputV22 = __esm(() => {
  init_dist();
  conv3DBackpropInputConfig = {
    kernelName: Conv3DBackpropInputV2,
    backendName: "webgl",
    kernelFunc: conv3DBackpropInput2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cos.js
var COS, COS_PACKED, cos6, cosConfig2;
var init_Cos2 = __esm(() => {
  init_dist();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  COS = CHECK_NAN_SNIPPET_UNARY + `
  return cos(x);
`;
  COS_PACKED = `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${CHECK_NAN_SNIPPET_PACKED}
  return result;
`;
  cos6 = unaryKernelFunc2({ opSnippet: COS, packedOpSnippet: COS_PACKED });
  cosConfig2 = {
    kernelName: Cos,
    backendName: "webgl",
    kernelFunc: cos6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cosh.js
var COSH = `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`, cosh5, coshConfig2;
var init_Cosh2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  cosh5 = unaryKernelFunc2({ opSnippet: COSH });
  coshConfig2 = {
    kernelName: Cosh,
    backendName: "webgl",
    kernelFunc: cosh5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js
class CropAndResizeProgram {
  constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {
    this.variableNames = ["Image", "Boxes", "BoxInd"];
    this.outputShape = [];
    const [batch, imageHeight, imageWidth, depth] = imageShape;
    const [numBoxes] = boxShape;
    const [cropHeight, cropWidth] = cropSize;
    this.outputShape = [numBoxes, cropHeight, cropWidth, depth];
    const methodId = method === "bilinear" ? 1 : 0;
    const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];
    const [heightRatio, heightScale, inY] = cropHeight > 1 ? [
      `${(imageHeight - 1) / (cropHeight - 1)}`,
      "(y2-y1) * height_ratio",
      `y1*${inputHeightFloat} + float(y)*(height_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (y1+y2) * ${inputHeightFloat}`
    ];
    const [widthRatio, widthScale, inX] = cropWidth > 1 ? [
      `${(imageWidth - 1) / (cropWidth - 1)}`,
      "(x2-x1) * width_ratio",
      `x1*${inputWidthFloat} + float(x)*(width_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (x1+x2) * ${inputWidthFloat}`
    ];
    this.userCode = `
      const float height_ratio = float(${heightRatio});
      const float width_ratio = float(${widthRatio});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${batch}) {
          return;
        }

        float height_scale = ${heightScale};
        float width_scale = ${widthScale};

        float in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }
        float in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutput(float(${extrapolationValue}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${methodId} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/CropAndResize.js
var cropAndResize4 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2, boxes, boxInd } = inputs;
  const { cropSize, method, extrapolationValue } = attrs;
  const program = new CropAndResizeProgram(image2.shape, boxes.shape, cropSize, method, extrapolationValue);
  return backend3.runWebGLProgram(program, [image2, boxes, boxInd], "float32");
}, cropAndResizeConfig2;
var init_CropAndResize2 = __esm(() => {
  init_dist();
  cropAndResizeConfig2 = {
    kernelName: CropAndResize,
    backendName: "webgl",
    kernelFunc: cropAndResize4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/cum_gpu.js
function getCoords2(rank, name, op2) {
  if (rank === 1) {
    return `${name}`;
  } else if (rank === 2) {
    return `${name}.x, ${name}.y`;
  } else if (rank === 3) {
    return `${name}.x, ${name}.y, ${name}.z`;
  } else if (rank === 4) {
    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
  } else {
    throw new Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
  }
}
function getFinalCoord(rank, name, op2) {
  if (rank === 1) {
    return `${name}`;
  } else if (rank === 2) {
    return `${name}.y`;
  } else if (rank === 3) {
    return `${name}.z`;
  } else if (rank === 4) {
    return `${name}.w`;
  } else {
    throw new Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
  }
}

class CumProgram {
  constructor(op2, outputShape, exclusive, reverse11) {
    this.op = op2;
    this.outputShape = outputShape;
    this.variableNames = ["x"];
    this.customUniforms = [{ name: "index", type: "float" }];
    const rank = this.outputShape.length;
    const initVal = this.op === CumOpType.Prod ? "1.0" : "0.0";
    const val = exclusive ? initVal : `getX(${getCoords2(rank, "coords", this.op)})`;
    const length = this.outputShape[this.outputShape.length - 1];
    let condition = "";
    let idxString = "";
    if (exclusive) {
      condition = reverse11 ? `end != ${length - 1}` : "end != 0";
      idxString = reverse11 ? "end + 1" : "end - 1";
    } else {
      condition = reverse11 ? `end + pow2 < ${length}` : "end >= pow2";
      idxString = reverse11 ? "end + pow2" : "end - pow2";
    }
    this.userCode = `
      void main() {
        ${getCoordsDataType(rank)} coords = getOutputCoords();
        int end = ${getFinalCoord(rank, "coords", this.op)};
        float val = ${val};
        int pow2 = int(pow(2.0, index));
        if (${condition}) {
          int idx = ${idxString};
          ${getFinalCoord(rank, "coords", this.op)} = idx;
          val ${this.op}= getX(${getCoords2(rank, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
  }
}
var CumOpType;
var init_cum_gpu = __esm(() => {
  init_shader_compiler();
  (function(CumOpType2) {
    CumOpType2["Prod"] = "*";
    CumOpType2["Sum"] = "+";
  })(CumOpType || (CumOpType = {}));
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cum_impl.js
function cumImpl(op2, x, backend3, axis, exclusive, reverse11) {
  const xRank = x.shape.length;
  const permutation = exports_backend_util.getAxesPermutation([axis], xRank);
  let permutedX = x;
  if (permutation != null) {
    permutedX = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
  }
  const permutedAxis = exports_backend_util.getInnerMostAxes(1, xRank)[0];
  if (permutedAxis !== xRank - 1) {
    throw new Error(`WebGL cumprod shader expects an inner-most axis=${x.shape.length - 1} ` + `but got axis=${axis}`);
  }
  const size = permutedX.shape[permutedAxis];
  let result = identity3({ inputs: { x: permutedX }, backend: backend3 });
  for (let i = 0;i <= Math.ceil(Math.log2(size)) - 1; i++) {
    const program = new CumProgram(op2, permutedX.shape, false, reverse11);
    const customValues = [[i]];
    const prevResult = result;
    result = backend3.runWebGLProgram(program, [result], result.dtype, customValues);
    backend3.disposeIntermediateTensorInfo(prevResult);
  }
  if (exclusive) {
    const program = new CumProgram(op2, permutedX.shape, exclusive, reverse11);
    const prevResult = result;
    result = backend3.runWebGLProgram(program, [result], result.dtype);
    backend3.disposeIntermediateTensorInfo(prevResult);
  }
  if (permutation != null) {
    const reversePermutation = exports_backend_util.getUndoAxesPermutation(permutation);
    const reverseTransposedResult = transpose12({ inputs: { x: result }, backend: backend3, attrs: { perm: reversePermutation } });
    backend3.disposeIntermediateTensorInfo(result);
    backend3.disposeIntermediateTensorInfo(permutedX);
    return reverseTransposedResult;
  }
  return result;
}
var init_Cum_impl = __esm(() => {
  init_dist();
  init_cum_gpu();
  init_Identity2();
  init_Transpose2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumprod.js
function cumprod6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, exclusive, reverse: reverse11 } = attrs;
  return cumImpl(CumOpType.Prod, x, backend3, axis, exclusive, reverse11);
}
var cumprodConfig2;
var init_Cumprod2 = __esm(() => {
  init_dist();
  init_cum_gpu();
  init_Cum_impl();
  cumprodConfig2 = {
    kernelName: Cumprod,
    backendName: "webgl",
    kernelFunc: cumprod6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Cumsum.js
function cumsum6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, exclusive, reverse: reverse11 } = attrs;
  return cumImpl(CumOpType.Sum, x, backend3, axis, exclusive, reverse11);
}
var cumsumConfig2;
var init_Cumsum2 = __esm(() => {
  init_dist();
  init_cum_gpu();
  init_Cum_impl();
  cumsumConfig2 = {
    kernelName: Cumsum,
    backendName: "webgl",
    kernelFunc: cumsum6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DenseBincount.js
function denseBincount3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, weights } = inputs;
  const { size, binaryOutput } = attrs;
  if (x.shape.length === 1) {
    const xVals = backend3.readSync(x.dataId);
    const weightsVals = backend3.readSync(weights.dataId);
    const outVals = bincountImplCPU(xVals, weightsVals, weights.dtype, weights.shape, size);
    return backend3.makeTensorInfo([size], weights.dtype, outVals);
  } else if (x.shape.length === 2) {
    const xBuf = backend3.bufferSync(x);
    const weightsBuf = backend3.bufferSync(weights);
    const outBuf = bincountReduceImplCPU(xBuf, weightsBuf, size, binaryOutput);
    return backend3.makeTensorInfo(outBuf.shape, weights.dtype, outBuf.values);
  }
  throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank` + `${x.shape.length}.`);
}
var denseBincountConfig2;
var init_DenseBincount2 = __esm(() => {
  init_dist();
  init_shared2();
  denseBincountConfig2 = {
    kernelName: DenseBincount,
    backendName: "webgl",
    kernelFunc: denseBincount3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js
class DepthToSpaceProgram {
  constructor(outputShape, blockSize, dataFormat) {
    this.variableNames = ["x"];
    this.outputShape = [];
    this.outputShape = outputShape;
    this.blockSize = blockSize;
    this.dataFormat = dataFormat;
    this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${blockSize};
      int offset_h = imod(h, ${blockSize});
      int in_w = w / ${blockSize};
      int offset_w = imod(w, ${blockSize});
      int offset_d = (offset_h * ${blockSize} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
  }
  getHeightCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[1]`;
    } else {
      return `coords[2]`;
    }
  }
  getWidthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[2]`;
    } else {
      return `coords[3]`;
    }
  }
  getDepthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[3]`;
    } else {
      return `coords[1]`;
    }
  }
  getOutputDepthSize() {
    if (this.dataFormat === "NHWC") {
      return this.outputShape[3];
    } else {
      return this.outputShape[1];
    }
  }
  getInputSamplingString() {
    if (this.dataFormat === "NHWC") {
      return `getX(b, in_h, in_w, in_d)`;
    } else {
      return `getX(b, in_d, in_h, in_w)`;
    }
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthToSpace.js
function depthToSpace3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockSize, dataFormat } = attrs;
  const batchSize = x.shape[0];
  const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
  const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
  const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
  const program = new DepthToSpaceProgram(outputShape, blockSize, dataFormat);
  return backend3.runWebGLProgram(program, [x], x.dtype);
}
var depthToSpaceConfig2;
var init_DepthToSpace2 = __esm(() => {
  init_dist();
  depthToSpaceConfig2 = {
    kernelName: DepthToSpace,
    backendName: "webgl",
    kernelFunc: depthToSpace3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js
class DepthwiseConv2DProgram {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ];
    this.outputShape = convInfo.outShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyReluAlpha) {
        activationSnippet = `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `
          float activation(float x) {
            ${activation2}
          }
        `;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyReluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${filterHeight}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
  }
}
var init_conv_gpu_depthwise = __esm(() => {
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js
class DepthwiseConvPacked2DProgram {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {
    this.variableNames = ["x", "W"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [
      { name: "pads", type: "ivec2" },
      { name: "strides", type: "ivec2" },
      { name: "dilations", type: "ivec2" },
      { name: "inDims", type: "ivec2" }
    ];
    this.outputShape = convInfo.outShape;
    this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    const padLeft = convInfo.padInfo.left;
    const strideWidth = convInfo.strideWidth;
    const dilationWidth = convInfo.dilationWidth;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const texelsAcross = filterWidth;
    let mainLoop = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
    for (let c = 0;c < filterWidth; c++) {
      mainLoop += `
          vec4 xTexelC${c * 2};
          int xTexelC${c * 2}Ready;
          vec4 xTexelC${c * 2 + 1};
          int xTexelC${c * 2 + 1}Ready;
          vec4 xC${c};`;
    }
    mainLoop += `
    for (int r = 0; r < ${filterHeight}; r++) {
      `;
    for (let c = 0;c < filterWidth; c++) {
      mainLoop += `
          xTexelC${c * 2} = vec4(0.0);
          xTexelC${c * 2}Ready = 0;
          xTexelC${c * 2 + 1} = vec4(0.0);
          xTexelC${c * 2 + 1}Ready = 0;
          xC${c} = vec4(0.0);`;
    }
    mainLoop += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
    for (let texelC = 0;texelC < (texelsAcross + 1) / 2; texelC++) {
      const colIndex = texelC * 2;
      mainLoop += `
          xC = xCCorner + ${colIndex * dilationWidth};
          `;
      if (strideWidth === 1) {
        if (colIndex < filterWidth) {
          if (padLeft % 2 === 1) {
            mainLoop += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }
              `;
            if (dilationWidth === 1 && colIndex > 0) {
              mainLoop += `
                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);
                `;
            } else {
              mainLoop += `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);
                  } else {
                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);
                  }
                  `;
            }
          } else {
            mainLoop += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xC${colIndex} = xTexelC${colIndex};
                `;
          }
          if (colIndex + 1 < filterWidth) {
            const nextTexelOffset = padLeft % 2 === 0 ? exports_util.nearestLargerEven(dilationWidth) : dilationWidth;
            if (dilationWidth % 2 === 0 && padLeft % 2 === 1 || dilationWidth % 2 !== 0 && padLeft % 2 !== 1) {
              mainLoop += `
                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${colIndex + 1}.zw = vec2(0.0);
                    }
                    xTexelC${colIndex + 1}Ready = 1;
                  }
                  `;
              if (dilationWidth > 1) {
                mainLoop += `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);
                    } else {
                     xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);
                    }
                    `;
              } else {
                mainLoop += `
                    xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);
                    `;
              }
            } else {
              if (nextTexelOffset === 1) {
                mainLoop += `
                    xC${colIndex + 1} = xTexelC${colIndex};
                    `;
              } else {
                mainLoop += `
                    xCOffset = xC + ${nextTexelOffset};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${colIndex + 1}.zw = vec2(0.0);
                      }
                      xTexelC${colIndex + 1}Ready = 1;
                    }

                    xC${colIndex + 1} = xTexelC${colIndex + 1};
                    `;
              }
            }
          }
        }
      } else {
        if (colIndex < filterWidth) {
          if (padLeft % 2 === 1) {
            mainLoop += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
              `;
            if (colIndex + 1 < filterWidth) {
              mainLoop += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);
                `;
            }
          } else {
            mainLoop += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {
                  xTexelC${colIndex} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${colIndex}.zw = vec2(0.0);
                  }
                  xTexelC${colIndex}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {
                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${colIndex + 1}.zw = vec2(0.);
                  }
                  xTexelC${colIndex + 1}Ready = 1;
                }

                xC${colIndex} = vec4(
                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);
              `;
            if (colIndex + 1 < filterWidth) {
              mainLoop += `
                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);
                `;
            }
          }
        }
      }
      if (colIndex < filterWidth) {
        mainLoop += `
            wTexel = getW(r, ${colIndex}, d1, q);
            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);
          `;
        if (colIndex + 1 < filterWidth) {
          mainLoop += `
              wTexel = getW(r, ${colIndex + 1}, d1, q);
              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);
            `;
        }
      }
    }
    mainLoop += `
    }
  `;
    mainLoop += `
      }
    `;
    let activationSnippet = "", applyActivationSnippet = "";
    if (activation2) {
      if (hasPreluActivation) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${activation2}
        }`;
      } else if (hasLeakyReluAlpha) {
        activationSnippet = `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${activation2}
        }`;
      } else {
        activationSnippet = `vec4 activation(vec4 x) {
          ${activation2}
        }`;
      }
      applyActivationSnippet = `result = activation(result);`;
    }
    const addBiasSnippet = addBias ? "result += getBiasAtOutCoords();" : "";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    if (hasLeakyReluAlpha) {
      this.variableNames.push("leakyreluAlpha");
    }
    this.userCode = `
      ${activationSnippet}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${channelMul};
        int q = d2 - d1 * ${channelMul};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${mainLoop}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${addBiasSnippet}
        ${applyActivationSnippet}
        setOutput(result);
      }
    `;
  }
}
var init_conv_packed_gpu_depthwise = __esm(() => {
  init_dist();
  init_gpgpu_math();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNative.js
function depthwiseConv2dNative2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations, dimRoundingMode } = attrs;
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => "Error in depthwiseConv2d: Either strides or dilations must be " + `1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad9, dimRoundingMode, true);
  let program;
  if (env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1) {
    program = new DepthwiseConvPacked2DProgram(convInfo);
  } else {
    program = new DepthwiseConv2DProgram(convInfo);
  }
  const customValues = [
    [convInfo.padInfo.top, convInfo.padInfo.left],
    [convInfo.strideHeight, convInfo.strideWidth],
    [convInfo.dilationHeight, convInfo.dilationWidth],
    [convInfo.inHeight, convInfo.inWidth]
  ];
  return backend3.runWebGLProgram(program, [x, filter], "float32", customValues);
}
var depthwiseConv2dNativeConfig2;
var init_DepthwiseConv2dNative2 = __esm(() => {
  init_dist();
  init_conv_gpu_depthwise();
  init_conv_packed_gpu_depthwise();
  depthwiseConv2dNativeConfig2 = {
    kernelName: DepthwiseConv2dNative,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNative2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js
class DepthwiseConv2DDerFilterProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.outputShape = convInfo.filterShape;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padTop = convInfo.padInfo.top;
    const padLeft = convInfo.padInfo.left;
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${channelMul} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${convInfo.batchSize}; b++) {
          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {
            int xR = wR + yR * ${strideHeight} - ${padTop};

            if (xR < 0 || xR >= ${convInfo.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {
              int xC = wC + yC * ${strideWidth} - ${padLeft};

              if (xC < 0 || xC >= ${convInfo.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

class DepthwiseConv2DDerInputProgram {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.outputShape = convInfo.inShape;
    const filterHeight = convInfo.filterHeight;
    const filterWidth = convInfo.filterWidth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const padTop = filterHeight - 1 - convInfo.padInfo.top;
    const padLeft = filterWidth - 1 - convInfo.padInfo.left;
    const channelMul = convInfo.outChannels / convInfo.inChannels;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${filterHeight}; wR++) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${filterHeight} - 1 - wR;

          for (int wC = 0; wC < ${filterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${filterWidth} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${channelMul}; dm++) {
              int d2 = d1 * ${channelMul} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
function depthwiseConv2dNativeBackpropFilter3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, dilations, pad: pad9, dimRoundingMode, filterShape } = attrs;
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad9, dimRoundingMode, true);
  const program = new DepthwiseConv2DDerFilterProgram(convInfo);
  return backend3.runWebGLProgram(program, [x, dy2], "float32");
}
var depthwiseConv2dNativeBackpropFilterConfig2;
var init_DepthwiseConv2dNativeBackpropFilter2 = __esm(() => {
  init_dist();
  depthwiseConv2dNativeBackpropFilterConfig2 = {
    kernelName: DepthwiseConv2dNativeBackpropFilter,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropFilter3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
function depthwiseConv2dNativeBackpropInput3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { strides, dilations, pad: pad9, dimRoundingMode, inputShape } = attrs;
  const convInfo = exports_backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad9, dimRoundingMode, true);
  const program = new DepthwiseConv2DDerInputProgram(convInfo);
  return backend3.runWebGLProgram(program, [dy2, filter], "float32");
}
var depthwiseConv2dNativeBackpropInputConfig2;
var init_DepthwiseConv2dNativeBackpropInput2 = __esm(() => {
  init_dist();
  depthwiseConv2dNativeBackpropInputConfig2 = {
    kernelName: DepthwiseConv2dNativeBackpropInput,
    backendName: "webgl",
    kernelFunc: depthwiseConv2dNativeBackpropInput3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js
class DiagProgram {
  constructor(size) {
    this.variableNames = ["X"];
    this.outputShape = [size, size];
    this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Diag.js
function diag3(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  const outShape = [...x.shape, ...x.shape];
  const xSize = exports_util.sizeFromShape(x.shape);
  const flat = reshape79({ inputs: { x }, backend: backend3, attrs: { shape: [xSize] } });
  const program = new DiagProgram(xSize);
  const res = backend3.runWebGLProgram(program, [flat], flat.dtype);
  const out = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape: outShape } });
  backend3.disposeIntermediateTensorInfo(flat);
  backend3.disposeIntermediateTensorInfo(res);
  return out;
}
var diagConfig2;
var init_Diag2 = __esm(() => {
  init_dist();
  init_Reshape2();
  diagConfig2 = {
    kernelName: Diag,
    backendName: "webgl",
    kernelFunc: diag3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js
class Dilation2DProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.outputShape = convInfo.outShape;
    const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;
    const { top: padTop, left: padLeft } = padInfo;
    this.userCode = `
      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});
      const ivec2 pads = ivec2(${padTop}, ${padLeft});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${filterHeight}; h++) {
          int hIn = hBeg + h * ${dilationHeight};

          if (hIn >= 0 && hIn < ${inHeight}) {
            for (int w = 0; w < ${filterWidth}; w++) {
              int wIn = wBeg + w * ${dilationWidth};

              if (wIn >= 0 && wIn < ${inWidth}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Dilation2D.js
function dilation2D(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  const convInfo = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
  let out;
  const program = new Dilation2DProgram(convInfo);
  out = backend3.runWebGLProgram(program, [x, filter], "float32");
  const outReshaped = reshape79({ inputs: { x: out }, backend: backend3, attrs: { shape: convInfo.outShape } });
  backend3.disposeIntermediateTensorInfo(out);
  return outReshaped;
}
var dilation2DConfig2;
var init_Dilation2D2 = __esm(() => {
  init_dist();
  init_Reshape2();
  dilation2DConfig2 = {
    kernelName: Dilation2D,
    backendName: "webgl",
    kernelFunc: dilation2D
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Einsum.js
function einsum4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { equation } = attrs;
  const tensors = inputs;
  const { allDims, summedDims, idDims } = exports_backend_util.decodeEinsumEquation(equation, tensors.length);
  exports_backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);
  const { path, steps } = exports_backend_util.getEinsumComputePath(summedDims, idDims);
  const nSteps = steps.length;
  let out = null;
  let numDimsRemaining = allDims.length;
  const tensorsToDispose = [];
  for (let i = 0;i < nSteps; ++i) {
    for (const idTerm of steps[i]) {
      const { permutationIndices: perm, expandDims: dimsToExpand } = exports_backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
      let x;
      if (exports_backend_util.isIdentityPermutation(perm)) {
        x = tensors[idTerm];
      } else {
        x = transpose12({ inputs: { x: tensors[idTerm] }, backend: backend3, attrs: { perm } });
        tensorsToDispose.push(x);
      }
      const targetShape = x.shape.slice();
      for (let k = 0;k < dimsToExpand.length; ++k) {
        targetShape.splice(dimsToExpand[k], 0, 1);
      }
      if (!exports_util.arraysEqual(x.shape, targetShape)) {
        x = reshape79({ inputs: { x }, backend: backend3, attrs: { shape: targetShape } });
        tensorsToDispose.push(x);
      }
      if (out === null) {
        out = x;
      } else {
        out = multiply3({ inputs: { a: x, b: out }, backend: backend3 });
        tensorsToDispose.push(out);
      }
    }
    if (i < nSteps - 1) {
      if (path[i] >= 0) {
        out = sum28({
          inputs: { x: out },
          backend: backend3,
          attrs: {
            axis: path[i] - (allDims.length - numDimsRemaining),
            keepDims: false
          }
        });
        tensorsToDispose.push(out);
      }
      numDimsRemaining--;
    }
  }
  for (const tensorInfo of tensorsToDispose) {
    if (tensorInfo === out) {
      continue;
    }
    backend3.disposeIntermediateTensorInfo(tensorInfo);
  }
  return out;
}
var einsumConfig2;
var init_Einsum2 = __esm(() => {
  init_dist();
  init_Multiply2();
  init_Reshape2();
  init_Sum2();
  init_Transpose2();
  einsumConfig2 = {
    kernelName: Einsum,
    backendName: "webgl",
    kernelFunc: einsum4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Elu.js
var ELU4 = `return (x >= 0.0) ? x : (exp(x) - 1.0);`, ELU_PACKED = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, elu8, eluConfig2;
var init_Elu2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  elu8 = unaryKernelFunc2({ opSnippet: ELU4, packedOpSnippet: ELU_PACKED });
  eluConfig2 = {
    kernelName: Elu,
    backendName: "webgl",
    kernelFunc: elu8
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/EluGrad.js
var ELU_DER = `return (b >= 0.0) ? a : a * (b + 1.0);`, ELU_DER_PACKED = `
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, eluGrad2 = (args) => {
  const { inputs, backend: backend3 } = args;
  const { dy: dy2, y } = inputs;
  const program = env().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new BinaryOpPackedProgram(ELU_DER_PACKED, dy2.shape, y.shape) : new BinaryOpProgram(ELU_DER, dy2.shape, y.shape);
  return backend3.runWebGLProgram(program, [dy2, y], dy2.dtype);
}, eluGradConfig3;
var init_EluGrad2 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  eluGradConfig3 = {
    kernelName: EluGrad,
    backendName: "webgl",
    kernelFunc: eluGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Equal.js
var PACKED_EQUAL = `
  return vec4(equal(a, b));
`, EQUAL = `return float(a == b);`, equal7, equalConfig2;
var init_Equal2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  equal7 = binaryKernelFunc2({
    opSnippet: EQUAL,
    packedOpSnippet: PACKED_EQUAL,
    dtype: "bool",
    cpuKernelImpl: equalImplCPU
  });
  equalConfig2 = {
    kernelName: Equal,
    backendName: "webgl",
    kernelFunc: equal7
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Erf.js
var ERF, erf4, erfConfig2;
var init_Erf2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  ERF = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${exports_backend_util.ERF_P};
  float a1 = ${exports_backend_util.ERF_A1};
  float a2 = ${exports_backend_util.ERF_A2};
  float a3 = ${exports_backend_util.ERF_A3};
  float a4 = ${exports_backend_util.ERF_A4};
  float a5 = ${exports_backend_util.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`;
  erf4 = unaryKernelFunc2({ opSnippet: ERF });
  erfConfig2 = {
    kernelName: Erf,
    backendName: "webgl",
    kernelFunc: erf4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Exp.js
var EXP, EXP_PACKED = `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, exp12, expConfig2;
var init_Exp2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  EXP = CHECK_NAN_SNIPPET_UNARY + `
  return exp(x);
`;
  exp12 = unaryKernelFunc2({
    opSnippet: EXP,
    packedOpSnippet: EXP_PACKED,
    cpuKernelImpl: expImplCPU,
    dtype: "float32"
  });
  expConfig2 = {
    kernelName: Exp,
    backendName: "webgl",
    kernelFunc: exp12
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ExpandDims.js
function expandDims4(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { dim } = attrs;
  const { input: input2 } = inputs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    exports_util.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape79({ inputs: { x: input2 }, backend: backend3, attrs: { shape: newShape } });
}
var expandDimsConfig2;
var init_ExpandDims2 = __esm(() => {
  init_dist();
  init_Reshape2();
  expandDimsConfig2 = {
    kernelName: ExpandDims,
    backendName: "webgl",
    kernelFunc: expandDims4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Expm1.js
var EXPM1 = `return exp(x) - 1.0;`, expm14, expm1Config2;
var init_Expm12 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  expm14 = unaryKernelFunc2({ opSnippet: EXPM1, packedOpSnippet: EXPM1, cpuKernelImpl: expm1ImplCPU });
  expm1Config2 = {
    kernelName: Expm1,
    backendName: "webgl",
    kernelFunc: expm14
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js
class FFTProgram {
  constructor(component, inputShape, inverse) {
    this.variableNames = ["real", "imag"];
    const innerDim = inputShape[1];
    this.outputShape = inputShape;
    const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;
    const resultDenominator = inverse ? `${innerDim}.0` : "1.0";
    let opString;
    if (component === "real") {
      opString = "return real * expR - imag * expI;";
    } else if (component === "imag") {
      opString = "return real * expI + imag * expR;";
    } else {
      throw new Error(`FFT component must be either "real" or "imag", got ${component}.`);
    }
    this.userCode = `
      const float exponentMultiplier = ${exponentMultiplierSnippet};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${opString}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${innerDim});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${innerDim}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT_impl.js
function fftImpl2(x, inverse, backend3) {
  const xData = backend3.texData.get(x.dataId);
  const inputSize = exports_util.sizeFromShape(x.shape);
  const innerDimensionSize = x.shape[x.shape.length - 1];
  const batch = inputSize / innerDimensionSize;
  const input2D = reshape79({ inputs: { x }, backend: backend3, attrs: { shape: [batch, innerDimensionSize] } });
  const xShape = input2D.shape;
  const realProgram = new FFTProgram("real", xShape, inverse);
  const imagProgram = new FFTProgram("imag", xShape, inverse);
  const inputs = [
    {
      dataId: xData.complexTensorInfos.real.dataId,
      dtype: xData.complexTensorInfos.real.dtype,
      shape: xShape
    },
    {
      dataId: xData.complexTensorInfos.imag.dataId,
      dtype: xData.complexTensorInfos.imag.dtype,
      shape: xShape
    }
  ];
  const realPart = backend3.runWebGLProgram(realProgram, inputs, "float32");
  const imagPart = backend3.runWebGLProgram(imagProgram, inputs, "float32");
  const complexOutput = complex9({ inputs: { real: realPart, imag: imagPart }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(realPart);
  backend3.disposeIntermediateTensorInfo(imagPart);
  const complexOutputReshaped = reshape79({ inputs: { x: complexOutput }, backend: backend3, attrs: { shape: x.shape } });
  backend3.disposeIntermediateTensorInfo(input2D);
  backend3.disposeIntermediateTensorInfo(complexOutput);
  return complexOutputReshaped;
}
var init_FFT_impl = __esm(() => {
  init_dist();
  init_Complex2();
  init_Reshape2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FFT.js
function fft6(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  return fftImpl2(input2, false, backend3);
}
var fftConfig2;
var init_FFT2 = __esm(() => {
  init_dist();
  init_FFT_impl();
  fftConfig2 = {
    kernelName: FFT,
    backendName: "webgl",
    kernelFunc: fft6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js
class FillProgram {
  constructor(shape, value) {
    this.outputShape = [];
    this.customUniforms = [{ name: "value", type: "float" }];
    this.variableNames = ["x"];
    this.outputShape = shape;
    this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Fill.js
function fill7(args) {
  const { backend: backend3, attrs } = args;
  const { shape, value } = attrs;
  let { dtype } = attrs;
  dtype = dtype || exports_util.inferDtype(value);
  if (dtype === "string") {
    const values = exports_util.getArrayFromDType(dtype, exports_util.sizeFromShape(shape));
    values.fill(value);
    return backend3.makeTensorInfo(shape, dtype, values);
  } else {
    const program = new FillProgram(shape, value);
    const customValues = [[value]];
    return backend3.runWebGLProgram(program, [], dtype, customValues);
  }
}
var fillConfig2;
var init_Fill2 = __esm(() => {
  init_dist();
  fillConfig2 = {
    kernelName: Fill,
    backendName: "webgl",
    kernelFunc: fill7
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js
class FlipLeftRightProgram {
  constructor(imageShape) {
    this.variableNames = ["Image"];
    this.outputShape = [];
    const imageWidth = imageShape[2];
    this.outputShape = imageShape;
    this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${imageWidth} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${imageWidth}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FlipLeftRight.js
var flipLeftRightConfig2;
var init_FlipLeftRight2 = __esm(() => {
  init_dist();
  flipLeftRightConfig2 = {
    kernelName: FlipLeftRight,
    backendName: "webgl",
    kernelFunc: ({ inputs, backend: backend3 }) => {
      const { image: image2 } = inputs;
      const webglBackend = backend3;
      const program = new FlipLeftRightProgram(image2.shape);
      const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype);
      return output;
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Floor.js
var FLOOR = `return floor(x);`, floor6, floorConfig2;
var init_Floor2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  floor6 = unaryKernelFunc2({ opSnippet: FLOOR, packedOpSnippet: FLOOR, cpuKernelImpl: floorImplCPU });
  floorConfig2 = {
    kernelName: Floor,
    backendName: "webgl",
    kernelFunc: floor6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FloorDiv.js
var INT_DIV = `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`, INT_DIV_PACKED = `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`, floorDiv6, floorDivConfig2;
var init_FloorDiv2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  floorDiv6 = binaryKernelFunc2({ opSnippet: INT_DIV, packedOpSnippet: INT_DIV_PACKED, dtype: "int32" });
  floorDivConfig2 = {
    kernelName: FloorDiv,
    backendName: "webgl",
    kernelFunc: floorDiv6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_gpu.js
class FromPixelsProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    const glsl = getGlslDifferences();
    const [height, width] = outputShape;
    this.outputShape = outputShape;
    this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${width}.0, ${height}.0);

        vec4 values = ${glsl.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
  }
}
var init_from_pixels_gpu = __esm(() => {
  init_glsl_version();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels_utils/from_pixels_packed_gpu.js
class FromPixelsPackedProgram {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.packedInputs = false;
    this.packedOutput = true;
    const glsl = getGlslDifferences();
    const [height, width] = outputShape;
    this.outputShape = outputShape;
    this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${width}.0, ${height}.0);
            vec4 values = ${glsl.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${glsl.output} = result;
      }
    `;
  }
}
var init_from_pixels_packed_gpu = __esm(() => {
  init_glsl_version();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FromPixels.js
function fromPixels2(args) {
  const { inputs, backend: backend3, attrs } = args;
  let { pixels } = inputs;
  const { numChannels } = attrs;
  const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
  const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  const texShape = [height, width];
  const outShape = [height, width, numChannels];
  if (isImage || isVideo) {
    const newWillReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    if (fromPixels2DContext2 == null || newWillReadFrequently !== willReadFrequently) {
      willReadFrequently = newWillReadFrequently;
      fromPixels2DContext2 = document.createElement("canvas").getContext("2d", { willReadFrequently });
    }
    fromPixels2DContext2.canvas.width = width;
    fromPixels2DContext2.canvas.height = height;
    fromPixels2DContext2.drawImage(pixels, 0, 0, width, height);
    pixels = fromPixels2DContext2.canvas;
  }
  const tempPixelHandle = backend3.makeTensorInfo(texShape, "int32");
  backend3.texData.get(tempPixelHandle.dataId).usage = TextureUsage.PIXELS;
  backend3.gpgpu.uploadPixelDataToTexture(backend3.getTexture(tempPixelHandle.dataId), pixels);
  const program = env().getBool("WEBGL_PACK") ? new FromPixelsPackedProgram(outShape) : new FromPixelsProgram(outShape);
  const res = backend3.runWebGLProgram(program, [tempPixelHandle], "int32");
  backend3.disposeData(tempPixelHandle.dataId);
  return res;
}
var fromPixelsConfig, fromPixels2DContext2, willReadFrequently;
var init_FromPixels = __esm(() => {
  init_dist();
  init_dist();
  init_tex_util();
  init_from_pixels_gpu();
  init_from_pixels_packed_gpu();
  fromPixelsConfig = {
    kernelName: FromPixels,
    backendName: "webgl",
    kernelFunc: fromPixels2
  };
  willReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedConv2D.js
function fusedConv2d(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad9, dimRoundingMode, false, $dataFormat);
  let out;
  const intermediates = [];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  const prepareInputs = () => {
    const inputs2 = [x, filter];
    const alignInputWithDataFormat = (input2, dataFormat2) => {
      if (dataFormat2 === "NCHW" && input2.shape.length === 1 && input2.shape[0] !== 1) {
        const alignedInput = reshape79({
          inputs: { x: input2 },
          backend: backend3,
          attrs: { shape: [input2.shape[0], 1, 1] }
        });
        intermediates.push(alignedInput);
        return alignedInput;
      }
      return input2;
    };
    if (hasBias) {
      inputs2.push(alignInputWithDataFormat(bias, dataFormat));
    }
    if (hasPreluActivationWeights) {
      inputs2.push(alignInputWithDataFormat(preluActivationWeights, dataFormat));
    }
    if (hasLeakyreluAlpha) {
      const $leakyreluAlpha = backend3.makeTensorInfo([], "float32", exports_util.createScalarValue(leakyreluAlpha, "float32"));
      inputs2.push($leakyreluAlpha);
      intermediates.push($leakyreluAlpha);
    }
    return inputs2;
  };
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID")) {
    out = conv2dByMatMul({
      x,
      filter,
      convInfo,
      backend: backend3,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
  } else if (convInfo.strideWidth <= 2 && $dataFormat === "channelsLast" && env().getBool("WEBGL_EXP_CONV")) {
    const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, true) : null;
    const program = new Conv2DPackedProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const customValues = [
      [convInfo.padInfo.top, convInfo.padInfo.left],
      [convInfo.strideHeight, convInfo.strideWidth],
      [convInfo.dilationHeight, convInfo.dilationWidth],
      [convInfo.inHeight, convInfo.inWidth]
    ];
    const inputs2 = prepareInputs();
    out = backend3.runWebGLProgram(program, inputs2, "float32", customValues);
  } else if (env().getBool("WEBGL_CONV_IM2COL")) {
    out = conv2dWithIm2Row({
      x,
      filter,
      convInfo,
      backend: backend3,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
  } else {
    const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, false) : null;
    const program = new Conv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
    const inputs2 = prepareInputs();
    out = backend3.runWebGLProgram(program, inputs2, "float32");
  }
  const outReshaped = reshape79({ inputs: { x: out }, backend: backend3, attrs: { shape: convInfo.outShape } });
  intermediates.push(out);
  intermediates.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return outReshaped;
}
var fusedConv2DConfig2;
var init_FusedConv2D2 = __esm(() => {
  init_dist();
  init_conv_packed_gpu();
  init_kernel_funcs_utils();
  init_Conv2D_impl();
  init_Reshape2();
  fusedConv2DConfig2 = {
    kernelName: FusedConv2D,
    backendName: "webgl",
    kernelFunc: fusedConv2d
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/FusedDepthwiseConv2D.js
function fusedDepthwiseConv2D2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad9, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const intermediates = [];
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => "Error in depthwiseConv2d: Either strides or dilations must be " + `1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad9, dimRoundingMode, true);
  const shouldPackDepthwiseConv = env().getBool("WEBGL_PACK_DEPTHWISECONV") && convInfo.strideWidth <= 2 && convInfo.outChannels / convInfo.inChannels === 1;
  const fusedActivation = activation2 ? mapActivationToShaderProgram(activation2, shouldPackDepthwiseConv) : null;
  const programInputs = [x, filter];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const hasLeakyreluAlpha = activation2 === "leakyrelu";
  if (hasBias) {
    programInputs.push(bias);
  }
  if (hasPreluActivationWeights) {
    programInputs.push(preluActivationWeights);
  }
  if (hasLeakyreluAlpha) {
    const $leakyreluAlpha = backend3.makeTensorInfo([], "float32", exports_util.createScalarValue(leakyreluAlpha, "float32"));
    programInputs.push($leakyreluAlpha);
    intermediates.push($leakyreluAlpha);
  }
  let program;
  if (shouldPackDepthwiseConv) {
    program = new DepthwiseConvPacked2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
  } else {
    program = new DepthwiseConv2DProgram(convInfo, hasBias, fusedActivation, hasPreluActivationWeights, hasLeakyreluAlpha);
  }
  const customValues = [
    [convInfo.padInfo.top, convInfo.padInfo.left],
    [convInfo.strideHeight, convInfo.strideWidth],
    [convInfo.dilationHeight, convInfo.dilationWidth],
    [convInfo.inHeight, convInfo.inWidth]
  ];
  const result = backend3.runWebGLProgram(program, programInputs, "float32", customValues);
  intermediates.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}
var fusedDepthwiseConv2DConfig2;
var init_FusedDepthwiseConv2D2 = __esm(() => {
  init_dist();
  init_conv_gpu_depthwise();
  init_conv_packed_gpu_depthwise();
  init_kernel_funcs_utils();
  fusedDepthwiseConv2DConfig2 = {
    kernelName: FusedDepthwiseConv2D,
    backendName: "webgl",
    kernelFunc: fusedDepthwiseConv2D2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js
class GatherNDProgram {
  constructor(sliceDim, strides, shape, paramsShape) {
    this.sliceDim = sliceDim;
    this.strides = strides;
    this.paramsShape = paramsShape;
    this.variableNames = ["x", "indices"];
    this.outputShape = shape;
    const dtype = getCoordsDataType(shape.length);
    let mainLoop = `
    int index;`;
    for (let j = 0;j < this.sliceDim; j++) {
      mainLoop += `
          index = round(getIndices(coords[0], ${j}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[j]};
          flattenIndex += index * ${this.strides[j]};`;
    }
    this.userCode = `
         void main() {
          ${dtype} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${mainLoop}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
  }
}
var init_gather_nd_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherNd.js
function gatherNd2(args) {
  const { inputs, backend: backend3 } = args;
  const { params, indices } = inputs;
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const paramsSize = exports_util.sizeFromShape(params.shape);
  const [resultShape, numSlices, sliceSize, strides] = exports_backend_util.prepareAndValidate(params, indices);
  const flattenIndices = reshape79({ inputs: { x: indices }, backend: backend3, attrs: { shape: [numSlices, sliceRank] } });
  const flattenX = reshape79({
    inputs: { x: params },
    backend: backend3,
    attrs: { shape: [exports_util.sizeFromShape(params.shape) / sliceSize, sliceSize] }
  });
  if (backend3.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
    const indicesData = backend3.readSync(indices.dataId);
    const paramsBuf = backend3.bufferSync(params);
    const outValue = gatherNdImplCPU(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
    return backend3.makeTensorInfo(resultShape, params.dtype, outValue.values);
  }
  const program = new GatherNDProgram(sliceRank, strides, [numSlices, sliceSize], params.shape);
  const res = backend3.runWebGLProgram(program, [flattenX, flattenIndices], flattenX.dtype);
  const reshaped = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape: resultShape } });
  backend3.disposeIntermediateTensorInfo(flattenIndices);
  backend3.disposeIntermediateTensorInfo(flattenX);
  backend3.disposeIntermediateTensorInfo(res);
  return reshaped;
}
var gatherNdConfig2;
var init_GatherNd2 = __esm(() => {
  init_dist();
  init_gather_nd_gpu();
  init_shared2();
  init_Reshape2();
  gatherNdConfig2 = {
    kernelName: GatherNd,
    backendName: "webgl",
    kernelFunc: gatherNd2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js
function getSourceCoords2(aShape, axis) {
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
  const sourceCoords = [];
  for (let i = 0;i < aShape.length; i++) {
    if (i === 2) {
      sourceCoords.push("index");
    } else {
      sourceCoords.push(`${currentCoords[i]}`);
    }
  }
  return sourceCoords.join();
}

class GatherProgram {
  constructor(aShape, outputShape) {
    this.variableNames = ["A", "indices"];
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    const dtype = getCoordsDataType(this.rank);
    const sourceCoords = getSourceCoords2(aShape, 2);
    this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${aShape[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${sourceCoords}));
      }
    `;
  }
}
var init_gather_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GatherV2.js
function gatherV22(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, indices } = inputs;
  const { axis, batchDims } = attrs;
  const parsedAxis = exports_util.parseAxisParam(axis, x.shape)[0];
  if (env().get("DEBUG")) {
    const indicesVals = backend3.readSync(indices.dataId);
    const axisDim = x.shape[parsedAxis];
    for (let i = 0;i < indicesVals.length; ++i) {
      const index = indicesVals[i];
      exports_util.assert(index <= axisDim - 1 && index >= 0, () => `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);
    }
  }
  const shapeInfo = exports_backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
  const indicesSize = exports_util.sizeFromShape(indices.shape);
  const toDispose = [];
  const flattenX = reshape79({
    inputs: { x },
    backend: backend3,
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    }
  });
  const flattenIndex = reshape79({
    inputs: { x: indices },
    backend: backend3,
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
  });
  toDispose.push(flattenX);
  toDispose.push(flattenIndex);
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  if (backend3.shouldExecuteOnCPU([x, indices]) || x.dtype === "string") {
    const indicesBuf = backend3.bufferSync(flattenIndex);
    const xBuf = backend3.bufferSync(flattenX);
    const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);
    toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
    return backend3.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
  }
  const program = new GatherProgram(flattenX.shape, flattenOutputShape);
  const res = backend3.runWebGLProgram(program, [flattenX, flattenIndex], flattenX.dtype);
  toDispose.push(res);
  const reshaped = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape: shapeInfo.outputShape } });
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return reshaped;
}
var gatherV2Config2;
var init_GatherV22 = __esm(() => {
  init_dist();
  init_gather_gpu();
  init_shared2();
  init_Reshape2();
  gatherV2Config2 = {
    kernelName: GatherV2,
    backendName: "webgl",
    kernelFunc: gatherV22
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Greater.js
var GREATER = `return float(a > b);`, GREATER_PACKED = `
  return vec4(greaterThan(a, b));
`, greater13, greaterConfig2;
var init_Greater2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  greater13 = binaryKernelFunc2({
    opSnippet: GREATER,
    packedOpSnippet: GREATER_PACKED,
    cpuKernelImpl: greaterImplCPU,
    dtype: "bool"
  });
  greaterConfig2 = {
    kernelName: Greater,
    backendName: "webgl",
    kernelFunc: greater13
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/GreaterEqual.js
var GREATER_EQUAL = `return float(a >= b);`, GREATER_EQUAL_PACKED = `
  return vec4(greaterThanEqual(a, b));
`, greaterEqual3, greaterEqualConfig2;
var init_GreaterEqual2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  greaterEqual3 = binaryKernelFunc2({
    opSnippet: GREATER_EQUAL,
    packedOpSnippet: GREATER_EQUAL_PACKED,
    dtype: "bool",
    cpuKernelImpl: greaterEqualImplCPU
  });
  greaterEqualConfig2 = {
    kernelName: GreaterEqual,
    backendName: "webgl",
    kernelFunc: greaterEqual3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IFFT.js
function ifft6(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  return fftImpl2(input2, true, backend3);
}
var ifftConfig2;
var init_IFFT2 = __esm(() => {
  init_dist();
  init_FFT_impl();
  ifftConfig2 = {
    kernelName: IFFT,
    backendName: "webgl",
    kernelFunc: ifft6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsFinite.js
var IS_FINITE = `return float(!isnan(x) && !isinf(x));`, isFinite4, isFiniteConfig2;
var init_IsFinite2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  isFinite4 = unaryKernelFunc2({ opSnippet: IS_FINITE, dtype: "bool" });
  isFiniteConfig2 = {
    kernelName: IsFinite,
    backendName: "webgl",
    kernelFunc: isFinite4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsInf.js
var IS_INF = `return float(isinf(x));`, isInf3, isInfConfig2;
var init_IsInf2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  isInf3 = unaryKernelFunc2({ opSnippet: IS_INF, dtype: "bool" });
  isInfConfig2 = {
    kernelName: IsInf,
    backendName: "webgl",
    kernelFunc: isInf3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/IsNaN.js
var IS_NAN = `return float(isnan(x));`, isNaN4, isNaNConfig2;
var init_IsNaN2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  isNaN4 = unaryKernelFunc2({ opSnippet: IS_NAN, dtype: "bool" });
  isNaNConfig2 = {
    kernelName: IsNan,
    backendName: "webgl",
    kernelFunc: isNaN4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Less.js
var LESS = `return float(a < b);`, LESS_PACKED = `
  return vec4(lessThan(a, b));
`, less8, lessConfig2;
var init_Less2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  less8 = binaryKernelFunc2({
    opSnippet: LESS,
    packedOpSnippet: LESS_PACKED,
    cpuKernelImpl: lessImplCPU,
    dtype: "bool"
  });
  lessConfig2 = {
    kernelName: Less,
    backendName: "webgl",
    kernelFunc: less8
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LessEqual.js
var LESS_EQUAL = `return float(a <= b);`, LESS_EQUAL_PACKED = `
  return vec4(lessThanEqual(a, b));
`, lessEqual3, lessEqualConfig2;
var init_LessEqual2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  lessEqual3 = binaryKernelFunc2({
    opSnippet: LESS_EQUAL,
    packedOpSnippet: LESS_EQUAL_PACKED,
    cpuKernelImpl: lessEqualImplCPU,
    dtype: "bool"
  });
  lessEqualConfig2 = {
    kernelName: LessEqual,
    backendName: "webgl",
    kernelFunc: lessEqual3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LinSpace.js
function linSpace2(args) {
  const { backend: backend3, attrs } = args;
  const { start, stop, num } = attrs;
  const outVals = linSpaceImplCPU(start, stop, num);
  return backend3.makeTensorInfo([outVals.length], "float32", outVals);
}
var linSpaceConfig2;
var init_LinSpace2 = __esm(() => {
  init_dist();
  init_shared2();
  linSpaceConfig2 = {
    kernelName: LinSpace,
    backendName: "webgl",
    kernelFunc: linSpace2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log.js
var LOG, LOG_PACKED = `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`, log10, logConfig2;
var init_Log2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  LOG = CHECK_NAN_SNIPPET_UNARY + `
  return x < 0.0 ? 0./0. : log(x);
`;
  log10 = unaryKernelFunc2({ opSnippet: LOG, packedOpSnippet: LOG_PACKED, cpuKernelImpl: logImplCPU });
  logConfig2 = {
    kernelName: Log,
    backendName: "webgl",
    kernelFunc: log10
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Log1p.js
var LOG1P, log1p5, log1pConfig2;
var init_Log1p2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  LOG1P = CHECK_NAN_SNIPPET_UNARY + `
  return log(1.0 + x);
`;
  log1p5 = unaryKernelFunc2({ opSnippet: LOG1P });
  log1pConfig2 = {
    kernelName: Log1p,
    backendName: "webgl",
    kernelFunc: log1p5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalAnd.js
var LOGICAL_AND = `return float(a >= 1.0 && b >= 1.0);`, LOGICAL_AND_PACKED = `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`, logicalAnd3, logicalAndConfig2;
var init_LogicalAnd2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  logicalAnd3 = binaryKernelFunc2({
    opSnippet: LOGICAL_AND,
    packedOpSnippet: LOGICAL_AND_PACKED,
    dtype: "bool"
  });
  logicalAndConfig2 = {
    kernelName: LogicalAnd,
    backendName: "webgl",
    kernelFunc: logicalAnd3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalNot.js
var LOGICAL_NOT = `return float(!(x >= 1.0));`, logicalNot3, logicalNotConfig2;
var init_LogicalNot2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  logicalNot3 = unaryKernelFunc2({ opSnippet: LOGICAL_NOT });
  logicalNotConfig2 = {
    kernelName: LogicalNot,
    backendName: "webgl",
    kernelFunc: logicalNot3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LogicalOr.js
var LOGICAL_OR = `return float(a >= 1.0 || b >= 1.0);`, LOGICAL_OR_PACKED = `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`, logicalOr3, logicalOrConfig2;
var init_LogicalOr2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  logicalOr3 = binaryKernelFunc2({ opSnippet: LOGICAL_OR, packedOpSnippet: LOGICAL_OR_PACKED, dtype: "bool" });
  logicalOrConfig2 = {
    kernelName: LogicalOr,
    backendName: "webgl",
    kernelFunc: logicalOr3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_gpu.js
class LRNProgram {
  constructor(xShape, radius, bias, alpha, beta) {
    this.variableNames = ["x"];
    this.outputShape = [];
    const rad = radius;
    const maxD = xShape[3] - 1;
    this.outputShape = xShape;
    let powOperator;
    const basis = `float(${bias}) + float(${alpha}) * sum`;
    if (beta === 0.5) {
      powOperator = `inversesqrt(${basis})`;
    } else if (beta === 1) {
      powOperator = `1.0/(${basis})`;
    } else {
      powOperator = `exp(log(${basis}) * float(-${beta}));`;
    }
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${rad}; j <= ${rad}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${maxD}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${powOperator};
        setOutput(val);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_packed_gpu.js
class LRNPackedProgram {
  constructor(xShape, radius, bias, alpha, beta) {
    this.variableNames = ["x"];
    this.outputShape = [];
    this.packedInputs = true;
    this.packedOutput = true;
    const rad = radius;
    const maxD = xShape[3] - 1;
    this.outputShape = xShape;
    let powOperator;
    const basis = `float(${bias}) + float(${alpha}) * sum`;
    if (beta === 0.5) {
      powOperator = `inversesqrt(${basis})`;
    } else if (beta === 1) {
      powOperator = `1.0/(${basis})`;
    } else {
      powOperator = `exp(log(${basis}) * float(-${beta}));`;
    }
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${rad};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${rad}; j <= ${rad}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${maxD}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${powOperator};
        setOutput(result);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRN.js
var lrn = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  const program = env().getBool("WEBGL_PACK_NORMALIZATION") ? new LRNPackedProgram(x.shape, depthRadius, bias, alpha, beta) : new LRNProgram(x.shape, depthRadius, bias, alpha, beta);
  return backend3.runWebGLProgram(program, [x], x.dtype);
}, LRNConfig2;
var init_LRN2 = __esm(() => {
  init_dist();
  LRNConfig2 = {
    kernelName: LRN,
    backendName: "webgl",
    kernelFunc: lrn
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/lrn_grad_gpu.js
class LRNGradProgram {
  constructor(inputShape, depthRadius, bias, alpha, beta) {
    this.variableNames = ["inputImage", "outputImage", "dy"];
    this.outputShape = [];
    this.outputShape = inputShape;
    this.depth = inputShape[3];
    this.depthRadius = depthRadius;
    this.bias = bias;
    this.alpha = alpha;
    this.beta = beta;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${depthRadius})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${depthRadius} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${alpha}) * norm + float(${bias});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${alpha})
                * float(${beta})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${beta});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/LRNGrad.js
var lrnGrad = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x, y, dy: dy2 } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  const program = new LRNGradProgram(x.shape, depthRadius, bias, alpha, beta);
  return backend3.runWebGLProgram(program, [x, y, dy2], x.dtype);
}, LRNGradConfig2;
var init_LRNGrad2 = __esm(() => {
  init_dist();
  LRNGradConfig2 = {
    kernelName: LRNGrad,
    backendName: "webgl",
    kernelFunc: lrnGrad
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max_impl.js
function maxImpl2(x, reduceShape, outShape, backend3) {
  const inSize = exports_util.sizeFromShape(reduceShape);
  const xSize = exports_util.sizeFromShape(x.shape);
  const batchSize = xSize / inSize;
  const reshapedInput = reshape79({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend: backend3 });
  const reduced = reduce(reshapedInput, x.dtype, "max", backend3);
  const reshapedOutput = reshape79({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(reshapedInput);
  backend3.disposeIntermediateTensorInfo(reduced);
  return reshapedOutput;
}
var init_Max_impl2 = __esm(() => {
  init_dist();
  init_reduce();
  init_Reshape2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Max.js
function max9(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { reductionIndices, keepDims } = attrs;
  const xRank = x.shape.length;
  const origAxes = exports_util.parseAxisParam(reductionIndices, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  const maxInputIsTransposed = permutedAxes != null;
  const shouldExecuteOnCPU = backend3.shouldExecuteOnCPU([x]);
  let maxInput = x;
  if (maxInputIsTransposed) {
    if (shouldExecuteOnCPU) {
      const xTexData = backend3.texData.get(maxInput.dataId);
      const values = xTexData.values;
      const newShape = new Array(xRank);
      for (let i = 0;i < newShape.length; i++) {
        newShape[i] = x.shape[permutedAxes[i]];
      }
      const maxInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
      maxInput = backend3.makeTensorInfo(newShape, x.dtype);
      const maxInputData = backend3.texData.get(maxInput.dataId);
      maxInputData.values = maxInputValues;
    } else {
      maxInput = transposeImpl2(x, permutedAxes, backend3);
    }
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
  }
  exports_backend_util.assertAxesAreInnerMostDims("max", axes, xRank);
  const [maxOutShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(maxInput.shape, axes);
  let outShape = maxOutShape;
  if (keepDims) {
    outShape = exports_backend_util.expandShapeToKeepDim(maxOutShape, origAxes);
  }
  let out;
  if (shouldExecuteOnCPU) {
    const xTexData = backend3.texData.get(maxInput.dataId);
    const values = xTexData.values;
    const outValues = maxImplCPU(values, exports_util.sizeFromShape(reduceShape), outShape, x.dtype);
    out = backend3.makeTensorInfo(outShape, x.dtype);
    const outData = backend3.texData.get(out.dataId);
    outData.values = outValues;
  } else {
    out = maxImpl2(maxInput, reduceShape, outShape, backend3);
  }
  if (maxInputIsTransposed) {
    backend3.disposeIntermediateTensorInfo(maxInput);
  }
  return out;
}
var maxConfig2;
var init_Max2 = __esm(() => {
  init_dist();
  init_dist();
  init_shared2();
  init_Max_impl2();
  init_Transpose_impl2();
  maxConfig2 = {
    kernelName: Max,
    backendName: "webgl",
    kernelFunc: max9
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Maximum.js
var MAXIMUM, MAXIMUM_PACKED, maximum8, maximumConfig2;
var init_Maximum2 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  init_shared2();
  MAXIMUM = CHECK_NAN_SNIPPET2 + `
  return max(a, b);
`;
  MAXIMUM_PACKED = `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  maximum8 = binaryKernelFunc2({
    opSnippet: MAXIMUM,
    packedOpSnippet: MAXIMUM_PACKED,
    cpuKernelImpl: maximumImplCPU
  });
  maximumConfig2 = {
    kernelName: Maximum,
    backendName: "webgl",
    kernelFunc: maximum8
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool.js
function maxPool3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  assertNotComplex2(x, "maxPool");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = 1;
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && exports_util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    return identity3({ inputs: { x }, backend: backend3 });
  }
  const maxPoolProgram = new Pool2DProgram(convInfo, "max", false);
  return backend3.runWebGLProgram(maxPoolProgram, [x], x.dtype);
}
var maxPoolConfig2;
var init_MaxPool2 = __esm(() => {
  init_dist();
  init_webgl_util();
  init_Identity2();
  maxPoolConfig2 = {
    kernelName: MaxPool,
    backendName: "webgl",
    kernelFunc: maxPool3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3D.js
function maxPool3d2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dataFormat, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode, dataFormat);
  const maxPoolProgram = new Pool3DProgram(convInfo, "max", false);
  return backend3.runWebGLProgram(maxPoolProgram, [x], x.dtype);
}
var maxPool3DConfig2;
var init_MaxPool3D2 = __esm(() => {
  init_dist();
  maxPool3DConfig2 = {
    kernelName: MaxPool3D,
    backendName: "webgl",
    kernelFunc: maxPool3d2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/max_pool_backprop_gpu.js
class MaxPool2DBackpropProgram {
  constructor(convInfo) {
    this.variableNames = ["dy", "maxPos"];
    this.outputShape = convInfo.inShape;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationHeight = convInfo.dilationHeight;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const lastIndex = effectiveFilterHeight * effectiveFilterWidth - 1;
    this.userCode = `
      const ivec2 pads = ivec2(${padTop}, ${padLeft});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${effectiveFilterHeight};
          wR += ${dilationHeight}) {
          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${effectiveFilterWidth}; wC++) {
            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${lastIndex} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${effectiveFilterWidth} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

class MaxPool3DBackpropProgram {
  constructor(convInfo) {
    this.variableNames = ["dy", "maxPos"];
    this.outputShape = convInfo.inShape;
    const strideDepth = convInfo.strideDepth;
    const strideHeight = convInfo.strideHeight;
    const strideWidth = convInfo.strideWidth;
    const dilationDepth = convInfo.dilationDepth;
    const dilationHeight = convInfo.dilationHeight;
    const dilationWidth = convInfo.dilationWidth;
    const effectiveFilterDepth = convInfo.effectiveFilterDepth;
    const effectiveFilterHeight = convInfo.effectiveFilterHeight;
    const effectiveFilterWidth = convInfo.effectiveFilterWidth;
    const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;
    const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;
    const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;
    const lastIndex = effectiveFilterDepth * effectiveFilterHeight * effectiveFilterWidth - 1;
    this.userCode = `
      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${effectiveFilterDepth};
           wD += ${dilationDepth}) {
          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;

          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${effectiveFilterHeight};
              wR += ${dilationHeight}) {
            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;

            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${effectiveFilterWidth};
                wC += ${dilationWidth}) {
              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;

              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${lastIndex} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +
                  wR * ${effectiveFilterWidth} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPool3DGrad.js
function maxPool3DGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  const maxPool3dPositionsProgram = new Pool3DProgram(convInfo, "max", true);
  const maxPool3dPositions2 = backend3.runWebGLProgram(maxPool3dPositionsProgram, [x], x.dtype);
  const maxPoolBackpropProgram = new MaxPool3DBackpropProgram(convInfo);
  const result = backend3.runWebGLProgram(maxPoolBackpropProgram, [dy2, maxPool3dPositions2], x.dtype);
  backend3.disposeIntermediateTensorInfo(maxPool3dPositions2);
  return result;
}
var maxPool3DGradConfig3;
var init_MaxPool3DGrad2 = __esm(() => {
  init_dist();
  maxPool3DGradConfig3 = {
    kernelName: MaxPool3DGrad,
    backendName: "webgl",
    kernelFunc: maxPool3DGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolGrad.js
function maxPoolGrad3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2, output } = inputs;
  const x = input2;
  assertNotComplex2([input2, output], "maxPoolGrad");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, 1, pad9, dimRoundingMode);
  const getPositions = true;
  const maxPoolPositionsProgram = new Pool2DProgram(convInfo, "max", getPositions);
  const maxPoolPositions2 = backend3.runWebGLProgram(maxPoolPositionsProgram, [x], x.dtype);
  const maxPoolBackPropProgram = new MaxPool2DBackpropProgram(convInfo);
  const result = backend3.runWebGLProgram(maxPoolBackPropProgram, [dy2, maxPoolPositions2], x.dtype);
  backend3.disposeIntermediateTensorInfo(maxPoolPositions2);
  return result;
}
var maxPoolGradConfig3;
var init_MaxPoolGrad2 = __esm(() => {
  init_dist();
  init_webgl_util();
  maxPoolGradConfig3 = {
    kernelName: MaxPoolGrad,
    backendName: "webgl",
    kernelFunc: maxPoolGrad3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax_impl.js
function maxPoolWithArgmaxImpl2(x, includeBatchInIndex, convInfo, backend3) {
  let program = new Pool2DProgram(convInfo, "max", false);
  const poolOutput = backend3.runWebGLProgram(program, [x], "float32");
  program = new Pool2DProgram(convInfo, "max", true, true, includeBatchInIndex);
  const indexOutput = backend3.runWebGLProgram(program, [x], "float32");
  return [poolOutput, indexOutput];
}
var init_MaxPoolWithArgmax_impl2 = () => {
};

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MaxPoolWithArgmax.js
var maxPoolWithArgmaxConfig2;
var init_MaxPoolWithArgmax2 = __esm(() => {
  init_dist();
  init_dist();
  init_MaxPoolWithArgmax_impl2();
  maxPoolWithArgmaxConfig2 = {
    kernelName: MaxPoolWithArgmax,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
      const { x } = inputs;
      const { filterSize, strides, pad: pad9, includeBatchInIndex } = attrs;
      const webglBackend = backend3;
      exports_util.assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
      const dilations = [1, 1];
      exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
      const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9);
      const [result, indexes] = maxPoolWithArgmaxImpl2(x, includeBatchInIndex, convInfo, webglBackend);
      return [result, indexes];
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean_impl.js
function meanImpl(x, reduceShape, outShape, backend3) {
  const inSize = exports_util.sizeFromShape(reduceShape);
  const xSize = exports_util.sizeFromShape(x.shape);
  const batchSize = xSize / inSize;
  const reshapedInput = reshape79({ inputs: { x }, attrs: { shape: [batchSize, inSize] }, backend: backend3 });
  const reduced = reduce(reshapedInput, "float32", "mean", backend3);
  const reshapedOutput = reshape79({ inputs: { x: reduced }, attrs: { shape: outShape }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(reshapedInput);
  backend3.disposeIntermediateTensorInfo(reduced);
  return reshapedOutput;
}
var init_Mean_impl = __esm(() => {
  init_dist();
  init_reduce();
  init_Reshape2();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mean.js
var meanConfig2;
var init_Mean2 = __esm(() => {
  init_dist();
  init_Mean_impl();
  init_Transpose_impl2();
  meanConfig2 = {
    kernelName: Mean,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
      const { x } = inputs;
      const { keepDims, axis } = attrs;
      const webglBackend = backend3;
      const xRank = x.shape.length;
      const origAxes = exports_util.parseAxisParam(axis, x.shape);
      let axes = origAxes;
      const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
      const meanInputIsTransposed = permutedAxes != null;
      const shouldExecuteOnCPU = webglBackend.shouldExecuteOnCPU([x]);
      const intermediates = [];
      let meanInput = x;
      if (meanInputIsTransposed) {
        if (shouldExecuteOnCPU) {
          const xTexData = webglBackend.texData.get(meanInput.dataId);
          const values = xTexData.values;
          const newShape = new Array(xRank);
          for (let i = 0;i < newShape.length; i++) {
            newShape[i] = x.shape[permutedAxes[i]];
          }
          const meanInputValues = transposeImplCPU(values, x.shape, x.dtype, permutedAxes, newShape);
          meanInput = webglBackend.makeTensorInfo(newShape, x.dtype);
          const meanInputData = webglBackend.texData.get(meanInput.dataId);
          meanInputData.values = meanInputValues;
        } else {
          meanInput = transposeImpl2(x, permutedAxes, webglBackend);
        }
        intermediates.push(meanInput);
        axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
      }
      exports_backend_util.assertAxesAreInnerMostDims("sum", axes, xRank);
      const [meanOutShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(meanInput.shape, axes);
      let outShape = meanOutShape;
      if (keepDims) {
        outShape = exports_backend_util.expandShapeToKeepDim(meanOutShape, origAxes);
      }
      const out = meanImpl(meanInput, reduceShape, outShape, webglBackend);
      for (const i of intermediates) {
        webglBackend.disposeIntermediateTensorInfo(i);
      }
      return out;
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Min.js
function min7(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x.shape.length;
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  let permutedX = x;
  if (permutedAxes != null) {
    permutedX = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("min", axes, xRank);
  const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
  const inSize = exports_util.sizeFromShape(reduceShape);
  const a2D = reshape79({ inputs: { x: permutedX }, backend: backend3, attrs: { shape: [-1, inSize] } });
  const reduced = reduce(a2D, a2D.dtype, "min", backend3);
  let res;
  if (keepDims) {
    const newShape = exports_backend_util.expandShapeToKeepDim(outShape, origAxes);
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: newShape } });
  } else {
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: outShape } });
  }
  backend3.disposeIntermediateTensorInfo(a2D);
  backend3.disposeIntermediateTensorInfo(reduced);
  if (permutedAxes != null) {
    backend3.disposeIntermediateTensorInfo(permutedX);
  }
  return res;
}
var minConfig2;
var init_Min2 = __esm(() => {
  init_dist();
  init_reduce();
  init_Reshape2();
  init_Transpose2();
  minConfig2 = {
    kernelName: Min,
    backendName: "webgl",
    kernelFunc: min7
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Minimum.js
var MINIMUM, MINIMUM_PACKED, minimum8, minimumConfig2;
var init_Minimum2 = __esm(() => {
  init_dist();
  init_binaryop_gpu();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  init_shared2();
  MINIMUM = CHECK_NAN_SNIPPET2 + `
  return min(a, b);
`;
  MINIMUM_PACKED = `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  minimum8 = binaryKernelFunc2({
    opSnippet: MINIMUM,
    packedOpSnippet: MINIMUM_PACKED,
    cpuKernelImpl: minimumImplCPU
  });
  minimumConfig2 = {
    kernelName: Minimum,
    backendName: "webgl",
    kernelFunc: minimum8
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js
class MirrorPadProgram {
  constructor(xShape, paddings, mode) {
    this.variableNames = ["x"];
    this.outputShape = paddings.map((p4, i) => p4[0] + xShape[i] + p4[1]);
    const rank = xShape.length;
    const dtype = getCoordsDataType(rank);
    const start = paddings.map((p4) => p4[0]).join(",");
    const end = paddings.map((p4, i) => p4[0] + xShape[i]).join(",");
    const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
    const offset = mode === "reflect" ? 0 : 1;
    if (rank === 1) {
      this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${offset};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${offset};
          }
          setOutput(getX(outC - start));
        }
      `;
      return;
    }
    this.userCode = `
      ${dtype} start = ${dtype}(${start});
      ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outC = getOutputCoords();
        for (int i = 0; i < ${rank}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${offset};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};
          }
        }
        ${dtype} coords = outC - start;
        setOutput(getX(${unpackedCoords}));
      }
    `;
  }
}
var init_mirror_pad_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js
class MirrorPadPackedProgram {
  constructor(xShape, paddings, mode) {
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = paddings.map((p4, i) => p4[0] + xShape[i] + p4[1]);
    const rank = xShape.length;
    const dtype = getCoordsDataType(rank);
    const start = paddings.map((p4) => p4[0]).join(",");
    const end = paddings.map((p4, i) => p4[0] + xShape[i]).join(",");
    const coords2 = getChannels("rc", rank);
    const source = getChannels("source", rank);
    const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
    const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
    const offset = mode === "reflect" ? 0 : 1;
    let mainLoop = "";
    if (rank === 1) {
      const padSetup = `
        ${dtype} source = rc;
        if (source < start) {
          source = start * 2 - source - ${offset};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${offset};
        }
        source -= start;
      `;
      mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
    } else {
      const padSetup = `
        ${dtype} source = rc;
        ${dtype} lt = ${dtype}(lessThan(source, start));
        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));
        ${dtype} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${offset}) +
                gte * ((end - 1) * 2 - source + ${offset});
        source -= start;
      `;
      mainLoop = `
        ${dtype} rc = outputLoc;
        ${padSetup}
        result[0] = getChannel(getX(${source.join()}), ${innerDims});
        ${coords2[rank - 1]} += 1;
        if(${cLimit}) {
          ${padSetup}
          result[1] = getChannel(getX(${source.join()}), ${innerDims});
        }
        rc = outputLoc;
        ${coords2[rank - 2]} += 1;
        if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {
          ${padSetup}
          result[2] = getChannel(getX(${source.join()}), ${innerDims});
          ${coords2[rank - 1]} += 1;
          if(${cLimit}) {
            ${padSetup}
            result[3] = getChannel(getX(${source.join()}), ${innerDims});
          }
        }
      `;
    }
    this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
  }
}
var init_mirror_pad_packed_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/MirrorPad.js
var mirrorPadKernelFunc = ({ inputs, backend: backend3, attrs }) => {
  const { x } = inputs;
  const { paddings, mode } = attrs;
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new MirrorPadPackedProgram(x.shape, paddings, mode) : new MirrorPadProgram(x.shape, paddings, mode);
  const output = backend3.runWebGLProgram(program, [x], x.dtype);
  return output;
}, mirrorPadConfig2;
var init_MirrorPad2 = __esm(() => {
  init_dist();
  init_mirror_pad_gpu();
  init_mirror_pad_packed_gpu();
  mirrorPadConfig2 = {
    kernelName: MirrorPad,
    backendName: "webgl",
    kernelFunc: mirrorPadKernelFunc
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Mod.js
var MOD = `if (b == 0.0) return NAN;
  return mod(a, b);`, MOD_PACKED, mod5, modConfig2;
var init_Mod2 = __esm(() => {
  init_dist();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  MOD_PACKED = `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  mod5 = binaryKernelFunc2({
    opSnippet: MOD,
    packedOpSnippet: MOD_PACKED
  });
  modConfig2 = {
    kernelName: Mod,
    backendName: "webgl",
    kernelFunc: mod5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js
class MultinomialProgram {
  constructor(batchSize, numOutcomes, numSamples) {
    this.variableNames = ["probs"];
    this.customUniforms = [{ name: "seed", type: "float" }];
    this.outputShape = [batchSize, numSamples];
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${numOutcomes - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${numOutcomes - 1}));
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RealDiv.js
var DIV = `
if (a == b) {
  return 1.0;
};
return a / b;`, DIV_PACKED = `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`, realDiv, realDivConfig2;
var init_RealDiv2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  realDiv = binaryKernelFunc2({ opSnippet: DIV, packedOpSnippet: DIV_PACKED, checkOutOfBounds: true });
  realDivConfig2 = {
    kernelName: RealDiv,
    backendName: "webgl",
    kernelFunc: realDiv
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sub.js
var SUB = "return a - b;", sub34, subConfig2;
var init_Sub2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  sub34 = binaryKernelFunc2({
    opSnippet: SUB,
    packedOpSnippet: SUB,
    supportsComplex: true,
    cpuKernelImpl: subImplCPU
  });
  subConfig2 = {
    kernelName: Sub,
    backendName: "webgl",
    kernelFunc: sub34
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softmax.js
function softmax5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { logits } = inputs;
  const { dim } = attrs;
  const axes = exports_util.parseAxisParam([dim], logits.shape);
  const maxLogit = max9({
    inputs: { x: logits },
    backend: backend3,
    attrs: { reductionIndices: axes, keepDims: false }
  });
  const expandedShape = exports_backend_util.expandShapeToKeepDim(maxLogit.shape, axes);
  const maxLogitsReshaped = reshape79({ inputs: { x: maxLogit }, backend: backend3, attrs: { shape: expandedShape } });
  const a = sub34({ inputs: { a: logits, b: maxLogitsReshaped }, backend: backend3 });
  const b = exp12({ inputs: { x: a }, backend: backend3 });
  const sumExp = sum28({ inputs: { x: b }, backend: backend3, attrs: { axis: axes, keepDims: false } });
  const sumExpReshaped = reshape79({ inputs: { x: sumExp }, backend: backend3, attrs: { shape: expandedShape } });
  const res = realDiv({ inputs: { a: b, b: sumExpReshaped }, backend: backend3 });
  backend3.disposeIntermediateTensorInfo(maxLogit);
  backend3.disposeIntermediateTensorInfo(maxLogitsReshaped);
  backend3.disposeIntermediateTensorInfo(a);
  backend3.disposeIntermediateTensorInfo(b);
  backend3.disposeIntermediateTensorInfo(sumExp);
  backend3.disposeIntermediateTensorInfo(sumExpReshaped);
  return res;
}
var softmaxConfig2;
var init_Softmax2 = __esm(() => {
  init_dist();
  init_Exp2();
  init_Max2();
  init_RealDiv2();
  init_Reshape2();
  init_Sub2();
  init_Sum2();
  softmaxConfig2 = {
    kernelName: Softmax,
    backendName: "webgl",
    kernelFunc: softmax5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Multinomial.js
function multinomial3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { logits } = inputs;
  const { numSamples, seed, normalized } = attrs;
  const probs = normalized ? logits : softmax5({ inputs: { logits }, backend: backend3, attrs: { dim: logits.shape.length - 1 } });
  const batchSize = probs.shape[0];
  const numOutcomes = probs.shape[1];
  const program = new MultinomialProgram(batchSize, numOutcomes, numSamples);
  const customValues = [[seed]];
  const res = backend3.runWebGLProgram(program, [probs], "int32", customValues);
  if (!normalized) {
    backend3.disposeIntermediateTensorInfo(probs);
  }
  return res;
}
var multinomialConfig2;
var init_Multinomial2 = __esm(() => {
  init_dist();
  init_Softmax2();
  multinomialConfig2 = {
    kernelName: Multinomial,
    backendName: "webgl",
    kernelFunc: multinomial3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Neg.js
function neg22(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (backend3.shouldExecuteOnCPU([x])) {
    const xData = backend3.texData.get(x.dataId);
    const [outValues, newShape] = negImplCPU(xData.values, x.shape, x.dtype);
    return backend3.makeTensorInfo(newShape, x.dtype, outValues);
  }
  let program;
  if (env().getBool("WEBGL_PACK_UNARY_OPERATIONS")) {
    program = new UnaryOpPackedProgram(x.shape, NEG_PACKED);
  } else {
    program = new UnaryOpProgram(x.shape, NEG);
  }
  return backend3.runWebGLProgram(program, [x], x.dtype);
}
var NEG, NEG_PACKED = `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, negConfig2;
var init_Neg2 = __esm(() => {
  init_dist();
  init_shared2();
  init_unaryop_gpu();
  init_unaryop_packed_gpu();
  NEG = CHECK_NAN_SNIPPET + `
  return -x;
`;
  negConfig2 = {
    kernelName: Neg,
    backendName: "webgl",
    kernelFunc: neg22
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV3.js
function nonMaxSuppressionV32(args) {
  exports_backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. " + "Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
  const boxesVals = backend3.readSync(boxes.dataId);
  const scoresVals = backend3.readSync(scores.dataId);
  const { selectedIndices } = nonMaxSuppressionV3Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  return backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
}
var nonMaxSuppressionV3Impl3, nonMaxSuppressionV3Config2;
var init_NonMaxSuppressionV32 = __esm(() => {
  init_dist();
  nonMaxSuppressionV3Impl3 = exports_kernel_impls.nonMaxSuppressionV3Impl;
  nonMaxSuppressionV3Config2 = {
    kernelName: NonMaxSuppressionV3,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV32
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV4.js
function nonMaxSuppressionV42(args) {
  exports_backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. " + "Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize } = attrs;
  const boxesVals = backend3.readSync(boxes.dataId);
  const scoresVals = backend3.readSync(scores.dataId);
  const { selectedIndices, validOutputs } = nonMaxSuppressionV4Impl3(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize);
  return [
    backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend3.makeTensorInfo([], "int32", new Int32Array([validOutputs]))
  ];
}
var nonMaxSuppressionV4Impl3, nonMaxSuppressionV4Config2;
var init_NonMaxSuppressionV42 = __esm(() => {
  init_dist();
  nonMaxSuppressionV4Impl3 = exports_kernel_impls.nonMaxSuppressionV4Impl;
  nonMaxSuppressionV4Config2 = {
    kernelName: NonMaxSuppressionV4,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV42
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/NonMaxSuppressionV5.js
function nonMaxSuppressionV52(args) {
  exports_backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. " + "Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
  const boxesVals = backend3.readSync(boxes.dataId);
  const scoresVals = backend3.readSync(scores.dataId);
  const maxOutputSizeVal = maxOutputSize;
  const iouThresholdVal = iouThreshold;
  const scoreThresholdVal = scoreThreshold;
  const softNmsSigmaVal = softNmsSigma;
  const { selectedIndices, selectedScores } = nonMaxSuppressionV5Impl3(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
  return [
    backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend3.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
  ];
}
var nonMaxSuppressionV5Impl3, nonMaxSuppressionV5Config2;
var init_NonMaxSuppressionV52 = __esm(() => {
  init_dist();
  nonMaxSuppressionV5Impl3 = exports_kernel_impls.nonMaxSuppressionV5Impl;
  nonMaxSuppressionV5Config2 = {
    kernelName: NonMaxSuppressionV5,
    backendName: "webgl",
    kernelFunc: nonMaxSuppressionV52
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js
class OneHotProgram {
  constructor(numIndices, depth, onValue, offValue) {
    this.variableNames = ["indices"];
    this.outputShape = [numIndices, depth];
    this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${offValue}), float(${onValue}),
                      float(index == coords.y)));
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OneHot.js
var oneHot3 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { indices } = inputs;
  const { dtype, depth, onValue, offValue } = attrs;
  const indicesSize = exports_util.sizeFromShape(indices.shape);
  const program = new OneHotProgram(indicesSize, depth, onValue, offValue);
  const reshaped = reshape79({ inputs: { x: indices }, backend: backend3, attrs: { shape: [indicesSize] } });
  const result = backend3.runWebGLProgram(program, [reshaped], dtype);
  backend3.disposeIntermediateTensorInfo(reshaped);
  const outShape = [...indices.shape, depth];
  const out = reshape79({ inputs: { x: result }, backend: backend3, attrs: { shape: outShape } });
  backend3.disposeIntermediateTensorInfo(result);
  return out;
}, oneHotConfig2;
var init_OneHot2 = __esm(() => {
  init_dist();
  init_Reshape2();
  oneHotConfig2 = {
    kernelName: OneHot,
    backendName: "webgl",
    kernelFunc: oneHot3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ZerosLike.js
function zerosLike3(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (x.dtype === "complex64") {
    const realPart = real6({ inputs: { input: x }, backend: backend3 });
    const r = zerosLike3({ inputs: { x: realPart }, backend: backend3 });
    const imagPart = imag6({ inputs: { input: x }, backend: backend3 });
    const i = zerosLike3({ inputs: { x: imagPart }, backend: backend3 });
    const result = complex9({ inputs: { real: r, imag: i }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(realPart);
    backend3.disposeIntermediateTensorInfo(r);
    backend3.disposeIntermediateTensorInfo(imagPart);
    backend3.disposeIntermediateTensorInfo(i);
    return result;
  } else {
    return fill7({
      attrs: {
        shape: x.shape,
        dtype: x.dtype,
        value: x.dtype === "string" ? "" : 0
      },
      backend: backend3
    });
  }
}
var zerosLikeConfig2;
var init_ZerosLike2 = __esm(() => {
  init_dist();
  init_Complex2();
  init_Fill2();
  init_Imag2();
  init_Real2();
  zerosLikeConfig2 = {
    kernelName: ZerosLike,
    backendName: "webgl",
    kernelFunc: zerosLike3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/OnesLike.js
function onesLike3(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (x.dtype === "string") {
    throw new Error("onesLike is not supported under string dtype");
  } else if (x.dtype === "complex64") {
    const realPart = real6({ inputs: { input: x }, backend: backend3 });
    const r = onesLike3({ inputs: { x: realPart }, backend: backend3 });
    const imagPart = imag6({ inputs: { input: x }, backend: backend3 });
    const i = zerosLike3({ inputs: { x: imagPart }, backend: backend3 });
    const result = complex9({ inputs: { real: r, imag: i }, backend: backend3 });
    backend3.disposeIntermediateTensorInfo(realPart);
    backend3.disposeIntermediateTensorInfo(r);
    backend3.disposeIntermediateTensorInfo(imagPart);
    backend3.disposeIntermediateTensorInfo(i);
    return result;
  } else {
    return fill7({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend: backend3 });
  }
}
var onesLikeConfig2;
var init_OnesLike2 = __esm(() => {
  init_dist();
  init_Complex2();
  init_Fill2();
  init_Imag2();
  init_Real2();
  init_ZerosLike2();
  onesLikeConfig2 = {
    kernelName: OnesLike,
    backendName: "webgl",
    kernelFunc: onesLike3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pack.js
function pack2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims4({ inputs: { input: inputs[0] }, backend: backend3, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t) => {
    exports_util.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
    exports_util.assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t) => {
    const expandedT = expandDims4({ inputs: { input: t }, backend: backend3, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat15({ inputs: expandedTensors, backend: backend3, attrs: { axis } });
  intermediateTensorInfos.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}
var packConfig2;
var init_Pack2 = __esm(() => {
  init_dist();
  init_Concat2();
  init_ExpandDims2();
  packConfig2 = {
    kernelName: Pack,
    backendName: "webgl",
    kernelFunc: pack2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js
class PadProgram {
  constructor(xShape, paddings, constantValue) {
    this.variableNames = ["x"];
    this.customUniforms = [{ name: "value", type: "float" }];
    this.outputShape = paddings.map((p4, i) => p4[0] + xShape[i] + p4[1]);
    const rank = xShape.length;
    const type = getCoordsDataType(rank);
    const start = paddings.map((p4) => p4[0]).join(",");
    const end = paddings.map((p4, i) => p4[0] + xShape[i]).join(",");
    const unpackedCoords = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank);
    if (rank === 1) {
      this.userCode = `
        int start = ${start};
        int end = ${end};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
      return;
    }
    this.userCode = `
      ${type} start = ${type}(${start});
      ${type} end = ${type}(${end});

      void main() {
        ${type} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${type} coords = outC - start;
          setOutput(getX(${unpackedCoords}));
        }
      }
    `;
  }
}
var init_pad_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js
class PadPackedProgram {
  constructor(xShape, paddings, constantValue) {
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.customUniforms = [{ name: "value", type: "float" }];
    this.outputShape = paddings.map((p4, i) => p4[0] + xShape[i] + p4[1]);
    const rank = xShape.length;
    const dtype = getCoordsDataType(rank);
    const start = paddings.map((p4) => p4[0]).join(",");
    const end = paddings.map((p4, i) => p4[0] + xShape[i]).join(",");
    const coords2 = getChannels("rc", rank);
    const source = getChannels("source", rank);
    const cLimit = `${coords2[rank - 1]} < ${this.outputShape[rank - 1]}`;
    const innerDims = rank === 1 ? "source" : `vec2(${source.slice(-2).join()})`;
    const componentSetup = [
      `${dtype} rc = outputLoc;`,
      `${coords2[rank - 1]} += 1;
       if(${cLimit}) {
      `,
      rank === 1 ? "" : `}
       rc = outputLoc;
       ${coords2[rank - 2]} += 1;
       if(${coords2[rank - 2]} < ${this.outputShape[rank - 2]}) {`,
      rank === 1 ? "" : `  ${coords2[rank - 1]} += 1;
         if(${cLimit}) {`
    ];
    const paddingArea = rank === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    let mainLoop = "";
    for (let i = 0, j = rank === 1 ? 2 : 4;i < j; i++) {
      mainLoop += `
        ${componentSetup[i]}
        if (${paddingArea}) {
          result[${i}] = float(value);
        } else {
          ${dtype} source = rc - start;
          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});
        }
      `;
    }
    mainLoop += rank === 1 ? `} ` : `}}`;
    this.userCode = `
      const ${dtype} start = ${dtype}(${start});
      const ${dtype} end = ${dtype}(${end});

      void main() {
        ${dtype} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${mainLoop}
        setOutput(result);
      }
    `;
  }
}
var init_pad_packed_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/PadV2.js
var padV22 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { paddings, constantValue } = attrs;
  if (exports_util.sizeFromShape(x.shape) === 0) {
    const outputShape = paddings.map((p4, i) => p4[0] + x.shape[i] + p4[1]);
    return fill7({
      backend: backend3,
      attrs: { shape: outputShape, value: constantValue, dtype: x.dtype }
    });
  }
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new PadPackedProgram(x.shape, paddings, constantValue) : new PadProgram(x.shape, paddings, constantValue);
  const customValues = [[constantValue]];
  return backend3.runWebGLProgram(program, [x], x.dtype, customValues);
}, padV2Config2;
var init_PadV22 = __esm(() => {
  init_dist();
  init_pad_gpu();
  init_pad_packed_gpu();
  init_Fill2();
  padV2Config2 = {
    kernelName: PadV2,
    backendName: "webgl",
    kernelFunc: padV22
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Pow.js
var POW = `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`, POW_PACKED, pow10, powConfig2;
var init_Pow2 = __esm(() => {
  init_dist();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  POW_PACKED = `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + CHECK_NAN_SNIPPET_PACKED + `
  return result;
`;
  pow10 = binaryKernelFunc2({ opSnippet: POW, packedOpSnippet: POW_PACKED });
  powConfig2 = {
    kernelName: Pow,
    backendName: "webgl",
    kernelFunc: pow10
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Prod.js
function prod5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  const xRank = x.shape.length;
  const toDispose = [];
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  let permutedX = x;
  if (permutedAxes != null) {
    permutedX = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
    toDispose.push(permutedX);
  }
  exports_backend_util.assertAxesAreInnerMostDims("prod", axes, xRank);
  let res;
  if (backend3.shouldExecuteOnCPU([permutedX])) {
    const xVals = backend3.texData.get(permutedX.dataId).values;
    const { outVals, outShape, outDtype } = prodImplCPU(permutedX.shape, permutedX.dtype, xVals, axes);
    res = backend3.makeTensorInfo(outShape, outDtype, outVals);
  } else {
    const [outShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(permutedX.shape, axes);
    const inSize = exports_util.sizeFromShape(reduceShape);
    const a2D = reshape79({ inputs: { x: permutedX }, backend: backend3, attrs: { shape: [-1, inSize] } });
    const outputDType = sumOutType(x.dtype);
    const reduced = reduce(a2D, outputDType, "prod", backend3);
    res = reshape79({ inputs: { x: reduced }, backend: backend3, attrs: { shape: outShape } });
    toDispose.push(a2D);
    toDispose.push(reduced);
  }
  if (keepDims) {
    toDispose.push(res);
    const newShape = exports_backend_util.expandShapeToKeepDim(res.shape, origAxes);
    res = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape: newShape } });
  }
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return res;
}
var prodConfig2;
var init_Prod2 = __esm(() => {
  init_dist();
  init_reduce();
  init_shared2();
  init_Reshape2();
  init_Transpose2();
  prodConfig2 = {
    kernelName: Prod,
    backendName: "webgl",
    kernelFunc: prod5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedGather.js
function raggedGather3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { paramsNestedSplits, paramsDenseValues, indices } = inputs;
  const { outputRaggedRank } = attrs;
  const $paramsNestedSplits = paramsNestedSplits.map((t) => backend3.readSync(t.dataId));
  const $paramsNestedSplitsShapes = paramsNestedSplits.map((t) => t.shape);
  const $paramsDenseValues = backend3.readSync(paramsDenseValues.dataId);
  const $indices = backend3.readSync(indices.dataId);
  const [outputNestedSplits, outputDenseValues, outputDenseValuesShape] = raggedGatherImplCPU($paramsNestedSplits, $paramsNestedSplitsShapes, $paramsDenseValues, paramsDenseValues.shape, paramsDenseValues.dtype, $indices, indices.shape, outputRaggedRank);
  const outputNestedSplitsTensors = outputNestedSplits.map((splits) => backend3.makeTensorInfo([splits.length], "int32", splits));
  const outputDenseValuesTensor = backend3.makeTensorInfo(outputDenseValuesShape, paramsDenseValues.dtype, outputDenseValues);
  return outputNestedSplitsTensors.concat([outputDenseValuesTensor]);
}
var raggedGatherConfig2;
var init_RaggedGather2 = __esm(() => {
  init_dist();
  init_shared2();
  raggedGatherConfig2 = {
    kernelName: RaggedGather,
    backendName: "webgl",
    kernelFunc: raggedGather3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedRange.js
function raggedRange3(args) {
  const { inputs, backend: backend3 } = args;
  const { starts, limits, deltas } = inputs;
  const $starts = backend3.readSync(starts.dataId);
  const $limits = backend3.readSync(limits.dataId);
  const $deltas = backend3.readSync(deltas.dataId);
  const [rtNestedSplitsData, rtDenseValuesData] = raggedRangeImplCPU($starts, starts.shape, starts.dtype, $limits, limits.shape, $deltas, deltas.shape);
  const rtNestedSplits = backend3.makeTensorInfo([rtNestedSplitsData.length], "int32", rtNestedSplitsData);
  const rtDenseValues = backend3.makeTensorInfo([rtDenseValuesData.length], starts.dtype, rtDenseValuesData);
  return [rtNestedSplits, rtDenseValues];
}
var raggedRangeConfig2;
var init_RaggedRange2 = __esm(() => {
  init_dist();
  init_shared2();
  raggedRangeConfig2 = {
    kernelName: RaggedRange,
    backendName: "webgl",
    kernelFunc: raggedRange3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RaggedTensorToTensor.js
function raggedTensorToTensor3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { shape, values, defaultValue, rowPartitionTensors } = inputs;
  const { rowPartitionTypes } = attrs;
  const $shape = backend3.readSync(shape.dataId);
  const $values = backend3.readSync(values.dataId);
  const $defaultValue = backend3.readSync(defaultValue.dataId);
  const $rowPartitionValues = rowPartitionTensors.map((t) => backend3.readSync(t.dataId));
  const rowPartitionValuesShapes = rowPartitionTensors.map((t) => t.shape);
  const [outputShape, output] = raggedTensorToTensorImplCPU($shape, shape.shape, $values, values.shape, values.dtype, $defaultValue, defaultValue.shape, $rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes);
  return backend3.makeTensorInfo(outputShape, values.dtype, output);
}
var raggedTensorToTensorConfig2;
var init_RaggedTensorToTensor2 = __esm(() => {
  init_dist();
  init_shared2();
  raggedTensorToTensorConfig2 = {
    kernelName: RaggedTensorToTensor,
    backendName: "webgl",
    kernelFunc: raggedTensorToTensor3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Range.js
var range6 = (args) => {
  const { backend: backend3, attrs } = args;
  const { start, stop, step: step8, dtype } = attrs;
  const values = rangeImplCPU(start, stop, step8, dtype);
  return backend3.makeTensorInfo([values.length], dtype, values);
}, rangeConfig2;
var init_Range2 = __esm(() => {
  init_dist();
  init_shared2();
  rangeConfig2 = {
    kernelName: Range,
    backendName: "webgl",
    kernelFunc: range6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reciprocal.js
var RECIPROCAL = `return 1.0 / x;`, reciprocal4, reciprocalConfig2;
var init_Reciprocal2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  reciprocal4 = unaryKernelFunc2({ opSnippet: RECIPROCAL });
  reciprocalConfig2 = {
    kernelName: Reciprocal,
    backendName: "webgl",
    kernelFunc: reciprocal4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu.js
var RELU3, RELU_PACKED = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, relu10, reluConfig2;
var init_Relu2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  RELU3 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : x;
`;
  relu10 = unaryKernelFunc2({ opSnippet: RELU3, packedOpSnippet: RELU_PACKED });
  reluConfig2 = {
    kernelName: Relu,
    backendName: "webgl",
    kernelFunc: relu10
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Relu6.js
var RELU63, RELU6_PACKED = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, relu66, relu6Config2;
var init_Relu62 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_unaryop_gpu();
  RELU63 = CHECK_NAN_SNIPPET + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`;
  relu66 = unaryKernelFunc2({ opSnippet: RELU63, packedOpSnippet: RELU6_PACKED });
  relu6Config2 = {
    kernelName: Relu6,
    backendName: "webgl",
    kernelFunc: relu66
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js
class ResizeBilinearProgram {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` + ` - vec2(0.5)`;
    } else {
      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js
class ResizeBilinearPackedProgram {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` + `effectiveInputOverOutputRatioRC - vec3(0.5)`;
    } else {
      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinear.js
function resizeBilinear4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size } = attrs;
  const [newHeight, newWidth] = size;
  const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeBilinearPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeBilinearProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
  return backend3.runWebGLProgram(program, [images], "float32");
}
var resizeBilinearConfig2;
var init_ResizeBilinear2 = __esm(() => {
  init_dist();
  resizeBilinearConfig2 = {
    kernelName: ResizeBilinear,
    backendName: "webgl",
    kernelFunc: resizeBilinear4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js
class ResizeBilinearBackpropProgram {
  constructor(dyShape, inputShape, alignCorners) {
    this.variableNames = ["dy"];
    this.outputShape = [];
    this.outputShape = inputShape;
    const [, xHeight, xWidth] = inputShape;
    const [, yHeight, yWidth] = dyShape;
    const effectiveXSize = [
      alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
      alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
      alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
      alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    const winHeight = Math.ceil(invHeightScale) * 2 + 2;
    const winWidth = Math.ceil(invWidthScale) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeBilinearGrad.js
function resizeBilinearGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images, dy: dy2 } = inputs;
  const { alignCorners } = attrs;
  const program = new ResizeBilinearBackpropProgram(dy2.shape, images.shape, alignCorners);
  return backend3.runWebGLProgram(program, [dy2], dy2.dtype);
}
var resizeBilinearGradConfig3;
var init_ResizeBilinearGrad2 = __esm(() => {
  init_dist();
  resizeBilinearGradConfig3 = {
    kernelName: ResizeBilinearGrad,
    backendName: "webgl",
    kernelFunc: resizeBilinearGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js
class ResizeNearestNeighborProgram {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    const roundBase = alignCorners ? "0.5" : "0.0";
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` + `, vec2(0.0))`;
    } else {
      sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js
class ResizeNearestNeighborPackedProgram {
  constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {
    this.variableNames = ["A"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = [];
    const [batch, oldHeight, oldWidth, depth] = inputShape;
    this.outputShape = [batch, newHeight, newWidth, depth];
    const effectiveInSize = [
      alignCorners && newHeight > 1 ? oldHeight - 1 : oldHeight,
      alignCorners && newWidth > 1 ? oldWidth - 1 : oldWidth
    ];
    const effectiveOutSize = [
      alignCorners && newHeight > 1 ? newHeight - 1 : newHeight,
      alignCorners && newWidth > 1 ? newWidth - 1 : newWidth
    ];
    const roundBase = alignCorners ? "0.5" : "0.0";
    let sourceFracIndexRC;
    if (halfPixelCenters) {
      sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * ` + `effectiveInputOverOutputRatioRC, vec3(0.0))`;
    } else {
      sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;
    }
    this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${effectiveInSize[0] / effectiveOutSize[0]},
          ${effectiveInSize[1] / effectiveOutSize[1]},
          ${effectiveInSize[1] / effectiveOutSize[1]});
      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,
                                     ${oldWidth}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${sourceFracIndexRC};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${depth - 1};
        bool hasNextRow = coords.z < ${newWidth - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighbor.js
function resizeNearestNeighbor3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size } = attrs;
  const [newHeight, newWidth] = size;
  const program = env().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new ResizeNearestNeighborPackedProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters) : new ResizeNearestNeighborProgram(images.shape, newHeight, newWidth, alignCorners, halfPixelCenters);
  return backend3.runWebGLProgram(program, [images], images.dtype);
}
var resizeNearestNeighborConfig2;
var init_ResizeNearestNeighbor2 = __esm(() => {
  init_dist();
  resizeNearestNeighborConfig2 = {
    kernelName: ResizeNearestNeighbor,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighbor3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js
class ResizeNearestNeigborBackpropProgram {
  constructor(dyShape, inputShape, alignCorners) {
    this.variableNames = ["dy"];
    this.outputShape = [];
    this.outputShape = inputShape;
    const [, xHeight, xWidth] = inputShape;
    const [, yHeight, yWidth] = dyShape;
    const effectiveXSize = [
      alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
      alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
    ];
    const effectiveYSize = [
      alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
      alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
    ];
    const heightScale = effectiveXSize[0] / effectiveYSize[0];
    const widthScale = effectiveXSize[1] / effectiveYSize[1];
    const invHeightScale = 1 / heightScale;
    const invWidthScale = 1 / widthScale;
    const winHeight = Math.ceil(invHeightScale) * 2 + 2;
    const winWidth = Math.ceil(invWidthScale) * 2 + 2;
    this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${heightScale});
        const float widthScale = float(${widthScale});

        const float invHeightScale = float(${invHeightScale});
        const float invWidthScale = float(${invWidthScale});

        const int winHeight = int(${winHeight});
        const int winWidth = int(${winWidth});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${yHeight}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${yWidth}) {
              continue;
            }

            float sourceFracRow =
              float(${effectiveXSize[0]}) *
                (float(dyR) / float(${effectiveYSize[0]}));

            float sourceFracCol =
                float(${effectiveXSize[1]}) *
                  (float(dyC) / float(${effectiveYSize[1]}));

            int sourceNearestRow = int(min(
                float(int(${xHeight}) - 1),
                ${alignCorners} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${xWidth}) - 1),
                ${alignCorners} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ResizeNearestNeighborGrad.js
function resizeNearestNeighborGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images, dy: dy2 } = inputs;
  const { alignCorners } = attrs;
  const program = new ResizeNearestNeigborBackpropProgram(dy2.shape, images.shape, alignCorners);
  return backend3.runWebGLProgram(program, [dy2], dy2.dtype);
}
var resizeNearestNeighborGradConfig3;
var init_ResizeNearestNeighborGrad2 = __esm(() => {
  init_dist();
  resizeNearestNeighborGradConfig3 = {
    kernelName: ResizeNearestNeighborGrad,
    backendName: "webgl",
    kernelFunc: resizeNearestNeighborGrad2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js
class ReverseProgram {
  constructor(xShape, axis) {
    this.variableNames = ["x"];
    const rank = xShape.length;
    if (rank > 4) {
      throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
    }
    this.outputShape = xShape;
    if (rank === 1) {
      this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${xShape[0]} - coord - 1));
        }
      `;
      return;
    }
    const getInCoord = (i) => {
      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
        return `${xShape[i]} - coords[${i}] - 1`;
      }
      return `coords[${i}]`;
    };
    const inCoords = xShape.map((_, i) => getInCoord(i)).join(",");
    const type = getCoordsDataType(rank);
    this.userCode = `
      void main() {
        ${type} coords = getOutputCoords();
        setOutput(getX(${inCoords}));
      }
    `;
  }
}
var init_reverse_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js
class ReversePackedProgram {
  constructor(xShape, axis) {
    this.variableNames = ["x"];
    this.packedInputs = true;
    this.packedOutput = true;
    const rank = xShape.length;
    if (rank > 4) {
      throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);
    }
    this.outputShape = xShape;
    const channels = getChannels("rc", rank);
    const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;
    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;
    const type = getCoordsDataType(rank);
    if (rank === 1) {
      this.userCode = `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${xShape[0]} - rc - 1),
            ${xShape[0]} - rc - 1);
          if(${nextColumn}){
              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),
                ${xShape[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `;
    } else {
      this.userCode = `
        void main() {
          ${type} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getR(channels.slice())};
          if(${nextColumn}){
            result.g = ${getG(channels.slice())};
          }
          if(${nextRow}) {
            result.b = ${getB(channels.slice())};
            if(${nextColumn}) {
              result.a = ${getA(channels.slice())};
            }
          }
          setOutput(result);
        }
    `;
    }
    function getR(channels2) {
      return getChannel(channels2);
    }
    function getG(channels2) {
      channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
      return getChannel(channels2);
    }
    function getB(channels2) {
      channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
      return getChannel(channels2);
    }
    function getA(channels2) {
      channels2[rank - 1] = "(" + channels2[rank - 1] + ` + 1)`;
      channels2[rank - 2] = "(" + channels2[rank - 2] + ` + 1)`;
      return getChannel(channels2);
    }
    function getChannel(channels2) {
      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels2));
      const inCoords = inCoordsArray.join(",");
      const innerDims = inCoordsArray.slice(-2).join(",");
      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;
    }
    function getInCoord(i, channels1) {
      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
        return `${xShape[i]} - ${channels1[i]} - 1`;
      } else {
        return `${channels1[i]}`;
      }
    }
  }
}
var init_reverse_packed_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Reverse.js
function reverse11(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { dims } = attrs;
  const xRank = x.shape.length;
  const $dims = exports_util.parseAxisParam(dims, x.shape);
  if (xRank === 0) {
    return identity3({ inputs: { x }, backend: backend3 });
  }
  const program = env().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new ReversePackedProgram(x.shape, $dims) : new ReverseProgram(x.shape, $dims);
  return backend3.runWebGLProgram(program, [x], x.dtype);
}
var reverseConfig2;
var init_Reverse2 = __esm(() => {
  init_dist();
  init_reverse_gpu();
  init_reverse_packed_gpu();
  init_Identity2();
  reverseConfig2 = {
    kernelName: Reverse,
    backendName: "webgl",
    kernelFunc: reverse11
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js
class RotateProgram {
  constructor(imageShape, fillValue) {
    this.variableNames = ["Image"];
    this.outputShape = [];
    this.customUniforms = [{ name: "params", type: "vec4" }];
    const imageHeight = imageShape[1];
    const imageWidth = imageShape[2];
    this.outputShape = imageShape;
    let fillSnippet = "";
    if (typeof fillValue === "number") {
      fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;
    } else {
      fillSnippet = `
        vec3 fill = vec3(${fillValue.join(",")});
        float outputValue = fill[coords[3]];`;
    }
    this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${fillSnippet}
          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/RotateWithOffset.js
var rotateWithOffsetConfig2;
var init_RotateWithOffset2 = __esm(() => {
  init_dist();
  init_dist();
  rotateWithOffsetConfig2 = {
    kernelName: RotateWithOffset,
    backendName: "webgl",
    kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
      const { image: image2 } = inputs;
      const { radians, fillValue, center } = attrs;
      const webglBackend = backend3;
      const program = new RotateProgram(image2.shape, fillValue);
      const [centerX, centerY] = exports_backend_util.getImageCenter(center, image2.shape[1], image2.shape[2]);
      const customValues = [[centerX, centerY, Math.sin(radians), Math.cos(radians)]];
      const output = webglBackend.runWebGLProgram(program, [image2], image2.dtype, customValues);
      return output;
    }
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Round.js
var ROUND = `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`, round6, roundConfig2;
var init_Round2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  round6 = unaryKernelFunc2({ opSnippet: ROUND });
  roundConfig2 = {
    kernelName: Round,
    backendName: "webgl",
    kernelFunc: round6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Rsqrt.js
var RSQRT = `return inversesqrt(x);`, rsqrt5, rsqrtConfig2;
var init_Rsqrt2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  rsqrt5 = unaryKernelFunc2({ opSnippet: RSQRT, cpuKernelImpl: rsqrtImplCPU });
  rsqrtConfig2 = {
    kernelName: Rsqrt,
    backendName: "webgl",
    kernelFunc: rsqrt5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js
class ScatterProgram {
  constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true, defaultIsTensor = false) {
    this.variableNames = ["updates", "indices", "defaultValue"];
    this.outputShape = shape;
    const stridesType = getCoordsDataType(strides.length);
    const dtype = getCoordsDataType(shape.length);
    let indicesString = "";
    if (indicesRank === 1) {
      indicesString = "i";
    } else if (indicesRank === 2) {
      indicesString = "i, j";
    }
    const indicesSnippet = `getIndices(${indicesString})`;
    let updatesString = "";
    if (updatesRank === 1) {
      updatesString = "i";
    } else if (updatesRank === 2) {
      updatesString = "i, coords[1]";
    }
    const updatesSnippet = `getUpdates(${updatesString})`;
    let defaultValuesString = "";
    if (defaultIsTensor) {
      defaultValuesString = "coords[0], coords[1]";
    }
    const defaultValueSnippet = `getDefaultValue(${defaultValuesString})`;
    const strideString = sliceDim > 1 ? "strides[j]" : "strides";
    this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${updateSize}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${sliceDim}; j++) {
              int index = round(${indicesSnippet});
              flattenedIndex += index * ${strideString};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${updatesSnippet};
              found = true;
            }
          }
          setOutput(mix(${defaultValueSnippet}, sum, float(found)));
        }
      `;
  }
}
var init_scatter_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_packed_gpu.js
class ScatterPackedProgram {
  constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true, defaultIsTensor = false) {
    this.variableNames = ["updates", "indices", "defaultValue"];
    this.packedInputs = true;
    this.packedOutput = true;
    this.outputShape = shape;
    const stridesType = getCoordsDataType(strides.length);
    const dtype = getCoordsDataType(shape.length);
    let indicesString = "";
    if (indicesRank === 1) {
      indicesString = "i";
    } else if (indicesRank === 2) {
      indicesString = "i, j";
    }
    const indicesSnippet = `getIndices(${indicesString})`;
    let updatesString = "";
    if (updatesRank === 1) {
      updatesString = "i";
    } else if (updatesRank === 2) {
      updatesString = "i, coords[1]";
    }
    const updatesSnippet = `getUpdates(${updatesString})`;
    let defaultValuesString = "";
    if (defaultIsTensor) {
      defaultValuesString = "coords[0], coords[1]";
    }
    const defaultValueSnippet = `getDefaultValue(${defaultValuesString})`;
    const strideString = sliceDim > 1 ? "strides[j]" : "strides";
    const strideString2 = sliceDim > 1 ? "strides[j + 1]" : "strides";
    this.userCode = `
        ${stridesType} strides = ${stridesType}(${strides});

        void main() {
          ${dtype} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${updateSize}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${sliceDim}; j+=2) {
              ivec4 index = round(${indicesSnippet});
              flattenedIndex += index.xz * ${strideString};
              if (j + 1 < ${sliceDim}) {
                flattenedIndex += index.yw * ${strideString2};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${updatesSnippet};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${defaultValueSnippet}, sum, found));
        }
      `;
  }
}
var init_scatter_packed_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/ScatterNd.js
function scatterNd2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(updates, indices, shape);
  const flattenShape = [outputSize / sliceSize, sliceSize];
  if (outputSize === 0) {
    return backend3.makeTensorInfo(shape, indices.dtype);
  }
  const flattenIndices = reshape79({ inputs: { x: indices }, backend: backend3, attrs: { shape: [numUpdates, sliceRank] } });
  const flattenX = reshape79({ inputs: { x: updates }, backend: backend3, attrs: { shape: [numUpdates, sliceSize] } });
  const defaultValue = backend3.makeTensorInfo([], "float32", new Float32Array([0]));
  let program;
  if (env().getBool("WEBGL_PACK")) {
    program = new ScatterPackedProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
  } else {
    program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape);
  }
  const res = backend3.runWebGLProgram(program, [flattenX, flattenIndices, defaultValue], flattenX.dtype);
  const reshaped = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape } });
  backend3.disposeIntermediateTensorInfo(flattenIndices);
  backend3.disposeIntermediateTensorInfo(flattenX);
  backend3.disposeIntermediateTensorInfo(res);
  backend3.disposeIntermediateTensorInfo(defaultValue);
  return reshaped;
}
var scatterNdConfig2;
var init_ScatterNd2 = __esm(() => {
  init_dist();
  init_scatter_gpu();
  init_scatter_packed_gpu();
  init_Reshape2();
  scatterNdConfig2 = {
    kernelName: ScatterNd,
    backendName: "webgl",
    kernelFunc: scatterNd2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/search_sorted_gpu.js
class SearchSortedProgram {
  constructor(batchSize, numInputs, numValues, side) {
    this.variableNames = ["sortedSequence", "values"];
    this.customUniforms = [{ name: "numInputs", type: "int" }];
    this.outputShape = [batchSize, numValues];
    const webGL2LoopHead = "while (left < right) {";
    const webGL1LoopHead = `for (int i = 0; i < ${Math.ceil(Math.log2(numInputs + 1))}; ++i) { if (left >= right) break;`;
    const loopHead = env().getNumber("WEBGL_VERSION") === 2 ? webGL2LoopHead : webGL1LoopHead;
    const boundComparator = side === "left" ? "<" : "<=";
    this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${loopHead}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${boundComparator} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
  }
}
var init_search_sorted_gpu = __esm(() => {
  init_dist();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SearchSorted.js
function searchSorted3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { sortedSequence, values } = inputs;
  const { side } = attrs;
  const program = new SearchSortedProgram(sortedSequence.shape[0], sortedSequence.shape[1], values.shape[1], side);
  const customValues = [[sortedSequence.shape[1]]];
  return backend3.runWebGLProgram(program, [sortedSequence, values], "int32", customValues);
}
var searchSortedConfig2;
var init_SearchSorted2 = __esm(() => {
  init_dist();
  init_search_sorted_gpu();
  searchSortedConfig2 = {
    kernelName: SearchSorted,
    backendName: "webgl",
    kernelFunc: searchSorted3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js
class SelectProgram {
  constructor(cRank, shape, rank) {
    this.variableNames = ["c", "a", "b"];
    this.outputShape = shape;
    let cCoords;
    let abCoords;
    if (rank > 4) {
      throw Error(`Where for rank ${rank} is not yet supported`);
    }
    if (rank === 1) {
      abCoords = `resRC`;
      cCoords = `resRC`;
    } else {
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      const cCoordVars = [];
      const abCoordVars = [];
      for (let i = 0;i < shape.length; i++) {
        abCoordVars.push(`${currentCoords[i]}`);
        if (i < cRank) {
          cCoordVars.push(`${currentCoords[i]}`);
        }
      }
      cCoords = cCoordVars.join();
      abCoords = abCoordVars.join();
    }
    const dtype = getCoordsDataType(rank);
    this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        float cVal = getC(${cCoords});
        if (cVal >= 1.0) {
          setOutput(getA(${abCoords}));
        } else {
          setOutput(getB(${abCoords}));
        }
      }
    `;
  }
}
var init_select_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Select.js
function select3(args) {
  const { inputs, backend: backend3 } = args;
  const { condition, t, e } = inputs;
  const program = new SelectProgram(condition.shape.length, t.shape, t.shape.length);
  return backend3.runWebGLProgram(program, [condition, t, e], upcastType(t.dtype, e.dtype));
}
var selectConfig2;
var init_Select2 = __esm(() => {
  init_dist();
  init_select_gpu();
  selectConfig2 = {
    kernelName: Select,
    backendName: "webgl",
    kernelFunc: select3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Selu.js
var SELU, selu5, seluConfig2;
var init_Selu2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  SELU = `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${exports_backend_util.SELU_SCALEALPHA};
  float scale = ${exports_backend_util.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`;
  selu5 = unaryKernelFunc2({ opSnippet: SELU });
  seluConfig2 = {
    kernelName: Selu,
    backendName: "webgl",
    kernelFunc: selu5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sigmoid.js
var SIGMOID3, SIGMOID_PACKED = `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, sigmoid8, sigmoidConfig2;
var init_Sigmoid2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  SIGMOID3 = CHECK_NAN_SNIPPET_UNARY + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`;
  sigmoid8 = unaryKernelFunc2({
    opSnippet: SIGMOID3,
    packedOpSnippet: SIGMOID_PACKED,
    cpuKernelImpl: sigmoidImplCPU
  });
  sigmoidConfig2 = {
    kernelName: Sigmoid,
    backendName: "webgl",
    kernelFunc: sigmoid8
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sign.js
var SIGN = `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`, sign4, signConfig2;
var init_Sign2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  sign4 = unaryKernelFunc2({ opSnippet: SIGN });
  signConfig2 = {
    kernelName: Sign,
    backendName: "webgl",
    kernelFunc: sign4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sin.js
var SIN, SIN_PACKED, sin5, sinConfig2;
var init_Sin2 = __esm(() => {
  init_dist();
  init_binaryop_packed_gpu();
  init_kernel_funcs_utils();
  SIN = CHECK_NAN_SNIPPET_UNARY + `
  return sin(x);
`;
  SIN_PACKED = `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${CHECK_NAN_SNIPPET_PACKED}
  return result;
`;
  sin5 = unaryKernelFunc2({ opSnippet: SIN, packedOpSnippet: SIN_PACKED });
  sinConfig2 = {
    kernelName: Sin,
    backendName: "webgl",
    kernelFunc: sin5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sinh.js
var SINH = `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`, sinh5, sinhConfig2;
var init_Sinh2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  sinh5 = unaryKernelFunc2({ opSnippet: SINH });
  sinhConfig2 = {
    kernelName: Sinh,
    backendName: "webgl",
    kernelFunc: sinh5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Softplus.js
var SOFTPLUS = `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`, softplus5, softplusConfig2;
var init_Softplus2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  softplus5 = unaryKernelFunc2({ opSnippet: SOFTPLUS });
  softplusConfig2 = {
    kernelName: Softplus,
    backendName: "webgl",
    kernelFunc: softplus5
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SpaceToBatchND.js
var spaceToBatchND3 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockShape, paddings } = attrs;
  exports_util.assert(x.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not " + "implemented yet");
  const prod6 = blockShape.reduce((a, b) => a * b);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i = 1 + blockShape.length;i < x.shape.length; ++i) {
    completePaddings.push([0, 0]);
  }
  const toDispose = [];
  const paddedX = padV22({
    inputs: { x },
    backend: backend3,
    attrs: { paddings: completePaddings, constantValue: 0 }
  });
  const reshapedPaddedShape = exports_backend_util.getReshaped(paddedX.shape, blockShape, prod6, false);
  const permutedReshapedPaddedPermutation = exports_backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = exports_backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod6, false);
  const reshapedPaddedX = reshape79({ inputs: { x: paddedX }, backend: backend3, attrs: { shape: reshapedPaddedShape } });
  const paddedXT = transpose12({
    inputs: { x: reshapedPaddedX },
    backend: backend3,
    attrs: { perm: permutedReshapedPaddedPermutation }
  });
  const result = reshape79({ inputs: { x: paddedXT }, backend: backend3, attrs: { shape: flattenShape } });
  toDispose.push(paddedX);
  toDispose.push(reshapedPaddedX);
  toDispose.push(paddedXT);
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}, spaceToBatchNDConfig2;
var init_SpaceToBatchND2 = __esm(() => {
  init_dist();
  init_PadV22();
  init_Reshape2();
  init_Transpose2();
  spaceToBatchNDConfig2 = {
    kernelName: SpaceToBatchND,
    backendName: "webgl",
    kernelFunc: spaceToBatchND3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseFillEmptyRows.js
function sparseFillEmptyRows3(args) {
  const { inputs, backend: backend3 } = args;
  const { indices, values, denseShape, defaultValue } = inputs;
  if (denseShape.shape.length !== 1) {
    throw new Error(`Dense shape must be a vector, saw:
         ${denseShape.shape}`);
  }
  if (indices.shape.length !== 2) {
    throw new Error(`Indices must be a matrix, saw:
         ${indices.shape}`);
  }
  if (values.shape.length !== 1) {
    throw new Error(`Values must be a vector, saw:
         ${values.shape}`);
  }
  if (defaultValue.shape.length !== 0) {
    throw new Error(`Default value must be a scalar, saw:
        ${defaultValue.shape}`);
  }
  const $indices = backend3.readSync(indices.dataId);
  const $values = backend3.readSync(values.dataId);
  const $denseShape = backend3.readSync(denseShape.dataId);
  const $defaultValue = backend3.readSync(defaultValue.dataId)[0];
  const [outputIndices, outputIndicesShape, outputValues, emptyRowIndicator, reverseIndexMap] = sparseFillEmptyRowsImplCPU($indices, indices.shape, indices.dtype, $values, values.dtype, $denseShape, $defaultValue);
  return [
    backend3.makeTensorInfo(outputIndicesShape, indices.dtype, outputIndices),
    backend3.makeTensorInfo([outputIndicesShape[0]], values.dtype, outputValues),
    backend3.makeTensorInfo([emptyRowIndicator.length], "bool", new Uint8Array(emptyRowIndicator.map((value) => Number(value)))),
    backend3.makeTensorInfo([reverseIndexMap.length], indices.dtype, new Int32Array(reverseIndexMap))
  ];
}
var sparseFillEmptyRowsConfig2;
var init_SparseFillEmptyRows2 = __esm(() => {
  init_dist();
  init_shared2();
  sparseFillEmptyRowsConfig2 = {
    kernelName: SparseFillEmptyRows,
    backendName: "webgl",
    kernelFunc: sparseFillEmptyRows3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseReshape.js
function sparseReshape3(args) {
  const { inputs, backend: backend3 } = args;
  const { inputIndices, inputShape, newShape } = inputs;
  if (inputIndices.shape.length !== 2) {
    throw new Error(`Input indices should be a matrix but received shape ${inputIndices.shape}`);
  }
  if (inputShape.shape.length !== 1) {
    throw new Error(`Input shape should be a vector but received shape ${inputShape.shape}`);
  }
  if (newShape.shape.length !== 1) {
    throw new Error(`Target shape should be a vector but received shape ${newShape.shape}`);
  }
  const $inputShape = Array.from(backend3.readSync(inputShape.dataId));
  const $inputIndices = backend3.readSync(inputIndices.dataId);
  const targetShape = Array.from(backend3.readSync(newShape.dataId));
  const [newIndices, indicesShape, outputShape] = sparseReshapeImplCPU($inputIndices, inputIndices.shape, inputIndices.dtype, $inputShape, targetShape);
  return [
    backend3.makeTensorInfo(indicesShape, inputIndices.dtype, newIndices),
    backend3.makeTensorInfo([outputShape.length], newShape.dtype, new Int32Array(outputShape))
  ];
}
var sparseReshapeConfig2;
var init_SparseReshape2 = __esm(() => {
  init_dist();
  init_shared2();
  sparseReshapeConfig2 = {
    kernelName: SparseReshape,
    backendName: "webgl",
    kernelFunc: sparseReshape3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentMean.js
function sparseSegmentMean3(args) {
  const { inputs, backend: backend3 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
              ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
              ${segmentIds.shape}`);
  }
  const $data = backend3.readSync(data.dataId);
  const $indices = backend3.readSync(indices.dataId);
  const $segmentIds = backend3.readSync(segmentIds.dataId);
  const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds, true);
  return backend3.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentMeanConfig2;
var init_SparseSegmentMean2 = __esm(() => {
  init_dist();
  init_shared2();
  sparseSegmentMeanConfig2 = {
    kernelName: SparseSegmentMean,
    backendName: "webgl",
    kernelFunc: sparseSegmentMean3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseSegmentSum.js
function sparseSegmentSum3(args) {
  const { inputs, backend: backend3 } = args;
  const { data, indices, segmentIds } = inputs;
  if (data.shape.length < 1) {
    throw new Error(`Data should be at least 1 dimensional but received scalar`);
  }
  if (indices.shape.length !== 1) {
    throw new Error(`Indices should be a vector but received shape
             ${indices.shape}`);
  }
  if (segmentIds.shape.length !== 1) {
    throw new Error(`Segment ids should be a vector but received shape
             ${segmentIds.shape}`);
  }
  const $data = backend3.readSync(data.dataId);
  const $indices = backend3.readSync(indices.dataId);
  const $segmentIds = backend3.readSync(segmentIds.dataId);
  const [outputData, outputDataShape] = sparseSegmentReductionImplCPU($data, data.shape, data.dtype, $indices, $segmentIds);
  return backend3.makeTensorInfo(outputDataShape, data.dtype, outputData);
}
var sparseSegmentSumConfig2;
var init_SparseSegmentSum2 = __esm(() => {
  init_dist();
  init_shared2();
  sparseSegmentSumConfig2 = {
    kernelName: SparseSegmentSum,
    backendName: "webgl",
    kernelFunc: sparseSegmentSum3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SparseToDense.js
function sparseToDense3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { sparseIndices, sparseValues, defaultValue } = inputs;
  const { outputShape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);
  const sumDupeIndices = false;
  if (sparseValues.dtype === "string") {
    const indicesBuf = backend3.bufferSync(sparseIndices);
    const updatesBuf = backend3.bufferSync(sparseValues);
    const $defaultValue = exports_util.decodeString(backend3.readSync(defaultValue.dataId)[0]);
    const outBuf = scatterImplCPU(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue, sumDupeIndices);
    return backend3.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
  }
  const program = new ScatterProgram(numUpdates, sliceRank, sparseIndices.shape.length, sparseValues.shape.length, strides, [outputSize, 1], sumDupeIndices);
  const res = backend3.runWebGLProgram(program, [sparseValues, sparseIndices, defaultValue], sparseValues.dtype);
  const reshaped = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape: outputShape } });
  backend3.disposeIntermediateTensorInfo(res);
  return reshaped;
}
var sparseToDenseConfig2;
var init_SparseToDense2 = __esm(() => {
  init_dist();
  init_shared2();
  init_scatter_gpu();
  init_Reshape2();
  sparseToDenseConfig2 = {
    kernelName: SparseToDense,
    backendName: "webgl",
    kernelFunc: sparseToDense3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SplitV.js
function splitV2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = exports_util.parseAxisParam(axis, x.shape)[0];
  const splitSizes = exports_backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);
  const xRank = x.shape.length;
  const begin = new Array(xRank).fill(0);
  const size = x.shape.slice();
  return splitSizes.map((s) => {
    const sliceSize = [...size];
    sliceSize[$axis] = s;
    const sliceT = slice17({ inputs: { x }, backend: backend3, attrs: { begin, size: sliceSize } });
    begin[$axis] += s;
    return sliceT;
  });
}
var splitVConfig2;
var init_SplitV2 = __esm(() => {
  init_dist();
  init_Slice2();
  splitVConfig2 = {
    kernelName: SplitV,
    backendName: "webgl",
    kernelFunc: splitV2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Sqrt.js
var SQRT = `return sqrt(x);`, sqrt13, sqrtConfig2;
var init_Sqrt2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  init_shared2();
  sqrt13 = unaryKernelFunc2({ opSnippet: SQRT, packedOpSnippet: SQRT, cpuKernelImpl: sqrtImplCPU });
  sqrtConfig2 = {
    kernelName: Sqrt,
    backendName: "webgl",
    kernelFunc: sqrt13
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Square.js
var SQUARE = `return x * x;`, square24, squareConfig2;
var init_Square2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  square24 = unaryKernelFunc2({ opSnippet: SQUARE });
  squareConfig2 = {
    kernelName: Square,
    backendName: "webgl",
    kernelFunc: square24
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/SquaredDifference.js
var SQUARED_DIFFERENCE = "return (a - b) * (a - b);", squaredDifference3, squaredDifferenceConfig2;
var init_SquaredDifference2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  squaredDifference3 = binaryKernelFunc2({ opSnippet: SQUARED_DIFFERENCE, packedOpSnippet: SQUARED_DIFFERENCE });
  squaredDifferenceConfig2 = {
    kernelName: SquaredDifference,
    backendName: "webgl",
    kernelFunc: squaredDifference3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StaticRegexReplace.js
function staticRegexReplace3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  if (x.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  const $x = backend3.readSync(x.dataId);
  const stringInput = exports_backend_util.fromUint8ToStringArray($x);
  const output = staticRegexReplaceImplCPU(stringInput, "string", attrs);
  return backend3.makeTensorInfo(x.shape, "string", output);
}
var staticRegexReplaceConfig2;
var init_StaticRegexReplace2 = __esm(() => {
  init_dist();
  init_shared2();
  staticRegexReplaceConfig2 = {
    kernelName: StaticRegexReplace,
    backendName: "webgl",
    kernelFunc: staticRegexReplace3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Step.js
function step8({ inputs, attrs, backend: backend3 }) {
  const { x } = inputs;
  const opSnippet = CHECK_NAN_SNIPPET + `
    return x > 0.0 ? 1.0 : float(${attrs.alpha});
  `;
  const program = new UnaryOpProgram(x.shape, opSnippet);
  return backend3.runWebGLProgram(program, [x], x.dtype);
}
var stepConfig2;
var init_Step2 = __esm(() => {
  init_dist();
  init_unaryop_gpu();
  stepConfig2 = {
    kernelName: Step,
    backendName: "webgl",
    kernelFunc: step8
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js
class StridedSliceProgram {
  constructor(begin, strides, size) {
    this.variableNames = ["x"];
    this.outputShape = size;
    const rank = size.length;
    const inputDtype = getCoordsDataType(size.length);
    const dtype = getCoordsDataType(size.length);
    let newCoords = "";
    if (rank === 1) {
      newCoords = "coords * strides + begin";
    } else {
      let outputAxis = 0;
      newCoords = size.map((_, i) => {
        outputAxis++;
        return size.length === 1 ? `coords * strides[${i}] + begin[${i}]` : `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;
      }).join(",");
    }
    this.userCode = `
      ${inputDtype} begin = ${inputDtype}(${begin});
      ${inputDtype} strides = ${inputDtype}(${strides});

      void main() {
        ${dtype} coords = getOutputCoords();
        setOutput(getX(${newCoords}));
      }
    `;
  }
}
var init_strided_slice_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StridedSlice.js
function stridedSlice3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = exports_slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  let result;
  if (isIdentity) {
    result = reshape79({ inputs: { x }, backend: backend3, attrs: { shape: finalShape } });
  } else if (sliceDim0 || isSimpleSlice) {
    exports_util.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);
    const size = exports_slice_util.computeOutShape($begin, $end, $strides);
    const sliced = slice17({ inputs: { x }, backend: backend3, attrs: { begin: $begin, size } });
    result = reshape79({ inputs: { x: sliced }, backend: backend3, attrs: { shape: finalShape } });
    backend3.disposeIntermediateTensorInfo(sliced);
  } else {
    const shouldExecuteOnCPU = backend3.shouldExecuteOnCPU([x]);
    if (shouldExecuteOnCPU) {
      const values = backend3.readSync(x.dataId);
      const xBuf = buffer(x.shape, x.dtype, values);
      const resultValues = stridedSliceImplCPU(finalShapeSparse, xBuf, $strides, $begin);
      result = backend3.makeTensorInfo(finalShape, x.dtype, resultValues.values);
    } else {
      const program = new StridedSliceProgram($begin, $strides, finalShapeSparse);
      result = backend3.runWebGLProgram(program, [x], x.dtype);
    }
  }
  const resultReshaped = reshape79({ inputs: { x: result }, backend: backend3, attrs: { shape: finalShape } });
  backend3.disposeIntermediateTensorInfo(result);
  return resultReshaped;
}
var stridedSliceConfig2;
var init_StridedSlice2 = __esm(() => {
  init_dist();
  init_shared2();
  init_strided_slice_gpu();
  init_Reshape2();
  init_Slice2();
  stridedSliceConfig2 = {
    kernelName: StridedSlice,
    backendName: "webgl",
    kernelFunc: stridedSlice3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringNGrams.js
function stringNGrams3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
  const { data, dataSplits } = inputs;
  const $data = backend3.readSync(data.dataId);
  const $dataSplits = backend3.readSync(dataSplits.dataId);
  const [nGrams, nGramsSplits] = stringNGramsImplCPU($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
  return [
    backend3.makeTensorInfo([nGrams.length], "string", nGrams),
    backend3.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
  ];
}
var stringNGramsConfig2;
var init_StringNGrams2 = __esm(() => {
  init_dist();
  init_shared2();
  stringNGramsConfig2 = {
    kernelName: StringNGrams,
    backendName: "webgl",
    kernelFunc: stringNGrams3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringSplit.js
function stringSplit3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { skipEmpty } = attrs;
  const { input: input2, delimiter } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (input2.shape.length !== 1) {
    throw new Error(`Input must be a vector, got shape: ${input2.shape}`);
  }
  if (delimiter.shape.length !== 0) {
    throw new Error(`Delimiter must be a scalar, got shape: ${delimiter.shape}`);
  }
  const $input = backend3.readSync(input2.dataId);
  const $delimiter = backend3.readSync(delimiter.dataId)[0];
  const [indices, values, shape] = stringSplitImplCPU($input, $delimiter, skipEmpty);
  const outputSize = values.length;
  return [
    backend3.makeTensorInfo([outputSize, 2], "int32", indices),
    backend3.makeTensorInfo([outputSize], "string", values),
    backend3.makeTensorInfo([2], "int32", new Int32Array(shape))
  ];
}
var stringSplitConfig2;
var init_StringSplit2 = __esm(() => {
  init_dist();
  init_shared2();
  stringSplitConfig2 = {
    kernelName: StringSplit,
    backendName: "webgl",
    kernelFunc: stringSplit3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/StringToHashBucketFast.js
function stringToHashBucketFast3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { numBuckets } = attrs;
  const { input: input2 } = inputs;
  if (input2.dtype !== "string") {
    throw new Error("Input must be of datatype string");
  }
  if (numBuckets <= 0) {
    throw new Error(`Number of buckets must be at least 1`);
  }
  const $input = backend3.readSync(input2.dataId);
  const output = stringToHashBucketFastImplCPU($input, numBuckets);
  return backend3.makeTensorInfo(input2.shape, "int32", output);
}
var stringToHashBucketFastConfig2;
var init_StringToHashBucketFast2 = __esm(() => {
  init_dist();
  init_shared2();
  stringToHashBucketFastConfig2 = {
    kernelName: StringToHashBucketFast,
    backendName: "webgl",
    kernelFunc: stringToHashBucketFast3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tan.js
var TAN = `return tan(x);`, tan4, tanConfig2;
var init_Tan2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  tan4 = unaryKernelFunc2({ opSnippet: TAN });
  tanConfig2 = {
    kernelName: Tan,
    backendName: "webgl",
    kernelFunc: tan4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tanh.js
var TANH = `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`, tanh6, tanhConfig2;
var init_Tanh2 = __esm(() => {
  init_dist();
  init_kernel_funcs_utils();
  tanh6 = unaryKernelFunc2({ opSnippet: TANH });
  tanhConfig2 = {
    kernelName: Tanh,
    backendName: "webgl",
    kernelFunc: tanh6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TensorScatterUpdate.js
function tensorScatterUpdate3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { tensor: tensor153, indices, updates } = inputs;
  const {} = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(updates, indices, tensor153.shape);
  const flattenShape = [outputSize / sliceSize, sliceSize];
  if (outputSize === 0) {
    return backend3.makeTensorInfo(tensor153.shape, indices.dtype);
  }
  const flattenIndices = reshape79({ inputs: { x: indices }, backend: backend3, attrs: { shape: [numUpdates, sliceRank] } });
  const flattenX = reshape79({ inputs: { x: updates }, backend: backend3, attrs: { shape: [numUpdates, sliceSize] } });
  const flattenTensor = reshape79({ inputs: { x: tensor153 }, backend: backend3, attrs: { shape: flattenShape } });
  const program = new ScatterProgram(numUpdates, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape, false, true);
  const res = backend3.runWebGLProgram(program, [flattenX, flattenIndices, flattenTensor], flattenTensor.dtype);
  const reshaped = reshape79({ inputs: { x: res }, backend: backend3, attrs: { shape: tensor153.shape } });
  backend3.disposeIntermediateTensorInfo(flattenIndices);
  backend3.disposeIntermediateTensorInfo(flattenX);
  backend3.disposeIntermediateTensorInfo(flattenTensor);
  backend3.disposeIntermediateTensorInfo(res);
  return reshaped;
}
var tensorScatterUpdateConfig2;
var init_TensorScatterUpdate2 = __esm(() => {
  init_dist();
  init_scatter_gpu();
  init_Reshape2();
  tensorScatterUpdateConfig2 = {
    kernelName: TensorScatterUpdate,
    backendName: "webgl",
    kernelFunc: tensorScatterUpdate3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js
function getSourceCoords3(aShape) {
  const rank = aShape.length;
  if (rank > 5) {
    throw Error(`Tile for rank ${rank} is not yet supported`);
  }
  if (rank === 1) {
    return `imod(resRC, ${aShape[0]})`;
  }
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"];
  const sourceCoords = [];
  for (let i = 0;i < aShape.length; i++) {
    sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);
  }
  return sourceCoords.join();
}

class TileProgram {
  constructor(aShape, reps) {
    this.variableNames = ["A"];
    const outputShape = new Array(aShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = aShape[i] * reps[i];
    }
    this.outputShape = outputShape;
    this.rank = outputShape.length;
    const dtype = getCoordsDataType(this.rank);
    const sourceCoords = getSourceCoords3(aShape);
    this.userCode = `
      void main() {
        ${dtype} resRC = getOutputCoords();
        setOutput(getA(${sourceCoords}));
      }
    `;
  }
}
var init_tile_gpu = __esm(() => {
  init_shader_compiler();
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Tile.js
function tile9(params) {
  const { inputs, backend: backend3, attrs } = params;
  const { x } = inputs;
  const { reps } = attrs;
  if (x.dtype === "string" || x.shape.length > 5) {
    const data = backend3.readSync(x.dataId);
    const value = x.dtype === "string" ? data.map((d) => exports_util.decodeString(d)) : data;
    const buf = buffer(x.shape, x.dtype, value);
    const outBuf = tileImplCPU(buf, reps);
    return backend3.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  const program = new TileProgram(x.shape, reps);
  const output = backend3.runWebGLProgram(program, [x], x.dtype);
  return output;
}
var tileConfig2;
var init_Tile2 = __esm(() => {
  init_dist();
  init_shared2();
  init_tile_gpu();
  tileConfig2 = {
    kernelName: Tile,
    backendName: "webgl",
    kernelFunc: tile9
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/top_k_gpu.js
class SwapProgram {
  constructor(shape) {
    this.variableNames = ["x", "indices"];
    this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "negativeInf", type: "float" },
      { name: "dir", type: "int" },
      { name: "inc", type: "int" }
    ];
    this.outputShape = shape;
    this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
  }
}

class MergeProgram {
  constructor(shape) {
    this.variableNames = ["x", "indices"];
    this.customUniforms = [
      { name: "n", type: "int" },
      { name: "firstPass", type: "int" },
      { name: "k", type: "int" }
    ];
    this.outputShape = shape;
    this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/TopK.js
function disposeIntermediateTensorInfoOrNull(backend3, tensorInfo) {
  if (tensorInfo !== null) {
    backend3.disposeIntermediateTensorInfo(tensorInfo);
  }
}
function roundUpToPow2(num) {
  let pow22 = 1;
  while (pow22 < num) {
    pow22 *= 2;
  }
  return pow22;
}
function topK2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { k, sorted } = attrs;
  const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD");
  const TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD");
  const xShape = x.shape;
  const lastDim = xShape[xShape.length - 1];
  if (backend3.shouldExecuteOnCPU([x]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k > TOPK_K_CPU_HANDOFF_THRESHOLD) {
    const xVals = backend3.readSync(x.dataId);
    const [allTopKVals, allTopKIndices] = topKImplCPU(xVals, xShape, x.dtype, k, sorted);
    return [
      backend3.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
      backend3.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
    ];
  }
  if (k === 0) {
    xShape[xShape.length - 1] = 0;
    return [
      backend3.makeTensorInfo(xShape, x.dtype, []),
      backend3.makeTensorInfo(xShape, "int32", [])
    ];
  }
  if (lastDim === 1) {
    return [
      x,
      fill7({ attrs: { shape: xShape, dtype: "int32", value: 0 }, backend: backend3 })
    ];
  }
  const xtexData = backend3.texData.get(x.dataId);
  const xIsPacked = xtexData !== null && xtexData.isPacked;
  const xUnPacked = xIsPacked ? backend3.unpackTensor(x) : x;
  const xSize = exports_util.sizeFromShape(xShape);
  const batch = xSize / lastDim;
  const x2D = reshape79({ inputs: { x: xUnPacked }, attrs: { shape: [batch, lastDim] }, backend: backend3 });
  if (xIsPacked) {
    disposeIntermediateTensorInfoOrNull(backend3, xUnPacked);
  }
  const kPow2 = roundUpToPow2(k);
  const lastDimPow2 = roundUpToPow2(lastDim);
  let indices = null;
  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
  const runSwap = (dir, inc, shape) => {
    const inputs2 = getInputs();
    const program = new SwapProgram(shape);
    const fistPass = indices === null ? 1 : 0;
    const customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];
    const prevIndices2 = indices;
    indices = backend3.runWebGLProgram(program, inputs2, "int32", customValues);
    disposeIntermediateTensorInfoOrNull(backend3, prevIndices2);
  };
  for (let len = 1;len < kPow2; len *= 2) {
    const dir = len * 2;
    for (let inc = len;inc >= 1; inc /= 2) {
      runSwap(dir, inc, [batch, lastDimPow2]);
    }
  }
  for (let indicesSize = lastDimPow2;indicesSize > kPow2; indicesSize /= 2) {
    const inputs2 = getInputs();
    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);
    const firstPass = indices === null ? 1 : 0;
    const customValues = [[lastDim], [firstPass], [kPow2]];
    const prevIndices2 = indices;
    indices = backend3.runWebGLProgram(mergeProgram, inputs2, "int32", customValues);
    disposeIntermediateTensorInfoOrNull(backend3, prevIndices2);
    const len = kPow2 / 2;
    const dir = len * 2;
    for (let inc = len;inc >= 1; inc /= 2) {
      runSwap(dir, inc, indices.shape);
    }
  }
  let prevIndices = indices;
  indices = slice17({ inputs: { x: indices }, backend: backend3, attrs: { begin: 0, size: [batch, k] } });
  disposeIntermediateTensorInfoOrNull(backend3, prevIndices);
  let values = gatherV22({ inputs: { x: x2D, indices }, backend: backend3, attrs: { axis: 1, batchDims: 1 } });
  disposeIntermediateTensorInfoOrNull(backend3, x2D);
  const newShape = xShape.slice(0, -1);
  newShape.push(k);
  prevIndices = indices;
  indices = reshape79({ inputs: { x: indices }, attrs: { shape: newShape }, backend: backend3 });
  disposeIntermediateTensorInfoOrNull(backend3, prevIndices);
  const prevValues = values;
  values = reshape79({ inputs: { x: values }, attrs: { shape: newShape }, backend: backend3 });
  disposeIntermediateTensorInfoOrNull(backend3, prevValues);
  return [values, indices];
}
var topKConfig2;
var init_TopK2 = __esm(() => {
  init_dist();
  init_shared2();
  init_Fill2();
  init_GatherV22();
  init_Reshape2();
  init_Slice2();
  topKConfig2 = {
    kernelName: TopK,
    backendName: "webgl",
    kernelFunc: topK2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/transform_gpu.js
class TransformProgram {
  constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {
    this.variableNames = ["Image", "Transforms"];
    this.outputShape = outShape;
    const interpolationModeId = interpolation === "nearest" ? 1 : 2;
    let fillModeId;
    switch (fillMode) {
      case "constant":
        fillModeId = 1;
        break;
      case "reflect":
        fillModeId = 2;
        break;
      case "wrap":
        fillModeId = 3;
        break;
      case "nearest":
        fillModeId = 4;
        break;
      default:
        fillModeId = 1;
        break;
    }
    this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${fillModeId} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${fillModeId} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${fillValue});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${fillValue});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${imageWidth}));
                float mapY = mapCoord(inY, float(${imageHeight}));

                if (${interpolationModeId} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Transform.js
function transform4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [
    batch,
    outHeight,
    outWidth,
    numChannels
  ];
  const program = new TransformProgram(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape);
  return backend3.runWebGLProgram(program, [image2, transforms], "float32");
}
var transformConfig2;
var init_Transform2 = __esm(() => {
  init_dist();
  transformConfig2 = {
    kernelName: Transform,
    backendName: "webgl",
    kernelFunc: transform4
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unique.js
function unique6(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { axis } = attrs;
  const { x } = inputs;
  assertNotComplex2(x, "unique");
  console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
  const values = backend3.readSync(x.dataId);
  const { outputValues, outputShape, indices } = uniqueImplCPU(values, axis, x.shape, x.dtype);
  return [
    backend3.makeTensorInfo(outputShape, x.dtype, outputValues),
    backend3.makeTensorInfo([indices.length], "int32", indices)
  ];
}
var uniqueConfig2;
var init_Unique2 = __esm(() => {
  init_dist();
  init_shared2();
  init_webgl_util();
  uniqueConfig2 = {
    kernelName: Unique,
    backendName: "webgl",
    kernelFunc: unique6
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/Unpack.js
function unpack2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const x = value;
  const xRank = x.shape.length;
  const num = value.shape[axis];
  const outShape = new Array(xRank - 1);
  let outIndex = 0;
  for (let i = 0;i < xRank; i++) {
    if (i !== axis) {
      outShape[outIndex++] = x.shape[i];
    }
  }
  const toDispose = [];
  const begin = new Array(xRank).fill(0);
  const size = x.shape.slice();
  size[axis] = 1;
  const res = new Array(num);
  for (let i = 0;i < res.length; i++) {
    begin[axis] = i;
    const sliced = slice17({ inputs: { x }, backend: backend3, attrs: { begin, size } });
    const reshaped = reshape79({ inputs: { x: sliced }, backend: backend3, attrs: { shape: outShape } });
    res[i] = reshaped;
    toDispose.push(sliced);
  }
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return res;
}
var unpackConfig2;
var init_Unpack2 = __esm(() => {
  init_dist();
  init_Reshape2();
  init_Slice2();
  unpackConfig2 = {
    kernelName: Unpack,
    backendName: "webgl",
    kernelFunc: unpack2
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js
class SegmentOpProgram {
  constructor(segOpInfo, segOpType) {
    this.variableNames = ["x", "segmentIds"];
    const windowSize = segOpInfo.windowSize;
    const batchSize = segOpInfo.batchSize;
    const inSize = segOpInfo.inSize;
    const numSegments = segOpInfo.numSegments;
    const outSize = numSegments * Math.ceil(inSize / windowSize);
    this.outputShape = [batchSize, outSize];
    const initializationValue = "0.0";
    const returnValue = `sumValue`;
    const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
    const windowSizeVec4Remainder = windowSize % 4;
    const updateSnippet = `
        sumValue += dot(values, segFilter);
    `;
    let checkValueOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkValueOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return initializationValue;
        }
      `;
    }
    let checkSegmentIdOutOfBounds = "";
    if (inSize % windowSize > 0) {
      checkSegmentIdOutOfBounds = `
        if (inIdx < 0 || inIdx >= ${inSize}) {
          return -1.0;
        }
      `;
    }
    this.userCode = `
      const float initializationValue = ${initializationValue};

      float getValue(int batch, int inIdx) {
        ${checkValueOutOfBounds}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${checkSegmentIdOutOfBounds}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${numSegments})) * float(${windowSize}));
        int currentSeg = int(mod(float(outIdx), float(${numSegments})));

        float sumValue = 0.0;

        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${updateSnippet}
        }

        int inIdx = inOffset + ${windowSizeNearestVec4};
        if (${windowSizeVec4Remainder === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${updateSnippet}
        } else if (${windowSizeVec4Remainder === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${updateSnippet}
        }
        setOutput(${returnValue});
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgl/dist/kernels/UnsortedSegmentSum.js
function unsortedSegmentSum3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, segmentIds } = inputs;
  const { numSegments } = attrs;
  const xRank = x.shape.length;
  const toDispose = [];
  let axis = 0;
  const permutation = exports_backend_util.getAxesPermutation([axis], xRank);
  let permutedX = x;
  if (permutation != null) {
    permutedX = transpose12({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
    toDispose.push(permutedX);
    axis = exports_backend_util.getInnerMostAxes(1, xRank)[0];
  }
  const outShape = exports_backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
  const inSize = exports_util.sizeFromShape([permutedX.shape[axis]]);
  const a2D = reshape79({ inputs: { x: permutedX }, backend: backend3, attrs: { shape: [-1, inSize] } });
  toDispose.push(a2D);
  const outputDType = sumOutType(x.dtype);
  const segOpCompute = (x2, segOpType, segmentIds2, dtype, numSegments2) => {
    const batchSize = x2.shape[0];
    const inSize2 = x2.shape[1];
    const windowSize = exports_backend_util.segment_util.segOpComputeOptimalWindowSize(inSize2, numSegments2);
    const segOpInfo = { windowSize, inSize: inSize2, batchSize, numSegments: numSegments2 };
    const program = new SegmentOpProgram(segOpInfo, segOpType);
    const output = backend3.compileAndRun(program, [x2, segmentIds2], dtype);
    toDispose.push(output);
    if (output.shape[1] === numSegments2) {
      return output;
    }
    const rangeInfo = range6({
      backend: backend3,
      attrs: { start: 0, stop: numSegments2, step: 1, dtype: "float32" }
    });
    const tileInfo = tile9({
      inputs: { x: rangeInfo },
      backend: backend3,
      attrs: { reps: [inSize2 / windowSize] }
    });
    toDispose.push(rangeInfo);
    toDispose.push(tileInfo);
    const result2 = segOpCompute(output, segOpType, tileInfo, dtype, numSegments2);
    return result2;
  };
  const segOpResult = segOpCompute(a2D, "unsortedSegmentSum", segmentIds, outputDType, numSegments);
  const reshaped = reshape79({ inputs: { x: segOpResult }, backend: backend3, attrs: { shape: outShape } });
  let result = reshaped;
  if (permutation != null) {
    toDispose.push(reshaped);
    const perm = exports_backend_util.getUndoAxesPermutation(permutation);
    result = transpose12({ inputs: { x: result }, backend: backend3, attrs: { perm } });
  }
  toDispose.forEach((t) => backend3.disposeIntermediateTensorInfo(t));
  return result;
}
var unsortedSegmentSumConfig2;
var init_UnsortedSegmentSum2 = __esm(() => {
  init_dist();
  init_Range2();
  init_Reshape2();
  init_Tile2();
  init_Transpose2();
  unsortedSegmentSumConfig2 = {
    kernelName: UnsortedSegmentSum,
    backendName: "webgl",
    kernelFunc: unsortedSegmentSum3
  };
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js
var kernelConfigs2;
var init_register_all_kernels2 = __esm(() => {
  init_dist();
  init__FusedMatMul2();
  init_Abs2();
  init_Acos2();
  init_Acosh2();
  init_Add2();
  init_AddN2();
  init_All2();
  init_Any2();
  init_ArgMax2();
  init_ArgMin2();
  init_Asin2();
  init_Asinh2();
  init_Atan3();
  init_Atan22();
  init_Atanh2();
  init_AvgPool2();
  init_AvgPool3D2();
  init_AvgPool3DGrad2();
  init_AvgPoolGrad2();
  init_BatchMatMul2();
  init_BatchNorm2();
  init_BatchToSpaceND2();
  init_Bincount2();
  init_BitwiseAnd2();
  init_BroadcastArgs2();
  init_Cast2();
  init_Ceil2();
  init_ClipByValue2();
  init_Complex2();
  init_ComplexAbs2();
  init_Concat2();
  init_Conv2D2();
  init_Conv2DBackpropFilter2();
  init_Conv2DBackpropInput2();
  init_Conv3D2();
  init_Conv3DBackpropFilterV22();
  init_Conv3DBackpropInputV22();
  init_Cos2();
  init_Cosh2();
  init_CropAndResize2();
  init_Cumprod2();
  init_Cumsum2();
  init_DenseBincount2();
  init_DepthToSpace2();
  init_DepthwiseConv2dNative2();
  init_DepthwiseConv2dNativeBackpropFilter2();
  init_DepthwiseConv2dNativeBackpropInput2();
  init_Diag2();
  init_Dilation2D2();
  init_Einsum2();
  init_Elu2();
  init_EluGrad2();
  init_Equal2();
  init_Erf2();
  init_Exp2();
  init_ExpandDims2();
  init_Expm12();
  init_FFT2();
  init_Fill2();
  init_FlipLeftRight2();
  init_Floor2();
  init_FloorDiv2();
  init_FromPixels();
  init_FusedConv2D2();
  init_FusedDepthwiseConv2D2();
  init_GatherNd2();
  init_GatherV22();
  init_Greater2();
  init_GreaterEqual2();
  init_Identity2();
  init_IFFT2();
  init_Imag2();
  init_IsFinite2();
  init_IsInf2();
  init_IsNaN2();
  init_LeakyRelu2();
  init_Less2();
  init_LessEqual2();
  init_LinSpace2();
  init_Log2();
  init_Log1p2();
  init_LogicalAnd2();
  init_LogicalNot2();
  init_LogicalOr2();
  init_LRN2();
  init_LRNGrad2();
  init_Max2();
  init_Maximum2();
  init_MaxPool2();
  init_MaxPool3D2();
  init_MaxPool3DGrad2();
  init_MaxPoolGrad2();
  init_MaxPoolWithArgmax2();
  init_Mean2();
  init_Min2();
  init_Minimum2();
  init_MirrorPad2();
  init_Mod2();
  init_Multinomial2();
  init_Multiply2();
  init_Neg2();
  init_NonMaxSuppressionV32();
  init_NonMaxSuppressionV42();
  init_NonMaxSuppressionV52();
  init_NotEqual2();
  init_OneHot2();
  init_OnesLike2();
  init_Pack2();
  init_PadV22();
  init_Pow2();
  init_Prelu2();
  init_Prod2();
  init_RaggedGather2();
  init_RaggedRange2();
  init_RaggedTensorToTensor2();
  init_Range2();
  init_Real2();
  init_RealDiv2();
  init_Reciprocal2();
  init_Relu2();
  init_Relu62();
  init_Reshape2();
  init_ResizeBilinear2();
  init_ResizeBilinearGrad2();
  init_ResizeNearestNeighbor2();
  init_ResizeNearestNeighborGrad2();
  init_Reverse2();
  init_RotateWithOffset2();
  init_Round2();
  init_Rsqrt2();
  init_ScatterNd2();
  init_SearchSorted2();
  init_Select2();
  init_Selu2();
  init_Sigmoid2();
  init_Sign2();
  init_Sin2();
  init_Sinh2();
  init_Slice2();
  init_Softmax2();
  init_Softplus2();
  init_SpaceToBatchND2();
  init_SparseFillEmptyRows2();
  init_SparseReshape2();
  init_SparseSegmentMean2();
  init_SparseSegmentSum2();
  init_SparseToDense2();
  init_SplitV2();
  init_Sqrt2();
  init_Square2();
  init_SquaredDifference2();
  init_StaticRegexReplace2();
  init_Step2();
  init_StridedSlice2();
  init_StringNGrams2();
  init_StringSplit2();
  init_StringToHashBucketFast2();
  init_Sub2();
  init_Sum2();
  init_Tan2();
  init_Tanh2();
  init_TensorScatterUpdate2();
  init_Tile2();
  init_TopK2();
  init_Transform2();
  init_Transpose2();
  init_Unique2();
  init_Unpack2();
  init_UnsortedSegmentSum2();
  init_ZerosLike2();
  kernelConfigs2 = [
    _fusedMatMulConfig2,
    absConfig2,
    acosConfig2,
    acoshConfig2,
    addConfig2,
    addNConfig2,
    allConfig2,
    anyConfig2,
    argMaxConfig2,
    argMinConfig2,
    asinConfig2,
    asinhConfig2,
    atanConfig2,
    atan2Config2,
    atanhConfig2,
    avgPoolConfig2,
    avgPool3DConfig2,
    avgPool3DGradConfig3,
    avgPoolGradConfig3,
    batchMatMulConfig2,
    batchNormConfig2,
    batchToSpaceNDConfig2,
    bincountConfig2,
    bitwiseAndConfig2,
    broadcastArgsConfig2,
    castConfig2,
    ceilConfig2,
    clipByValueConfig2,
    complexConfig2,
    complexAbsConfig2,
    concatConfig2,
    conv2DConfig2,
    conv2DBackpropFilterConfig2,
    conv2DBackpropInputConfig2,
    conv3DConfig2,
    conv3DBackpropFilterV2Config2,
    conv3DBackpropInputConfig,
    cosConfig2,
    coshConfig2,
    cropAndResizeConfig2,
    cumprodConfig2,
    cumsumConfig2,
    denseBincountConfig2,
    depthToSpaceConfig2,
    depthwiseConv2dNativeConfig2,
    depthwiseConv2dNativeBackpropFilterConfig2,
    depthwiseConv2dNativeBackpropInputConfig2,
    diagConfig2,
    dilation2DConfig2,
    einsumConfig2,
    eluConfig2,
    eluGradConfig3,
    equalConfig2,
    erfConfig2,
    expConfig2,
    expandDimsConfig2,
    expm1Config2,
    fftConfig2,
    fillConfig2,
    flipLeftRightConfig2,
    floorConfig2,
    floorDivConfig2,
    fromPixelsConfig,
    fusedConv2DConfig2,
    fusedDepthwiseConv2DConfig2,
    gatherNdConfig2,
    gatherV2Config2,
    greaterConfig2,
    greaterEqualConfig2,
    identityConfig2,
    ifftConfig2,
    imagConfig2,
    isFiniteConfig2,
    isInfConfig2,
    isNaNConfig2,
    leakyReluConfig2,
    lessConfig2,
    lessEqualConfig2,
    linSpaceConfig2,
    logConfig2,
    log1pConfig2,
    logicalAndConfig2,
    logicalNotConfig2,
    logicalOrConfig2,
    LRNConfig2,
    LRNGradConfig2,
    maxConfig2,
    maximumConfig2,
    maxPoolConfig2,
    maxPool3DConfig2,
    maxPool3DGradConfig3,
    maxPoolGradConfig3,
    maxPoolWithArgmaxConfig2,
    meanConfig2,
    minConfig2,
    minimumConfig2,
    mirrorPadConfig2,
    modConfig2,
    multinomialConfig2,
    multiplyConfig2,
    negConfig2,
    nonMaxSuppressionV3Config2,
    nonMaxSuppressionV4Config2,
    nonMaxSuppressionV5Config2,
    notEqualConfig2,
    oneHotConfig2,
    onesLikeConfig2,
    packConfig2,
    padV2Config2,
    powConfig2,
    preluConfig2,
    prodConfig2,
    raggedGatherConfig2,
    raggedRangeConfig2,
    raggedTensorToTensorConfig2,
    rangeConfig2,
    realConfig2,
    realDivConfig2,
    reciprocalConfig2,
    reluConfig2,
    relu6Config2,
    reshapeConfig2,
    resizeBilinearConfig2,
    resizeBilinearGradConfig3,
    resizeNearestNeighborConfig2,
    resizeNearestNeighborGradConfig3,
    reverseConfig2,
    rotateWithOffsetConfig2,
    roundConfig2,
    rsqrtConfig2,
    scatterNdConfig2,
    searchSortedConfig2,
    selectConfig2,
    seluConfig2,
    sigmoidConfig2,
    signConfig2,
    sinConfig2,
    sinhConfig2,
    sliceConfig2,
    softmaxConfig2,
    softplusConfig2,
    spaceToBatchNDConfig2,
    sparseFillEmptyRowsConfig2,
    sparseReshapeConfig2,
    sparseSegmentMeanConfig2,
    sparseSegmentSumConfig2,
    sparseToDenseConfig2,
    splitVConfig2,
    sqrtConfig2,
    squareConfig2,
    squaredDifferenceConfig2,
    staticRegexReplaceConfig2,
    stepConfig2,
    stridedSliceConfig2,
    stringNGramsConfig2,
    stringSplitConfig2,
    stringToHashBucketFastConfig2,
    subConfig2,
    sumConfig2,
    tanConfig2,
    tanhConfig2,
    tensorScatterUpdateConfig2,
    tileConfig2,
    topKConfig2,
    transformConfig2,
    transposeConfig2,
    uniqueConfig2,
    unpackConfig2,
    unsortedSegmentSumConfig2,
    zerosLikeConfig2
  ];
  for (const kernelConfig of kernelConfigs2) {
    registerKernel(kernelConfig);
  }
});

// node_modules/@tensorflow/tfjs-backend-webgl/dist/index.js
var init_dist6 = __esm(() => {
  init_base3();
  init_register_all_kernels2();
});

// node_modules/@tensorflow/tfjs/dist/version.js
var version10 = "4.22.0";
var init_version7 = () => {
};

// node_modules/@tensorflow/tfjs/dist/index.js
var exports_dist3 = {};
__export(exports_dist3, {
  zerosLike: () => zerosLike,
  zeros: () => zeros,
  whereAsync: () => whereAsync,
  where: () => where,
  webgl_util: () => exports_webgl_util,
  webgl: () => webgl3,
  version_webgl: () => version9,
  version_layers: () => version3,
  version_cpu: () => version8,
  version_core: () => version,
  version_converter: () => version6,
  version: () => version12,
  variableGrads: () => variableGrads,
  variable: () => variable,
  valueAndGrads: () => valueAndGrads,
  valueAndGrad: () => valueAndGrad,
  util: () => exports_util,
  upperBound: () => upperBound,
  upcastType: () => upcastType,
  unstack: () => unstack,
  unsortedSegmentSum: () => unsortedSegmentSum,
  unregisterKernel: () => unregisterKernel,
  unregisterGradient: () => unregisterGradient,
  unique: () => unique,
  truncatedNormal: () => truncatedNormal,
  transpose: () => transpose,
  train: () => train,
  topk: () => topk,
  time: () => time,
  tile: () => tile,
  tidy: () => tidy,
  test_util: () => exports_test_util,
  tensor_util: () => exports_tensor_util,
  tensorScatterUpdate: () => tensorScatterUpdate,
  tensor6d: () => tensor6d,
  tensor5d: () => tensor5d,
  tensor4d: () => tensor4d,
  tensor3d: () => tensor3d,
  tensor2d: () => tensor2d,
  tensor1d: () => tensor1d,
  tensor: () => tensor4,
  tanh: () => tanh2,
  tan: () => tan,
  sumOutType: () => sumOutType,
  sum: () => sum2,
  sub: () => sub,
  string: () => string,
  stridedSlice: () => stridedSlice,
  step: () => step,
  stack: () => stack,
  squeeze: () => squeeze,
  squaredDifference: () => squaredDifference,
  square: () => square,
  sqrt: () => sqrt,
  split: () => split,
  spectral: () => spectral,
  sparseToDense: () => sparseToDense,
  sparse: () => sparse,
  spaceToBatchND: () => spaceToBatchND,
  softplus: () => softplus,
  softmax: () => softmax,
  slice_util: () => exports_slice_util,
  slice4d: () => slice4d,
  slice3d: () => slice3d,
  slice2d: () => slice2d,
  slice1d: () => slice1d,
  slice: () => slice,
  sinh: () => sinh,
  sin: () => sin,
  signal: () => signal,
  sign: () => sign,
  sigmoid: () => sigmoid,
  shared: () => exports_shared,
  setdiff1dAsync: () => setdiff1dAsync,
  setWebGLContext: () => setWebGLContext,
  setPlatform: () => setPlatform,
  setBackend: () => setBackend,
  serialization: () => exports_serialization,
  sequential: () => sequential,
  separableConv2d: () => separableConv2d,
  selu: () => selu,
  searchSorted: () => searchSorted,
  scatter_util: () => exports_scatter_nd_util,
  scatterND: () => scatterND,
  scalar: () => scalar,
  rsqrt: () => rsqrt,
  round: () => round2,
  rfft: () => rfft,
  reverse4d: () => reverse4d,
  reverse3d: () => reverse3d,
  reverse2d: () => reverse2d,
  reverse1d: () => reverse1d,
  reverse: () => reverse,
  reshape: () => reshape,
  removeBackend: () => removeBackend,
  relu6: () => relu6,
  relu: () => relu,
  regularizers: () => exports_exports_regularizers,
  registerOp: () => registerOp,
  registerKernel: () => registerKernel,
  registerGradient: () => registerGradient,
  registerCallbackConstructor: () => registerCallbackConstructor,
  registerBackend: () => registerBackend,
  reciprocal: () => reciprocal,
  real: () => real,
  ready: () => ready,
  range: () => range,
  randomUniformInt: () => randomUniformInt,
  randomUniform: () => randomUniform,
  randomStandardNormal: () => randomStandardNormal,
  randomNormal: () => randomNormal,
  randomGamma: () => randomGamma,
  rand: () => rand,
  raggedTensorToTensor: () => raggedTensorToTensor,
  raggedRange: () => raggedRange,
  raggedGather: () => raggedGather,
  profile: () => profile,
  prod: () => prod,
  print: () => print,
  prelu: () => prelu,
  pow: () => pow,
  pool: () => pool,
  pad4d: () => pad4d,
  pad3d: () => pad3d,
  pad2d: () => pad2d,
  pad1d: () => pad1d,
  pad: () => pad,
  outerProduct: () => outerProduct,
  op: () => op,
  onesLike: () => onesLike,
  ones: () => ones2,
  oneHot: () => oneHot,
  notEqual: () => notEqual,
  norm: () => norm,
  nextFrame: () => nextFrame,
  neg: () => neg,
  multinomial: () => multinomial,
  multiRNNCell: () => multiRNNCell,
  mul: () => mul,
  movingAverage: () => movingAverage,
  moments: () => moments,
  models: () => exports_exports_models,
  model: () => model,
  mod: () => mod,
  mirrorPad: () => mirrorPad,
  minimum: () => minimum,
  min: () => min,
  metrics: () => exports_exports_metrics,
  meshgrid: () => meshgrid,
  memory: () => memory,
  mean: () => mean,
  maximum: () => maximum,
  maxPoolWithArgmax: () => maxPoolWithArgmax,
  maxPool3d: () => maxPool3d,
  maxPool: () => maxPool,
  max: () => max,
  math: () => exports_math,
  matMul: () => matMul,
  lowerBound: () => lowerBound,
  losses: () => losses,
  logicalXor: () => logicalXor,
  logicalOr: () => logicalOr,
  logicalNot: () => logicalNot,
  logicalAnd: () => logicalAnd,
  logSumExp: () => logSumExp,
  logSoftmax: () => logSoftmax,
  logSigmoid: () => logSigmoid,
  log1p: () => log1p,
  log: () => log2,
  localResponseNormalization: () => localResponseNormalization,
  loadLayersModel: () => loadLayersModel,
  loadGraphModelSync: () => loadGraphModelSync,
  loadGraphModel: () => loadGraphModel,
  linspace: () => linspace,
  linalg: () => linalg,
  lessEqual: () => lessEqual,
  less: () => less,
  leakyRelu: () => leakyRelu,
  layers: () => exports_exports_layers,
  kernel_impls: () => exports_kernel_impls,
  keep: () => keep,
  isNaN: () => isNaN2,
  isInf: () => isInf,
  isFinite: () => isFinite2,
  irfft: () => irfft,
  io: () => exports_io,
  input: () => input,
  initializers: () => exports_exports_initializers,
  inTopKAsync: () => inTopKAsync,
  image: () => image,
  imag: () => imag,
  ifft: () => ifft,
  greaterEqual: () => greaterEqual,
  greater: () => greater,
  grads: () => grads,
  grad: () => grad,
  gpgpu_util: () => exports_gpgpu_util,
  getKernelsForBackend: () => getKernelsForBackend,
  getKernel: () => getKernel,
  getGradient: () => getGradient,
  getBackend: () => getBackend,
  gather_util: () => exports_gather_nd_util,
  gatherND: () => gatherND,
  gather: () => gather,
  fused: () => exports_fused_ops,
  forceHalfFloat: () => forceHalfFloat,
  floorDiv: () => floorDiv,
  floor: () => floor,
  findBackendFactory: () => findBackendFactory,
  findBackend: () => findBackend,
  fill: () => fill,
  fft: () => fft,
  eye: () => eye,
  expm1: () => expm1,
  expandDims: () => expandDims,
  exp: () => exp,
  euclideanNorm: () => euclideanNorm,
  erf: () => erf,
  equal: () => equal,
  env: () => env,
  ensureShape: () => ensureShape,
  engine: () => engine7,
  enclosingPowerOfTwo: () => enclosingPowerOfTwo,
  enableProdMode: () => enableProdMode,
  enableDebugMode: () => enableDebugMode,
  elu: () => elu,
  einsum: () => einsum,
  dropout: () => dropout,
  dot: () => dot,
  divNoNan: () => divNoNan,
  div: () => div,
  disposeVariables: () => disposeVariables,
  dispose: () => dispose,
  disableDeprecationWarnings: () => disableDeprecationWarnings,
  dilation2d: () => dilation2d,
  diag: () => diag,
  device_util: () => exports_device_util,
  deregisterOp: () => deregisterOp,
  depthwiseConv2d: () => depthwiseConv2d,
  depthToSpace: () => depthToSpace,
  deprecationWarn: () => deprecationWarn,
  denseBincount: () => denseBincount,
  data: () => exports_dist2,
  customGrad: () => customGrad,
  cumsum: () => cumsum,
  cumprod: () => cumprod,
  cosineWindow: () => cosineWindow,
  cosh: () => cosh,
  cos: () => cos,
  copyRegisteredKernels: () => copyRegisteredKernels,
  conv3dTranspose: () => conv3dTranspose,
  conv3d: () => conv3d,
  conv2dTranspose: () => conv2dTranspose,
  conv2d: () => conv2d,
  conv1d: () => conv1d,
  constraints: () => exports_exports_constraints,
  concat4d: () => concat4d,
  concat3d: () => concat3d,
  concat2d: () => concat2d,
  concat1d: () => concat1d,
  concat: () => concat,
  complex: () => complex,
  clone: () => clone,
  clipByValue: () => clipByValue,
  ceil: () => ceil,
  cast: () => cast,
  callbacks: () => callbacks,
  buffer: () => buffer,
  browser: () => exports_browser,
  broadcast_util: () => exports_broadcast_util,
  broadcastTo: () => broadcastTo,
  broadcastArgs: () => broadcastArgs,
  booleanMaskAsync: () => booleanMaskAsync,
  bitwiseAnd: () => bitwiseAnd,
  bincount: () => bincount,
  batchToSpaceND: () => batchToSpaceND,
  batchNorm4d: () => batchNorm4d,
  batchNorm3d: () => batchNorm3d,
  batchNorm2d: () => batchNorm2d,
  batchNorm: () => batchNorm,
  basicLSTMCell: () => basicLSTMCell,
  backend_util: () => exports_backend_util,
  backend: () => backend2,
  avgPool3d: () => avgPool3d,
  avgPool: () => avgPool,
  atanh: () => atanh,
  atan2: () => atan2,
  atan: () => atan,
  asinh: () => asinh,
  asin: () => asin,
  argMin: () => argMin,
  argMax: () => argMax,
  any: () => any,
  all: () => all,
  addN: () => addN,
  add: () => add2,
  acosh: () => acosh,
  acos: () => acos,
  abs: () => abs,
  _FusedMatMul: () => _FusedMatMul,
  ZerosLike: () => ZerosLike,
  Variable: () => Variable,
  UpperBound: () => UpperBound,
  UnsortedSegmentSum: () => UnsortedSegmentSum,
  Unpack: () => Unpack,
  Unique: () => Unique,
  Transpose: () => Transpose,
  Transform: () => Transform,
  TopK: () => TopK,
  Tile: () => Tile,
  TensorScatterUpdate: () => TensorScatterUpdate,
  TensorBuffer: () => TensorBuffer,
  Tensor: () => Tensor,
  Tanh: () => Tanh,
  Tan: () => Tan,
  SymbolicTensor: () => SymbolicTensor,
  Sum: () => Sum,
  Sub: () => Sub,
  StringToHashBucketFast: () => StringToHashBucketFast,
  StringSplit: () => StringSplit,
  StringNGrams: () => StringNGrams,
  StridedSlice: () => StridedSlice,
  Step: () => Step,
  StaticRegexReplace: () => StaticRegexReplace,
  SquaredDifference: () => SquaredDifference,
  Square: () => Square,
  Sqrt: () => Sqrt,
  SplitV: () => SplitV,
  SparseToDense: () => SparseToDense,
  SparseSegmentSum: () => SparseSegmentSum,
  SparseSegmentMean: () => SparseSegmentMean,
  SparseReshape: () => SparseReshape,
  SparseFillEmptyRows: () => SparseFillEmptyRows,
  SpaceToBatchND: () => SpaceToBatchND,
  Softplus: () => Softplus,
  Softmax: () => Softmax,
  Slice: () => Slice,
  Sinh: () => Sinh,
  Sin: () => Sin,
  Sign: () => Sign,
  Sigmoid: () => Sigmoid,
  Sequential: () => Sequential,
  Selu: () => Selu,
  Select: () => Select,
  SearchSorted: () => SearchSorted,
  ScatterNd: () => ScatterNd,
  SGDOptimizer: () => SGDOptimizer,
  Rsqrt: () => Rsqrt,
  Round: () => Round,
  RotateWithOffset: () => RotateWithOffset,
  Reverse: () => Reverse,
  ResizeNearestNeighborGrad: () => ResizeNearestNeighborGrad,
  ResizeNearestNeighbor: () => ResizeNearestNeighbor,
  ResizeBilinearGrad: () => ResizeBilinearGrad,
  ResizeBilinear: () => ResizeBilinear,
  Reshape: () => Reshape,
  Relu6: () => Relu6,
  Relu: () => Relu,
  Reduction: () => Reduction,
  Reciprocal: () => Reciprocal,
  RealDiv: () => RealDiv,
  Real: () => Real,
  Rank: () => Rank,
  Range: () => Range,
  RaggedTensorToTensor: () => RaggedTensorToTensor,
  RaggedRange: () => RaggedRange,
  RaggedGather: () => RaggedGather,
  RNN: () => RNN,
  RMSPropOptimizer: () => RMSPropOptimizer,
  Prod: () => Prod,
  Prelu: () => Prelu,
  Pow: () => Pow,
  Pool: () => Pool,
  PadV2: () => PadV2,
  Pack: () => Pack,
  OptimizerConstructors: () => OptimizerConstructors,
  Optimizer: () => Optimizer,
  OnesLike: () => OnesLike,
  OneHot: () => OneHot,
  OP_SCOPE_SUFFIX: () => OP_SCOPE_SUFFIX,
  NotEqual: () => NotEqual,
  NonMaxSuppressionV5: () => NonMaxSuppressionV5,
  NonMaxSuppressionV4: () => NonMaxSuppressionV4,
  NonMaxSuppressionV3: () => NonMaxSuppressionV3,
  Neg: () => Neg,
  Multiply: () => Multiply,
  Multinomial: () => Multinomial,
  MomentumOptimizer: () => MomentumOptimizer,
  Mod: () => Mod,
  MirrorPad: () => MirrorPad,
  Minimum: () => Minimum,
  Min: () => Min,
  Mean: () => Mean,
  Maximum: () => Maximum,
  MaxPoolWithArgmax: () => MaxPoolWithArgmax,
  MaxPoolGrad: () => MaxPoolGrad,
  MaxPool3DGrad: () => MaxPool3DGrad,
  MaxPool3D: () => MaxPool3D,
  MaxPool: () => MaxPool,
  Max: () => Max,
  MatrixBandPart: () => MatrixBandPart,
  MathBackendWebGL: () => MathBackendWebGL,
  MathBackendCPU: () => MathBackendCPU,
  LowerBound: () => LowerBound,
  LogicalXor: () => LogicalXor,
  LogicalOr: () => LogicalOr,
  LogicalNot: () => LogicalNot,
  LogicalAnd: () => LogicalAnd,
  LogSoftmax: () => LogSoftmax,
  Log1p: () => Log1p,
  Log: () => Log,
  LinSpace: () => LinSpace,
  LessEqual: () => LessEqual,
  Less: () => Less,
  LeakyRelu: () => LeakyRelu,
  LayersModel: () => LayersModel,
  LayerVariable: () => LayerVariable,
  LRNGrad: () => LRNGrad,
  LRN: () => LRN,
  KernelBackend: () => KernelBackend,
  IsNan: () => IsNan,
  IsInf: () => IsInf,
  IsFinite: () => IsFinite,
  InputSpec: () => InputSpec,
  Imag: () => Imag,
  Identity: () => Identity,
  IFFT: () => IFFT,
  History: () => History,
  GreaterEqual: () => GreaterEqual,
  Greater: () => Greater,
  GraphModel: () => GraphModel,
  GatherV2: () => GatherV2,
  GatherNd: () => GatherNd,
  GPGPUContext: () => GPGPUContext,
  FusedDepthwiseConv2D: () => FusedDepthwiseConv2D,
  FusedConv2D: () => FusedConv2D,
  FusedBatchNorm: () => FusedBatchNorm,
  FromPixels: () => FromPixels,
  FloorDiv: () => FloorDiv,
  Floor: () => Floor,
  FlipLeftRight: () => FlipLeftRight,
  Fill: () => Fill,
  FFT: () => FFT,
  Expm1: () => Expm1,
  ExpandDims: () => ExpandDims,
  Exp: () => Exp,
  Erf: () => Erf,
  Equal: () => Equal,
  Environment: () => Environment,
  EluGrad: () => EluGrad,
  Elu: () => Elu,
  Einsum: () => Einsum,
  EarlyStopping: () => EarlyStopping,
  ENV: () => ENV,
  Draw: () => Draw,
  Dilation2DBackpropInput: () => Dilation2DBackpropInput,
  Dilation2DBackpropFilter: () => Dilation2DBackpropFilter,
  Dilation2D: () => Dilation2D,
  Diag: () => Diag,
  DepthwiseConv2dNativeBackpropInput: () => DepthwiseConv2dNativeBackpropInput,
  DepthwiseConv2dNativeBackpropFilter: () => DepthwiseConv2dNativeBackpropFilter,
  DepthwiseConv2dNative: () => DepthwiseConv2dNative,
  DepthToSpace: () => DepthToSpace,
  DenseBincount: () => DenseBincount,
  DataStorage: () => DataStorage,
  CustomCallback: () => CustomCallback,
  Cumsum: () => Cumsum,
  Cumprod: () => Cumprod,
  CropAndResize: () => CropAndResize,
  Cosh: () => Cosh,
  Cos: () => Cos,
  Conv3DBackpropInputV2: () => Conv3DBackpropInputV2,
  Conv3DBackpropFilterV2: () => Conv3DBackpropFilterV2,
  Conv3D: () => Conv3D,
  Conv2DBackpropInput: () => Conv2DBackpropInput,
  Conv2DBackpropFilter: () => Conv2DBackpropFilter,
  Conv2D: () => Conv2D,
  Concat: () => Concat,
  ComplexAbs: () => ComplexAbs,
  Complex: () => Complex,
  ClipByValue: () => ClipByValue,
  Ceil: () => Ceil,
  Cast: () => Cast,
  CallbackList: () => CallbackList,
  Callback: () => Callback,
  BroadcastTo: () => BroadcastTo,
  BroadcastArgs: () => BroadcastArgs,
  BitwiseAnd: () => BitwiseAnd,
  Bincount: () => Bincount,
  BatchToSpaceND: () => BatchToSpaceND,
  BatchMatMul: () => BatchMatMul,
  AvgPoolGrad: () => AvgPoolGrad,
  AvgPool3DGrad: () => AvgPool3DGrad,
  AvgPool3D: () => AvgPool3D,
  AvgPool: () => AvgPool,
  Atanh: () => Atanh,
  Atan2: () => Atan2,
  Atan: () => Atan,
  Asinh: () => Asinh,
  Asin: () => Asin,
  ArgMin: () => ArgMin,
  ArgMax: () => ArgMax,
  Any: () => Any,
  All: () => All,
  AddN: () => AddN,
  Add: () => Add,
  AdamaxOptimizer: () => AdamaxOptimizer,
  AdamOptimizer: () => AdamOptimizer,
  AdagradOptimizer: () => AdagradOptimizer,
  AdadeltaOptimizer: () => AdadeltaOptimizer,
  Acosh: () => Acosh,
  Acos: () => Acos,
  Abs: () => Abs
});
var version12;
var init_dist7 = __esm(() => {
  init_dist();
  init_register_all_gradients();
  init_register_all_chained_ops();
  init_dist();
  init_dist2();
  init_dist3();
  init_dist4();
  init_dist5();
  init_dist6();
  init_dist();
  init_dist5();
  init_dist6();
  init_dist4();
  init_dist2();
  init_dist3();
  init_version7();
  version12 = {
    "tfjs-core": version,
    "tfjs-backend-cpu": version8,
    "tfjs-backend-webgl": version9,
    "tfjs-data": version7,
    "tfjs-layers": version3,
    "tfjs-converter": version6,
    tfjs: version10
  };
});

// src/engine/engine.ts
init_dist7();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/flags_webgpu.js
init_dist();
var ENV6 = env();
ENV6.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15);
ENV6.registerFlag("WEBGPU_CPU_FORWARD", () => true);
ENV6.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE", () => -1);
ENV6.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => true);
ENV6.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => false);
ENV6.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1000);
ENV6.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => false);
ENV6.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE", () => true);
ENV6.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG", () => false);
ENV6.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL", () => -1);
ENV6.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => false);
ENV6.registerFlag("WEBGPU_PRINT_SHADER", () => "");
ENV6.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY", () => false);

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/base.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/backend_webgpu.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/adapter_info.js
class AdapterInfo {
  constructor(adapterInfo) {
    if (adapterInfo) {
      this.vendor = adapterInfo.vendor;
      this.architecture = adapterInfo.architecture;
      this.intelGPUGeneration = this.getIntelGPUGeneration();
    }
  }
  getIntelGPUGeneration() {
    if (this.isIntel()) {
      if (this.architecture.startsWith("gen")) {
        return Number(this.architecture.match(/\d+/));
      } else if (this.architecture.startsWith("xe")) {
        return 12;
      }
    }
    return 0;
  }
  isIntel() {
    return this.vendor === "intel";
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/buffer_manager.js
function getBufferKey(size, usage) {
  return `${size}_${usage}`;
}

class BufferManager {
  constructor(device) {
    this.device = device;
    this.numUsedBuffers = 0;
    this.numFreeBuffers = 0;
    this.freeBuffers = new Map;
    this.usedBuffers = new Map;
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
  acquireBuffer(size, usage, mappedAtCreation = false, reuse = true) {
    let buffer9;
    const key = getBufferKey(size, usage);
    if (reuse) {
      if (!this.freeBuffers.has(key)) {
        this.freeBuffers.set(key, []);
      }
      if (this.freeBuffers.get(key).length > 0) {
        buffer9 = this.freeBuffers.get(key).pop();
        this.numFreeBuffers--;
      } else {
        buffer9 = this.device.createBuffer({ size, usage, mappedAtCreation });
        this.numBytesAllocated += size;
      }
    } else {
      buffer9 = this.device.createBuffer({ size, usage, mappedAtCreation });
      this.numBytesAllocated += size;
    }
    if (!this.usedBuffers.has(key)) {
      this.usedBuffers.set(key, []);
    }
    this.usedBuffers.get(key).push(buffer9);
    this.numUsedBuffers++;
    this.numBytesUsed += size;
    return buffer9;
  }
  releaseBuffer(buffer9, reuse = true) {
    if (this.freeBuffers.size === 0) {
      return;
    }
    const size = buffer9.size;
    const usage = buffer9.usage;
    const key = getBufferKey(size, usage);
    const bufferArray = this.usedBuffers.get(key);
    const index = bufferArray.indexOf(buffer9);
    if (index < 0) {
      throw new Error("Cannot find the buffer in buffer manager");
    }
    bufferArray[index] = bufferArray[bufferArray.length - 1];
    bufferArray.pop();
    this.numUsedBuffers--;
    this.numBytesUsed -= size;
    if (reuse) {
      this.freeBuffers.get(key).push(buffer9);
      this.numFreeBuffers++;
    } else {
      buffer9.destroy();
      this.numBytesAllocated -= size;
    }
  }
  getNumUsedBuffers() {
    return this.numUsedBuffers;
  }
  getNumFreeBuffers() {
    return this.numFreeBuffers;
  }
  dispose() {
    this.freeBuffers.forEach((buffers, key) => {
      buffers.forEach((buffer9) => {
        buffer9.destroy();
      });
    });
    this.usedBuffers.forEach((buffers, key) => {
      buffers.forEach((buffer9) => {
        buffer9.destroy();
      });
    });
    this.freeBuffers = new Map;
    this.usedBuffers = new Map;
    this.numUsedBuffers = 0;
    this.numFreeBuffers = 0;
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/texture_manager.js
function getTextureKey(width, height, format, usage) {
  return `${width}_${height}_${format}_${usage}`;
}
function getBytesPerElement(format) {
  if (format === "rgba8unorm") {
    return 16;
  } else {
    throw new Error(`${format} is not supported!`);
  }
}

class TextureManager2 {
  constructor(device) {
    this.device = device;
    this.numUsedTextures = 0;
    this.numFreeTextures = 0;
    this.freeTextures = new Map;
    this.usedTextures = new Map;
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
  acquireTexture(width, height, format, usage) {
    const bytesPerElement2 = getBytesPerElement(format);
    const byteSize = width * height * bytesPerElement2;
    const key = getTextureKey(width, height, format, usage);
    if (!this.freeTextures.has(key)) {
      this.freeTextures.set(key, []);
    }
    if (!this.usedTextures.has(key)) {
      this.usedTextures.set(key, []);
    }
    this.numBytesUsed += byteSize;
    this.numUsedTextures++;
    if (this.freeTextures.get(key).length > 0) {
      this.numFreeTextures--;
      const newTexture2 = this.freeTextures.get(key).shift();
      this.usedTextures.get(key).push(newTexture2);
      return newTexture2;
    }
    this.numBytesAllocated += byteSize;
    const newTexture = this.device.createTexture({
      size: [width, height],
      format,
      usage
    });
    this.usedTextures.get(key).push(newTexture);
    return newTexture;
  }
  releaseTexture(texture) {
    if (this.freeTextures.size === 0) {
      return;
    }
    const width = texture.width;
    const height = texture.height;
    const format = texture.format;
    const usage = texture.usage;
    const key = getTextureKey(width, height, format, usage);
    if (!this.freeTextures.has(key)) {
      this.freeTextures.set(key, []);
    }
    this.freeTextures.get(key).push(texture);
    this.numFreeTextures++;
    this.numUsedTextures--;
    const textureList = this.usedTextures.get(key);
    const textureIndex = textureList.indexOf(texture);
    if (textureIndex < 0) {
      throw new Error("Cannot release a texture that was never provided by this " + "texture manager");
    }
    textureList.splice(textureIndex, 1);
    const bytesPerElement2 = getBytesPerElement(format);
    const byteSize = width * height * bytesPerElement2;
    this.numBytesUsed -= byteSize;
  }
  getNumUsedTextures() {
    return this.numUsedTextures;
  }
  getNumFreeTextures() {
    return this.numFreeTextures;
  }
  dispose() {
    this.freeTextures.forEach((textures, key) => {
      textures.forEach((texture) => {
        texture.destroy();
      });
    });
    this.usedTextures.forEach((textures, key) => {
      textures.forEach((texture) => {
        texture.destroy();
      });
    });
    this.freeTextures = new Map;
    this.usedTextures = new Map;
    this.numUsedTextures = 0;
    this.numFreeTextures = 0;
    this.numBytesUsed = 0;
    this.numBytesAllocated = 0;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/webgpu_program.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/shader_util.js
function symbolicallyComputeStrides2(indicesArr, variableName) {
  if (Math.max(...indicesArr) > 5) {
    throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");
  }
  const numCoords = indicesArr.length;
  const indicesStr = "xyzwuv";
  const shape = indicesArr.map((d) => `${variableName}.${indicesStr[d]}`);
  const strides = new Array(numCoords - 1);
  strides[numCoords - 2] = shape[numCoords - 1];
  for (let i = numCoords - 3;i >= 0; --i) {
    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;
  }
  return strides;
}
var atomicAddSnippet = (ptr, v, type) => {
  if (type === "int32") {
    return `atomicAdd(${ptr}, bitcast<i32>(${v}));`;
  } else {
    return `
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${v});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${ptr}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;
  }
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/webgpu_program.js
function getCoordsDataType2(rank) {
  if (rank <= 1) {
    return "i32";
  } else if (rank === 2) {
    return `vec2<i32>`;
  } else if (rank === 3) {
    return `vec3<i32>`;
  } else if (rank === 4) {
    return `vec4<i32>`;
  } else if (rank === 5) {
    return `vec5`;
  } else if (rank === 6) {
    return `vec6`;
  } else {
    throw Error(`GPU for rank ${rank} is not yet supported`);
  }
}
function getCoordsXYZ(index) {
  if (index === 0) {
    return "x";
  } else if (index === 1) {
    return "y";
  } else if (index === 2) {
    return "z";
  } else if (index === 3) {
    return "w";
  } else if (index === 4) {
    return "u";
  } else if (index === 5) {
    return "v";
  } else {
    throw Error(`Index ${index} is not yet supported`);
  }
}
function getMainHeaderString(...params) {
  let snippet;
  switch (params.length) {
    case 0:
      snippet = `
        fn main()
      `;
      break;
    case 1:
      snippet = `
        fn main(${params[0]} : i32)
      `;
      break;
    default:
      throw Error("Unreachable");
  }
  return snippet;
}
function getStartHeaderString(useGlobalIndex, program) {
  let snippet;
  snippet = `
     ${getWorkgroupSizeString(program)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${useGlobalIndex ? `main(getGlobalIndex());` : `main();`};
      }
    `;
  return snippet;
}
function getWorkgroupSizeString(program) {
  return `
  @compute @workgroup_size(${program.workgroupSize[0]}, ${program.workgroupSize[1]}, ${program.workgroupSize[2]})
`;
}
function makeShader2(inputInfo, outputData, program) {
  const prefixSnippets = [];
  const flatWorkgroupSize = program.workgroupSize[0] * program.workgroupSize[1] * program.workgroupSize[2];
  program.outputComponent = program.outputComponent ? program.outputComponent : 1;
  prefixSnippets.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${isFlatDispatch(program) ? `  return i32(globalId.x);` : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${flatWorkgroupSize}u +
                localIndex);
        `}
      }
    `);
  if (program.pixelsOpType != null) {
    const inoutSnippet = program.pixelsOpType === PixelsOpType.FROM_PIXELS ? `@group(0) @binding(0) var<storage, read_write> result: array<${dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;` : `@group(0) @binding(1) var<storage, read> inBuf : array<${dataTypeToGPUType(inputInfo[0].dtype, program.outputComponent)}>;`;
    const outShapeStridesType = outputData.shape.length === 3 ? "vec2<i32>" : "i32";
    prefixSnippets.push(`
        struct Uniform {
          outShapeStrides : ${outShapeStridesType},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${inoutSnippet}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
    const useGlobalIndex2 = isFlatDispatchLayout(program);
    return [
      commonSnippet,
      prefixSnippets.join("\n"),
      getCoordsFromIndexSnippet(outputData.shape),
      program.getUserCode(),
      getStartHeaderString(useGlobalIndex2, program)
    ].join("\n");
  }
  let stridesLength;
  let stridesDataType;
  let uniformDeclaration = "struct Uniforms { NAN : f32, INFINITY : f32, ";
  program.variableNames.forEach((x, i) => {
    const perDataType = getCoordsDataType2(inputInfo[i].shape.length);
    uniformDeclaration += `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${perDataType}, `;
    stridesLength = inputInfo[i].shape.length - 1;
    stridesDataType = getCoordsDataType2(stridesLength);
    uniformDeclaration += `${x.charAt(0).toLowerCase() + x.slice(1)}ShapeStrides: ${stridesDataType}, `;
  });
  const outputDataType = getCoordsDataType2(outputData.shape.length);
  uniformDeclaration += `outShape : ${outputDataType}, `;
  stridesLength = outputData.shape.length - 1;
  stridesDataType = getCoordsDataType2(stridesLength);
  uniformDeclaration += `
         outShapeStrides: ${stridesDataType}, `;
  if (program.size) {
    uniformDeclaration += "size : i32, ";
  }
  if (program.uniforms) {
    uniformDeclaration += program.uniforms;
  }
  uniformDeclaration += "};";
  uniformDeclaration = insertAlignment(uniformDeclaration);
  prefixSnippets.push(uniformDeclaration);
  if (program.atomic) {
    prefixSnippets.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `);
  } else {
    prefixSnippets.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${dataTypeToGPUType(outputData.dtype, program.outputComponent)}>;
    `);
  }
  program.variableNames.forEach((x, i) => {
    prefixSnippets.push(`
      @group(0) @binding(${1 + i}) var<storage, read> ${x}: array<${program.variableComponents ? dataTypeToGPUType(inputInfo[i].dtype, program.variableComponents[i]) : dataTypeToGPUType(inputInfo[i].dtype, program.outputComponent)}>;
        `);
  });
  if (uniformDeclaration !== "") {
    prefixSnippets.push(`
      @group(0) @binding(${1 + program.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
  }
  const coordsSnippet = getOutputCoordsSnippet(outputData.shape, program.dispatchLayout);
  const sources = [
    commonSnippet,
    prefixSnippets.join("\n") + isInfSnippet,
    getCoordsFromIndexSnippet(outputData.shape),
    coordsSnippet,
    getOutputIndexFromCoordsSnippet(outputData.shape.length)
  ];
  if (!program.atomic) {
    sources.push(setOutputSnippet(outputData.shape, outputData.dtype, program.outputComponent));
  }
  program.variableNames.forEach((x, i) => {
    sources.push(`${getCoordsFromIndexSnippet(inputInfo[i].shape, x)}`);
  });
  const inputSnippet = inputInfo.map((x, i) => getInputSnippet(x, outputData.shape, program.variableComponents ? program.variableComponents[i] : program.outputComponent, program.dispatchLayout.x.length === outputData.shape.length)).join("\n");
  sources.push(inputSnippet);
  sources.push(program.getUserCode());
  const useGlobalIndex = isFlatDispatchLayout(program);
  sources.push(getStartHeaderString(useGlobalIndex, program));
  const source = sources.join("\n");
  return source;
}
function makeShaderKey2(program, inputsData, output) {
  let key = program.shaderKey;
  if (program.pixelsOpType != null) {
    return key;
  }
  const shapes = [];
  const types6 = [];
  inputsData.forEach((element) => {
    shapes.push(element.shape);
    types6.push(element.dtype);
  });
  shapes.push(output.shape);
  types6.push(output.dtype);
  const broadcastDims = inputsData.map((d) => exports_backend_util.getBroadcastDims(d.shape, output.shape));
  const inputShapesEqualsOutShape = inputsData.map((d) => exports_util.arraysEqual(d.shape, output.shape)).join("_");
  const broadcastDimsKey = broadcastDims.map((d) => d.join("_")).join(";");
  const flatDispatchString = isFlatDispatch(program) ? "flatDispatch" : "";
  key += "_" + (program.workgroupSize ? program.workgroupSize.join(",") : "") + shapes.map((shape) => shape.length).join(",") + types6.join(",") + program.variableNames.join(",") + broadcastDimsKey + inputShapesEqualsOutShape + flatDispatchString;
  return key;
}
function getCoordsFromIndexSnippet(shape, name = "") {
  const rank = shape.length;
  const funcName = name !== "" ? `get${name.charAt(0).toUpperCase() + name.slice(1)}CoordsFromIndex` : "getCoordsFromIndex";
  const stridesName = name !== "" ? `${name.charAt(0).toLowerCase() + name.slice(1)}ShapeStrides` : `outShapeStrides`;
  if (rank <= 1) {
    return `fn ${funcName}(index : i32) -> i32 { return index; }`;
  }
  const strides = exports_util.computeStrides(shape);
  const dtype = getCoordsDataType2(rank);
  const coords2 = [];
  for (let i = 0;i < rank; i++) {
    coords2.push(`d${i}`);
  }
  if (strides.length === 1) {
    return `    fn ${funcName}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${stridesName}; let d1 = index - d0 * uniforms.${stridesName};
      return vec2<i32>(d0, d1);
    }`;
  }
  let snippet;
  snippet = "var index2 = index;" + strides.map((_, i) => {
    const line1 = `let ${coords2[i]} = index2 / uniforms.${stridesName}.${getCoordsXYZ(i)}`;
    const line2 = i === strides.length - 1 ? `let ${coords2[i + 1]} = index2 - ${coords2[i]} * uniforms.${stridesName}.${getCoordsXYZ(i)}` : `index2 = index2 - ${coords2[i]} * uniforms.${stridesName}.${getCoordsXYZ(i)}`;
    return `${line1}; ${line2};`;
  }).join("");
  return `
    fn ${funcName}(index : i32) -> ${dtype} {
      ${snippet}
      return ${dtype}(${coords2.join(",")});
    }
  `;
}
function getInputAtCoordsSnippet(inputInfo, component) {
  const texName = inputInfo.name;
  const rank = inputInfo.shape.length;
  const type = getCoordsDataType2(rank);
  const funcName = "get" + texName.charAt(0).toUpperCase() + texName.slice(1);
  const dims = ["d0", "d1", "d2", "d3", "d4", "d5"].slice(0, rank);
  const inputs = dims.map((d) => `${d} : i32`).join(", ");
  if (rank < 1) {
    return `
      fn ${funcName}() -> ${typeSnippet(component)} {
        return ${typeSnippet(component)}(${texName}[0]);
      }
    `;
  }
  const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
  let rankStr = `${rank}D`;
  if (rank === 0) {
    rankStr = "1D";
  }
  return `
    fn ${funcName}(${inputs}) -> ${typeSnippet(component)} {
      return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${type}(${dims.join(",")}),
        ${shapeStr})${component === 1 ? "" : ` / ${component}`}]);
    }
   `;
}
function getInputByOutputSnippet(inputInfo, outShape, component, isFlatDispatchLayout) {
  const texName = inputInfo.name;
  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
  const funcName = "get" + texFuncSnippet + "ByOutput";
  const inRank = inputInfo.shape.length;
  const outRank = outShape.length;
  const type = getCoordsDataType2(outRank);
  if (exports_util.arraysEqual(inputInfo.shape, outShape) && isFlatDispatchLayout) {
    return `
    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {
      return ${typeSnippet(component)}(${texName}[globalIndex]);
    }

    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)} {
      return ${typeSnippet(component)}(${texName}[${outRank > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}${component === 1 ? "" : ` / ${component}`}]);
    }
    `;
  }
  const broadcastDims = exports_backend_util.getBroadcastDims(inputInfo.shape, outShape);
  const rankDiff = outRank - inRank;
  let coordsSnippet = "";
  if (inRank === 0) {
    return `
    fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)}{
      return get${texFuncSnippet}();
    }

    fn ${funcName}Coords(coords : ${type}) -> ${typeSnippet(component)}{
      return get${texFuncSnippet}();
    }
  `;
  } else {
    if (outRank < 2 && broadcastDims.length >= 1) {
      coordsSnippet = "coords = 0;";
    } else {
      coordsSnippet = broadcastDims.map((d) => `coords.${getCoordsXYZ(d + rankDiff)} = 0;`).join("\n");
    }
  }
  let unpackedCoordsSnippet = "";
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    if (outRank > 1) {
      const coordsType = getCoordsDataType2(inRank);
      const coordsValues = inputInfo.shape.map((s, i) => `coords.${getCoordsXYZ(i + rankDiff)}`).join(", ");
      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;
    } else {
      unpackedCoordsSnippet = "coords";
    }
  }
  const shapeStr = `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;
  const rankStr = `${inRank}D`;
  return `
  fn ${funcName}Index(globalIndex : i32) -> ${typeSnippet(component)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${coordsSnippet}
    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})${component === 1 ? "" : ` / ${component}`}]);
  }

  fn ${funcName}Coords(coordsIn : ${type}) -> ${typeSnippet(component)} {
    var coords = coordsIn;
    ${coordsSnippet}
    return ${typeSnippet(component)}(${texName}[getIndexFromCoords${rankStr}(${unpackedCoordsSnippet}, ${shapeStr})${component === 1 ? "" : ` / ${component}`}]);
  }
`;
}
function getInputSnippet(inputInfo, outShape, component, isFlatDispatchLayout) {
  let res = getInputAtCoordsSnippet(inputInfo, component);
  const inShape = inputInfo.shape;
  if (inShape.length <= outShape.length) {
    res += getInputByOutputSnippet(inputInfo, outShape, component, isFlatDispatchLayout);
  }
  return res;
}
function getOutputCoordsSnippet(outShape, dispatchLayout) {
  const { x, y = [], z = [] } = dispatchLayout;
  const outRank = outShape.length;
  const rank = x.length + y.length + z.length;
  if (rank !== outRank) {
    return "";
  }
  if (x.length === outRank) {
    const dtype2 = getCoordsDataType2(outRank);
    const snippet2 = `fn getOutputCoords() -> ${dtype2}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
    return snippet2;
  }
  let gatherDimensionsStr = "";
  const dims = [x, y, z];
  for (let i = 0;i < dims.length; i++) {
    const arr = dims[i];
    if (arr.length === 0) {
      continue;
    }
    if (arr.length === 1) {
      gatherDimensionsStr += `let d${arr[0]} = i32(globalId[${i}]);`;
    } else {
      const strides = symbolicallyComputeStrides2(arr, "uniforms.outShape");
      gatherDimensionsStr += `var index${i} = i32(globalId[${i}]);`;
      for (let j = 0;j < strides.length; j++) {
        gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;
        if (j === strides.length - 1) {
          gatherDimensionsStr += `let d${arr[j + 1]} = ` + `index${i} - d${arr[j]} * ${strides[j]};`;
        } else {
          gatherDimensionsStr += `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;
        }
      }
    }
  }
  const dimensions = [];
  for (let i = 0;i < rank; i++) {
    dimensions.push(`d${i}`);
  }
  const dtype = getCoordsDataType2(rank);
  let snippet = `fn getOutputCoords() -> ${dtype} {
  ${gatherDimensionsStr}
`;
  if (dimensions.length === 0) {
    snippet += `return ${dtype}(0); }`;
  } else {
    snippet += `return ${dtype}(${dimensions.join(",")}); }`;
  }
  return snippet;
}
function getOutputIndexFromCoordsSnippet(outRank) {
  let snippet = "";
  switch (outRank) {
    case 0:
    case 1:
      snippet += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
      break;
    case 2:
      snippet += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
      break;
    case 3:
      snippet += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
      break;
    case 4:
      snippet += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
      break;
    case 5:
      snippet += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
      break;
    case 6:
      snippet += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
      break;
    default:
      exports_util.assert(false, () => `Unsupported ${outRank}D shape`);
      break;
  }
  return snippet;
}
function isFlatDispatch(program) {
  return program.dispatch[1] === 1 && program.dispatch[2] === 1;
}
function dataTypeToGPUType(type, component = 1) {
  if (type === "float32") {
    return typeSnippet(component, "f32");
  } else if (type === "int32" || type === "bool") {
    return typeSnippet(component, "i32");
  }
  throw new Error(`type ${type} is not supported.`);
}
function setOutputSnippet(outShape, outBufferType, component) {
  const outRank = outShape.length;
  const gpuType = dataTypeToGPUType(outBufferType, component);
  let snippet = `fn setOutputAtIndex(flatIndex : i32, value : ${typeSnippet(component)}) {
      result[flatIndex] = ${gpuType}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${typeSnippet(component, "i32")}) {
      result[flatIndex] = ${gpuType}(value);
    }
    `;
  if (outRank >= 2) {
    const dims = ["d0", "d1", "d2", "d3", "d4", "d5"].slice(0, outRank);
    const type = getCoordsDataType2(outRank);
    snippet += `
      fn setOutputAtCoords(${dims.map((d) => `${d} : i32`).join(", ")}, value : ${typeSnippet(component)}) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(", ")}));
        setOutputAtIndex(flatIndex${component === 1 ? "" : ` / ${component}`}, value);
      }
      fn setOutputAtCoordsI32(${dims.map((d) => `${d} : i32`).join(", ")}, value : ${typeSnippet(component, "i32")}) {
        let flatIndex = getOutputIndexFromCoords(${type}(${dims.join(", ")}));
        setOutputAtIndexI32(flatIndex${component === 1 ? "" : ` / ${component}`}, value);
      }
    `;
  }
  return snippet;
}
function insertAlignment(uniformShader) {
  const curInsertRe = /(\w+)\s*:\s*vec(5|6)/g;
  uniformShader = uniformShader.replace(curInsertRe, (match) => {
    return "@align(16) " + match;
  });
  const preInsertRe = /vec(5|6)\s*,\s*(\w+)/g;
  uniformShader = uniformShader.replace(preInsertRe, (_, p1, p22) => {
    return `vec${p1}, @align(16) ${p22}`;
  });
  return uniformShader;
}
function isFlatDispatchLayout(program) {
  if (program.dispatchLayout.hasOwnProperty("y") && program.dispatchLayout.y.length !== 0) {
    return false;
  }
  if (program.dispatchLayout.hasOwnProperty("z") && program.dispatchLayout.z.length !== 0) {
    return false;
  }
  return true;
}
var PixelsOpType;
(function(PixelsOpType2) {
  PixelsOpType2[PixelsOpType2["FROM_PIXELS"] = 0] = "FROM_PIXELS";
  PixelsOpType2[PixelsOpType2["DRAW"] = 1] = "DRAW";
})(PixelsOpType || (PixelsOpType = {}));
var compileProgram2 = (device, program, inputsData, output, parallelCompilation) => {
  const outputData = { dtype: output.dtype, shape: output.shape };
  const source = makeShader2(inputsData, outputData, program);
  const module = device.createShaderModule({ code: source, label: program.constructor.name });
  let printShaderString = env().get("WEBGPU_PRINT_SHADER");
  if (printShaderString !== "") {
    printShaderString = printShaderString.toLowerCase();
    const printShaderArray = printShaderString.split(",");
    if (printShaderString === "all" || printShaderArray.some((item) => program.shaderKey.toLowerCase().includes(item))) {
      console.group(program.shaderKey);
      console.debug(source);
      console.groupEnd();
    }
  }
  if (parallelCompilation) {
    return device.createComputePipelineAsync({
      compute: { module, entryPoint: "_start" },
      label: program.constructor.name,
      layout: "auto"
    });
  } else {
    return device.createComputePipeline({
      compute: { module, entryPoint: "_start" },
      label: program.constructor.name,
      layout: "auto"
    });
  }
};
var typeSnippet = (component, type = "f32") => {
  switch (component) {
    case 1:
      return `${type}`;
    case 2:
      return `vec2<${type}>`;
    case 3:
      return `vec3<${type}>`;
    case 4:
      return `vec4<${type}>`;
    default:
      throw new Error(`${component}-component ${type} is not supported.`);
  }
};
var commonSnippet = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`;
var isInfSnippet = `
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/webgpu_util.js
init_dist();
function computeDispatch(layout, outputShape, workgroupSize = [1, 1, 1], elementsPerThread = [1, 1, 1]) {
  const [dispatchX, dispatchY, dispatchZ] = [
    Math.ceil(arrayProduct(layout.x.map((d) => outputShape[d])) / (workgroupSize[0] * elementsPerThread[0])),
    layout.y ? Math.ceil(arrayProduct(layout.y.map((d) => outputShape[d])) / (workgroupSize[1] * elementsPerThread[1])) : 1,
    layout.z ? Math.ceil(arrayProduct(layout.z.map((d) => outputShape[d])) / (workgroupSize[2] * elementsPerThread[2])) : 1
  ];
  return [dispatchX, dispatchY, dispatchZ];
}
function computeWorkgroupInfoForMatMul(dimAOuter, dimInner, dimBOuter, transposeA = false) {
  const workgroupSize = [8, 8, 1];
  const elementsPerThread = [4, 4, 1];
  if (!transposeA) {
    if (dimAOuter <= 8) {
      elementsPerThread[1] = 1;
    }
    if (dimInner <= 16 && dimBOuter <= 16) {
      workgroupSize[0] = 4;
    }
  }
  return { workgroupSize, elementsPerThread };
}
function computeWorkgroupSizeForConv2d(layout, outputShape, isVec4 = false) {
  if (isVec4) {
    return [8, 8, 1];
  }
  const dim0 = arrayProduct(layout.x.map((d) => outputShape[d]));
  const dim1 = arrayProduct(layout.y.map((d) => outputShape[d]));
  if (dim0 <= 4) {
    return [4, 16, 1];
  }
  if (dim1 <= 4) {
    return [16, 4, 1];
  }
  return [16, 16, 1];
}
function computeWorkPerThreadForConv2d(layout, outputShape, isVec4 = false) {
  if (isVec4) {
    return [4, 4, 1];
  }
  const dim0 = arrayProduct(layout.x.map((d) => outputShape[d]));
  const dim1 = arrayProduct(layout.y.map((d) => outputShape[d]));
  if (dim0 <= 4) {
    return [1, 2, 1];
  }
  if (dim1 <= 4) {
    return [2, 1, 1];
  }
  return [2, 2, 1];
}
function flatDispatchLayout(shape) {
  return { x: shape.map((d, i) => i) };
}
function GPUBytesPerElement(dtype) {
  if (dtype === "float32" || dtype === "int32" || dtype === "bool" || dtype === "string") {
    return 4;
  } else if (dtype === "complex64") {
    return 8;
  } else {
    throw new Error(`Unknown dtype ${dtype}`);
  }
}
function isWebGPUSupported() {
  return !!(typeof globalThis !== "undefined" && globalThis.navigator && globalThis.navigator.gpu);
}
function assertNotComplex3(tensor153, opName) {
  if (!Array.isArray(tensor153)) {
    tensor153 = [tensor153];
  }
  tensor153.forEach((t) => {
    if (t != null) {
      exports_util.assert(t.dtype !== "complex64", () => `${opName} does not support complex64 tensors ` + "in the WebGPU backend.");
    }
  });
}
var arrayProduct = (arr) => {
  let product = 1;
  for (let i = 0;i < arr.length; i++) {
    product *= arr[i];
  }
  return product;
};
var MatMulProgramType;
(function(MatMulProgramType2) {
  MatMulProgramType2[MatMulProgramType2["MatMulReduceProgram"] = 0] = "MatMulReduceProgram";
  MatMulProgramType2[MatMulProgramType2["MatMulSplitKProgram"] = 1] = "MatMulSplitKProgram";
  MatMulProgramType2[MatMulProgramType2["MatMulSmallOutputSizeProgram"] = 2] = "MatMulSmallOutputSizeProgram";
  MatMulProgramType2[MatMulProgramType2["MatMulPackedProgram"] = 3] = "MatMulPackedProgram";
  MatMulProgramType2[MatMulProgramType2["MatMulMax"] = 4] = "MatMulMax";
})(MatMulProgramType || (MatMulProgramType = {}));

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/backend_webgpu.js
var CPU_HANDOFF_SIZE_THRESHOLD2 = env().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");
var reshapeDispatch = (device, program) => {
  const MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE = device.limits.maxComputeWorkgroupsPerDimension;
  const layout = program["dispatchLayout"];
  const dispatch = program["dispatch"];
  if (dispatch.every((d) => d <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE)) {
    return dispatch;
  }
  exports_util.assert(dispatch[0] > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE && layout.y === undefined && layout.z === undefined, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
  let dispatchAverage = Math.ceil(Math.sqrt(dispatch[0]));
  if (dispatchAverage > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {
    dispatchAverage = Math.ceil(Math.cbrt(dispatch[0]));
    exports_util.assert(dispatchAverage <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE, () => "Total dispatch size exceeds WebGPU maximum.");
    return [dispatchAverage, dispatchAverage, dispatchAverage];
  } else {
    return [dispatchAverage, dispatchAverage, 1];
  }
};

class WebGPUBackend extends KernelBackend {
  nextDataId() {
    return WebGPUBackend.nextDataId++;
  }
  constructor(device, adapterInfo) {
    super();
    this.commandQueueOwnedIds = new WeakSet;
    this.dispatchCountInPass = 0;
    this.disposed = false;
    this.downloadWaitMs = 0;
    this.tensorDataPendingDisposal = [];
    this.queryResolveBuffer = null;
    this.querySet = null;
    this.querySetCount = 2;
    this.stagingPendingDisposal = [];
    this.uniformPendingDisposal = [];
    this.uploadWaitMs = 0;
    this.hasReadSyncWarned = false;
    this.hasTimestampQueryWarned = false;
    if (!isWebGPUSupported()) {
      throw new Error("WebGPU is not supported on this device");
    }
    this.pipelineCache = {};
    this.device = device;
    this.queue = device.queue;
    this.commandEncoder = null;
    this.computePassEncoder = null;
    this.adapterInfo = new AdapterInfo(adapterInfo);
    this.supportTimestampQuery = this.device.features.has("timestamp-query");
    this.thresholdToIncreaseWorkgroups = this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8;
    this.bufferManager = new BufferManager(this.device);
    this.textureManager = new TextureManager2(this.device);
    this.tensorMap = new DataStorage(this, engine7());
    if (env().getBool("WEBGPU_USE_PROFILE_TOOL")) {
      this.dummyCanvas = document.createElement("canvas");
      this.dummyCanvas.width = 1;
      this.dummyCanvas.height = 1;
      this.dummyContext = this.dummyCanvas.getContext("webgpu");
      this.dummyContext.configure({
        device,
        format: "bgra8unorm"
      });
      document.body.appendChild(this.dummyCanvas);
    }
  }
  floatPrecision() {
    return 32;
  }
  disposeData(dataId, force = false) {
    if (!this.tensorMap.has(dataId)) {
      return true;
    }
    const tensorData = this.tensorMap.get(dataId);
    if (force) {
      tensorData.refCount = 0;
    } else {
      tensorData.refCount--;
    }
    if (tensorData.refCount > 0) {
      return false;
    }
    if (tensorData.complexTensorInfos != null) {
      this.disposeData(tensorData.complexTensorInfos.real.dataId);
      this.disposeData(tensorData.complexTensorInfos.imag.dataId);
    }
    if (this.commandQueueOwnedIds.has(dataId)) {
      this.tensorDataPendingDisposal.push(dataId);
      return true;
    }
    this.releaseResource(dataId);
    this.tensorMap.delete(dataId);
    return true;
  }
  memory() {
    return {
      numBytesInGPU: this.bufferManager.numBytesUsed,
      numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,
      unreliable: false
    };
  }
  releaseResource(dataId) {
    const tensorData = this.tensorMap.get(dataId);
    if (!tensorData || !tensorData.resource) {
      return;
    }
    if (tensorData.external) {
      tensorData.resource = null;
      return;
    }
    if (tensorData.resource instanceof GPUBuffer) {
      this.bufferManager.releaseBuffer(tensorData.resource);
    } else if (tensorData.resource instanceof GPUTexture) {
      this.textureManager.releaseTexture(tensorData.resource);
    }
    tensorData.resource = null;
  }
  refCount(dataId) {
    if (this.tensorMap.has(dataId)) {
      const tensorData = this.tensorMap.get(dataId);
      return tensorData.refCount;
    }
    return 0;
  }
  incRef(dataId) {
    const tensorData = this.tensorMap.get(dataId);
    tensorData.refCount++;
  }
  decRef(dataId) {
    if (this.tensorMap.has(dataId)) {
      const tensorData = this.tensorMap.get(dataId);
      tensorData.refCount--;
    }
  }
  write(values, shape, dtype) {
    if (dtype === "complex64" && values != null) {
      throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);
    }
    const dataId = { id: this.nextDataId() };
    this.tensorMap.set(dataId, { dtype, shape, values, refCount: 1 });
    return dataId;
  }
  move(dataId, values, shape, dtype, refCount) {
    if (dtype === "complex64") {
      throw new Error(`Cannot write to a complex64 dtype. ` + `Please use tf.complex(real, imag).`);
    }
    this.tensorMap.set(dataId, { dtype, shape, values, refCount });
  }
  submitQueue() {
    this.queue.submit([this.commandEncoder.finish()]);
    this.commandEncoder = null;
    this.dispatchCountInPass = 0;
    this.commandQueueOwnedIds = new WeakSet;
    this.tensorDataPendingDisposal.forEach((d) => {
      this.releaseResource(d);
      this.tensorMap.delete(d);
    });
    this.uniformPendingDisposal.forEach((b) => this.bufferManager.releaseBuffer(b));
    this.stagingPendingDisposal.forEach((b) => this.bufferManager.releaseBuffer(b, false));
    this.tensorDataPendingDisposal = [];
    this.uniformPendingDisposal = [];
    this.stagingPendingDisposal = [];
  }
  ensureCommandEncoderReady() {
    if (!this.commandEncoder) {
      this.commandEncoder = this.device.createCommandEncoder();
    }
  }
  endComputePassEncoder() {
    if (this.computePassEncoder) {
      this.computePassEncoder.end();
      this.computePassEncoder = null;
    }
  }
  async checkCompileCompletionAsync() {
    let pipelines;
    try {
      pipelines = await Promise.all(Object.values(this.pipelineCache));
    } catch (e) {
      throw new Error(e.message);
    }
    Object.keys(this.pipelineCache).map((key, i) => {
      this.pipelineCache[key] = pipelines[i];
    });
  }
  async getBufferData(buffer9) {
    if (env().getBool("WEBGPU_ENGINE_COMPILE_ONLY")) {
      console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false");
      return null;
    }
    const size = buffer9.size;
    const stagingBuffer = this.bufferManager.acquireBuffer(size, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
    this.ensureCommandEncoderReady();
    this.endComputePassEncoder();
    this.commandEncoder.copyBufferToBuffer(buffer9, 0, stagingBuffer, 0, size);
    this.submitQueue();
    await stagingBuffer.mapAsync(GPUMapMode.READ);
    const values = stagingBuffer.getMappedRange().slice(0);
    stagingBuffer.unmap();
    if (stagingBuffer != null) {
      this.bufferManager.releaseBuffer(stagingBuffer);
    }
    if (env().getBool("WEBGPU_USE_PROFILE_TOOL")) {
      exports_util.assert(this.dummyContext !== undefined, () => `Fail to get context for profiling tool`);
      this.dummyContext.getCurrentTexture();
    }
    return values;
  }
  convertAndCacheOnCPU(dataId, data) {
    const tensorData = this.tensorMap.get(dataId);
    tensorData.values = data;
    return tensorData.values;
  }
  readSync(dataId) {
    const tensorData = this.tensorMap.get(dataId);
    const { values, complexTensorInfos } = tensorData;
    if (values != null || tensorData.dtype === "string") {
      return values;
    }
    if (tensorData.dtype === "complex64") {
      const realValues = this.readSync(complexTensorInfos.real.dataId);
      const imagValues = this.readSync(complexTensorInfos.imag.dataId);
      const complexVals = exports_util.convertBackendValuesAndArrayBuffer(exports_backend_util.mergeRealAndImagArrays(realValues, imagValues).buffer, "float32");
      this.convertAndCacheOnCPU(dataId, complexVals);
      return complexVals;
    }
    if (!this.hasReadSyncWarned) {
      this.hasReadSyncWarned = true;
      console.warn(`The performance of synchronously reading data from GPU to CPU is ` + `poor on the webgpu backend, please use asynchronous APIs instead.`);
    }
    const alphaModes = ["opaque", "premultiplied"];
    const buffer9 = tensorData.resource;
    const bufferSize = buffer9.size;
    exports_util.assert(bufferSize % 4 === 0, () => "Because there is 4 bytes for " + "one pixel, buffer size must be multiple of 4.");
    const pixelsSize = bufferSize / 4;
    const valsGPU = new ArrayBuffer(bufferSize);
    const canvasWidth = 256, canvasHeight = 256;
    const stagingDeviceStorage = alphaModes.map((_) => new OffscreenCanvas(canvasWidth, canvasHeight));
    const stagingHostStorage = new OffscreenCanvas(canvasWidth, canvasHeight);
    this.endComputePassEncoder();
    stagingDeviceStorage.map((storage, index) => {
      const context = storage.getContext("webgpu");
      context.configure({
        device: this.device,
        format: "bgra8unorm",
        usage: GPUTextureUsage.COPY_DST,
        alphaMode: alphaModes[index]
      });
      return context.getCurrentTexture();
    }).map((texture, index) => {
      const bytesPerRow = canvasWidth * 4;
      const readDataGPUToCPU = (width2, height2, offset2) => {
        this.ensureCommandEncoderReady();
        this.commandEncoder.copyBufferToTexture({
          buffer: buffer9,
          bytesPerRow,
          offset: offset2
        }, {
          texture
        }, {
          width: width2,
          height: height2
        });
        this.submitQueue();
        const context = stagingHostStorage.getContext("2d", {
          willReadFrequently: true
        });
        context.clearRect(0, 0, width2, height2);
        context.drawImage(stagingDeviceStorage[index], 0, 0);
        const stagingValues = context.getImageData(0, 0, width2, height2).data;
        const alphaMode = alphaModes[index];
        const span = new Uint8ClampedArray(valsGPU, offset2, width2 * height2 * 4);
        for (let k = 0;k < span.length; k += 4) {
          if (alphaMode === "premultiplied") {
            span[k + 3] = stagingValues[k + 3];
          } else {
            const value = stagingValues[k];
            span[k] = stagingValues[k + 2];
            span[k + 1] = stagingValues[k + 1];
            span[k + 2] = value;
          }
        }
      };
      const fullyReadCount = Math.floor(pixelsSize / (canvasWidth * canvasHeight));
      let width = canvasWidth, height = canvasHeight, offset = 0;
      for (let i = 0;i < fullyReadCount; i++) {
        readDataGPUToCPU(width, height, offset);
        offset += canvasWidth * canvasHeight * 4;
      }
      const remainSize = pixelsSize % (canvasWidth * canvasHeight);
      height = Math.floor(remainSize / canvasWidth);
      if (height > 0) {
        readDataGPUToCPU(width, height, offset);
        offset += height * (canvasWidth * 4);
      }
      width = remainSize % canvasWidth;
      if (width > 0) {
        readDataGPUToCPU(width, 1, offset);
      }
    });
    const vals = exports_util.convertBackendValuesAndArrayBuffer(valsGPU, tensorData.dtype);
    this.convertAndCacheOnCPU(dataId, vals);
    return vals;
  }
  async read(dataId) {
    if (!this.tensorMap.has(dataId)) {
      throw new Error(`Tensor ${dataId} was not registered!`);
    }
    const tensorData = this.tensorMap.get(dataId);
    const { values } = tensorData;
    if (values != null) {
      return values;
    }
    let vals;
    if (tensorData.dtype === "complex64") {
      const ps = await Promise.all([
        this.read(tensorData.complexTensorInfos.real.dataId),
        this.read(tensorData.complexTensorInfos.imag.dataId)
      ]);
      const realValues = ps[0];
      const imagValues = ps[1];
      vals = exports_backend_util.mergeRealAndImagArrays(realValues, imagValues);
    } else {
      const data = await this.getBufferData(tensorData.resource);
      vals = exports_util.convertBackendValuesAndArrayBuffer(data, tensorData.dtype);
    }
    this.convertAndCacheOnCPU(dataId, vals);
    return vals;
  }
  copyBuffer(srcBuffer) {
    const size = srcBuffer.size;
    const usage = srcBuffer.usage;
    const dstBuffer = this.bufferManager.acquireBuffer(size, usage);
    this.ensureCommandEncoderReady();
    this.endComputePassEncoder();
    this.commandEncoder.copyBufferToBuffer(srcBuffer, 0, dstBuffer, 0, size);
    this.submitQueue();
    return dstBuffer;
  }
  createTensorFromGPUData(webGPUData, shape, dtype) {
    let buffer9 = webGPUData.buffer;
    if (dtype === "complex64") {
      throw new Error(`Cannot write to a complex64 dtype. `);
    }
    const dataId = { id: this.nextDataId() };
    this.tensorMap.set(dataId, {
      dtype,
      shape,
      values: null,
      refCount: 1,
      external: webGPUData.zeroCopy
    });
    const tensorData = this.tensorMap.get(dataId);
    const size = GPUBytesPerElement(tensorData.dtype) * exports_util.sizeFromShape(tensorData.shape);
    if (webGPUData.buffer.size < size) {
      throw new Error(`GPUBuffer size(${webGPUData.buffer.size}) is smaller than tensor size(${size})!`);
    } else if ((webGPUData.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) !== (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) {
      throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");
    }
    if (webGPUData.zeroCopy !== true) {
      buffer9 = this.copyBuffer(buffer9);
    }
    tensorData.resource = buffer9;
    return engine7().makeTensorFromDataId(dataId, shape, dtype, this);
  }
  readToGPU(dataId) {
    const srcTensorData = this.tensorMap.get(dataId);
    const { values, dtype, shape, resource } = srcTensorData;
    if (dtype === "complex64") {
      throw new Error("Does not support reading buffer for complex64 dtype.");
    }
    if (resource == null) {
      if (values != null) {
        throw new Error("Data is not on GPU but on CPU.");
      } else {
        throw new Error("There is no data on GPU or CPU.");
      }
    }
    const srcBuffer = resource;
    const size = srcBuffer.size;
    const usage = srcBuffer.usage;
    const buffer9 = this.bufferManager.acquireBuffer(size, usage);
    this.ensureCommandEncoderReady();
    this.endComputePassEncoder();
    this.commandEncoder.copyBufferToBuffer(resource, 0, buffer9, 0, size);
    this.submitQueue();
    const tensorInfo = this.makeTensorInfo(shape, dtype);
    const tensorRef = engine7().makeTensorFromTensorInfo(tensorInfo);
    const tensorData = this.tensorMap.get(tensorInfo.dataId);
    tensorData.resource = buffer9;
    return { tensorRef, buffer: buffer9 };
  }
  bufferSync(t) {
    const data = this.readSync(t.dataId);
    if (t.dtype === "string") {
      try {
        const strings = data.map((d) => exports_util.decodeString(d));
        return buffer(t.shape, t.dtype, strings);
      } catch (_a) {
        throw new Error("Failed to decode encoded string bytes into utf-8");
      }
    }
    return buffer(t.shape, t.dtype, data);
  }
  async time(f) {
    if (!this.supportTimestampQuery && !this.hasTimestampQueryWarned) {
      console.warn(`This device doesn't support timestamp-query extension. ` + `Start Chrome browser with flag ` + `--enable-dawn-features=allow_unsafe_apis to try it again. ` + `Otherwise, zero will be shown for the kernel time when profiling ` + `mode is enabled.`);
      this.hasTimestampQueryWarned = true;
    }
    const oldActiveTimers = this.activeTimers;
    const newActiveTimers = [];
    let outerMostTime = false;
    if (this.programTimersStack == null) {
      this.programTimersStack = newActiveTimers;
      outerMostTime = true;
    } else {
      this.activeTimers.push(newActiveTimers);
    }
    this.activeTimers = newActiveTimers;
    f();
    const flattenedActiveTimerQueries = exports_util.flatten(this.activeTimers.map((d) => d.query)).filter((d) => d != null);
    const flattenedActiveTimerNames = exports_util.flatten(this.activeTimers.map((d) => d.name)).filter((d) => d != null);
    this.activeTimers = oldActiveTimers;
    if (outerMostTime) {
      this.programTimersStack = null;
    }
    const res = {
      uploadWaitMs: this.uploadWaitMs,
      downloadWaitMs: this.downloadWaitMs,
      kernelMs: null,
      wallMs: null
    };
    const kernelMs = await Promise.all(flattenedActiveTimerQueries);
    res["kernelMs"] = exports_util.sum(kernelMs);
    res["getExtraProfileInfo"] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d })).map((d) => `${d.name}: ${d.ms}`).join(", ");
    this.uploadWaitMs = 0;
    this.downloadWaitMs = 0;
    return res;
  }
  makeTensorInfo(shape, dtype, values) {
    if (dtype === "string" && values != null && values.length > 0 && exports_util.isString(values[0])) {
      values = values.map((d) => exports_util.encodeString(d));
    }
    const dataId = this.write(values, shape, dtype);
    return { dataId, shape, dtype };
  }
  tensorToBinding(tensor153) {
    if (!tensor153) {
      return null;
    }
    const tensorData = this.tensorMap.get(tensor153.dataId);
    const resource = tensorData.resource;
    if (resource instanceof GPUBuffer) {
      return { buffer: resource };
    }
    if (resource instanceof GPUTexture) {
      return resource.createView();
    }
    return resource;
  }
  uploadToGPU(dataId) {
    const tensorData = this.tensorMap.get(dataId);
    if (tensorData.resource != null) {
      return;
    }
    const size = GPUBytesPerElement(tensorData.dtype) * exports_util.sizeFromShape(tensorData.shape);
    let buffer9;
    const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
    if (tensorData.values) {
      buffer9 = this.bufferManager.acquireBuffer(size, usage, true);
      if (buffer9.mapState === "unmapped") {
        const stagingBuffer = this.bufferManager.acquireBuffer(size, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, true, false);
        const arrayBuffer = stagingBuffer.getMappedRange();
        if (tensorData.dtype === "int32" || tensorData.dtype === "bool") {
          new Int32Array(arrayBuffer).set(tensorData.values);
        } else {
          new Float32Array(arrayBuffer).set(tensorData.values);
        }
        stagingBuffer.unmap();
        this.ensureCommandEncoderReady();
        this.endComputePassEncoder();
        this.commandEncoder.copyBufferToBuffer(stagingBuffer, 0, buffer9, 0, size);
        this.stagingPendingDisposal.push(stagingBuffer);
      } else {
        const arrayBuffer = buffer9.getMappedRange();
        if (tensorData.dtype === "int32" || tensorData.dtype === "bool") {
          new Int32Array(arrayBuffer).set(tensorData.values);
        } else {
          new Float32Array(arrayBuffer).set(tensorData.values);
        }
        buffer9.unmap();
      }
      tensorData.values = null;
    } else {
      buffer9 = this.bufferManager.acquireBuffer(size, usage);
    }
    tensorData.resource = buffer9;
  }
  makeUniforms(programUniform) {
    let currentOffset = 0;
    let preLength = 0;
    const offsets = [];
    let maxAlignmentOfField = 1;
    programUniform.forEach((d) => {
      if (d.data.length === 0) {
        d.data = [1];
      }
      let baseAlignment;
      switch (d.data.length) {
        case 1:
          baseAlignment = 4;
          break;
        case 2:
          baseAlignment = 8;
          break;
        case 3:
          baseAlignment = 16;
          break;
        case 4:
          baseAlignment = 16;
          break;
        case 5:
          baseAlignment = 16;
          break;
        case 6:
          baseAlignment = 16;
          break;
        default:
          exports_util.assert(false, () => `Unsupported ${d.data.length}D shape`);
      }
      if (preLength === 5 || preLength === 6) {
        baseAlignment = 16;
      }
      if (baseAlignment > maxAlignmentOfField) {
        maxAlignmentOfField = baseAlignment;
      }
      currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
      preLength = d.data.length;
      offsets.push(currentOffset);
      currentOffset += d.data.length * 4;
    });
    currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
    const arrayBuffer = new ArrayBuffer(currentOffset);
    programUniform.forEach((d, i) => {
      const offset = offsets[i];
      if (d.type === "int32") {
        new Int32Array(arrayBuffer, offset, d.data.length).set(d.data);
      } else if (d.type === "uint32") {
        new Uint32Array(arrayBuffer, offset, d.data.length).set(d.data);
      } else {
        new Float32Array(arrayBuffer, offset, d.data.length).set(d.data);
      }
    });
    const uniformBuffer = this.bufferManager.acquireBuffer(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
    this.queue.writeBuffer(uniformBuffer, 0, arrayBuffer, 0, currentOffset);
    this.uniformPendingDisposal.push(uniformBuffer);
    return { offset: 0, size: currentOffset, buffer: uniformBuffer };
  }
  runWebGPUProgram(program, inputs, outputDtype, programDefinedUniform, output) {
    if (!output) {
      output = this.makeTensorInfo(program.outputShape, outputDtype);
    }
    if (exports_util.sizeFromShape(output.shape) === 0) {
      this.tensorMap.get(output.dataId).values = exports_util.getTypedArrayFromDType(output.dtype, 0);
      return output;
    }
    this.uploadToGPU(output.dataId);
    program.dispatch = reshapeDispatch(this.device, program);
    const inputsData = inputs.map((input2, i) => {
      if (input2.dtype === "complex64") {
        throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` + `dtypes, please separate the program into real and imaginary ` + `parts.`);
      }
      this.uploadToGPU(input2.dataId);
      return {
        dtype: this.tensorMap.get(input2.dataId).dtype,
        shape: input2.shape,
        name: program.variableNames[i]
      };
    });
    program.shaderKey = makeShaderKey2(program, inputsData, output);
    const parallelCompilation = env().getBool("WEBGPU_ENGINE_COMPILE_ONLY");
    if (!(program.shaderKey in this.pipelineCache)) {
      this.pipelineCache[program.shaderKey] = compileProgram2(this.device, program, inputsData, output, parallelCompilation);
    }
    program.pipeline = this.pipelineCache[program.shaderKey];
    if (!parallelCompilation) {
      this.recordAndSubmit(program, output, inputs, programDefinedUniform);
    }
    return output;
  }
  recordAndSubmit(program, output, inputs, programDefinedUniform) {
    if (program.pipeline instanceof Promise) {
      throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");
    }
    let programUniform = [];
    let bufferShapes = [];
    const uniformsType = "int32";
    if (program.pixelsOpType == null) {
      programUniform.push({ type: "float32", data: [NaN] }, { type: "float32", data: [Infinity] });
      bufferShapes = inputs.concat(output).map((d) => d.shape);
      const uniformsType2 = "int32";
      bufferShapes.map((d) => {
        programUniform.push({ type: uniformsType2, data: d });
        const strides = exports_util.computeStrides(d);
        programUniform.push({ type: uniformsType2, data: strides });
      });
    } else {
      const strides = exports_util.computeStrides(output.shape);
      programUniform.push({ type: uniformsType, data: strides });
    }
    if (program.size) {
      const size = exports_util.sizeFromShape(program.outputShape);
      programUniform.push({
        type: uniformsType,
        data: [program.outputComponent ? size / program.outputComponent : size]
      });
    }
    if (programDefinedUniform) {
      programUniform = [...programUniform, ...programDefinedUniform];
    }
    const bindings = [
      this.tensorToBinding(output),
      ...inputs.map((t) => this.tensorToBinding(t)),
      this.makeUniforms(programUniform)
    ];
    inputs.forEach((input2) => {
      this.commandQueueOwnedIds.add(input2.dataId);
    });
    this.commandQueueOwnedIds.add(output.dataId);
    const bindGroup = this.device.createBindGroup({
      layout: program.pipeline.getBindGroupLayout(0),
      entries: bindings.map((b, i) => ({ binding: i, resource: b }))
    });
    const shouldTimeProgram = this.activeTimers != null;
    this.ensureCommandEncoderReady();
    const computePassDescriptor = {};
    if (shouldTimeProgram && this.supportTimestampQuery) {
      this.endComputePassEncoder();
      if (this.querySet == null) {
        this.querySet = this.device.createQuerySet({
          type: "timestamp",
          count: this.querySetCount
        });
      }
      computePassDescriptor.timestampWrites = {
        querySet: this.querySet,
        beginningOfPassWriteIndex: 0,
        endOfPassWriteIndex: 1
      };
      this.computePassEncoder = this.commandEncoder.beginComputePass(computePassDescriptor);
    } else if (!this.computePassEncoder) {
      this.computePassEncoder = this.commandEncoder.beginComputePass(computePassDescriptor);
    }
    this.computePassEncoder.setPipeline(program.pipeline);
    this.computePassEncoder.setBindGroup(0, bindGroup);
    this.computePassEncoder.dispatchWorkgroups(program.dispatch[0], program.dispatch[1], program.dispatch[2]);
    this.dispatchCountInPass++;
    if (shouldTimeProgram || env().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchCountInPass || program.pixelsOpType === PixelsOpType.DRAW) {
      this.endComputePassEncoder();
      if (shouldTimeProgram) {
        this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime() });
      } else {
        this.submitQueue();
      }
    }
  }
  async getQueryTime() {
    if (!this.supportTimestampQuery) {
      return 0;
    }
    if (this.queryResolveBuffer == null) {
      this.queryResolveBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE);
    }
    this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);
    const queryStagingBuffer = this.bufferManager.acquireBuffer(this.querySetCount * 8, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
    this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, queryStagingBuffer, 0, this.querySetCount * 8);
    this.submitQueue();
    await queryStagingBuffer.mapAsync(GPUMapMode.READ);
    const arrayBuffer = new BigUint64Array(queryStagingBuffer.getMappedRange());
    const time2 = Number(arrayBuffer[1] - arrayBuffer[0]) / 1e6;
    queryStagingBuffer.unmap();
    this.bufferManager.releaseBuffer(queryStagingBuffer);
    return time2;
  }
  shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD2) {
    return env().getBool("WEBGPU_CPU_FORWARD") && inputs.every((input2) => this.tensorMap.get(input2.dataId).resource == null && exports_util.sizeFromShape(input2.shape) < sizeThreshold);
  }
  numDataIds() {
    return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;
  }
  dispose() {
    if (this.disposed) {
      return;
    }
    if (this.querySet != null) {
      this.querySet.destroy();
    }
    this.bufferManager.dispose();
    this.textureManager.dispose();
    this.disposed = true;
  }
}
WebGPUBackend.nextDataId = 0;
// node_modules/@tensorflow/tfjs-backend-webgpu/dist/base.js
if (isWebGPUSupported()) {
  registerBackend("webgpu", async () => {
    const gpuDescriptor = {
      powerPreference: env().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance"
    };
    const adapter = await navigator.gpu.requestAdapter(gpuDescriptor);
    const deviceDescriptor = {};
    const requiredFeatures = [];
    if (adapter.features.has("timestamp-query")) {
      requiredFeatures.push("timestamp-query");
    }
    if (adapter.features.has("bgra8unorm-storage")) {
      requiredFeatures.push(["bgra8unorm-storage"]);
    }
    deviceDescriptor.requiredFeatures = requiredFeatures;
    const adapterLimits = adapter.limits;
    deviceDescriptor.requiredLimits = {
      maxComputeWorkgroupStorageSize: adapterLimits.maxComputeWorkgroupStorageSize,
      maxComputeWorkgroupsPerDimension: adapterLimits.maxComputeWorkgroupsPerDimension,
      maxStorageBufferBindingSize: adapterLimits.maxStorageBufferBindingSize,
      maxBufferSize: adapterLimits.maxBufferSize,
      maxComputeWorkgroupSizeX: adapterLimits.maxComputeWorkgroupSizeX,
      maxComputeInvocationsPerWorkgroup: adapterLimits.maxComputeInvocationsPerWorkgroup
    };
    const device = await adapter.requestDevice(deviceDescriptor);
    const adapterInfo = "info" in adapter ? adapter.info : ("requestAdapterInfo" in adapter) ? await adapter.requestAdapterInfo() : undefined;
    return new WebGPUBackend(device, adapterInfo);
  }, 3);
}
// node_modules/@tensorflow/tfjs-backend-webgpu/dist/register_all_kernels.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/_FusedMatMul.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BatchMatMul_impl.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/matmul_packed_webgpu.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/binary_op_util.js
function getBinaryOpString(type, useVec4) {
  let doOpSnippet;
  do {
    switch (type) {
      case BinaryOpType.ATAN2:
        doOpSnippet = ATAN22;
        break;
      case BinaryOpType.MAX:
        doOpSnippet = MAX;
        break;
      case BinaryOpType.MIN:
        doOpSnippet = MIN;
        break;
      case BinaryOpType.MOD:
        doOpSnippet = useVec4 ? MOD_VEC4 : MOD2;
        break;
      case BinaryOpType.NOT_EQUAL:
        doOpSnippet = useVec4 ? NOT_EQUAL_VEC4 : NOT_EQUAL2;
        break;
      case BinaryOpType.POW:
        doOpSnippet = useVec4 ? POW_VEC4 : POW2;
        break;
      default:
        continue;
    }
    let isNaN5;
    let dTypeN;
    let boolN;
    if (useVec4) {
      isNaN5 = "isnanVec4";
      dTypeN = "vec4<f32>";
      boolN = "vec4<bool>";
    } else {
      isNaN5 = "isnan";
      dTypeN = "f32";
      boolN = "bool";
    }
    return `
      let aIsNaN = ${isNaN5}(a);
      let aPostLegalization = select(a, ${dTypeN}(42), aIsNaN);
      let bIsNaN = ${isNaN5}(b);
      let bPostLegalization = select(b, ${dTypeN}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${doOpSnippet}
        return select(
            resultTemp, ${dTypeN}(valueForNaN),
            ${boolN}(isNaN) | aIsNaN | bIsNaN);
      }
    `;
  } while (false);
  switch (type) {
    case BinaryOpType.ADD:
      doOpSnippet = ADD2;
      break;
    case BinaryOpType.COMPLEX_MULTIPLY_IMAG:
      doOpSnippet = COMPLEX_MULTIPLY_IMAG;
      break;
    case BinaryOpType.COMPLEX_MULTIPLY_REAL:
      doOpSnippet = COMPLEX_MULTIPLY_REAL;
      break;
    case BinaryOpType.DIV:
      doOpSnippet = DIV2;
      break;
    case BinaryOpType.ELU_DER:
      doOpSnippet = ELU_DER2;
      break;
    case BinaryOpType.EQUAL:
      doOpSnippet = EQUAL2;
      break;
    case BinaryOpType.FLOOR_DIV:
      doOpSnippet = FLOOR_DIV;
      break;
    case BinaryOpType.GREATER:
      doOpSnippet = GREATER2;
      break;
    case BinaryOpType.GREATER_EQUAL:
      doOpSnippet = GREATER_EQUAL2;
      break;
    case BinaryOpType.LESS:
      doOpSnippet = LESS2;
      break;
    case BinaryOpType.LESS_EQUAL:
      doOpSnippet = LESS_EQUAL2;
      break;
    case BinaryOpType.LOGICAL_AND:
      return useVec4 ? LOGICAL_AND_VEC4 : LOGICAL_AND2;
    case BinaryOpType.LOGICAL_OR:
      return useVec4 ? LOGICAL_OR_VEC4 : LOGICAL_OR2;
    case BinaryOpType.MUL:
      doOpSnippet = MUL2;
      break;
    case BinaryOpType.PRELU:
      return useVec4 ? PRELU_VEC4 : PRELU2;
    case BinaryOpType.SQUARED_DIFFERENCE:
      doOpSnippet = SQUARED_DIFFERENCE2;
      break;
    case BinaryOpType.SUB:
      doOpSnippet = SUB2;
      break;
    default:
  }
  return `
    ${doOpSnippet}
    return resultTemp;
  `;
}
var BinaryOpType;
(function(BinaryOpType2) {
  BinaryOpType2[BinaryOpType2["ADD"] = 0] = "ADD";
  BinaryOpType2[BinaryOpType2["ATAN2"] = 1] = "ATAN2";
  BinaryOpType2[BinaryOpType2["COMPLEX_MULTIPLY_IMAG"] = 2] = "COMPLEX_MULTIPLY_IMAG";
  BinaryOpType2[BinaryOpType2["COMPLEX_MULTIPLY_REAL"] = 3] = "COMPLEX_MULTIPLY_REAL";
  BinaryOpType2[BinaryOpType2["DIV"] = 4] = "DIV";
  BinaryOpType2[BinaryOpType2["ELU_DER"] = 5] = "ELU_DER";
  BinaryOpType2[BinaryOpType2["EQUAL"] = 6] = "EQUAL";
  BinaryOpType2[BinaryOpType2["FLOOR_DIV"] = 7] = "FLOOR_DIV";
  BinaryOpType2[BinaryOpType2["GREATER"] = 8] = "GREATER";
  BinaryOpType2[BinaryOpType2["GREATER_EQUAL"] = 9] = "GREATER_EQUAL";
  BinaryOpType2[BinaryOpType2["LESS"] = 10] = "LESS";
  BinaryOpType2[BinaryOpType2["LESS_EQUAL"] = 11] = "LESS_EQUAL";
  BinaryOpType2[BinaryOpType2["LOGICAL_AND"] = 12] = "LOGICAL_AND";
  BinaryOpType2[BinaryOpType2["LOGICAL_OR"] = 13] = "LOGICAL_OR";
  BinaryOpType2[BinaryOpType2["MAX"] = 14] = "MAX";
  BinaryOpType2[BinaryOpType2["MIN"] = 15] = "MIN";
  BinaryOpType2[BinaryOpType2["MOD"] = 16] = "MOD";
  BinaryOpType2[BinaryOpType2["MUL"] = 17] = "MUL";
  BinaryOpType2[BinaryOpType2["NOT_EQUAL"] = 18] = "NOT_EQUAL";
  BinaryOpType2[BinaryOpType2["POW"] = 19] = "POW";
  BinaryOpType2[BinaryOpType2["PRELU"] = 20] = "PRELU";
  BinaryOpType2[BinaryOpType2["SQUARED_DIFFERENCE"] = 21] = "SQUARED_DIFFERENCE";
  BinaryOpType2[BinaryOpType2["SUB"] = 22] = "SUB";
})(BinaryOpType || (BinaryOpType = {}));
var ADD2 = "let resultTemp = a + b;";
var ATAN22 = "let resultTemp = atan2(a, b);";
var COMPLEX_MULTIPLY_REAL = "let resultTemp = areal * breal - aimag * bimag;";
var COMPLEX_MULTIPLY_IMAG = "let resultTemp = areal * bimag + aimag * breal;";
var DIV2 = "let resultTemp = a / b;";
var ELU_DER2 = "let resultTemp = select(a * (b + 1.0), a, b >= b - b);";
var EQUAL2 = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`;
var FLOOR_DIV = `
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`;
var GREATER2 = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`;
var GREATER_EQUAL2 = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`;
var LESS2 = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`;
var LESS_EQUAL2 = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`;
var LOGICAL_AND2 = "return f32(a >= 1.0 && b >= 1.0);";
var LOGICAL_AND_VEC4 = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`;
var LOGICAL_OR2 = "return f32(a >= 1.0 || b >= 1.0);";
var LOGICAL_OR_VEC4 = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`;
var MAX = "let resultTemp = max(a, b);";
var MIN = "let resultTemp = min(a, b);";
var MOD2 = `
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`;
var MOD_VEC4 = `
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`;
var MUL2 = "let resultTemp = a * b;";
var NOT_EQUAL2 = `
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`;
var NOT_EQUAL_VEC4 = `
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`;
var POW2 = `
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`;
var POW_VEC4 = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`;
var PRELU2 = `if (a < 0.0) { return b * a; }  return a;`;
var PRELU_VEC4 = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`;
var SQUARED_DIFFERENCE2 = "let resultTemp = (a - b) * (a - b);";
var SUB2 = "let resultTemp = a - b;";

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/unary_op_util.js
init_dist();
function getUnaryOpString(type, useVec4) {
  switch (type) {
    case UnaryOpType.ABS:
      return ABS3;
    case UnaryOpType.ACOS:
      return ACOS2;
    case UnaryOpType.ACOSH:
      return ACOSH2;
    case UnaryOpType.ASIN:
      return ASIN2;
    case UnaryOpType.ASINH:
      return ASINH2;
    case UnaryOpType.ATAN:
      return ATAN3;
    case UnaryOpType.ATANH:
      return ATANH2;
    case UnaryOpType.COS:
      return COS2;
    case UnaryOpType.COSH:
      return COSH2;
    case UnaryOpType.CEIL:
      return CEIL2;
    case UnaryOpType.ELU:
      return useVec4 ? ELU_VEC4 : ELU5;
    case UnaryOpType.ERF:
      return ERF2;
    case UnaryOpType.EXP:
      return EXP2;
    case UnaryOpType.EXPM1:
      return EXPM12;
    case UnaryOpType.FLOOR:
      return FLOOR2;
    case UnaryOpType.IS_FINITE:
      return IS_FINITE2;
    case UnaryOpType.IS_INF:
      return IS_INF2;
    case UnaryOpType.IS_NAN:
      return IS_NAN2;
    case UnaryOpType.LINEAR:
      return LINEAR3;
    case UnaryOpType.LOG:
      return LOG2;
    case UnaryOpType.LOG1P:
      return LOG1P2;
    case UnaryOpType.LOGICAL_NOT:
      return LOGICAL_NOT2;
    case UnaryOpType.NEG:
      return NEG2;
    case UnaryOpType.LEAKYRELU:
      return useVec4 ? LEAKYRELU_VEC4 : LEAKYRELU2;
    case UnaryOpType.RECIPROCAL:
      return RECIPROCAL2;
    case UnaryOpType.RELU:
      return useVec4 ? RELU_VEC4 : RELU4;
    case UnaryOpType.RELU6:
      return useVec4 ? RELU6_VEC4 : RELU64;
    case UnaryOpType.ROUND:
      return ROUND2;
    case UnaryOpType.RSQRT:
      return RSQRT2;
    case UnaryOpType.SELU:
      return SELU2;
    case UnaryOpType.SIGMOID:
      return SIGMOID4;
    case UnaryOpType.SIGN:
      return SIGN2;
    case UnaryOpType.SIN:
      return SIN2;
    case UnaryOpType.SINH:
      return SINH2;
    case UnaryOpType.SOFTPLUS:
      return SOFTPLUS2;
    case UnaryOpType.SQRT:
      return SQRT2;
    case UnaryOpType.SQUARE:
      return SQUARE2;
    case UnaryOpType.STEP:
      return STEP;
    case UnaryOpType.TAN:
      return TAN2;
    case UnaryOpType.TANH:
      return TANH2;
    case UnaryOpType.TO_INT:
      return TO_INT2;
    default:
      throw new Error(`BinaryType ${type} is not implemented!`);
  }
}
var UnaryOpType;
(function(UnaryOpType2) {
  UnaryOpType2[UnaryOpType2["ABS"] = 0] = "ABS";
  UnaryOpType2[UnaryOpType2["ACOS"] = 1] = "ACOS";
  UnaryOpType2[UnaryOpType2["ACOSH"] = 2] = "ACOSH";
  UnaryOpType2[UnaryOpType2["ASIN"] = 3] = "ASIN";
  UnaryOpType2[UnaryOpType2["ASINH"] = 4] = "ASINH";
  UnaryOpType2[UnaryOpType2["ATAN"] = 5] = "ATAN";
  UnaryOpType2[UnaryOpType2["ATANH"] = 6] = "ATANH";
  UnaryOpType2[UnaryOpType2["CEIL"] = 7] = "CEIL";
  UnaryOpType2[UnaryOpType2["COS"] = 8] = "COS";
  UnaryOpType2[UnaryOpType2["COSH"] = 9] = "COSH";
  UnaryOpType2[UnaryOpType2["ELU"] = 10] = "ELU";
  UnaryOpType2[UnaryOpType2["ERF"] = 11] = "ERF";
  UnaryOpType2[UnaryOpType2["EXP"] = 12] = "EXP";
  UnaryOpType2[UnaryOpType2["EXPM1"] = 13] = "EXPM1";
  UnaryOpType2[UnaryOpType2["FLOOR"] = 14] = "FLOOR";
  UnaryOpType2[UnaryOpType2["IS_FINITE"] = 15] = "IS_FINITE";
  UnaryOpType2[UnaryOpType2["IS_INF"] = 16] = "IS_INF";
  UnaryOpType2[UnaryOpType2["IS_NAN"] = 17] = "IS_NAN";
  UnaryOpType2[UnaryOpType2["LINEAR"] = 18] = "LINEAR";
  UnaryOpType2[UnaryOpType2["LOG"] = 19] = "LOG";
  UnaryOpType2[UnaryOpType2["LOG1P"] = 20] = "LOG1P";
  UnaryOpType2[UnaryOpType2["LOGICAL_NOT"] = 21] = "LOGICAL_NOT";
  UnaryOpType2[UnaryOpType2["NEG"] = 22] = "NEG";
  UnaryOpType2[UnaryOpType2["RELU"] = 23] = "RELU";
  UnaryOpType2[UnaryOpType2["RELU6"] = 24] = "RELU6";
  UnaryOpType2[UnaryOpType2["LEAKYRELU"] = 25] = "LEAKYRELU";
  UnaryOpType2[UnaryOpType2["RECIPROCAL"] = 26] = "RECIPROCAL";
  UnaryOpType2[UnaryOpType2["ROUND"] = 27] = "ROUND";
  UnaryOpType2[UnaryOpType2["RSQRT"] = 28] = "RSQRT";
  UnaryOpType2[UnaryOpType2["SELU"] = 29] = "SELU";
  UnaryOpType2[UnaryOpType2["SIGMOID"] = 30] = "SIGMOID";
  UnaryOpType2[UnaryOpType2["SIGN"] = 31] = "SIGN";
  UnaryOpType2[UnaryOpType2["SIN"] = 32] = "SIN";
  UnaryOpType2[UnaryOpType2["SINH"] = 33] = "SINH";
  UnaryOpType2[UnaryOpType2["SOFTPLUS"] = 34] = "SOFTPLUS";
  UnaryOpType2[UnaryOpType2["SQRT"] = 35] = "SQRT";
  UnaryOpType2[UnaryOpType2["SQUARE"] = 36] = "SQUARE";
  UnaryOpType2[UnaryOpType2["STEP"] = 37] = "STEP";
  UnaryOpType2[UnaryOpType2["TAN"] = 38] = "TAN";
  UnaryOpType2[UnaryOpType2["TANH"] = 39] = "TANH";
  UnaryOpType2[UnaryOpType2["TO_INT"] = 40] = "TO_INT";
})(UnaryOpType || (UnaryOpType = {}));
var ABS3 = `return abs(a);`;
var ACOS2 = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`;
var ACOSH2 = `
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`;
var ASIN2 = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`;
var ASINH2 = `return asinh(a);`;
var ATAN3 = `
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`;
var ATANH2 = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`;
var CEIL2 = `return ceil(a);`;
var COS2 = `return cos(a);`;
var COSH2 = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`;
var EXPM12 = `return exp(a) - 1.0;`;
var ELU5 = `if (a >= 0.0) { return a; }  return (exp(a) - 1.0);`;
var ELU_VEC4 = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`;
var ERF2 = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${exports_backend_util.ERF_P};
  let a1 = ${exports_backend_util.ERF_A1};
  let a2 = ${exports_backend_util.ERF_A2};
  let a3 = ${exports_backend_util.ERF_A3};
  let a4 = ${exports_backend_util.ERF_A4};
  let a5 = ${exports_backend_util.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`;
var EXP2 = `return exp(a);`;
var FLOOR2 = `return floor(a);`;
var IS_FINITE2 = `return f32(!isnan(a) && !isinf(a));`;
var IS_INF2 = `return f32(isinf(a));`;
var IS_NAN2 = `return f32(isnan(a));`;
var LINEAR3 = `return a;`;
var LOG2 = `if (a < 0.0) { return uniforms.NAN; }
  return log(a);`;
var LOG1P2 = `
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`;
var LOGICAL_NOT2 = `return f32(!(a >= 1.0));`;
var NEG2 = `return -a;`;
var LEAKYRELU2 = `if (a < 0.0) { return uniforms.alpha * a; } return a;`;
var LEAKYRELU_VEC4 = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`;
var RECIPROCAL2 = `return 1.0 / a;`;
var RELU4 = `return select(a, 0.0, a < 0.0);`;
var RELU64 = "return clamp(a, 0.0, 6.0);";
var RELU6_VEC4 = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));";
var RELU_VEC4 = `
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`;
var ROUND2 = `return round(a);`;
var RSQRT2 = `return inverseSqrt(a);`;
var SELU2 = `
  if (a >= 0.0) {
    return ${exports_backend_util.SELU_SCALE} * a;
  } else {
    return ${exports_backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`;
var SIGMOID4 = `return 1.0 / (1.0 + exp(-1.0 * a));`;
var SIGN2 = `return sign(a);`;
var SIN2 = `return sin(a);`;
var SINH2 = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`;
var SOFTPLUS2 = `
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`;
var SQRT2 = `return sqrt(a);`;
var SQUARE2 = `return a * a;`;
var STEP = `
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`;
var TAN2 = `return tan(a);`;
var TANH2 = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;
var TO_INT2 = `return f32(i32((a)));`;

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/activation_util.js
function activationFnSnippet(activation2, hasPreluActivationWeights = false, packed = false, coordsLength = 3) {
  if (activation2 === null) {
    return "";
  }
  let activationOpSnippet = "";
  if (activation2 === "linear") {
    activationOpSnippet = getUnaryOpString(UnaryOpType.LINEAR);
  } else if (activation2 === "relu") {
    activationOpSnippet = getUnaryOpString(UnaryOpType.RELU, packed);
  } else if (activation2 === "elu") {
    activationOpSnippet = getUnaryOpString(UnaryOpType.ELU, packed);
  } else if (activation2 === "relu6") {
    activationOpSnippet = getUnaryOpString(UnaryOpType.RELU6, packed);
  } else if (activation2 === "prelu") {
    activationOpSnippet = getBinaryOpString(BinaryOpType.PRELU, packed);
  } else if (activation2 === "sigmoid") {
    activationOpSnippet = getUnaryOpString(UnaryOpType.SIGMOID, packed);
  } else if (activation2 === "leakyrelu") {
    activationOpSnippet = getUnaryOpString(UnaryOpType.LEAKYRELU, packed);
  } else {
    throw new Error(`Activation ${activation2} has not been implemented for the WebGPU backend.`);
  }
  const elementSize = packed ? 4 : 1;
  const dataType = typeSnippet(elementSize);
  let activationFnSnippet2 = "";
  if (hasPreluActivationWeights) {
    activationFnSnippet2 = `
      fn activation(a : ${dataType}, coords : vec${coordsLength}<i32>) -> ${dataType} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${activationOpSnippet}
      }`;
  } else {
    activationFnSnippet2 = `
      fn activation(a : ${dataType}, coords : vec${coordsLength}<i32>) -> ${dataType} {
        ${activationOpSnippet}
      }`;
  }
  return activationFnSnippet2;
}
function biasActivationSnippet(hasBias, activation2) {
  return `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${activation2 ? "value = activation(value, coords);" : ""}
      `;
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/matmul_packed_webgpu.js
function matMulReadFnSource(transposeA, transposeB, fitAOuter = false, fitBOuter = false, fitInner = false, component = 1) {
  exports_util.assert(transposeA && component === 1 || !transposeA, () => `transposeA ${transposeA} is not compatible with component size ${component}`);
  const sampleA = `
      ${transposeA ? `value = getA(batch, col, row);` : `value = getA(batch, row, col);`}

    `;
  const sampleB = transposeB ? `value = getB(batch, col, row);` : `value = getB(batch, row, col);`;
  return `
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${typeSnippet(component)} {
    var value = ${typeSnippet(component)}(0.0);
    ${fitAOuter && fitInner ? sampleA : `
    ${transposeA ? `if(row < uniforms.dimAOuter && col < uniforms.dimInner)` : `if(row < uniforms.aShape[1] && col < uniforms.aShape[2])`}
    {
      ${sampleA}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${typeSnippet(component)} {
    var value = ${typeSnippet(component)}(0.0);
    ${sampleB}
    return value;
  }
  `;
}
function matMulReadWriteFnSource(hasBias, activation2, transposeA, transposeB, fitAOuter = false, fitBOuter = false, fitInner = false, component = 1) {
  return `
  ${matMulReadFnSource(transposeA, transposeB, fitAOuter, fitBOuter, fitInner, component)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${typeSnippet(component)}) {
    ${fitAOuter && fitBOuter ? "" : "if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${biasActivationSnippet(hasBias, activation2)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
}
function makeMatMulPackedVec4Source(workPerThread, workgroupSize, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, broadcastBatch = false) {
  const tileAOuter = workgroupSize[1] * workPerThread[1];
  const tileBOuter = workgroupSize[0] * workPerThread[0];
  const tileAWidth = transposeA ? tileAOuter : tileInner;
  const tileAHight = transposeA ? tileInner : tileAOuter;
  const innerElementSize = tileAWidth / workgroupSize[0];
  const rowPerThreadB = tileInner / workgroupSize[1];
  const rowPerThread = workPerThread[1];
  const colPerThread = workPerThread[0];
  exports_util.assert((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4, () => `If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
          Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
      tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
  return `
  var<workgroup> mm_Asub : array<array<vec${innerElementSize}<f32>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

  ${getMainHeaderString()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${rowPerThread};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${rowPerThread};
    let globalCol = i32(globalId.x) * ${colPerThread};
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    let batchA = ${splitK || !broadcastBatch ? "batch" : "batch % uniforms.aShape[0]"};
    let batchB = ${splitK || !broadcastBatch ? "batch" : "batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

    let numTiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : `(uniforms.dimInner - 1) / ${tileInner} + 1`};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc: array<vec4<f32>, ${rowPerThread}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${rowPerThreadB};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${writeDataToSubAVec4Snippet(transposeA, innerElementSize)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${tileInner};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${calculateResultSnippet(transposeA, innerElementSize, rowPerThread, tileInner)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
}
function makeMatMulPackedSource(workPerThread, workgroupSize, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false, broadcastBatch = false) {
  const tileAOuter = workPerThread[1] * workgroupSize[1];
  const tileBOuter = workPerThread[0] * workgroupSize[0];
  const tileAWidth = transposeA ? tileAOuter : tileInner;
  const tileAHight = transposeA ? tileInner : tileAOuter;
  exports_util.assert(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0, () => `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`);
  const rowPerThreadA = tileAHight / workgroupSize[1];
  const colPerThreadA = tileAWidth / workgroupSize[0];
  const rowPerThreadB = tileInner / workgroupSize[1];
  const rowPerThread = workPerThread[1];
  const colPerThread = workPerThread[0];
  const matmulSnippet = sequentialAccessByThreads ? `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
      let globalColStart = i32(workgroupId.x) * ${tileBOuter};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
            ${writeDataToSubASnippet(transposeA)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
              for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${tileInner};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${colPerThread}>;
        for (var k = 0; k < ${tileInner}; k++) {
          for (var inner = 0; inner < ${colPerThread}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
          }
          for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
            let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
            for (var innerCol = 0; innerCol < ${colPerThread}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
        for (var innerCol = 0; innerCol < ${colPerThread}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` : `
  let tileRow = i32(localId.y) * ${rowPerThread};
  let tileCol = i32(localId.x) * ${colPerThread};

  let globalRow = i32(globalId.y) * ${rowPerThread};
  let globalCol = i32(globalId.x) * ${colPerThread};
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let tileRowA = i32(localId.y) * ${rowPerThreadA};
  let tileColA = i32(localId.x) * ${colPerThreadA};
  let tileRowB = i32(localId.y) * ${rowPerThreadB};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow++) {
      for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${writeDataToSubASnippet(transposeA)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow++) {
      for (var innerCol = 0; innerCol < ${colPerThread}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${tileInner};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${colPerThread}>;
    for (var k = 0; k < ${tileInner}; k++) {
      for (var inner = 0; inner < ${colPerThread}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
        ${readDataFromSubASnippet(transposeA)}
        for (var innerCol = 0; innerCol < ${colPerThread}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
    for (var innerCol = 0; innerCol < ${colPerThread}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
  return `
    var<workgroup> mm_Asub : array<array<f32, ${tileAWidth}>, ${tileAHight}>;
    var<workgroup> mm_Bsub : array<array<f32, ${tileBOuter}>, ${tileInner}>;

    ${getMainHeaderString()} {
      let batch = ${splitK ? "0" : "i32(globalId.z)"};
      let batchA = ${splitK || !broadcastBatch ? "batch" : "batch % uniforms.aShape[0]"};
      let batchB = ${splitK || !broadcastBatch ? "batch" : "batch % uniforms.bShape[0]"};
      let numTiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : `(uniforms.dimInner - 1) / ${tileInner} + 1`};
      var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

      var acc : array<array<f32, ${colPerThread}>, ${rowPerThread}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${rowPerThread}; innerRow++) {
        for (var innerCol = 0; innerCol < ${colPerThread}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${matmulSnippet}
    }
  `;
}
function makeVectorMatrixProductSource(workgroupSize, transposeA = false) {
  exports_util.assert(workgroupSize[1] === 1 && workgroupSize[2] === 1, () => `A linear work group size is required. But got ${workgroupSize}.`);
  const tileSize = workgroupSize[0] * 4;
  return `
    var<workgroup> mm_Asub : array<vec4<f32>, ${workgroupSize[0]}>;

    ${getMainHeaderString()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${tileSize} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${tileSize} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${readVectorASnippet(transposeA)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${tileSize / 4}; k++) {
          let rowB = t * ${tileSize} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
}
var writeDataToSubAVec4Snippet = (transpose13, innerElementSize) => {
  if (transpose13) {
    return `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${innerElementSize});
        `;
  } else {
    return `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${innerElementSize});
        `;
  }
};
var calculateResultSnippet = (transposeA, innerElementSize, rowPerThread, tileInner) => {
  if (transposeA) {
    return `
      for (var k = 0; k < ${tileInner}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${rowPerThread}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;
  } else {
    let bCachedStr = "";
    let accStr = "";
    for (let i = 0;i < innerElementSize; i++) {
      bCachedStr += `let BCached${i} = mm_Bsub[k * ${innerElementSize} + ${i}][tileCol];`;
      accStr += `acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;
    }
    return `
      for (var k = 0; k < ${tileInner / innerElementSize}; k++) {
        ${bCachedStr}
        for (var i = 0; i < ${rowPerThread}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${accStr}
        }
      }`;
  }
};
var writeDataToSubASnippet = (transpose13) => {
  if (transpose13) {
    return `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `;
  } else {
    return `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `;
  }
};
var readDataFromSubASnippet = (transposeA) => {
  return transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
};
var readVectorASnippet = (transpose13) => {
  return transpose13 ? `
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  ` : `
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;
};

class MatMulPackedProgram2 {
  constructor(aShape, outputShape, transposeA = false, transposeB = false, bias = null, activation2 = null, preluActivationWeights = null, sequentialAccessByThreads = false) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [2], y: [1], z: [0] };
    const dimInner = transposeA ? aShape[1] : aShape[2];
    this.isVec4 = (dimInner % 4 === 0 && !transposeA || outputShape[1] % 4 === 0 && transposeA) && outputShape[2] % 4 === 0 && !transposeB;
    this.outputComponent = this.isVec4 ? 4 : 1;
    this.isVectorA = outputShape[1] === 1 && !transposeA;
    if (!this.isVec4 && this.isVectorA) {
      this.elementsPerThread = [1, 1, 1];
      this.workgroupSize = [32, 1, 1];
    } else {
      const workgroupInfo = computeWorkgroupInfoForMatMul(outputShape[1], dimInner, outputShape[2], transposeA);
      this.workgroupSize = workgroupInfo.workgroupSize;
      this.elementsPerThread = workgroupInfo.elementsPerThread;
    }
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
    const addBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.sequentialAccessByThreads = sequentialAccessByThreads;
    this.transposeA = transposeA;
    this.transposeB = transposeB;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    [this.fitAOuter, this.fitBOuter, this.fitInner] = this.getShapeFit(outputShape[1], outputShape[2], dimInner);
    this.shaderKey = `matMulPacked_${this.elementsPerThread}_${transposeA}_${transposeB}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`;
  }
  getShapeFit(dimAOuter, dimBOuter, dimInner) {
    const tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1];
    const tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0];
    if (!this.isVec4 && this.isVectorA) {
      this.tileInner = this.workgroupSize[0] * 4;
    } else {
      this.tileInner = tileBOuter;
    }
    const fitAOuter = dimAOuter % tileAOuter === 0;
    const fitBOuter = dimBOuter % tileBOuter === 0;
    const fitInner = dimInner % this.tileInner === 0;
    return [fitAOuter, fitBOuter, fitInner];
  }
  getUserCode() {
    const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${matMulReadWriteFnSource(this.addBias, this.activation, false, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, true) : this.isVectorA ? makeVectorMatrixProductSource(this.workgroupSize, this.transposeA) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, false, null, this.sequentialAccessByThreads, true)}
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/matmul_reduce_webgpu.js
function makeMatMulReduceSource(workgroupSizeX) {
  return `
    var<workgroup> sumValues : array<f32, ${workgroupSizeX}>;
    ${getMainHeaderString()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${workgroupSizeX}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${workgroupSizeX / 2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `;
}

class MatMulReduceProgram {
  constructor(outputShape, transposeA = false, transposeB = false, bias = null, activation2 = null, preluActivationWeights = null) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
    this.workgroupSize = [256, 1, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [], y: [1, 2], z: [0] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    const addBias = bias != null;
    const hasPreluActivationWeights = preluActivationWeights != null;
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.transposeA = transposeA;
    this.transposeB = transposeB;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    this.shaderKey = `matMulReduce_${this.activation}_${transposeA}_${transposeB}`;
  }
  getUserCode() {
    const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
      ${matMulReadWriteFnSource(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${makeMatMulReduceSource(this.workgroupSize[0])}
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/matmul_small_output_size_webgpu.js
function makeMatMulSmallOutputSizeSource(workgroupSize) {
  const tileAOuter = workgroupSize[1];
  const tileBOuter = workgroupSize[0];
  const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;
  return `
  var<workgroup> mm_Asub : array<array<f32, ${tileInner}>, ${tileAOuter}>;
  var<workgroup> mm_Bsub : array<array<f32, ${tileBOuter}>, ${tileInner}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${getMainHeaderString()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${tileInner} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${tileInner};
    globalRowB = globalRowB + ${tileInner};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${tileInner};
      globalRowB = globalRowB + ${tileInner};

      for (var k = 0; k < ${tileInner}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
}

class MatMulSmallOutputSizeProgram {
  constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, bias = null, activation2 = null, preluActivationWeights = null) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
    this.workgroupSize = [16, 8, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [2], y: [1], z: [0] };
    this.dispatch = [
      Math.ceil(outputShape[2] / this.workgroupSize[0]),
      Math.ceil(outputShape[1] / this.workgroupSize[1]),
      outputShape[0]
    ];
    const addBias = bias != null;
    if (addBias) {
      this.variableNames.push("bias");
    }
    const hasPreluActivationWeights = preluActivationWeights != null;
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.transposeA = transposeA;
    this.transposeB = transposeB;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    this.shaderKey = `matMulSmallOutputSize_${this.activation}_${transposeA}_${transposeB}`;
  }
  getUserCode() {
    const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
      ${matMulReadWriteFnSource(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${makeMatMulSmallOutputSizeSource(this.workgroupSize)}
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/matmul_splitK_webgpu.js
init_dist();
class MatMulSplitKProgram {
  constructor(outputShape, dimInner, transposeA = false, transposeB = false) {
    this.variableNames = ["A", "B"];
    this.uniforms = `dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
    this.workgroupSize = [8, 8, 1];
    this.atomic = true;
    this.splitedDimInner = 128;
    exports_util.assert(outputShape[0] === 1, () => "MatMulSplitKProgram only supports batch = 1.");
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [2], y: [1], z: [0, 3] };
    const isVec4 = (transposeA && this.outputShape[1] % 4 === 0 || !transposeA && dimInner % 4 === 0) && this.outputShape[2] % 4 === 0;
    this.elementsPerThread = [4, 4, this.splitedDimInner];
    this.outputComponent = isVec4 ? 4 : 1;
    if (!isVec4) {
      if (this.outputShape[1] < 16) {
        this.elementsPerThread[1] = 1;
      }
      if (this.outputShape[2] < 16) {
        this.elementsPerThread[0] = 1;
      }
    }
    this.dispatch = computeDispatch(this.dispatchLayout, [
      this.outputShape[0],
      this.outputShape[1],
      this.outputShape[2],
      dimInner
    ], this.workgroupSize, this.elementsPerThread);
    this.transposeA = transposeA;
    this.transposeB = transposeB;
    this.shaderKey = `matMulSplitK_${transposeA}_${transposeB}_${this.elementsPerThread}_${this.outputComponent}`;
  }
  getUserCode() {
    const component = this.outputComponent;
    const userCode = `
      ${matMulReadFnSource(false, this.transposeB, false, false, false, component)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${typeSnippet(component)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${component}; i = i + 1) {
            ${atomicAddSnippet("&result[flatIndex + i]", `${component > 1 ? "value[i]" : "value"}`, "float32")}
          }
        }
      }
      ${component === 4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, true, this.splitedDimInner)}
    `;
    return userCode;
  }
}

class BiasActivationProgram {
  constructor(outputShape, bias = null, activation2 = null, preluActivationWeights = null) {
    this.uniforms = "";
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.addBias = bias != null;
    this.hasPreluActivationWeights = preluActivationWeights != null;
    this.activation = activation2;
    if (this.addBias) {
      this.variableNames.push("bias");
    }
    if (this.hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.shaderKey = `biasActivation_${activation2}`;
  }
  getUserCode() {
    return `
    ${activationFnSnippet(this.activation, this.hasPreluActivationWeights)}
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${biasActivationSnippet(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Fill.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/fill_webgpu.js
class FillProgram2 {
  constructor(shape) {
    this.variableNames = [];
    this.outputShape = [];
    this.uniforms = "value : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "fill";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Fill.js
function fill8(args) {
  const { backend: backend3, attrs } = args;
  const { shape, value } = attrs;
  let { dtype } = attrs;
  dtype = dtype || exports_util.inferDtype(value);
  if (dtype === "string") {
    const values = exports_util.getArrayFromDType(dtype, exports_util.sizeFromShape(shape));
    values.fill(value);
    return backend3.makeTensorInfo(shape, dtype, values);
  } else {
    const program = new FillProgram2(shape);
    const uniformData = [{ type: "float32", data: [value] }];
    return backend3.runWebGPUProgram(program, [], dtype, uniformData);
  }
}
var fillConfig3 = {
  kernelName: Fill,
  backendName: "webgpu",
  kernelFunc: fill8
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Reshape.js
init_dist();
function reshape80(args) {
  const { inputs, attrs } = args;
  const { x } = inputs;
  const { shape } = attrs;
  const xSize = exports_util.sizeFromShape(x.shape);
  const $shape = exports_util.inferFromImplicitShape(shape, xSize);
  const $xSize = exports_util.sizeFromShape($shape);
  exports_util.assert(xSize === $xSize, () => `The new shape (${$shape}) has ${$xSize} elements and the old ` + `shape (${x.shape}) has ${xSize} elements. The new shape and old ` + `shape must have the same number of elements.`);
  args.backend.incRef(x.dataId);
  return { dataId: x.dataId, shape: $shape, dtype: x.dtype };
}
var reshapeConfig3 = {
  kernelName: Reshape,
  backendName: "webgpu",
  kernelFunc: reshape80
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BatchMatMul_impl.js
function batchMatMulImpl2({ a, b, transposeA, transposeB, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const aRank = a.shape.length;
  const bRank = b.shape.length;
  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];
  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];
  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];
  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];
  const outerDimsA = a.shape.slice(0, -2);
  const outerDimsB = b.shape.slice(0, -2);
  const batchDimA = exports_util.sizeFromShape(outerDimsA);
  const batchDimB = exports_util.sizeFromShape(outerDimsB);
  const outShapeOuterDims = exports_broadcast_util.assertAndGetBroadcastShape(a.shape.slice(0, -2), b.shape.slice(0, -2));
  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);
  exports_util.assert(innerShapeA === innerShapeB, () => `Error in matMul: inner shapes (${innerShapeA}) and (` + `${innerShapeB}) of Tensors with shapes ${a.shape} and ` + `${b.shape} and transposeA=${transposeA}` + ` and transposeB=${transposeB} must match.`);
  const a3dShape = transposeA ? [batchDimA, innerShapeA, outerShapeA] : [batchDimA, outerShapeA, innerShapeA];
  const b3dShape = transposeB ? [batchDimB, outerShapeB, innerShapeB] : [batchDimB, innerShapeB, outerShapeB];
  const a3d = reshape80({ inputs: { x: a }, backend: backend3, attrs: { shape: a3dShape } });
  const b3d = reshape80({ inputs: { x: b }, backend: backend3, attrs: { shape: b3dShape } });
  const intermediates = [a3d, b3d];
  const batchDim = Math.max(batchDimA, batchDimB);
  const inputs = [a3d, b3d];
  const dimensions = [
    { type: "int32", data: [outerShapeA] },
    { type: "int32", data: [outerShapeB] },
    { type: "int32", data: [innerShapeA] }
  ];
  let program;
  let out;
  const outputShape = [batchDim, outerShapeA, outerShapeB];
  let matmulProgramType = env().get("WEBGPU_MATMUL_PROGRAM_TYPE");
  if (matmulProgramType < 0) {
    const thresholdFlagValue = env().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL");
    const thresholdToIncreaseWorkgroups = thresholdFlagValue > 0 ? thresholdFlagValue : backend3.thresholdToIncreaseWorkgroups;
    const workgroupsBy32x32 = batchDim * Math.ceil(outerShapeA / 32) * Math.ceil(outerShapeB / 32);
    const hasFewWorkgroups = workgroupsBy32x32 <= thresholdToIncreaseWorkgroups || outerShapeA <= 8 && workgroupsBy32x32 <= thresholdToIncreaseWorkgroups * 2;
    if (hasFewWorkgroups) {
      if (batchDim * outerShapeA * outerShapeB <= 128) {
        matmulProgramType = MatMulProgramType.MatMulReduceProgram;
      } else if (batchDim === 1 && innerShapeB >= 2000) {
        matmulProgramType = MatMulProgramType.MatMulSplitKProgram;
      } else {
        matmulProgramType = MatMulProgramType.MatMulSmallOutputSizeProgram;
      }
    } else {
      matmulProgramType = MatMulProgramType.MatMulPackedProgram;
    }
  }
  switch (matmulProgramType) {
    case MatMulProgramType.MatMulReduceProgram:
      program = new MatMulReduceProgram(outputShape, transposeA, transposeB, bias, activation2, preluActivationWeights);
      break;
    case MatMulProgramType.MatMulSplitKProgram: {
      out = fill8({ backend: backend3, attrs: { shape: outputShape, value: 0, dtype: a.dtype } });
      program = new MatMulSplitKProgram(outputShape, innerShapeB, transposeA, transposeB);
      if (bias || activation2) {
        out = backend3.runWebGPUProgram(program, inputs, a.dtype, dimensions, out);
        const biasActivationProgram = new BiasActivationProgram(out.shape, bias, activation2, preluActivationWeights);
        let uniformData = null;
        const activationInputs = [out];
        if (bias) {
          activationInputs.push(bias);
        }
        if (preluActivationWeights) {
          activationInputs.push(preluActivationWeights);
        }
        if (activation2 === "leakyrelu") {
          uniformData = [{ type: "float32", data: [leakyreluAlpha] }];
          biasActivationProgram.uniforms += " alpha : f32,";
        }
        const outActivated = backend3.runWebGPUProgram(biasActivationProgram, activationInputs, out.dtype, uniformData);
        intermediates.push(out);
        const outReshaped2 = reshape80({ inputs: { x: outActivated }, backend: backend3, attrs: { shape: outShape } });
        intermediates.push(outActivated);
        for (const i of intermediates) {
          backend3.disposeData(i.dataId);
        }
        return outReshaped2;
      }
      break;
    }
    case MatMulProgramType.MatMulSmallOutputSizeProgram:
      program = new MatMulSmallOutputSizeProgram(a3dShape, b3dShape, outputShape, transposeA, transposeB, bias, activation2, preluActivationWeights);
      break;
    case MatMulProgramType.MatMulPackedProgram:
      const sequentialAccessByThreads = backend3.adapterInfo.isIntel();
      program = new MatMulPackedProgram2(a3dShape, outputShape, transposeA, transposeB, bias, activation2, preluActivationWeights, sequentialAccessByThreads);
      break;
    default:
      throw new Error(`Unsupported MatMulProgramType ${matmulProgramType}.`);
  }
  if (bias) {
    inputs.push(bias);
  }
  if (preluActivationWeights) {
    inputs.push(preluActivationWeights);
  }
  if (activation2 === "leakyrelu") {
    dimensions.push({ type: "float32", data: [leakyreluAlpha] });
    program.uniforms += " alpha : f32,";
  }
  out = backend3.runWebGPUProgram(program, inputs, a.dtype, dimensions, out);
  const outReshaped = reshape80({ inputs: { x: out }, backend: backend3, attrs: { shape: outShape } });
  intermediates.push(out);
  for (const i of intermediates) {
    backend3.disposeData(i.dataId);
  }
  return outReshaped;
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/_FusedMatMul.js
function _fusedMatMul3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { a, b, bias, preluActivationWeights } = inputs;
  const { transposeA, transposeB, activation: activation2, leakyreluAlpha } = attrs;
  return batchMatMulImpl2({
    a,
    b,
    transposeA,
    transposeB,
    backend: backend3,
    bias,
    preluActivationWeights,
    leakyreluAlpha,
    activation: activation2
  });
}
var _fusedMatMulConfig3 = {
  kernelName: _FusedMatMul,
  backendName: "webgpu",
  kernelFunc: _fusedMatMul3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Abs.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/kernel_funcs_utils.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/binary_op_complex_webgpu.js
init_dist();
class BinaryOpComplexProgram2 {
  constructor(op2, aShape, bShape) {
    this.variableNames = ["AReal", "AImag", "BReal", "BImag"];
    this.workgroupSize = [128, 1, 1];
    this.size = true;
    this.outputShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `binaryOpComplex_${op2}`;
    this.op = op2;
  }
  getUserCode() {
    const opStr = getBinaryOpString(this.op, false);
    const userCode = `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${opStr}
      }

      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/binary_op_webgpu.js
init_dist();
class BinaryOpProgram2 {
  constructor(op2, aShape, bShape) {
    this.size = true;
    this.variableNames = ["A", "B"];
    this.outputShape = exports_backend_util.assertAndGetBroadcastShape(aShape, bShape);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.op = op2;
    this.useSharedMemoryWithA = aShape.length <= 1 && bShape.length > 1 && aShape[0] < 128;
    this.useSharedMemoryWithB = bShape.length <= 1 && aShape.length > 1 && bShape[0] < 128;
    if (this.useSharedMemoryWithA || this.useSharedMemoryWithB) {
      this.outputComponent = 1;
      this.variableComponents = [1, 1];
      this.lastDimensionSize = this.useSharedMemoryWithB ? bShape[0] : aShape[0];
      this.shaderKey = `binary_${op2}_${this.lastDimensionSize}`;
      this.type = "shared";
      this.workgroupSize = [256, 1, 1];
    } else {
      const aDivisibleBy4 = aShape.length > 0 && aShape[aShape.length - 1] % 4 === 0;
      const bDivisibleBy4 = bShape.length > 0 && bShape[bShape.length - 1] % 4 === 0;
      if (aDivisibleBy4 && bDivisibleBy4) {
        this.outputComponent = 4;
        this.variableComponents = [4, 4];
      } else if (aDivisibleBy4 && (exports_util.isScalarShape(bShape) || bShape[bShape.length - 1] === 1) || bDivisibleBy4 && (exports_util.isScalarShape(aShape) || aShape[aShape.length - 1] === 1)) {
        this.outputComponent = 4;
        this.variableComponents = aDivisibleBy4 ? [4, 1] : [1, 4];
      } else {
        this.outputComponent = 1;
        this.variableComponents = [1, 1];
      }
      this.type = "nonshared";
      this.shaderKey = `binary_${op2}_${this.variableComponents}`;
      this.workgroupSize = [128, 1, 1];
    }
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.outputComponent, 1, 1]);
  }
  getUserCode() {
    let userCode;
    const dType = this.outputComponent === 4 ? "vec4<f32>" : "f32";
    const opFnStr = `
    fn binaryOperation(a : ${dType}, b : ${dType}) -> ${dType} {
      ${getBinaryOpString(this.op, this.outputComponent === 4)}
    };
    `;
    if (this.type === "shared") {
      const sharedIndexSnippet = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0";
      const accessDataSnippet = this.useSharedMemoryWithB ? `let a = getAByOutputIndex(index);
          let b = sharedBuf[${sharedIndexSnippet}];` : `let a = sharedBuf[${sharedIndexSnippet}];
          let b = getBByOutputIndex(index);`;
      userCode = `
        ${opFnStr}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${getMainHeaderString("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${accessDataSnippet}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
    } else {
      userCode = `
       ${opFnStr}
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${dType}(getAByOutputCoords(coords));
           let b = ${dType}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
    }
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Complex.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Identity.js
init_dist();
function identity4(args) {
  const { inputs } = args;
  const { x } = inputs;
  args.backend.incRef(x.dataId);
  return { dataId: x.dataId, shape: x.shape, dtype: x.dtype };
}
var identityConfig3 = {
  kernelName: Identity,
  backendName: "webgpu",
  kernelFunc: identity4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Complex.js
function complex10(args) {
  const { inputs, backend: backend3 } = args;
  const { real: real7, imag: imag7 } = inputs;
  const complexInfo = backend3.makeTensorInfo(real7.shape, "complex64");
  const complex11 = backend3.tensorMap.get(complexInfo.dataId);
  const realTensorInfo = identity4({ inputs: { x: real7 }, backend: backend3 });
  const imagTensorInfo = identity4({ inputs: { x: imag7 }, backend: backend3 });
  complex11.complexTensorInfos = { real: realTensorInfo, imag: imagTensorInfo };
  return complexInfo;
}
var complexConfig3 = {
  kernelName: Complex,
  backendName: "webgpu",
  kernelFunc: complex10
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/unary_op_webgpu.js
class UnaryOpProgram2 {
  constructor(outputShape, op2, uniforms = "") {
    this.variableNames = ["A"];
    this.size = true;
    const workgroupSizeX = 128;
    this.workgroupSize = [workgroupSizeX, 1, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.op = op2;
    if (uniforms !== "") {
      this.uniforms = uniforms;
    }
    this.shaderKey = `unary_${op2}`;
  }
  getUserCode() {
    return `
      fn unaryOperation(a : f32) -> f32 {
        ${getUnaryOpString(this.op, false)}
      }
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/kernel_funcs_utils.js
function unaryKernelFunc3({ opType, cpuKernelImpl, dtype }) {
  return ({ inputs, backend: backend3 }) => {
    const { x } = inputs;
    const webgpuBackend = backend3;
    const $dtype = dtype || x.dtype;
    if (webgpuBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {
      const xData = webgpuBackend.tensorMap.get(x.dataId);
      const outValues = cpuKernelImpl(xData.values, $dtype);
      return webgpuBackend.makeTensorInfo(x.shape, $dtype, outValues);
    }
    const program = new UnaryOpProgram2(x.shape, opType);
    return webgpuBackend.runWebGPUProgram(program, [x], $dtype);
  };
}
function binaryKernelFunc3({ opType, cpuKernelImpl, supportsComplex = false, dtype }) {
  return ({ inputs, backend: backend3 }) => {
    const { a, b } = inputs;
    const webgpuBackend = backend3;
    if (supportsComplex && a.dtype === "complex64") {
      const aData = webgpuBackend.tensorMap.get(a.dataId);
      const bData = webgpuBackend.tensorMap.get(b.dataId);
      let real7, imag7;
      if (opType !== BinaryOpType.MUL) {
        [real7, imag7] = [
          [aData.complexTensorInfos.real, bData.complexTensorInfos.real],
          [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]
        ].map((complexParts) => {
          const [aPart, bPart] = complexParts;
          const aHandle = {
            dataId: aPart.dataId,
            dtype: aPart.dtype,
            shape: a.shape
          };
          const bHandle = {
            dataId: bPart.dataId,
            dtype: bPart.dtype,
            shape: b.shape
          };
          const program2 = new BinaryOpProgram2(opType, a.shape, b.shape);
          return webgpuBackend.runWebGPUProgram(program2, [aHandle, bHandle], upcastType(aPart.dtype, bPart.dtype));
        });
      } else {
        const realProgram = new BinaryOpComplexProgram2(BinaryOpType.COMPLEX_MULTIPLY_REAL, a.shape, b.shape);
        const imagProgram = new BinaryOpComplexProgram2(BinaryOpType.COMPLEX_MULTIPLY_IMAG, a.shape, b.shape);
        const inputs2 = [
          {
            dataId: aData.complexTensorInfos.real.dataId,
            dtype: aData.complexTensorInfos.real.dtype,
            shape: a.shape
          },
          {
            dataId: aData.complexTensorInfos.imag.dataId,
            dtype: aData.complexTensorInfos.imag.dtype,
            shape: a.shape
          },
          {
            dataId: bData.complexTensorInfos.real.dataId,
            dtype: bData.complexTensorInfos.real.dtype,
            shape: b.shape
          },
          {
            dataId: bData.complexTensorInfos.imag.dataId,
            dtype: bData.complexTensorInfos.imag.dtype,
            shape: b.shape
          }
        ];
        real7 = webgpuBackend.runWebGPUProgram(realProgram, inputs2, "float32");
        imag7 = webgpuBackend.runWebGPUProgram(imagProgram, inputs2, "float32");
      }
      const complexOutput = complex10({ inputs: { real: real7, imag: imag7 }, backend: webgpuBackend });
      webgpuBackend.disposeData(real7.dataId);
      webgpuBackend.disposeData(imag7.dataId);
      return complexOutput;
    }
    const $dtype = dtype || upcastType(a.dtype, b.dtype);
    if ((a.dtype === "string" || b.dtype === "string" || webgpuBackend.shouldExecuteOnCPU([a, b])) && cpuKernelImpl != null) {
      const aData = webgpuBackend.tensorMap.get(a.dataId).values;
      const bData = webgpuBackend.tensorMap.get(b.dataId).values;
      const decodedAVals = a.dtype === "string" ? exports_backend_util.fromUint8ToStringArray(aData) : aData;
      const decodedBVals = a.dtype === "string" ? exports_backend_util.fromUint8ToStringArray(bData) : bData;
      const [outValues, outShape] = cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);
      return webgpuBackend.makeTensorInfo(outShape, $dtype, outValues);
    }
    const program = new BinaryOpProgram2(opType, a.shape, b.shape);
    return webgpuBackend.runWebGPUProgram(program, [a, b], $dtype);
  };
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/shared.js
init_shared();
var { addImpl: addImplCPU2, castImpl: castImplCPU2, ceilImpl: ceilImplCPU2, concatImpl: concatImplCPU2, equalImpl: equalImplCPU2, expImpl: expImplCPU2, expm1Impl: expm1ImplCPU2, floorImpl: floorImplCPU2, floorDivImpl: floorDivImplCPU, gatherNdImpl: gatherNdImplCPU2, gatherV2Impl: gatherV2ImplCPU2, greaterEqualImpl: greaterEqualImplCPU2, greaterImpl: greaterImplCPU2, lessEqualImpl: lessEqualImplCPU2, lessImpl: lessImplCPU2, logImpl: logImplCPU2, maxImpl: maxImplCPU2, maximumImpl: maximumImplCPU2, minimumImpl: minimumImplCPU2, multiplyImpl: multiplyImplCPU2, negImpl: negImplCPU2, notEqualImpl: notEqualImplCPU2, prodImpl: prodImplCPU2, rangeImpl: rangeImplCPU2, rsqrtImpl: rsqrtImplCPU2, scatterImpl: scatterImplCPU2, simpleAbsImpl: simpleAbsImplCPU2, sliceImpl: sliceImplCPU2, stridedSliceImpl: stridedSliceImplCPU2, stringNGramsImpl: stringNGramsImplCPU2, subImpl: subImplCPU2, tileImpl: tileImplCPU2, topKImpl: topKImplCPU2, transposeImpl: transposeImplCPU2, uniqueImpl: uniqueImplCPU2 } = exports_shared;

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Abs.js
var abs10 = unaryKernelFunc3({ opType: UnaryOpType.ABS, cpuKernelImpl: simpleAbsImplCPU2 });
var absConfig3 = {
  kernelName: Abs,
  backendName: "webgpu",
  kernelFunc: abs10
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Acos.js
init_dist();
var acos5 = unaryKernelFunc3({ opType: UnaryOpType.ACOS });
var acosConfig3 = {
  kernelName: Acos,
  backendName: "webgpu",
  kernelFunc: acos5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Acosh.js
init_dist();
var acosh5 = unaryKernelFunc3({ opType: UnaryOpType.ACOSH });
var acoshConfig3 = {
  kernelName: Acosh,
  backendName: "webgpu",
  kernelFunc: acosh5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Add.js
init_dist();
var addKernelFunc2 = binaryKernelFunc3({ opType: BinaryOpType.ADD, cpuKernelImpl: addImplCPU2, supportsComplex: true });
var addConfig3 = {
  kernelName: Add,
  backendName: "webgpu",
  kernelFunc: addKernelFunc2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AddN.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/addn_packed_webgpu.js
class AddNPackedProgram2 {
  constructor(shapes) {
    this.workPerThread = 1;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = shapes[0];
    this.variableNames = shapes.map((_, i) => `T${i}`);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    this.shaderKey = "addN";
  }
  getUserCode() {
    const snippets = [];
    this.variableNames.forEach((variable2) => {
      snippets.push(`let v${variable2} = get${variable2}ByOutputCoords(coords);`);
    });
    const operation235 = this.variableNames.map((variable2) => {
      return `v${variable2}`;
    }).join(" + ");
    const userCode = `
      ${getMainHeaderString("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${snippets.join("\n        ")}
            setOutputAtIndex(flatIndex, ${operation235});
          }
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AddN.js
function addN4(args) {
  const { inputs, backend: backend3 } = args;
  const tensors = inputs;
  if (tensors.length === 1) {
    return identity4({ inputs: { x: tensors[0] }, backend: backend3 });
  }
  const dtype = tensors.map((t) => t.dtype).reduce((d1, d2) => upcastType(d1, d2));
  const shapes = tensors.map((t) => t.shape);
  const program = new AddNPackedProgram2(shapes);
  return backend3.runWebGPUProgram(program, tensors, dtype);
}
var addNConfig3 = {
  kernelName: AddN,
  backendName: "webgpu",
  kernelFunc: addN4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/All.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/reduce.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Transpose.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/transpose_shared_webgpu.js
init_dist();
class TransposeSharedProgram {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    this.workgroupSize = [16, 16, 1];
    const outputShape = new Array(aShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = aShape[newDim[i]];
    }
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [0], y: [1] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [1, 1, 1]);
    this.shaderKey = "transposeShared";
  }
  getUserCode() {
    exports_util.assert(this.workgroupSize[0] === this.workgroupSize[1], () => `Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);
    const tileSize = this.workgroupSize[0];
    const userCode = `
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0] + 1}>, ${this.workgroupSize[0]}>;
      ${getMainHeaderString()} {
        var x = i32(workgroupId.x) * ${tileSize} + i32(localId.x);
        var y = i32(workgroupId.y) * ${tileSize} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${tileSize} + i32(localId.x);
        y = i32(workgroupId.x) * ${tileSize} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/transpose_webgpu.js
function getSwitchedCoords2(newDim) {
  const rank = newDim.length;
  if (rank > 6) {
    throw Error(`Transpose for rank ${rank} is not yet supported`);
  }
  const switchedCoords = new Array(rank);
  for (let i = 0;i < newDim.length; i++) {
    switchedCoords[newDim[i]] = `coords.${getCoordsXYZ(i)}`;
  }
  return switchedCoords.join();
}

class TransposeProgram2 {
  constructor(aShape, newDim) {
    this.variableNames = ["A"];
    this.workPerThread = 1;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    const outputShape = new Array(aShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = aShape[newDim[i]];
    }
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    this.newDim = newDim;
    this.shaderKey = `transpose_${newDim}`;
  }
  getUserCode() {
    const dtype = getCoordsDataType2(this.outputShape.length);
    const switched = getSwitchedCoords2(this.newDim);
    const userCode = `
      ${getMainHeaderString("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${dtype}(${switched}), uniforms.aShape)]);
          }
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Transpose.js
function transpose13(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { perm } = attrs;
  const webgpuBackend = backend3;
  const xRank = x.shape.length;
  const newShape = new Array(xRank);
  for (let i = 0;i < newShape.length; i++) {
    newShape[i] = x.shape[perm[i]];
  }
  if (backend3.shouldExecuteOnCPU([x])) {
    const xData = webgpuBackend.tensorMap.get(x.dataId);
    const values = xData.values;
    const outValues = transposeImplCPU2(values, x.shape, x.dtype, perm, newShape);
    return backend3.makeTensorInfo(newShape, x.dtype, outValues);
  }
  if (x.shape.length === 2 && exports_util.arraysEqual(perm, [1, 0])) {
    const program2 = new TransposeSharedProgram(x.shape, perm);
    return webgpuBackend.runWebGPUProgram(program2, [x], x.dtype);
  }
  const program = new TransposeProgram2(x.shape, perm);
  return webgpuBackend.runWebGPUProgram(program, [x], x.dtype);
}
var transposeConfig3 = {
  kernelName: Transpose,
  backendName: "webgpu",
  kernelFunc: transpose13
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/reduce_webgpu.js
init_dist();
class ReduceProgram2 {
  constructor(reduceInfo, reduceType, maxComputeWorkgroupSizeX) {
    this.variableNames = ["x"];
    this.uniforms = "reduceSize : i32,";
    this.size = true;
    this.inputShape = [reduceInfo.batchSize, reduceInfo.inSize];
    const [outputShape] = exports_backend_util.computeOutAndReduceShapes(this.inputShape, [1]);
    this.outputShape = outputShape.length === 0 ? [1] : outputShape;
    if (reduceInfo.inSize >= 32768 && maxComputeWorkgroupSizeX >= 512) {
      this.workgroupSize = [512, 1, 1];
    } else if (reduceInfo.inSize >= 4096) {
      this.workgroupSize = [256, 1, 1];
    } else {
      this.workgroupSize = [64, 1, 1];
    }
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);
    this.reduceType = reduceType;
    this.shaderKey = `reduce_${reduceType}`;
  }
  getUserCode() {
    let reduceOp = ``;
    let initValue = "0.0";
    const workgroupSizeX = this.workgroupSize[0];
    if (this.reduceType === "min" || this.reduceType === "max") {
      reduceOp = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === "min" ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`;
      initValue = "f32(x[offset])";
    } else if (this.reduceType === "sum" || this.reduceType === "mean") {
      reduceOp = " bestValue = bestValue + candidate; ";
    } else if (this.reduceType === "prod") {
      reduceOp = " bestValue = bestValue * candidate; ";
      initValue = "1.0";
    } else if (this.reduceType === "all") {
      reduceOp = " bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ";
      initValue = "1.0";
    } else if (this.reduceType === "any") {
      reduceOp = " bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ";
      initValue = "0.0";
    }
    const outputSnippet = this.reduceType === "mean" ? `setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));` : `setOutputAtIndex(outputIndex, bestValue);`;
    const sharedMemorySnippet = `
         var<workgroup> xBestValues : array<f32, ${workgroupSizeX}>;
       `;
    const userCode = `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${sharedMemorySnippet}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${getMainHeaderString("index")} {
         let outputIndex = index / ${workgroupSizeX};
         let offset = getOffset(outputIndex);
         var bestValue = ${initValue};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${workgroupSizeX}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${workgroupSizeX}) {
           let candidate = f32(x[offset + k]);
           ${reduceOp}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${workgroupSizeX}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${reduceOp}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${outputSnippet}
        }
       }
     `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/reduce.js
function reduce9(x, axis, keepDims, reduceType, backend3) {
  const xRank = x.shape.length;
  const toDispose = [];
  const origAxes = exports_util.parseAxisParam(axis, x.shape);
  let axes = origAxes;
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, xRank);
  let input2 = x;
  if (permutedAxes != null) {
    input2 = transpose13({ inputs: { x }, attrs: { perm: permutedAxes }, backend: backend3 });
    axes = exports_backend_util.getInnerMostAxes(axes.length, xRank);
    toDispose.push(input2);
  }
  exports_backend_util.assertAxesAreInnerMostDims(reduceType, axes, xRank);
  const [reduceOutShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(input2.shape, axes);
  let resOutShape = reduceOutShape;
  if (keepDims) {
    resOutShape = exports_backend_util.expandShapeToKeepDim(reduceOutShape, origAxes);
  }
  let res;
  if ((reduceType === "max" || reduceType === "prod") && backend3.shouldExecuteOnCPU([input2])) {
    const xVals = backend3.tensorMap.get(input2.dataId).values;
    switch (reduceType) {
      case "max":
        const outValues = maxImplCPU2(xVals, exports_util.sizeFromShape(reduceShape), resOutShape, x.dtype);
        res = backend3.makeTensorInfo(resOutShape, x.dtype, outValues);
        break;
      case "prod":
        const { outVals, outShape, outDtype } = prodImplCPU2(input2.shape, input2.dtype, xVals, axes);
        res = backend3.makeTensorInfo(outShape, outDtype, outVals);
        break;
      default:
        throw new Error(`${reduceType} CPU implementation is not yet supported.`);
    }
  } else {
    const inSize = exports_util.sizeFromShape(reduceShape);
    const xSize = exports_util.sizeFromShape(input2.shape);
    const batchSize = xSize / inSize;
    const reduceInfo = { windowSize: inSize, inSize, batchSize, outSize: 1 };
    const dtype = RETURN_TYPES[reduceType] || sumOutType(x.dtype);
    const uniformData = [
      { type: "int32", data: [inSize] }
    ];
    const program = new ReduceProgram2(reduceInfo, reduceType, backend3.device.limits.maxComputeWorkgroupSizeX);
    const reduced = backend3.runWebGPUProgram(program, [input2], dtype, uniformData);
    toDispose.push(reduced);
    res = reshape80({ inputs: { x: reduced }, attrs: { shape: resOutShape }, backend: backend3 });
  }
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return res;
}
var RETURN_TYPES = {
  mean: "float32",
  all: "bool",
  any: "bool"
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/All.js
function all6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { keepDims, axis } = attrs;
  return reduce9(x, axis, keepDims, "all", backend3);
}
var allConfig3 = {
  kernelName: All,
  backendName: "webgpu",
  kernelFunc: all6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Any.js
init_dist();
function any6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { keepDims, axis } = attrs;
  return reduce9(x, axis, keepDims, "any", backend3);
}
var anyConfig3 = {
  kernelName: Any,
  backendName: "webgpu",
  kernelFunc: any6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ArgMax.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/argminmax_webgpu.js
init_dist();
class ArgMinMaxProgram2 {
  constructor(inputShape, axis, reduceType) {
    this.workgroupSize = [64, 1, 1];
    this.variableNames = ["x"];
    this.uniforms = "infinityValue : f32,";
    this.size = true;
    const axes = [axis];
    this.op = reduceType === "min" ? "<" : ">";
    const [outputShape, reduceShape] = exports_backend_util.computeOutAndReduceShapes(inputShape, axes);
    this.outputShape = outputShape.length === 0 ? [1] : outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    if (exports_util.sizeFromShape(reduceShape) < 32) {
      this.type = "plain";
      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    } else {
      this.type = "shared";
      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [1, 1, 1]);
    }
    this.inputShape = inputShape;
    this.shaderKey = `argMinMax_${this.op}_${this.type}`;
  }
  getUserCode() {
    const workgroupSizeX = this.workgroupSize[0];
    const getInputShapeLastDim = () => {
      if (this.inputShape.length === 1) {
        return "uniforms.xShape";
      } else {
        return `uniforms.xShape.${getCoordsXYZ(this.inputShape.length - 1)}`;
      }
    };
    const splitOutputCoords = () => {
      let snippet = "";
      if (this.outputShape.length === 1) {
        if (this.inputShape.length !== 1) {
          snippet += "outputCoords,";
        }
      } else {
        for (let i = 0;i < this.outputShape.length; i++) {
          snippet += `outputCoords.${getCoordsXYZ(i)},`;
        }
      }
      return snippet;
    };
    if (this.type === "shared") {
      const sharedMemorySnippet = `
      var<workgroup> xBestIndices : array<i32, ${workgroupSizeX}>;
      var<workgroup> xBestValues : array<f32, ${workgroupSizeX}>;
    `;
      const userCode = `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${sharedMemorySnippet}

      ${getMainHeaderString("index")} {
        let outputIndex = index / ${workgroupSizeX};
        let reduceLength = ${getInputShapeLastDim()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${workgroupSizeX}) {
          let candidate = getX(${splitOutputCoords()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${workgroupSizeX}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `;
      return userCode;
    } else {
      const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${splitOutputCoords()} 0);
          let reduceLength = ${getInputShapeLastDim()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${splitOutputCoords()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
      return userCode;
    }
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ArgMax.js
function argMax4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis } = attrs;
  let axes = exports_util.parseAxisParam(axis, x.shape);
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose13({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = exports_backend_util.getInnerMostAxes(axes.length, $x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("argMax", [axes[0]], $x.shape.length);
  const program = new ArgMinMaxProgram2($x.shape, axes[0], "max");
  const uniformData = [{ type: "float32", data: [Number.NEGATIVE_INFINITY] }];
  const out = backend3.runWebGPUProgram(program, [$x], "int32", uniformData);
  intermediateTensorInfos.forEach((t) => backend3.disposeData(t.dataId));
  return out;
}
var argMaxConfig3 = {
  kernelName: ArgMax,
  backendName: "webgpu",
  kernelFunc: argMax4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ArgMin.js
init_dist();
function argMin4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis } = attrs;
  let axes = exports_util.parseAxisParam(axis, x.shape);
  const permutedAxes = exports_backend_util.getAxesPermutation(axes, x.shape.length);
  let $x = x;
  const intermediateTensorInfos = [];
  if (permutedAxes != null) {
    $x = transpose13({ inputs: { x }, backend: backend3, attrs: { perm: permutedAxes } });
    intermediateTensorInfos.push($x);
    axes = exports_backend_util.getInnerMostAxes(axes.length, $x.shape.length);
  }
  exports_backend_util.assertAxesAreInnerMostDims("argMin", [axes[0]], $x.shape.length);
  const program = new ArgMinMaxProgram2($x.shape, axes[0], "min");
  const uniformData = [{ type: "float32", data: [Number.POSITIVE_INFINITY] }];
  const out = backend3.runWebGPUProgram(program, [$x], "int32", uniformData);
  intermediateTensorInfos.forEach((t) => backend3.disposeData(t.dataId));
  return out;
}
var argMinConfig3 = {
  kernelName: ArgMin,
  backendName: "webgpu",
  kernelFunc: argMin4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Asin.js
init_dist();
var asin5 = unaryKernelFunc3({ opType: UnaryOpType.ASIN });
var asinConfig3 = {
  kernelName: Asin,
  backendName: "webgpu",
  kernelFunc: asin5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Asinh.js
init_dist();
var asinh5 = unaryKernelFunc3({ opType: UnaryOpType.ASINH });
var asinhConfig3 = {
  kernelName: Asinh,
  backendName: "webgpu",
  kernelFunc: asinh5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Atan.js
init_dist();
var atan7 = unaryKernelFunc3({ opType: UnaryOpType.ATAN });
var atanConfig3 = {
  kernelName: Atan,
  backendName: "webgpu",
  kernelFunc: atan7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Atan2.js
init_dist();
var atan26 = binaryKernelFunc3({ opType: BinaryOpType.ATAN2 });
var atan2Config3 = {
  kernelName: Atan2,
  backendName: "webgpu",
  kernelFunc: atan26
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Atanh.js
init_dist();
var atanh5 = unaryKernelFunc3({ opType: UnaryOpType.ATANH });
var atanhConfig3 = {
  kernelName: Atanh,
  backendName: "webgpu",
  kernelFunc: atanh5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AvgPool.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Pool_impl.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/pool_filtersizeone_webgpu.js
class PoolWithFilterSizeEqualsOneProgram {
  constructor(convInfo) {
    this.variableNames = ["x"];
    this.uniforms = `strides : vec2<i32>,`;
    this.workgroupSize = [256, 1, 1];
    this.size = true;
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "poolWithFilterSizeEqualsOne";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/pool_webgpu.js
class Pool2DProgram2 {
  constructor(convInfo, poolType, computePositions = false, flattenPositions = false, includeBatchIndex = false) {
    this.variableNames = ["x"];
    this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,`;
    this.workgroupSize = [128, 1, 1];
    this.size = true;
    if (poolType === "avg" && computePositions) {
      throw new Error("Cannot compute positions for average pool.");
    }
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.poolType = poolType;
    this.computePositions = computePositions;
    this.flattenPositions = flattenPositions;
    this.includeBatchIndex = includeBatchIndex;
    this.shaderKey = `pool2D_${poolType}_${computePositions}_${flattenPositions}_${includeBatchIndex}`;
  }
  getUserCode() {
    let updateSnippet;
    if (this.poolType === "avg") {
      updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;
    } else if (this.computePositions) {
      const positionStr = this.flattenPositions ? this.includeBatchIndex ? `((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d` : `(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d` : `wR * uniforms.filterDims.y + wC`;
      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${positionStr};
      }`;
    } else {
      updateSnippet = `resultValue = max(value, resultValue);`;
    }
    let returnValue = `resultValue`;
    if (this.poolType === "avg") {
      returnValue = `resultValue / max(count, 1.0)`;
    }
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${updateSnippet}
            }
          }

          ${this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` : `setOutputAtIndex(index, ${returnValue});`}
        }
      }
    `;
    return userCode;
  }
}

class Pool3DProgram2 {
  constructor(convInfo, poolType, computePositions = false, flattenPositions = false, includeBatchIndex = false) {
    this.variableNames = ["x"];
    this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,`;
    this.workgroupSize = [128, 1, 1];
    this.size = true;
    if (poolType === "avg" && computePositions) {
      throw new Error("Cannot compute positions for average pool.");
    }
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.poolType = poolType;
    this.computePositions = computePositions;
    this.flattenPositions = flattenPositions;
    this.includeBatchIndex = includeBatchIndex;
    this.shaderKey = `pool3D_${poolType}_${computePositions}_${flattenPositions}_${includeBatchIndex}`;
  }
  getUserCode() {
    let updateSnippet;
    if (this.poolType === "avg") {
      updateSnippet = `resultValue += value; count += 1.0;`;
    } else if (this.computePositions) {
      const positionStr = this.flattenPositions ? this.includeBatchIndex ? `(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch` : `((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch` : `wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC`;
      updateSnippet = `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${positionStr};
      }`;
    } else {
      updateSnippet = `resultValue = max(value, resultValue);`;
    }
    let returnValue = `resultValue`;
    if (this.poolType === "avg") {
      returnValue = `resultValue / max(count, 1.0)`;
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${updateSnippet}
              }
            }
          }

          ${this.computePositions ? `setOutputAtIndexI32(index, maxPosition);` : `setOutputAtIndex(index, ${returnValue});`}
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Max.js
init_dist();
function max10(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { reductionIndices, keepDims } = attrs;
  return reduce9(x, reductionIndices, keepDims, "max", backend3);
}
var maxConfig3 = {
  kernelName: Max,
  backendName: "webgpu",
  kernelFunc: max10
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Mean.js
init_dist();
function mean7(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { keepDims, axis } = attrs;
  return reduce9(x, axis, keepDims, "mean", backend3);
}
var meanConfig3 = {
  kernelName: Mean,
  backendName: "webgpu",
  kernelFunc: mean7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Pool_impl.js
function poolImpl(x, convInfo, poolType, backend3) {
  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 && exports_util.arraysEqual(convInfo.inShape, convInfo.outShape)) {
    return identity4({ inputs: { x }, backend: backend3 });
  }
  if (convInfo.filterWidth === convInfo.inWidth && convInfo.filterHeight === convInfo.inHeight && convInfo.batchSize === 1 && convInfo.padInfo.type === "VALID") {
    const length = x.shape.length;
    const reshapeX = reshape80({
      inputs: { x },
      backend: backend3,
      attrs: {
        shape: [
          x.shape[length - 3] * x.shape[length - 2],
          x.shape[length - 1]
        ]
      }
    });
    let reduceX;
    if (poolType === "avg") {
      reduceX = mean7({ inputs: { x: reshapeX }, backend: backend3, attrs: { axis: 0, keepDims: false } });
    } else {
      exports_util.assert(poolType === "max", () => `Invalid pool type ${poolType}`);
      reduceX = max10({
        inputs: { x: reshapeX },
        backend: backend3,
        attrs: { reductionIndices: 0, keepDims: false }
      });
    }
    const result = reshape80({ inputs: { x: reduceX }, backend: backend3, attrs: { shape: convInfo.outShape } });
    backend3.disposeData(reshapeX.dataId);
    backend3.disposeData(reduceX.dataId);
    return result;
  }
  let program;
  const dimensions = [{ type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] }];
  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1) {
    program = new PoolWithFilterSizeEqualsOneProgram(convInfo);
  } else {
    if (poolType === "avg") {
      program = new Pool2DProgram2(convInfo, "avg");
    } else {
      exports_util.assert(poolType === "max", () => `Invalid pool type ${poolType}`);
      program = new Pool2DProgram2(convInfo, "max");
    }
    dimensions.push({ type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] }, {
      type: "int32",
      data: [convInfo.dilationHeight, convInfo.dilationWidth]
    }, { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }, {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    });
  }
  return backend3.runWebGPUProgram(program, [x], x.dtype, dimensions);
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AvgPool.js
function avgPool4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = 1;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  return poolImpl(x, convInfo, "avg", backend3);
}
var avgPoolConfig3 = {
  kernelName: AvgPool,
  backendName: "webgpu",
  kernelFunc: avgPool4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AvgPool3D.js
init_dist();
function avgPool3D3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dataFormat, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode, dataFormat);
  const avgPoolProgram = new Pool3DProgram2(convInfo, "avg");
  const dimensions = [
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    {
      type: "int32",
      data: [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left]
    },
    {
      type: "int32",
      data: [convInfo.inDepth, convInfo.inHeight, convInfo.inWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth,
        convInfo.effectiveFilterHeight,
        convInfo.effectiveFilterWidth
      ]
    }
  ];
  return backend3.runWebGPUProgram(avgPoolProgram, [x], x.dtype, dimensions);
}
var avgPool3DConfig3 = {
  kernelName: AvgPool3D,
  backendName: "webgpu",
  kernelFunc: avgPool3D3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AvgPool3DGrad.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/avg_pool_backprop_webgpu.js
class AvgPool2DBackpropProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy"];
    this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `avgPool2DBackprop`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    return userCode;
  }
}

class AvgPool3DBackpropProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy"];
    this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `avgPool3DBackprop`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AvgPool3DGrad.js
function avgPool3DGrad3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, 1, pad9, dimRoundingMode);
  const program = new AvgPool3DBackpropProgram2(convInfo);
  const avgMultiplier = 1 / (convInfo.filterDepth * convInfo.filterHeight * convInfo.filterWidth);
  const uniformData = [
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth - 1 - convInfo.padInfo.front,
        convInfo.effectiveFilterHeight - 1 - convInfo.padInfo.top,
        convInfo.effectiveFilterWidth - 1 - convInfo.padInfo.left
      ]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth,
        convInfo.effectiveFilterHeight,
        convInfo.effectiveFilterWidth
      ]
    },
    { type: "int32", data: [convInfo.outDepth] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "float32", data: [avgMultiplier] }
  ];
  return backend3.runWebGPUProgram(program, [dy2], x.dtype, uniformData);
}
var avgPool3DGradConfig4 = {
  kernelName: AvgPool3DGrad,
  backendName: "webgpu",
  kernelFunc: avgPool3DGrad3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/AvgPoolGrad.js
init_dist();
function avgPoolGrad4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  assertNotComplex3([dy2, input2], "avgPoolGrad");
  const { filterSize, strides, pad: pad9 } = attrs;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, 1, pad9);
  const program = new AvgPool2DBackpropProgram2(convInfo);
  const avgMultiplier = 1 / (convInfo.filterHeight * convInfo.filterWidth);
  const uniformData = [
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterHeight - 1 - convInfo.padInfo.top,
        convInfo.effectiveFilterWidth - 1 - convInfo.padInfo.left
      ]
    },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "float32", data: [avgMultiplier] }
  ];
  return backend3.runWebGPUProgram(program, [dy2], x.dtype, uniformData);
}
var avgPoolGradConfig4 = {
  kernelName: AvgPoolGrad,
  backendName: "webgpu",
  kernelFunc: avgPoolGrad4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BatchMatMul.js
init_dist();
function batchMatMul3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { a, b } = inputs;
  const { transposeA, transposeB } = attrs;
  return batchMatMulImpl2({ a, b, transposeA, transposeB, backend: backend3 });
}
var batchMatMulConfig3 = {
  kernelName: BatchMatMul,
  backendName: "webgpu",
  kernelFunc: batchMatMul3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BatchToSpaceND.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Slice.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/slice_webgpu.js
function getCoords3(rank) {
  if (rank === 1) {
    return "sourceLoc";
  } else if (rank <= 6) {
    return coords2.slice(0, rank).map((coord) => `sourceLoc.${coord}`).join(",");
  } else {
    throw Error(`Slicing for rank ${rank} is not yet supported`);
  }
}

class SliceProgram2 {
  constructor(start, destSize) {
    this.variableNames = ["source"];
    this.workPerThread = 1;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = destSize;
    this.rank = destSize.length;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    this.start = start;
    this.uniforms = `start : ${getCoordsDataType2(start.length)}, `;
    this.shaderKey = "slice";
  }
  getUserCode() {
    const dtype = getCoordsDataType2(this.rank);
    const sourceCoords = getCoords3(this.rank);
    let coordSum;
    if (this.start.length === 1) {
      coordSum = this.outputShape.map((_, i) => {
        return `sourceLoc = uniforms.start + coords;`;
      });
    } else {
      coordSum = this.outputShape.map((_, i) => {
        return `sourceLoc.${coords2[i]} = uniforms.start.${getCoordsXYZ(i)} + coords.${coords2[i]};`;
      });
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${dtype};
          let coords = getCoordsFromIndex(index);
          ${coordSum.join("\n")}
          setOutputAtIndex(index, getSource(${sourceCoords}));
        }
      }
    `;
    return userCode;
  }
}
var coords2 = ["x", "y", "z", "w", "u", "v"];

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Slice.js
function slice18(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { begin, size } = attrs;
  const [$begin, $size] = exports_slice_util.parseSliceParams(x, begin, size);
  exports_slice_util.assertParamsValid(x, $begin, $size);
  if (backend3.shouldExecuteOnCPU([x]) || x.dtype === "string") {
    const xTensorData = backend3.tensorMap.get(x.dataId);
    const outValues = sliceImplCPU2(xTensorData.values, $begin, $size, x.shape, x.dtype);
    return backend3.makeTensorInfo($size, x.dtype, outValues);
  }
  if (exports_util.sizeFromShape($size) === 0) {
    return backend3.makeTensorInfo($size, x.dtype, []);
  }
  const program = new SliceProgram2($begin, $size);
  const uniformData = [{ type: "int32", data: $begin }];
  return backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
}
var sliceConfig3 = {
  kernelName: Slice,
  backendName: "webgpu",
  kernelFunc: slice18
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BatchToSpaceND.js
var batchToSpaceND4 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockShape, crops } = attrs;
  exports_util.assert(x.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not " + "implemented yet");
  const prod6 = blockShape.reduce((a, b) => a * b);
  const reshaped = exports_backend_util.getReshaped(x.shape, blockShape, prod6);
  const permuted = exports_backend_util.getPermuted(reshaped.length, blockShape.length);
  const reshapedPermuted = exports_backend_util.getReshapedPermuted(x.shape, blockShape, prod6);
  const sliceBeginCoords = exports_backend_util.getSliceBeginCoords(crops, blockShape.length);
  const sliceSize = exports_backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);
  const toDispose = [];
  const reshapedIntermediate = reshape80({ inputs: { x }, backend: backend3, attrs: { shape: reshaped } });
  const transposedIntermediate = transpose13({ inputs: { x: reshapedIntermediate }, backend: backend3, attrs: { perm: permuted } });
  const reshapedIntermediate2 = reshape80({
    inputs: { x: transposedIntermediate },
    backend: backend3,
    attrs: { shape: reshapedPermuted }
  });
  const sliced = slice18({
    inputs: { x: reshapedIntermediate2 },
    backend: backend3,
    attrs: { begin: sliceBeginCoords, size: sliceSize }
  });
  toDispose.push(reshapedIntermediate);
  toDispose.push(transposedIntermediate);
  toDispose.push(reshapedIntermediate2);
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return sliced;
};
var batchToSpaceNDConfig3 = {
  kernelName: BatchToSpaceND,
  backendName: "webgpu",
  kernelFunc: batchToSpaceND4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Bincount.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/bincount_webgpu.js
var writeSnippet = `
  fn bincount_write(index: i32, value: f32) {
    ${atomicAddSnippet("&result[index]", "value", "float32")}
  }
`;
var binaryWriteSnippet = `
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;

class BincountProgram {
  constructor(shape, hasWeights, binaryOutput = false) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.uniforms = "binCountSize : i32,";
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.hasWeights = true;
    this.binaryOutput = false;
    this.outputShape = shape;
    this.rank = shape.length;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.binaryOutput = binaryOutput;
    if (binaryOutput) {
      this.atomic = false;
    }
    this.hasWeights = hasWeights;
    if (this.hasWeights) {
      this.variableNames.push("w");
    }
    this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;
  }
  getUserCode() {
    const userCode = `
    ${this.binaryOutput ? binaryWriteSnippet : writeSnippet}
  ${getMainHeaderString("index")} {
    ${this.rank === 1 ? `if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(index)" : "1."};
        bincount_write(indexVal, value);
      }
    }` : `let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(coord[0], coord[1])" : "1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Bincount.js
function bincount5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, weights } = inputs;
  const { size } = attrs;
  const xSize = exports_util.sizeFromShape(x.shape);
  const weightsSize = exports_util.sizeFromShape(weights.shape);
  const hasWeights = weightsSize > 0;
  const outputSize = [size];
  const dtype = weights.dtype;
  const output = fill8({ backend: backend3, attrs: { shape: outputSize, value: 0, dtype } });
  const program = new BincountProgram([xSize], hasWeights);
  const uniformData = [{ type: "int32", data: [size] }];
  const bincountInputs = hasWeights ? [x, weights] : [x];
  const res = backend3.runWebGPUProgram(program, bincountInputs, dtype, uniformData, output);
  return res;
}
var bincountConfig3 = {
  kernelName: Bincount,
  backendName: "webgpu",
  kernelFunc: bincount5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BroadcastArgs.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/broadcast_args_webgpu.js
class BroadcastArgsProgram {
  constructor(shape) {
    this.outputShape = [];
    this.variableNames = ["s0", "s1"];
    this.uniforms = "s0Size : i32, s1Size : i32, ";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [shape];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "broadcastArgs";
  }
  getUserCode() {
    const userCode = `
  ${getMainHeaderString("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/BroadcastArgs.js
function broadcastArgs4(args) {
  const { inputs, backend: backend3 } = args;
  const { s0, s1 } = inputs;
  if (backend3.shouldExecuteOnCPU([s0, s1])) {
    const s0TensorInfo = backend3.tensorMap.get(s0.dataId);
    const s1TensorInfo = backend3.tensorMap.get(s1.dataId);
    const s0Vals = s0TensorInfo.values;
    const s1Vals = s1TensorInfo.values;
    const broadcastShape = exports_backend_util.assertAndGetBroadcastShape(Array.from(s0Vals), Array.from(s1Vals));
    return backend3.makeTensorInfo([broadcastShape.length], "int32", Int32Array.from(broadcastShape));
  }
  const s0Size = exports_util.sizeFromShape(s0.shape);
  const s1Size = exports_util.sizeFromShape(s1.shape);
  const outputSize = Math.max(s0Size, s1Size);
  const program = new BroadcastArgsProgram(outputSize);
  const uniformData = [{ type: "int32", data: [s0Size] }, { type: "int32", data: [s1Size] }];
  return backend3.runWebGPUProgram(program, [s0, s1], "int32", uniformData);
}
var broadcastArgsConfig3 = {
  kernelName: BroadcastArgs,
  backendName: "webgpu",
  kernelFunc: broadcastArgs4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cast.js
init_dist();
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/NotEqual.js
init_dist();
var notEqual4 = binaryKernelFunc3({
  opType: BinaryOpType.NOT_EQUAL,
  dtype: "bool",
  cpuKernelImpl: notEqualImplCPU2
});
var notEqualConfig3 = {
  kernelName: NotEqual,
  backendName: "webgpu",
  kernelFunc: notEqual4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Real.js
init_dist();
function real7(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const inputData = backend3.tensorMap.get(input2.dataId);
  return identity4({ inputs: { x: inputData.complexTensorInfos.real }, backend: backend3 });
}
var realConfig3 = {
  kernelName: Real,
  backendName: "webgpu",
  kernelFunc: real7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/int.js
function int3(input2, backend3) {
  const program = new UnaryOpProgram2(input2.shape, UnaryOpType.TO_INT);
  const output = backend3.runWebGPUProgram(program, [input2], "int32");
  return { dataId: output.dataId, shape: output.shape, dtype: output.dtype };
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cast.js
function cast48(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { dtype } = attrs;
  if (dtype === "complex64") {
    if (x.dtype === "complex64") {
      return identity4({ inputs: { x }, backend: backend3 });
    }
    const zerosTensor = zeros(x.shape);
    const floatX = cast48({ inputs: { x }, backend: backend3, attrs: { dtype: "float32" } });
    const result = complex10({ inputs: { real: floatX, imag: zerosTensor }, backend: backend3 });
    zerosTensor.dispose();
    backend3.disposeData(floatX.dataId);
    return result;
  }
  if (x.dtype === "complex64") {
    const realPart = real7({ inputs: { input: x }, backend: backend3 });
    const result = cast48({ inputs: { x: realPart }, backend: backend3, attrs: { dtype } });
    backend3.disposeData(realPart.dataId);
    return result;
  }
  if (!exports_util.hasEncodingLoss(x.dtype, dtype)) {
    const result = identity4({ inputs: { x }, backend: backend3 });
    return { dataId: result.dataId, shape: result.shape, dtype };
  }
  if (backend3.shouldExecuteOnCPU([x])) {
    const values = backend3.tensorMap.get(x.dataId).values;
    const [resultShape, resultType, resultData] = castImplCPU2(values, x.shape, x.dtype, dtype);
    return backend3.makeTensorInfo(resultShape, resultType, resultData);
  }
  if (dtype === "int32") {
    return int3(x, backend3);
  }
  if (dtype === "bool") {
    const zerosTensorInfo = backend3.makeTensorInfo([], "bool", exports_util.getTypedArrayFromDType("bool", 1));
    const binaryInputs = { a: x, b: zerosTensorInfo };
    const result = notEqual4({ inputs: binaryInputs, backend: backend3 });
    backend3.disposeData(zerosTensorInfo.dataId);
    return result;
  }
  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);
}
var castConfig3 = {
  kernelName: Cast,
  backendName: "webgpu",
  kernelFunc: cast48
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Ceil.js
init_dist();
var ceil5 = unaryKernelFunc3({ opType: UnaryOpType.CEIL, cpuKernelImpl: ceilImplCPU2 });
var ceilConfig3 = {
  kernelName: Ceil,
  backendName: "webgpu",
  kernelFunc: ceil5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ClipByValue.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/clip_vec4_webgpu.js
class ClipVec4Program {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.uniforms = "minVal : f32, maxVal : f32,";
    this.workPerThread = 4;
    this.workgroupSize = [64, 1, 1];
    this.outputComponent = 4;
    this.size = true;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    this.shaderKey = "clipVec4";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/clip_webgpu.js
class ClipProgram2 {
  constructor(outputShape) {
    this.variableNames = ["A"];
    this.uniforms = "minVal : f32, maxVal : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "clip";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ClipByValue.js
function clipByValue4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { clipValueMin, clipValueMax } = attrs;
  let program;
  const uniformData = [
    { type: "float32", data: [clipValueMin] },
    { type: "float32", data: [clipValueMax] }
  ];
  if (exports_util.sizeFromShape(x.shape) % 4 === 0) {
    program = new ClipVec4Program(x.shape);
  } else {
    program = new ClipProgram2(x.shape);
  }
  return backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
}
var clipByValueConfig3 = {
  kernelName: ClipByValue,
  backendName: "webgpu",
  kernelFunc: clipByValue4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ComplexAbs.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/complex_abs_webgpu.js
class ComplexAbsProgram2 {
  constructor(shape) {
    this.outputShape = [];
    this.variableNames = ["real", "imag"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "complexAbs";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ComplexAbs.js
function makeComplexComponentTensorInfo2(complexTensor, complexPart) {
  return {
    dataId: complexPart.dataId,
    dtype: complexPart.dtype,
    shape: complexTensor.shape
  };
}
function complexAbs3(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  const xData = backend3.tensorMap.get(x.dataId);
  const program = new ComplexAbsProgram2(x.shape);
  const programInputs = [
    makeComplexComponentTensorInfo2(x, xData.complexTensorInfos.real),
    makeComplexComponentTensorInfo2(x, xData.complexTensorInfos.imag)
  ];
  return backend3.runWebGPUProgram(program, programInputs, programInputs[0].dtype);
}
var complexAbsConfig3 = {
  kernelName: ComplexAbs,
  backendName: "webgpu",
  kernelFunc: complexAbs3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Concat.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Concat_impl.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/concat_webgpu.js
init_dist();
class ConcatProgram2 {
  constructor(shapes) {
    this.uniforms = "";
    this.workPerThread = 1;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = exports_backend_util.computeOutShape(shapes, 1);
    this.variableNames = shapes.map((_, i) => `T${i}`);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    this.offsetLength = shapes.length - 1;
    for (let i = 0;i < this.offsetLength; i++) {
      this.uniforms += `offset${i} : i32,`;
    }
    this.shaderKey = "concat";
  }
  getUserCode() {
    const snippets = [];
    if (this.offsetLength > 0) {
      snippets.push(`if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }`);
      for (let i = 1;i < this.offsetLength; i++) {
        snippets.push(`else if (yC < uniforms.offset${[i]}){ ` + `setOutputAtCoords(coords.x, coords.y, getT${i}(yR, yC - uniforms.offset${i - 1})); }`);
      }
      const lastIndex = this.offsetLength;
      const lastShiftIndex = this.offsetLength - 1;
      snippets.push(`else { setOutputAtCoords(coords.x, coords.y, getT${lastIndex}(yR, yC - uniforms.offset${lastShiftIndex})); }`);
    } else {
      snippets.push(`setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));`);
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${snippets.join("\n        ")}
          }
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Imag.js
init_dist();
function imag7(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  const inputData = backend3.tensorMap.get(input2.dataId);
  return identity4({ inputs: { x: inputData.complexTensorInfos.imag }, backend: backend3 });
}
var imagConfig3 = {
  kernelName: Imag,
  backendName: "webgpu",
  kernelFunc: imag7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Concat_impl.js
function concatImpl3(inputs, axis, backend3) {
  const dtype = inputs[0].dtype;
  if (dtype === "complex64") {
    const reals = inputs.map((t) => real7({ inputs: { input: t }, backend: backend3 }));
    const imags = inputs.map((t) => imag7({ inputs: { input: t }, backend: backend3 }));
    const realConcated = concatImpl3(reals, axis, backend3);
    const imagConcated = concatImpl3(imags, axis, backend3);
    const result = complex10({ inputs: { real: realConcated, imag: imagConcated }, backend: backend3 });
    reals.forEach((r) => backend3.disposeData(r.dataId));
    imags.forEach((i) => backend3.disposeData(i.dataId));
    backend3.disposeData(realConcated.dataId);
    backend3.disposeData(imagConcated.dataId);
    return result;
  }
  let runOnCpu = backend3.shouldExecuteOnCPU(inputs);
  if (dtype === "string") {
    runOnCpu = true;
  }
  if (runOnCpu) {
    const tensors2D2 = inputs.map((t) => {
      const innerSize = exports_util.sizeFromShape(t.shape.slice(axis));
      const shape = [-1, innerSize];
      return reshape80({ inputs: { x: t }, backend: backend3, attrs: { shape } });
    });
    const inputsValShapes = tensors2D2.map((t) => {
      return { vals: backend3.readSync(t.dataId), shape: t.shape };
    });
    const outShape2 = exports_backend_util.computeOutShape(tensors2D2.map((t) => t.shape), 1);
    const simplyConcat = tensors2D2[0].shape[0] === 1;
    const outVals = concatImplCPU2(inputsValShapes, outShape2, dtype, simplyConcat);
    const finalOutShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), axis);
    const outInfo = backend3.makeTensorInfo(finalOutShape, dtype, outVals);
    tensors2D2.forEach((t) => backend3.disposeData(t.dataId));
    return outInfo;
  }
  const maxInputNum = backend3.device.limits.maxStorageBuffersPerShaderStage - 1;
  if (inputs.length > maxInputNum) {
    const reducedInputs = [];
    for (let i = 0;i < inputs.length; i += maxInputNum) {
      const subArray = inputs.slice(i, i + maxInputNum);
      reducedInputs.push(concatImpl3(subArray, axis, backend3));
    }
    const result = concatImpl3(reducedInputs, axis, backend3);
    for (const i of reducedInputs) {
      backend3.disposeData(i.dataId);
    }
    return result;
  }
  const { tensors2D, outShape } = computeTensors2D2(inputs, axis, backend3);
  const shapes = tensors2D.map((t) => t.shape);
  const program = new ConcatProgram2(shapes);
  const uniformData = [];
  const offsets = new Array(shapes.length - 1);
  if (offsets.length > 0) {
    offsets[0] = shapes[0][1];
    uniformData.push({ type: "int32", data: [offsets[0]] });
    for (let i = 1;i < offsets.length; i++) {
      offsets[i] = offsets[i - 1] + shapes[i][1];
      uniformData.push({ type: "int32", data: [offsets[i]] });
    }
  }
  const res = backend3.runWebGPUProgram(program, tensors2D, tensors2D[0].dtype, uniformData);
  tensors2D.forEach((r) => backend3.disposeData(r.dataId));
  const reshapedResult = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape: outShape } });
  backend3.disposeData(res.dataId);
  return reshapedResult;
}
function computeTensors2D2(inputs, axis, backend3) {
  const outShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), axis);
  const tensors2D = inputs.map((t) => reshape80({
    inputs: { x: t },
    backend: backend3,
    attrs: {
      shape: [
        exports_util.sizeFromShape(t.shape.slice(0, axis)),
        exports_util.sizeFromShape(t.shape.slice(axis))
      ]
    }
  }));
  return { tensors2D, outShape };
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Concat.js
function concat16(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { axis } = attrs;
  const $axis = exports_util.parseAxisParam(axis, inputs[0].shape)[0];
  const shapes = inputs.map((t) => t.shape);
  exports_backend_util.assertParamsConsistent(shapes, $axis);
  const outShape = exports_backend_util.computeOutShape(inputs.map((t) => t.shape), $axis);
  if (exports_util.sizeFromShape(outShape) === 0) {
    return backend3.makeTensorInfo(outShape, inputs[0].dtype, []);
  }
  const $inputs = inputs.filter((t) => exports_util.sizeFromShape(t.shape) > 0);
  if ($inputs.length === 1) {
    return identity4({ inputs: { x: $inputs[0] }, backend: backend3 });
  }
  return concatImpl3($inputs, $axis, backend3);
}
var concatConfig3 = {
  kernelName: Concat,
  backendName: "webgpu",
  kernelFunc: concat16
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2D.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2D_impl.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/conv2d_mm_webgpu.js
function conv2dCommonSnippet(isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, activation2 = null, hasPreluActivationWeights = false, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4) {
  const getXSnippet = (innerElementSize2) => {
    switch (innerElementSize2) {
      case 1:
        return "resData = f32(x[xIndex]);";
      case 3:
        return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
      case 4:
        return "resData = vec4<f32>(x[xIndex / 4]);";
      default:
        throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
    }
  };
  const getWSnippet = (innerElementSize2) => {
    switch (innerElementSize2) {
      case 1:
        return "return f32(W[row * uniforms.wShape[3] + col]);";
      case 4:
        return "return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";
      default:
        throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
    }
  };
  const coordASnippet = isChannelsLast ? `
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `;
  const coordResSnippet = isChannelsLast ? `
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      ` : `
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `;
  const xHight = isChannelsLast ? "uniforms.xShape[1]" : "uniforms.xShape[2]";
  const xWidth = isChannelsLast ? "uniforms.xShape[2]" : "uniforms.xShape[3]";
  const row = isChannelsLast ? "row" : "col";
  const col = isChannelsLast ? "col" : "row";
  const readXSnippet = `
      let inChannels = uniforms.wShape[2];
      let outWidth = ${isChannelsLast ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
      let outRow = ${row} / outWidth;
      let outCol = ${row} % outWidth;

      let WRow = ${col} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${col} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${col} % inChannels;
      var resData = ${typeSnippet(innerElementSizeX)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${xHight} && xCol >= 0 && xCol < ${xWidth}) {
        ${coordASnippet}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${getXSnippet(innerElementSizeX)}
      }
      return resData;`;
  const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
      ${readXSnippet}` : `
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${readXSnippet}
      }
      return ${typeSnippet(innerElementSizeX)}(0.0);` : fitInner && fitBOuter ? `
      ${readXSnippet}` : `
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${readXSnippet}
      }
      return ${typeSnippet(innerElementSizeX)}(0.0);`;
  const sampleW = `${getWSnippet(innerElementSizeW)}`;
  const resType = typeSnippet(innerElementSize);
  const aType = isChannelsLast ? typeSnippet(innerElementSizeX) : typeSnippet(innerElementSizeW);
  const bType = isChannelsLast ? typeSnippet(innerElementSizeW) : typeSnippet(innerElementSizeX);
  const userCode = `
      ${activationFnSnippet(activation2, hasPreluActivationWeights, innerElementSize === 4, 4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${aType} {
        ${isChannelsLast ? sampleX : sampleW}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${bType} {
        ${isChannelsLast ? sampleW : sampleX}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${resType}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${isChannelsLast ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
        ${coordResSnippet}
        ${biasActivationSnippet(addBias, activation2)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;
  return userCode;
}

class Conv2DMMProgram {
  constructor(convInfo, dimAOuter, dimBOuter, dimInner, addBias = false, activation2 = null, hasPreluActivationWeights = false, sequentialAccessByThreads = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,`;
    this.outputShape = convInfo.outShape;
    this.isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.isVec4 = ((convInfo.inChannels % 4 === 0 || convInfo.inChannels % 3 === 0) && this.isChannelsLast || convInfo.outWidth % 4 === 0 && !this.isChannelsLast) && convInfo.outChannels % 4 === 0;
    this.dispatchLayout = this.isChannelsLast ? { x: [3], y: [1, 2], z: [0] } : { x: [2, 3], y: [1], z: [0] };
    this.workgroupSize = computeWorkgroupSizeForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);
    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
    if (this.isVec4) {
      this.outputComponent = 4;
      if (this.isChannelsLast && convInfo.inChannels % 4 !== 0) {
        this.innerElementSize = 3;
        this.variableComponents = [1, 4];
      } else {
        this.innerElementSize = 4;
        this.variableComponents = [4, 4];
      }
      if (addBias) {
        this.variableNames.push("bias");
        this.variableComponents.push(4);
      }
      if (hasPreluActivationWeights) {
        this.variableNames.push("preluActivationWeights");
        this.variableComponents.push(4);
      }
    } else {
      this.innerElementSize = this.elementsPerThread[0];
      if (addBias) {
        this.variableNames.push("bias");
      }
      if (hasPreluActivationWeights) {
        this.variableNames.push("preluActivationWeights");
      }
    }
    this.sequentialAccessByThreads = sequentialAccessByThreads;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1];
    this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0];
    this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]);
    this.fitAOuter = dimAOuter % this.tileAOuter === 0;
    this.fitBOuter = dimBOuter % this.tileBOuter === 0;
    this.fitInner = dimInner % this.tileInner === 0;
    this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;
  }
  getUserCode() {
    const matMulSource = this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, false, null, this.sequentialAccessByThreads);
    const elementsSize = this.isVec4 ? [this.innerElementSize, 4, 4] : [1, 1, 1];
    const userCode = `
    ${conv2dCommonSnippet(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, elementsSize[0], elementsSize[1], elementsSize[2])}
    ${matMulSource}
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/conv2d_naive_webgpu.js
class Conv2DNaiveProgram {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivationWeights = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,";
    this.workgroupSize = [4, 4, 8];
    this.outputShape = convInfo.outShape;
    this.isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.dispatchLayout = this.isChannelsLast ? { x: [2], y: [1], z: [0, 3] } : { x: [3], y: [2], z: [0, 1] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivationWeights = hasPreluActivationWeights;
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivationWeights) {
      this.variableNames.push("preluActivationWeights");
    }
    this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;
  }
  getUserCode() {
    const userCode = `
       ${activationFnSnippet(this.activation, this.hasPreluActivationWeights, false, 4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast ? `vec4<i32>(batch, row, col, chan);` : `vec4<i32>(batch, chan, row, col);`}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${biasActivationSnippet(this.addBias, this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${getMainHeaderString("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast ? `coords[3];` : `coords[1];`}
         let outRow = ${this.isChannelsLast ? `coords[1];` : `coords[2];`}
         let outCol = ${this.isChannelsLast ? `coords[2];` : `coords[3];`}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast ? `uniforms.xShape[3];` : `uniforms.xShape[1];`} xChannel = xChannel + 1) {
               ${this.isChannelsLast ? `let v = readInp(batch, xRow, xCol, xChannel);` : `let v = readInp(batch, xChannel, xRow, xCol);`}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/im2col_webgpu.js
class Im2ColProgram {
  constructor(outputShape, isChannelsLast) {
    this.variableNames = ["x"];
    this.uniforms = `pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.isChannelsLast = isChannelsLast;
    this.shaderKey = `im2col_${this.isChannelsLast}`;
  }
  getUserCode() {
    const rowDim = this.isChannelsLast ? 1 : 2;
    const colDim = this.isChannelsLast ? 2 : 3;
    const row = this.isChannelsLast ? "coords[1]" : "coords[2]";
    const col = this.isChannelsLast ? "coords[2]" : "coords[1]";
    const getXSnippet = this.isChannelsLast ? "getX(batch, xRow, xCol, ch)" : "getX(batch, ch, xRow, xCol)";
    const userCode = `
    ${getMainHeaderString("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${row};
        let col = ${col};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${rowDim}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${colDim}] && xCol >= 0) {
            value = ${getXSnippet};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2D_impl.js
function getShapeForBatchMatMul2(shape, isChannelsLast) {
  const length = shape.length;
  if (length >= 3) {
    return isChannelsLast ? [
      ...shape.slice(0, -3),
      shape[length - 3] * shape[length - 2],
      shape[length - 1]
    ] : [
      ...shape.slice(0, -3),
      shape[length - 3],
      shape[length - 2] * shape[length - 1]
    ];
  } else if (!isChannelsLast && length === 1 && shape[0] > 1) {
    return [shape[0], 1];
  } else {
    return null;
  }
}
function conv2dByMatMul2({ x, filter, convInfo, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const transposeA = isChannelsLast ? false : true;
  const transposeB = false;
  const sameSize = isChannelsLast && convInfo.filterHeight === convInfo.inHeight && convInfo.filterWidth === convInfo.inWidth && convInfo.padInfo.type === "VALID";
  const intermediates = [];
  let xReshaped;
  let filterReshaped;
  if (sameSize) {
    const sharedDim = convInfo.inHeight * convInfo.inWidth * convInfo.inChannels;
    xReshaped = reshape80({
      inputs: { x },
      backend: backend3,
      attrs: { shape: [1, convInfo.batchSize, sharedDim] }
    });
    filterReshaped = reshape80({
      inputs: { x: filter },
      backend: backend3,
      attrs: { shape: [1, sharedDim, convInfo.outChannels] }
    });
  } else {
    xReshaped = reshape80({
      inputs: { x },
      backend: backend3,
      attrs: {
        shape: isChannelsLast ? [
          convInfo.batchSize,
          convInfo.inHeight * convInfo.inWidth,
          convInfo.inChannels
        ] : [
          convInfo.batchSize,
          convInfo.inChannels,
          convInfo.inHeight * convInfo.inWidth
        ]
      }
    });
    filterReshaped = reshape80({
      inputs: { x: filter },
      backend: backend3,
      attrs: { shape: [1, convInfo.inChannels, convInfo.outChannels] }
    });
  }
  intermediates.push(xReshaped);
  intermediates.push(filterReshaped);
  if (preluActivationWeights != null) {
    const targetShape = getShapeForBatchMatMul2(preluActivationWeights.shape, isChannelsLast);
    if (targetShape != null) {
      preluActivationWeights = reshape80({
        inputs: { x: preluActivationWeights },
        backend: backend3,
        attrs: { shape: targetShape }
      });
      intermediates.push(preluActivationWeights);
    }
  }
  if (bias != null) {
    const targetShape = getShapeForBatchMatMul2(bias.shape, isChannelsLast);
    if (targetShape != null) {
      bias = reshape80({ inputs: { x: bias }, backend: backend3, attrs: { shape: targetShape } });
      intermediates.push(bias);
    }
  }
  const result = batchMatMulImpl2({
    a: isChannelsLast ? xReshaped : filterReshaped,
    b: isChannelsLast ? filterReshaped : xReshaped,
    transposeA,
    transposeB,
    backend: backend3,
    bias,
    activation: activation2,
    preluActivationWeights,
    leakyreluAlpha
  });
  const out = reshape80({ inputs: { x: result }, backend: backend3, attrs: { shape: convInfo.outShape } });
  intermediates.push(result);
  for (const i of intermediates) {
    backend3.disposeData(i.dataId);
  }
  return out;
}
function conv2dWithIm2Col({ x, filter, convInfo, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const { filterWidth, filterHeight, inChannels, strideWidth, strideHeight, padInfo, outWidth, outHeight, dilationWidth, dilationHeight, dataFormat } = convInfo;
  const isChannelsLast = dataFormat === "channelsLast";
  const sharedDim = filterWidth * filterHeight * inChannels;
  const numCols = outHeight * outWidth;
  const x2ColShape = isChannelsLast ? [convInfo.batchSize, numCols, sharedDim] : [convInfo.batchSize, sharedDim, numCols];
  const im2ColProgram = new Im2ColProgram(x2ColShape, isChannelsLast);
  const dimensions = [
    { type: "int32", data: [padInfo.top, padInfo.left] },
    { type: "int32", data: [strideHeight, strideWidth] },
    { type: "int32", data: [dilationHeight, dilationWidth] },
    { type: "int32", data: [outWidth] },
    { type: "int32", data: [inChannels * filterWidth] },
    { type: "int32", data: [inChannels] }
  ];
  const x2Col = backend3.runWebGPUProgram(im2ColProgram, [x], x.dtype, dimensions);
  const intermediates = [];
  intermediates.push(x2Col);
  const filterReshaped = reshape80({ inputs: { x: filter }, backend: backend3, attrs: { shape: [1, sharedDim, -1] } });
  intermediates.push(filterReshaped);
  if (preluActivationWeights != null) {
    const targetShape = getShapeForBatchMatMul2(preluActivationWeights.shape, isChannelsLast);
    if (targetShape != null) {
      preluActivationWeights = reshape80({
        inputs: { x: preluActivationWeights },
        backend: backend3,
        attrs: { shape: targetShape }
      });
      intermediates.push(preluActivationWeights);
    }
  }
  if (bias != null) {
    const targetShape = getShapeForBatchMatMul2(bias.shape, isChannelsLast);
    if (targetShape != null) {
      bias = reshape80({ inputs: { x: bias }, backend: backend3, attrs: { shape: targetShape } });
      intermediates.push(bias);
    }
  }
  const transposeA = isChannelsLast ? false : true;
  const transposeB = false;
  const result = batchMatMulImpl2({
    a: isChannelsLast ? x2Col : filterReshaped,
    b: isChannelsLast ? filterReshaped : x2Col,
    transposeA,
    transposeB,
    backend: backend3,
    bias,
    activation: activation2,
    preluActivationWeights,
    leakyreluAlpha
  });
  const out = reshape80({ inputs: { x: result }, backend: backend3, attrs: { shape: convInfo.outShape } });
  intermediates.push(result);
  for (const i of intermediates) {
    backend3.disposeData(i.dataId);
  }
  return out;
}
function conv2DImpl({ x, filter, convInfo, backend: backend3, bias = null, preluActivationWeights = null, leakyreluAlpha = 0, activation: activation2 = null }) {
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  const sameSize = isChannelsLast && convInfo.filterHeight === convInfo.inHeight && convInfo.filterWidth === convInfo.inWidth && convInfo.padInfo.type === "VALID";
  const useNaiveConv2d = env().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");
  if (!useNaiveConv2d && (sameSize || convInfo.filterHeight === 1 && convInfo.filterWidth === 1 && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && (convInfo.padInfo.type === "SAME" || convInfo.padInfo.type === "VALID"))) {
    return conv2dByMatMul2({
      x,
      filter,
      convInfo,
      backend: backend3,
      bias,
      activation: activation2,
      preluActivationWeights,
      leakyreluAlpha
    });
  }
  const thresholdFlagValue = env().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL");
  const thresholdToIncreaseWorkgroups = thresholdFlagValue > -1 ? thresholdFlagValue : backend3.thresholdToIncreaseWorkgroups;
  const workgroupsBy32x32 = convInfo.batchSize * Math.ceil(convInfo.outHeight * convInfo.outWidth / 32) * Math.ceil(convInfo.outChannels / 32);
  if (env().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") || workgroupsBy32x32 <= thresholdToIncreaseWorkgroups) {
    return conv2dWithIm2Col({
      x,
      filter,
      convInfo,
      backend: backend3,
      bias,
      preluActivationWeights,
      leakyreluAlpha,
      activation: activation2
    });
  }
  let program;
  const padInfo = [convInfo.padInfo.top, convInfo.padInfo.left];
  const dimensions = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [...padInfo] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] }
  ];
  if (useNaiveConv2d) {
    program = new Conv2DNaiveProgram(convInfo, hasBias, activation2, hasPreluActivationWeights);
  } else {
    const dimAOuter = isChannelsLast ? convInfo.outHeight * convInfo.outWidth : convInfo.outChannels;
    const dimBOuter = isChannelsLast ? convInfo.outChannels : convInfo.outHeight * convInfo.outWidth;
    const dimInner = convInfo.filterHeight * convInfo.filterWidth * convInfo.inChannels;
    dimensions.push({ type: "int32", data: [dimAOuter] }, { type: "int32", data: [dimBOuter] }, { type: "int32", data: [dimInner] });
    const sequentialAccessByThreads = backend3.adapterInfo.isIntel();
    program = new Conv2DMMProgram(convInfo, dimAOuter, dimBOuter, dimInner, hasBias, activation2, hasPreluActivationWeights, sequentialAccessByThreads);
  }
  const intermediates = [];
  const inputVar = [x, filter];
  if (hasBias) {
    if (!isChannelsLast && bias.shape.length === 1) {
      bias = reshape80({ inputs: { x: bias }, backend: backend3, attrs: { shape: [bias.shape[0], 1, 1] } });
      intermediates.push(bias);
    }
    inputVar.push(bias);
  }
  if (hasPreluActivationWeights) {
    if (!isChannelsLast && preluActivationWeights.shape.length === 1) {
      preluActivationWeights = reshape80({
        inputs: { x: preluActivationWeights },
        backend: backend3,
        attrs: { shape: [preluActivationWeights.shape[0], 1, 1] }
      });
      intermediates.push(preluActivationWeights);
    }
    inputVar.push(preluActivationWeights);
  }
  if (activation2 === "leakyrelu") {
    dimensions.push({ type: "float32", data: [leakyreluAlpha] });
    program.uniforms += " alpha : f32,";
  }
  const out = backend3.runWebGPUProgram(program, inputVar, x.dtype, dimensions);
  for (const i of intermediates) {
    backend3.disposeData(i.dataId);
  }
  return out;
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2D.js
function conv2d12(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad9, dimRoundingMode, false, $dataFormat);
  return conv2DImpl({ x, filter, convInfo, backend: backend3 });
}
var conv2DConfig3 = {
  kernelName: Conv2D,
  backendName: "webgpu",
  kernelFunc: conv2d12
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2DBackpropFilter.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/conv_backprop_webgpu.js
class Conv2DDerInputProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,";
    this.workgroupSize = [64, 1, 1];
    this.size = false;
    this.isVec4 = false;
    this.workPerThread = 1;
    this.outputShape = convInfo.inShape;
    this.isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.isVec4 = this.isChannelsLast && convInfo.outChannels % 4 === 0 && convInfo.inChannels % 4 === 0;
    if (this.isVec4) {
      this.workPerThread = 2;
      this.outputComponent = 4;
      this.workgroupSize = [4, 4, 4];
      this.dispatchLayout = { x: [3], y: [2], z: [0, 1] };
      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [4, this.workPerThread, 1]);
    } else {
      this.size = true;
      this.workPerThread = 1;
      this.workgroupSize = [64, 1, 1];
      this.dispatchLayout = flatDispatchLayout(this.outputShape);
      this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    }
    this.shaderKey = `conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`;
  }
  getUserCode() {
    const rowDim = this.isChannelsLast ? 1 : 2;
    const colDim = this.isChannelsLast ? 2 : 3;
    const channelDim = this.isChannelsLast ? 3 : 1;
    const vec4Snippet = `
    ${getMainHeaderString()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;
    return this.isVec4 ? `
    ${vec4Snippet}
    ` : `
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${channelDim}];

        let dyCorner = vec2<i32>(coords[${rowDim}], coords[${colDim}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast ? "getDy(batch, idyR, idyC, d2)" : "getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
}

class Conv2DDerFilterProgram2 {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.filterShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.isChannelsLast = convInfo.dataFormat === "channelsLast";
    this.shaderKey = `conv2DDerFilter_${this.isChannelsLast}`;
  }
  getUserCode() {
    return `
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
}

class Conv3DDerFilterProgram2 {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.uniforms = `pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.filterShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `conv3DDerFilter`;
  }
  getUserCode() {
    return `
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
}

class Conv3DDerInputProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.uniforms = `filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `conv3DDerInput`;
  }
  getUserCode() {
    return `
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2DBackpropFilter.js
function conv2DBackpropFilter4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, pad: pad9, dataFormat, dimRoundingMode, filterShape } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filterShape, strides, 1, pad9, dimRoundingMode, false, $dataFormat);
  const program = new Conv2DDerFilterProgram2(convInfo);
  const uniformData = [
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.batchSize] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "int32", data: [convInfo.inHeight] },
    { type: "int32", data: [convInfo.inWidth] }
  ];
  return backend3.runWebGPUProgram(program, [x, dy2], x.dtype, uniformData);
}
var conv2DBackpropFilterConfig3 = {
  kernelName: Conv2DBackpropFilter,
  backendName: "webgpu",
  kernelFunc: conv2DBackpropFilter4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2DBackpropInput.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/conv_backprop_mm_webgpu.js
init_dist();
function conv2dTransposeCommonSnippet(innerElementSize = 4) {
  const getWSnippet = (innerElementSize2) => {
    switch (innerElementSize2) {
      case 1:
        return "return W[getIndexFromCoords4D(coord, uniforms.wShape)];";
      case 4:
        return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;
      default:
        throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
    }
  };
  const readASnippet = `
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${typeSnippet(innerElementSize)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${typeSnippet(innerElementSize)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${innerElementSize}];`;
  const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${readASnippet}
      }
      return ${typeSnippet(innerElementSize)}(0.0);`;
  const userCode = `
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${typeSnippet(innerElementSize)} {
    ${sampleA}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${typeSnippet(innerElementSize)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${getWSnippet(innerElementSize)}
    }
    return ${typeSnippet(innerElementSize)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${typeSnippet(innerElementSize)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${innerElementSize}] = value;
    }
  }`;
  return userCode;
}

class Conv2DDerInputMMProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";
    this.outputShape = convInfo.inShape;
    exports_util.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    this.isVec4 = convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;
    this.dispatchLayout = { x: [3], y: [1, 2], z: [0] };
    this.workgroupSize = computeWorkgroupSizeForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);
    this.elementsPerThread = computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape, this.isVec4);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
    if (this.isVec4) {
      this.outputComponent = 4;
      this.variableComponents = [4, 1];
    }
    this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
  }
  getUserCode() {
    const matMulSource = this.isVec4 ? makeMatMulPackedVec4Source(this.elementsPerThread, this.workgroupSize) : makeMatMulPackedSource(this.elementsPerThread, this.workgroupSize);
    const userCode = `
    ${conv2dTransposeCommonSnippet(this.isVec4 ? 4 : 1)}
    ${matMulSource}
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv2DBackpropInput.js
function conv2DBackpropInput4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { inputShape, strides, pad: pad9, dataFormat, dimRoundingMode } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(inputShape, filter.shape, strides, 1, pad9, dimRoundingMode, false, $dataFormat);
  const dimensions = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    {
      type: "int32",
      data: [
        convInfo.filterHeight - 1 - convInfo.padInfo.top,
        convInfo.filterWidth - 1 - convInfo.padInfo.left
      ]
    },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    {
      type: "int32",
      data: [
        convInfo.batchSize,
        convInfo.outHeight,
        convInfo.outWidth,
        convInfo.outChannels
      ]
    }
  ];
  let program;
  if (env().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE") || convInfo.dataFormat !== "channelsLast") {
    program = new Conv2DDerInputProgram2(convInfo);
  } else {
    program = new Conv2DDerInputMMProgram(convInfo);
    const dimAOuter = convInfo.inHeight * convInfo.inWidth;
    const dimBOuter = convInfo.inChannels;
    const dimInner = convInfo.filterHeight * convInfo.filterWidth * convInfo.outChannels;
    dimensions.push({ type: "uint32", data: [dimAOuter] }, { type: "uint32", data: [dimBOuter] }, { type: "uint32", data: [dimInner] });
  }
  return backend3.runWebGPUProgram(program, [dy2, filter], "float32", dimensions);
}
var conv2DBackpropInputConfig3 = {
  kernelName: Conv2DBackpropInput,
  backendName: "webgpu",
  kernelFunc: conv2DBackpropInput4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv3D.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/conv3d_naive_webgpu.js
class Conv3DNaiveProgram {
  constructor(convInfo) {
    this.variableNames = ["x", "W"];
    this.uniforms = "filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `conv3dnaive`;
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv3D.js
function conv3D3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  const convInfo = exports_backend_util.computeConv3DInfo(x.shape, filter.shape, strides, dilations, pad9);
  const padInfo = [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left];
  const dimensions = [
    {
      type: "int32",
      data: [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth]
    },
    { type: "int32", data: [...padInfo] },
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.dilationDepth,
        convInfo.dilationHeight,
        convInfo.dilationWidth
      ]
    }
  ];
  const program = new Conv3DNaiveProgram(convInfo);
  const dtype = upcastType(x.dtype, filter.dtype);
  return backend3.runWebGPUProgram(program, [x, filter], dtype, dimensions);
}
var conv3DConfig3 = {
  kernelName: Conv3D,
  backendName: "webgpu",
  kernelFunc: conv3D3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv3DBackpropFilterV2.js
init_dist();
function conv3DBackpropFilterV23(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, pad: pad9, filterShape } = attrs;
  const convInfo = exports_backend_util.computeConv3DInfo(x.shape, filterShape, strides, 1, pad9);
  const program = new Conv3DDerFilterProgram2(convInfo);
  const uniformData = [
    {
      type: "int32",
      data: [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left]
    },
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    { type: "int32", data: [convInfo.batchSize] },
    { type: "int32", data: [convInfo.outDepth] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "int32", data: [convInfo.inDepth] },
    { type: "int32", data: [convInfo.inHeight] },
    { type: "int32", data: [convInfo.inWidth] }
  ];
  return backend3.runWebGPUProgram(program, [x, dy2], dy2.dtype, uniformData);
}
var conv3DBackpropFilterV2Config3 = {
  kernelName: Conv3DBackpropFilterV2,
  backendName: "webgpu",
  kernelFunc: conv3DBackpropFilterV23
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Conv3DBackpropInputV2.js
init_dist();
function conv3DBackpropInputV22(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { strides, pad: pad9, inputShape } = attrs;
  const convInfo = exports_backend_util.computeConv3DInfo(inputShape, filter.shape, strides, 1, pad9);
  const program = new Conv3DDerInputProgram2(convInfo);
  const uniformData = [
    {
      type: "int32",
      data: [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.filterDepth - 1 - convInfo.padInfo.front,
        convInfo.filterHeight - 1 - convInfo.padInfo.top,
        convInfo.filterWidth - 1 - convInfo.padInfo.left
      ]
    },
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    { type: "int32", data: [convInfo.outDepth] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "int32", data: [convInfo.outChannels] }
  ];
  return backend3.runWebGPUProgram(program, [dy2, filter], dy2.dtype, uniformData);
}
var conv3DBackpropInputV2Config2 = {
  kernelName: Conv3DBackpropInputV2,
  backendName: "webgpu",
  kernelFunc: conv3DBackpropInputV22
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cos.js
init_dist();
var cos7 = unaryKernelFunc3({ opType: UnaryOpType.COS });
var cosConfig3 = {
  kernelName: Cos,
  backendName: "webgpu",
  kernelFunc: cos7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cosh.js
init_dist();
var cosh6 = unaryKernelFunc3({ opType: UnaryOpType.COSH });
var coshConfig3 = {
  kernelName: Cosh,
  backendName: "webgpu",
  kernelFunc: cosh6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/CropAndResize.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/crop_and_resize_webgpu.js
class CropAndResizeProgram2 {
  constructor(channnel, boxShape, cropSize, method) {
    this.variableNames = ["Image", "Boxes", "BoxInd"];
    this.uniforms = "extrapolationValue : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    const [numBoxes] = boxShape;
    this.outputShape = [numBoxes, cropSize[0], cropSize[1], channnel];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.methodId = method === "bilinear" ? 1 : 0;
    this.cropHeightBiggerThan1 = this.outputShape[1] > 1;
    this.cropWidthBiggerThan1 = this.outputShape[2] > 1;
    this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
  }
  getUserCode() {
    const [inputHeightFloat, inputWidthFloat] = [`f32(uniforms.imageShape[1] - 1)`, `f32(uniforms.imageShape[2] - 1)`];
    const [heightRatio, heightScale, inY] = this.cropHeightBiggerThan1 ? [
      `(${inputHeightFloat} / f32(uniforms.outShape[1] - 1))`,
      "(y2-y1) * height_ratio",
      `y1*${inputHeightFloat} + f32(y)*(height_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (y1+y2) * ${inputHeightFloat}`
    ];
    const [widthRatio, widthScale, inX] = this.cropWidthBiggerThan1 ? [
      `(${inputWidthFloat} / f32(uniforms.outShape[2] - 1))`,
      "(x2-x1) * width_ratio",
      `x1*${inputWidthFloat} + f32(x)*(width_scale)`
    ] : [
      "0.0",
      "0.0",
      `0.5 * (x1+x2) * ${inputWidthFloat}`
    ];
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${heightRatio});
        let width_ratio = f32(${widthRatio});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${heightScale};
        let width_scale = ${widthScale};
        let in_y = ${inY};
        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${inX};
        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/CropAndResize.js
var cropAndResize5 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2, boxes, boxInd } = inputs;
  const { cropSize, method, extrapolationValue } = attrs;
  const program = new CropAndResizeProgram2(image2.shape[3], boxes.shape, cropSize, method);
  const uniformData = [{ type: "float32", data: [extrapolationValue] }];
  return backend3.runWebGPUProgram(program, [image2, boxes, boxInd], "float32", uniformData);
};
var cropAndResizeConfig3 = {
  kernelName: CropAndResize,
  backendName: "webgpu",
  kernelFunc: cropAndResize5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cumprod.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/cum_webgpu.js
function getCoords4(rank, name, op2) {
  if (rank === 1) {
    return `${name}`;
  } else if (rank === 2) {
    return `${name}.x, ${name}.y`;
  } else if (rank === 3) {
    return `${name}.x, ${name}.y, ${name}.z`;
  } else if (rank === 4) {
    return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;
  } else {
    throw Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
  }
}
function getFinalCoord2(rank, name, op2) {
  if (rank === 1) {
    return `${name}`;
  } else if (rank === 2) {
    return `${name}.y`;
  } else if (rank === 3) {
    return `${name}.z`;
  } else if (rank === 4) {
    return `${name}.w`;
  } else {
    throw Error(`Cumulative ${op2} for rank ${rank} is not yet supported`);
  }
}
var CumOpType2;
(function(CumOpType3) {
  CumOpType3["Prod"] = "*";
  CumOpType3["Sum"] = "+";
})(CumOpType2 || (CumOpType2 = {}));

class CumProgram2 {
  constructor(op2, shape, exclusive, reverse12) {
    this.variableNames = ["x"];
    this.uniforms = "index : f32,";
    this.size = true;
    this.workgroupSize = [128, 1, 1];
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.exclusive = exclusive;
    this.reverse = reverse12;
    this.op = op2;
    this.shaderKey = `cum_${this.op}_${this.exclusive}_${this.reverse}`;
  }
  getUserCode() {
    const rank = this.outputShape.length;
    const initVal = this.op === CumOpType2.Prod ? "1.0" : "0.0";
    const val = this.exclusive ? initVal : `getX(${getCoords4(rank, "coords", this.op)})`;
    const length = this.outputShape[this.outputShape.length - 1];
    let condition = "";
    let idxString = "";
    if (this.exclusive) {
      condition = this.reverse ? `end != ${length - 1}` : "end != 0";
      idxString = this.reverse ? "end + 1" : "end - 1";
    } else {
      condition = this.reverse ? `end + pow2 < ${length}` : "end >= pow2";
      idxString = this.reverse ? "end + pow2" : "end - pow2";
    }
    return `
      ${getMainHeaderString("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${getFinalCoord2(rank, "coords", this.op)};
         var val = ${val};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${condition}) {
           let idx = ${idxString};
           ${getFinalCoord2(rank, "coords", this.op)} = idx;
           val ${this.op}= getX(${getCoords4(rank, "coords", this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cum_impl.js
init_dist();
function cumImpl2(op2, x, backend3, axis, exclusive, reverse12) {
  const xRank = x.shape.length;
  const permutation = exports_backend_util.getAxesPermutation([axis], xRank);
  let permutedX = x;
  if (permutation != null) {
    permutedX = transpose13({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
  }
  const permutedAxis = exports_backend_util.getInnerMostAxes(1, xRank)[0];
  if (permutedAxis !== xRank - 1) {
    throw new Error(`WebGPU cumprod shader expects an inner-most axis=${x.shape.length - 1} ` + `but got axis=${axis}`);
  }
  const size = permutedX.shape[permutedAxis];
  let result = identity4({ inputs: { x: permutedX }, backend: backend3 });
  for (let i = 0;i <= Math.ceil(Math.log2(size)) - 1; i++) {
    const program = new CumProgram2(op2, permutedX.shape, false, reverse12);
    const prevResult = result;
    const uniformData = [{ type: "float32", data: [i] }];
    result = backend3.runWebGPUProgram(program, [result], result.dtype, uniformData);
    backend3.disposeData(prevResult.dataId);
  }
  if (exclusive) {
    const program = new CumProgram2(op2, permutedX.shape, exclusive, reverse12);
    const prevResult = result;
    const uniformData = [{ type: "float32", data: [0] }];
    result = backend3.runWebGPUProgram(program, [result], result.dtype, uniformData);
    backend3.disposeData(prevResult.dataId);
  }
  if (permutation != null) {
    const reversePermutation = exports_backend_util.getUndoAxesPermutation(permutation);
    const reverseTransposedResult = transpose13({ inputs: { x: result }, backend: backend3, attrs: { perm: reversePermutation } });
    backend3.disposeData(result.dataId);
    backend3.disposeData(permutedX.dataId);
    return reverseTransposedResult;
  }
  return result;
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cumprod.js
function cumprod7(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, exclusive, reverse: reverse12 } = attrs;
  return cumImpl2(CumOpType2.Prod, x, backend3, axis, exclusive, reverse12);
}
var cumprodConfig3 = {
  kernelName: Cumprod,
  backendName: "webgpu",
  kernelFunc: cumprod7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Cumsum.js
init_dist();
function cumsum7(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, exclusive, reverse: reverse12 } = attrs;
  return cumImpl2(CumOpType2.Sum, x, backend3, axis, exclusive, reverse12);
}
var cumsumConfig3 = {
  kernelName: Cumsum,
  backendName: "webgpu",
  kernelFunc: cumsum7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DenseBincount.js
init_dist();
function denseBincount4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, weights } = inputs;
  const { size, binaryOutput } = attrs;
  const xRankOne = x.shape.length === 1;
  const weightsSize = exports_util.sizeFromShape(weights.shape);
  const hasWeights = weightsSize > 0;
  const dtype = weights.dtype;
  const xSize = xRankOne ? [x.shape[0]] : [x.shape[0], x.shape[1]];
  const outputSize = xRankOne ? [size] : [x.shape[0], size];
  const output = fill8({ backend: backend3, attrs: { shape: outputSize, value: 0, dtype } });
  const program = new BincountProgram(xSize, hasWeights, binaryOutput);
  const uniformData = [{ type: "int32", data: [size] }];
  const bincountInputs = hasWeights ? [x, weights] : [x];
  const res = backend3.runWebGPUProgram(program, bincountInputs, dtype, uniformData, output);
  return res;
}
var denseBincountConfig3 = {
  kernelName: DenseBincount,
  backendName: "webgpu",
  kernelFunc: denseBincount4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthToSpace.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/depth_to_space_webgpu.js
class DepthToSpaceProgram2 {
  constructor(outputShape, dataFormat) {
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.uniforms = "blockSize : i32,";
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `depthToSpace_${dataFormat}`;
    this.dataFormat = dataFormat;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
    return userCode;
  }
  getHeightCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[1]`;
    } else {
      return `coords[2]`;
    }
  }
  getWidthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[2]`;
    } else {
      return `coords[3]`;
    }
  }
  getDepthCoordString() {
    if (this.dataFormat === "NHWC") {
      return `coords[3]`;
    } else {
      return `coords[1]`;
    }
  }
  getOutputDepthSize() {
    if (this.dataFormat === "NHWC") {
      return `uniforms.outShape[3]`;
    } else {
      return `uniforms.outShape[1]`;
    }
  }
  getInputSamplingString() {
    if (this.dataFormat === "NHWC") {
      return `getX(b, in_h, in_w, in_d)`;
    } else {
      return `getX(b, in_d, in_h, in_w)`;
    }
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthToSpace.js
function depthToSpace4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockSize, dataFormat } = attrs;
  const batchSize = x.shape[0];
  const inputHeight = dataFormat === "NHWC" ? x.shape[1] : x.shape[2];
  const inputWidth = dataFormat === "NHWC" ? x.shape[2] : x.shape[3];
  const inputDepth = dataFormat === "NHWC" ? x.shape[3] : x.shape[1];
  const outputHeight = inputHeight * blockSize;
  const outputWidth = inputWidth * blockSize;
  const outputDepth = inputDepth / (blockSize * blockSize);
  const outputShape = dataFormat === "NHWC" ? [batchSize, outputHeight, outputWidth, outputDepth] : [batchSize, outputDepth, outputHeight, outputWidth];
  const uniformData = [
    { type: "int32", data: [blockSize] }
  ];
  const program = new DepthToSpaceProgram2(outputShape, dataFormat);
  return backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
}
var depthToSpaceConfig3 = {
  kernelName: DepthToSpace,
  backendName: "webgpu",
  kernelFunc: depthToSpace4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthwiseConv2dNative.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/depthwise_conv2d_nchw_shared_webgpu.js
class DepthwiseConv2DNCHWSharedProgram {
  constructor(outputShape, filterHeight, filterWidth, addBias = false, activation2 = null, hasPreluActivation = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `pads : vec2<i32>, inDims : vec2<i32>,`;
    this.workgroupSize = [16, 16, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = { x: [3], y: [2], z: [0, 1] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivation = hasPreluActivation;
    this.filterHeight = filterHeight;
    this.filterWidth = filterWidth;
    this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
  }
  getUserCode() {
    const filterSize = this.filterWidth * this.filterHeight;
    const flatWorkgroupSize = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2];
    const tileAHeight = this.workgroupSize[1] + this.filterHeight - 1;
    const tileAWidth = this.workgroupSize[0] + this.filterWidth - 1;
    const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivation, false, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${tileAWidth}>, ${tileAHeight}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${getMainHeaderString()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${tileAHeight}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${filterSize < flatWorkgroupSize ? `if (wIndex < ${filterSize})` : `for(; wIndex < ${filterSize}; wIndex = wIndex + ${flatWorkgroupSize})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${biasActivationSnippet(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/depthwise_conv2d_vec4_webgpu.js
init_dist();
class DepthwiseConv2DVec4Program {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,";
    this.workgroupSize = [64, 1, 1];
    this.workPerThread = 4;
    this.outputComponent = 4;
    this.outputShape = convInfo.outShape;
    this.virtualWidth = Math.ceil(this.outputShape[2] / this.workPerThread) * this.workPerThread;
    const virtualOutputShape = [
      this.outputShape[0],
      this.outputShape[1],
      this.virtualWidth,
      this.outputShape[3]
    ];
    this.dispatchLayout = flatDispatchLayout(virtualOutputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, virtualOutputShape, this.workgroupSize, [this.outputComponent * this.workPerThread, 1, 1]);
    exports_util.assert(convInfo.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented");
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivation = hasPreluActivation;
    this.shaderKey = `depthwiseVec4_${activation2}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
  }
  getUserCode() {
    const xNumber = (this.workPerThread - 1) * this.convInfo.strideWidth + this.convInfo.filterWidth;
    const strideHeight = this.convInfo.strideHeight;
    const strideWidth = this.convInfo.strideWidth;
    const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivation, true, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${getMainHeaderString("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${strideHeight}, ${strideWidth}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${xNumber}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${xNumber}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${strideWidth} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${biasActivationSnippet(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/depthwise_conv2d_webgpu.js
class DepthwiseConv2DProgram2 {
  constructor(convInfo, addBias = false, activation2 = null, hasPreluActivation = false) {
    this.variableNames = ["x", "W"];
    this.uniforms = `pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`;
    this.workgroupSize = [256, 1, 1];
    this.size = true;
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.isChannelsLast = convInfo.dataFormat === "channelsLast";
    if (addBias) {
      this.variableNames.push("bias");
    }
    if (hasPreluActivation) {
      this.variableNames.push("preluActivationWeights");
    }
    this.convInfo = convInfo;
    this.addBias = addBias;
    this.activation = activation2;
    this.hasPreluActivation = hasPreluActivation;
    this.shaderKey = `depthwise_${this.activation}_${this.isChannelsLast}`;
  }
  getUserCode() {
    const getXSnippet = this.isChannelsLast ? "getX(batch, xR, xC, d1);" : "getX(batch, d1, xR, xC);";
    const userCode = `
      ${activationFnSnippet(this.activation, this.hasPreluActivation, false, 4)}

      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast ? "yz" : "zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast ? 3 : 1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${getXSnippet};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${getXSnippet};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${biasActivationSnippet(this.addBias, this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthwiseConv2dNative.js
function depthwiseConv2dNative3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad9, dimRoundingMode, true, $dataFormat);
  const dimensions = [
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }
  ];
  const isChannelsLast = convInfo.dataFormat === "channelsLast";
  let program;
  if (!isChannelsLast && convInfo.inHeight > 16 && convInfo.inWidth > 16 && convInfo.strideHeight === 1 && convInfo.strideWidth === 1 && convInfo.dilationWidth === 1 && convInfo.dilationHeight === 1 && convInfo.inChannels === convInfo.outChannels) {
    program = new DepthwiseConv2DNCHWSharedProgram(convInfo.outShape, convInfo.filterHeight, convInfo.filterWidth);
  } else if (isChannelsLast && convInfo.outHeight > 4 && convInfo.outWidth > 4 && convInfo.strideWidth <= 2 && convInfo.inChannels === convInfo.outChannels && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.inChannels % 4 === 0) {
    program = new DepthwiseConv2DVec4Program(convInfo);
    dimensions.push({ type: "int32", data: [program.virtualWidth] });
  } else {
    program = new DepthwiseConv2DProgram2(convInfo);
    dimensions.push({ type: "int32", data: [convInfo.filterHeight] }, { type: "int32", data: [convInfo.filterWidth] }, { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] }, {
      type: "int32",
      data: [convInfo.dilationHeight, convInfo.dilationWidth]
    });
  }
  return backend3.runWebGPUProgram(program, [x, filter], x.dtype, dimensions);
}
var depthwiseConv2dNativeConfig3 = {
  kernelName: DepthwiseConv2dNative,
  backendName: "webgpu",
  kernelFunc: depthwiseConv2dNative3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/conv_backprop_depthwise_webgpu.js
class DepthwiseConv2DDerFilterProgram2 {
  constructor(convInfo) {
    this.variableNames = ["x", "dy"];
    this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.filterShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `depthwise_conv2d_backprop_filter`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    return userCode;
  }
}

class DepthwiseConv2DDerInputProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy", "W"];
    this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `depthwise_conv2d_backprop_input`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthwiseConv2dNativeBackpropFilter.js
function depthwiseConv2dNativeBackpropFilter4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, dy: dy2 } = inputs;
  const { strides, dilations, pad: pad9, dimRoundingMode, filterShape } = attrs;
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filterShape, strides, dilations, pad9, dimRoundingMode, true);
  const program = new DepthwiseConv2DDerFilterProgram2(convInfo);
  const uniformData = [
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "int32", data: [convInfo.inHeight] },
    { type: "int32", data: [convInfo.inWidth] },
    { type: "int32", data: [convInfo.batchSize] },
    { type: "int32", data: [convInfo.outChannels / convInfo.inChannels] }
  ];
  return backend3.runWebGPUProgram(program, [x, dy2], "float32", uniformData);
}
var depthwiseConv2dNativeBackpropFilterConfig3 = {
  kernelName: DepthwiseConv2dNativeBackpropFilter,
  backendName: "webgpu",
  kernelFunc: depthwiseConv2dNativeBackpropFilter4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/DepthwiseConv2dNativeBackpropInput.js
init_dist();
function depthwiseConv2dNativeBackpropInput4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, filter } = inputs;
  const { strides, dilations, pad: pad9, dimRoundingMode, inputShape } = attrs;
  const convInfo = exports_backend_util.computeConv2DInfo(inputShape, filter.shape, strides, dilations, pad9, dimRoundingMode, true);
  const program = new DepthwiseConv2DDerInputProgram2(convInfo);
  const uniformData = [
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    {
      type: "int32",
      data: [
        convInfo.filterHeight - 1 - convInfo.padInfo.top,
        convInfo.filterWidth - 1 - convInfo.padInfo.left
      ]
    },
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] },
    { type: "int32", data: [convInfo.outChannels / convInfo.inChannels] }
  ];
  return backend3.runWebGPUProgram(program, [dy2, filter], dy2.dtype, uniformData);
}
var depthwiseConv2dNativeBackpropInputConfig3 = {
  kernelName: DepthwiseConv2dNativeBackpropInput,
  backendName: "webgpu",
  kernelFunc: depthwiseConv2dNativeBackpropInput4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Diag.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/diag_webgpu.js
class DiagProgram2 {
  constructor(size) {
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [size, size];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "diag";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Diag.js
function diag4(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  const outShape = [...x.shape, ...x.shape];
  const xSize = exports_util.sizeFromShape(x.shape);
  const flat = reshape80({ inputs: { x }, backend: backend3, attrs: { shape: [xSize] } });
  const program = new DiagProgram2(xSize);
  const res = backend3.runWebGPUProgram(program, [flat], flat.dtype);
  const out = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape: outShape } });
  backend3.disposeData(flat.dataId);
  backend3.disposeData(res.dataId);
  return out;
}
var diagConfig3 = {
  kernelName: Diag,
  backendName: "webgpu",
  kernelFunc: diag4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Dilation2D.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/dilation_webgpu.js
class Dilation2DProgram2 {
  constructor(convInfo) {
    this.variableNames = ["x", "w"];
    this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "dilation2d";
  }
  getUserCode() {
    const userCode = `
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Dilation2D.js
function dilation2D2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  const convInfo = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
  const padInfo = [convInfo.padInfo.top, convInfo.padInfo.left];
  const uniformData = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [...padInfo] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] }
  ];
  const program = new Dilation2DProgram2(convInfo);
  const out = backend3.runWebGPUProgram(program, [x, filter], x.dtype, uniformData);
  return out;
}
var dilation2DConfig3 = {
  kernelName: Dilation2D,
  backendName: "webgpu",
  kernelFunc: dilation2D2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Dilation2DBackpropFilter.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/dilation_backprop_webgpu.js
class Dilation2DBackpropInputProgram {
  constructor(convInfo, outputDtype) {
    this.variableNames = ["x", "w", "dy"];
    this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,";
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(convInfo.outShape);
    this.dispatch = computeDispatch(this.dispatchLayout, convInfo.outShape, this.workgroupSize);
    if (outputDtype !== "float32" && outputDtype !== "int32") {
      throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${outputDtype} type.`);
    }
    this.type = outputDtype;
    this.shaderKey = "dilation2DBackpropInput";
  }
  getUserCode() {
    const userCode = `
       ${getMainHeaderString("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${atomicAddSnippet("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    return userCode;
  }
}

class Dilation2DBackpropFilterProgram {
  constructor(convInfo, shape, outputDtype) {
    this.variableNames = ["x", "w", "dy"];
    this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,";
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.outputShape = convInfo.filterShape;
    this.dispatchLayout = flatDispatchLayout(convInfo.outShape);
    this.dispatch = computeDispatch(this.dispatchLayout, convInfo.outShape, this.workgroupSize);
    if (outputDtype !== "float32" && outputDtype !== "int32") {
      throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${outputDtype} type.`);
    }
    this.type = outputDtype;
    this.shaderKey = "dilation2DBackpropFilter";
  }
  getUserCode() {
    const userCode = `
       ${getMainHeaderString("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${atomicAddSnippet("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Dilation2DBackpropFilter.js
function dilation2DBackpropFilter(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, dy: dy2 } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  const convInfo = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
  const dtype = filter.dtype;
  const program = new Dilation2DBackpropFilterProgram(convInfo, filter.shape, dtype);
  const uniformData = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    { type: "int32", data: [exports_util.sizeFromShape(convInfo.outShape)] }
  ];
  const output = fill8({ backend: backend3, attrs: { shape: filter.shape, value: 0, dtype } });
  return backend3.runWebGPUProgram(program, [x, filter, dy2], dtype, uniformData, output);
}
var dilation2DBackpropFilterConfig2 = {
  kernelName: Dilation2DBackpropFilter,
  backendName: "webgpu",
  kernelFunc: dilation2DBackpropFilter
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Dilation2DBackpropInput.js
init_dist();
function dilation2DBackpropInput(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, dy: dy2 } = inputs;
  const { strides, pad: pad9, dilations } = attrs;
  const convInfo = exports_backend_util.computeDilation2DInfo(x.shape, filter.shape, strides, pad9, "NHWC", dilations);
  const dtype = x.dtype;
  const program = new Dilation2DBackpropInputProgram(convInfo, dtype);
  const uniformData = [
    { type: "int32", data: [convInfo.filterHeight, convInfo.filterWidth] },
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    { type: "int32", data: [exports_util.sizeFromShape(convInfo.outShape)] }
  ];
  const output = fill8({ backend: backend3, attrs: { shape: convInfo.inShape, value: 0, dtype } });
  return backend3.runWebGPUProgram(program, [x, filter, dy2], dtype, uniformData, output);
}
var dilation2DBackpropInputConfig2 = {
  kernelName: Dilation2DBackpropInput,
  backendName: "webgpu",
  kernelFunc: dilation2DBackpropInput
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Draw.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/draw_webgpu.js
class DrawProgram {
  constructor(outShape, type, textureFormat) {
    this.variableNames = ["Image"];
    this.uniforms = "alpha: f32,";
    this.workgroupSize = [64, 1, 1];
    this.pixelsOpType = PixelsOpType.DRAW;
    this.size = true;
    this.outputShape = outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.type = type;
    this.textureFormat = textureFormat;
    this.shaderKey = `draw_${type}_${textureFormat}`;
  }
  getUserCode() {
    let calculateResult;
    const value = this.type === "float32" ? "value" : "value / 255.0";
    calculateResult = `
      if (uniforms.numChannels == 1) {
        rgba[0] = ${value};
        rgba[1] = ${value};
        rgba[2] = ${value};
      } else {
        rgba[d] = ${value};
      }`;
    const userCode = `
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${calculateResult}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Draw.js
function draw3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2 } = inputs;
  const { canvas, options } = attrs;
  const [height, width] = image2.shape.slice(0, 2);
  const { imageOptions } = options || {};
  const alpha = (imageOptions === null || imageOptions === undefined ? undefined : imageOptions.alpha) || 1;
  const format = backend3.device.features.has("bgra8unorm-storage") ? "bgra8unorm" : "rgba8unorm";
  const outShape = [height, width];
  const program = new DrawProgram(outShape, image2.dtype, format);
  canvas.width = width;
  canvas.height = height;
  const backendName = "webgpu";
  let gpuContext = canvas.getContext(backendName);
  let canvasWebGPU;
  if (!gpuContext) {
    canvasWebGPU = new OffscreenCanvas(width, height);
    gpuContext = canvasWebGPU.getContext(backendName);
  }
  const numChannels = image2.shape.length === 3 ? image2.shape[2] : 1;
  gpuContext.configure({
    device: backend3.device,
    format,
    usage: GPUTextureUsage.STORAGE_BINDING,
    alphaMode: "premultiplied"
  });
  const outputDtype = "int32";
  const output = backend3.makeTensorInfo(outShape, outputDtype);
  const info = backend3.tensorMap.get(output.dataId);
  info.resource = gpuContext.getCurrentTexture();
  info.external = true;
  const uniformData = [{ type: "uint32", data: [numChannels] }, { type: "float32", data: [alpha] }];
  backend3.runWebGPUProgram(program, [image2], outputDtype, uniformData, output);
  if (canvasWebGPU) {
    const canvas2dContext = canvas.getContext("2d");
    if (!canvas2dContext) {
      throw new Error(`Please make sure this canvas has only been used for 2d or webgpu context!`);
    }
    canvas2dContext.drawImage(canvasWebGPU, 0, 0);
  }
  backend3.disposeData(output.dataId);
  return image2;
}
var drawConfig2 = {
  kernelName: Draw,
  backendName: "webgpu",
  kernelFunc: draw3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Einsum.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Multiply.js
init_dist();
var multiplyKernelFunc = binaryKernelFunc3({
  opType: BinaryOpType.MUL,
  cpuKernelImpl: multiplyImplCPU2,
  supportsComplex: true
});
var multiplyConfig3 = {
  kernelName: Multiply,
  backendName: "webgpu",
  kernelFunc: multiplyKernelFunc
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sum.js
init_dist();
function sum29(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  return reduce9(x, axis, keepDims, "sum", backend3);
}
var sumConfig3 = {
  kernelName: Sum,
  backendName: "webgpu",
  kernelFunc: sum29
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Einsum.js
function einsum5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { equation } = attrs;
  const tensors = inputs;
  const { allDims, summedDims, idDims } = exports_backend_util.decodeEinsumEquation(equation, tensors.length);
  exports_backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);
  const { path, steps } = exports_backend_util.getEinsumComputePath(summedDims, idDims);
  const nSteps = steps.length;
  let out = null;
  let numDimsRemaining = allDims.length;
  const tensorsToDispose = [];
  for (let i = 0;i < nSteps; ++i) {
    for (const idTerm of steps[i]) {
      const { permutationIndices: perm, expandDims: dimsToExpand } = exports_backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);
      let x;
      if (exports_backend_util.isIdentityPermutation(perm)) {
        x = tensors[idTerm];
      } else {
        x = transpose13({ inputs: { x: tensors[idTerm] }, backend: backend3, attrs: { perm } });
        tensorsToDispose.push(x);
      }
      const targetShape = x.shape.slice();
      for (let k = 0;k < dimsToExpand.length; ++k) {
        targetShape.splice(dimsToExpand[k], 0, 1);
      }
      if (!exports_util.arraysEqual(x.shape, targetShape)) {
        x = reshape80({ inputs: { x }, backend: backend3, attrs: { shape: targetShape } });
        tensorsToDispose.push(x);
      }
      if (out === null) {
        out = x;
      } else {
        out = multiplyKernelFunc({ inputs: { a: x, b: out }, backend: backend3 });
        tensorsToDispose.push(out);
      }
    }
    if (i < nSteps - 1) {
      if (path[i] >= 0) {
        out = sum29({
          inputs: { x: out },
          backend: backend3,
          attrs: {
            axis: path[i] - (allDims.length - numDimsRemaining),
            keepDims: false
          }
        });
        tensorsToDispose.push(out);
      }
      numDimsRemaining--;
    }
  }
  for (const tensorInfo of tensorsToDispose) {
    if (tensorInfo === out) {
      continue;
    }
    backend3.disposeData(tensorInfo.dataId);
  }
  return out;
}
var einsumConfig3 = {
  kernelName: Einsum,
  backendName: "webgpu",
  kernelFunc: einsum5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Elu.js
init_dist();
var elu9 = unaryKernelFunc3({ opType: UnaryOpType.ELU });
var eluConfig3 = {
  kernelName: Elu,
  backendName: "webgpu",
  kernelFunc: elu9
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/EluGrad.js
init_dist();
var eluGrad3 = (args) => {
  const { inputs, backend: backend3 } = args;
  const { dy: dy2, y } = inputs;
  const program = new BinaryOpProgram2(BinaryOpType.ELU_DER, dy2.shape, y.shape);
  return backend3.runWebGPUProgram(program, [dy2, y], dy2.dtype);
};
var eluGradConfig4 = {
  kernelName: EluGrad,
  backendName: "webgpu",
  kernelFunc: eluGrad3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Equal.js
init_dist();
var equal8 = binaryKernelFunc3({ opType: BinaryOpType.EQUAL, dtype: "bool", cpuKernelImpl: equalImplCPU2 });
var equalConfig3 = {
  kernelName: Equal,
  backendName: "webgpu",
  kernelFunc: equal8
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Erf.js
init_dist();
var erf5 = unaryKernelFunc3({ opType: UnaryOpType.ERF });
var erfConfig3 = {
  kernelName: Erf,
  backendName: "webgpu",
  kernelFunc: erf5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Exp.js
init_dist();
var exp13 = unaryKernelFunc3({
  opType: UnaryOpType.EXP,
  cpuKernelImpl: expImplCPU2,
  dtype: "float32"
});
var expConfig3 = {
  kernelName: Exp,
  backendName: "webgpu",
  kernelFunc: exp13
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ExpandDims.js
init_dist();
function expandDims5(args) {
  const { inputs, attrs, backend: backend3 } = args;
  const { dim } = attrs;
  const { input: input2 } = inputs;
  const inputRank = input2.shape.length;
  const newShape = input2.shape.slice();
  let $dim = dim;
  if (dim < 0) {
    exports_util.assert(-(inputRank + 1) <= dim, () => `Axis must be in the interval [${-(inputRank + 1)}, ${inputRank}]`);
    $dim = inputRank + dim + 1;
  }
  newShape.splice($dim, 0, 1);
  return reshape80({ inputs: { x: input2 }, backend: backend3, attrs: { shape: newShape } });
}
var expandDimsConfig3 = {
  kernelName: ExpandDims,
  backendName: "webgpu",
  kernelFunc: expandDims5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Expm1.js
init_dist();
var expm15 = unaryKernelFunc3({ opType: UnaryOpType.EXPM1, cpuKernelImpl: expm1ImplCPU2 });
var expm1Config3 = {
  kernelName: Expm1,
  backendName: "webgpu",
  kernelFunc: expm15
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FFT.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FFT_impl.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/fft_webgpu.js
class FFTProgram2 {
  constructor(component, shape) {
    this.variableNames = ["real", "imag"];
    this.outputShape = [];
    this.uniforms = "exponentMultiplier : f32, denominator: f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.component = component;
    this.shaderKey = `fft_${component}`;
  }
  getUserCode() {
    const opString = this.component === "real" ? "return real * expR - imag * expI;" : "return real * expI + imag * expR;";
    const userCode = `
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${opString}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FFT_impl.js
function fftImpl3(x, inverse, backend3) {
  const xData = backend3.tensorMap.get(x.dataId);
  const inputSize = exports_util.sizeFromShape(x.shape);
  const innerDimensionSize = x.shape[x.shape.length - 1];
  const batch = inputSize / innerDimensionSize;
  const toDispose = [];
  const input2D = reshape80({ inputs: { x }, backend: backend3, attrs: { shape: [batch, innerDimensionSize] } });
  toDispose.push(input2D);
  const xShape = input2D.shape;
  const realProgram = new FFTProgram2("real", xShape);
  const imagProgram = new FFTProgram2("imag", xShape);
  const inputs = [
    {
      dataId: xData.complexTensorInfos.real.dataId,
      dtype: xData.complexTensorInfos.real.dtype,
      shape: xShape
    },
    {
      dataId: xData.complexTensorInfos.imag.dataId,
      dtype: xData.complexTensorInfos.imag.dtype,
      shape: xShape
    }
  ];
  const exponentMultiplier = inverse ? 2 * Math.PI : -2 * Math.PI;
  const denominator = inverse ? xShape[1] : 1;
  const uniformData = [
    { type: "float32", data: [exponentMultiplier] },
    { type: "float32", data: [denominator] }
  ];
  const realPart = backend3.runWebGPUProgram(realProgram, inputs, "float32", uniformData);
  toDispose.push(realPart);
  const imagPart = backend3.runWebGPUProgram(imagProgram, inputs, "float32", uniformData);
  toDispose.push(imagPart);
  const complexOutput = complex10({ inputs: { real: realPart, imag: imagPart }, backend: backend3 });
  toDispose.push(complexOutput);
  const complexOutputReshaped = reshape80({ inputs: { x: complexOutput }, backend: backend3, attrs: { shape: x.shape } });
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return complexOutputReshaped;
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FFT.js
function fft7(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  return fftImpl3(input2, false, backend3);
}
var fftConfig3 = {
  kernelName: FFT,
  backendName: "webgpu",
  kernelFunc: fft7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FlipLeftRight.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/flip_left_right_webgpu.js
class FlipLeftRightProgram2 {
  constructor(imageShape) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = imageShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "flipLeftRight";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FlipLeftRight.js
var flipLeftRightConfig3 = {
  kernelName: FlipLeftRight,
  backendName: "webgpu",
  kernelFunc: ({ inputs, backend: backend3 }) => {
    const { image: image2 } = inputs;
    const webgpuBackend = backend3;
    const program = new FlipLeftRightProgram2(image2.shape);
    const output = webgpuBackend.runWebGPUProgram(program, [image2], image2.dtype);
    return output;
  }
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Floor.js
init_dist();
var floor7 = unaryKernelFunc3({ opType: UnaryOpType.FLOOR, cpuKernelImpl: floorImplCPU2 });
var floorConfig3 = {
  kernelName: Floor,
  backendName: "webgpu",
  kernelFunc: floor7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FloorDiv.js
init_dist();
var floorDiv7 = binaryKernelFunc3({
  opType: BinaryOpType.FLOOR_DIV,
  cpuKernelImpl: floorDivImplCPU,
  dtype: "int32"
});
var floorDivConfig3 = {
  kernelName: FloorDiv,
  backendName: "webgpu",
  kernelFunc: floorDiv7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FromPixels.js
init_dist();
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/from_pixels_webgpu.js
class FromPixelsProgram2 {
  constructor(outputShape, numChannels, importVideo = false) {
    this.pixelsOpType = PixelsOpType.FROM_PIXELS;
    this.outputShape = [0];
    this.variableNames = [];
    this.workgroupSize = [256, 1, 1];
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [numChannels, 1, 1]);
    this.importVideo = importVideo;
    this.shaderKey = `fromPixels_${this.importVideo}`;
  }
  getUserCode() {
    const textureLoad = this.importVideo ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
    const textureType = this.importVideo ? "texture_external" : "texture_2d<f32>";
    return `
      @binding(1) @group(0) var src: ${textureType};
      ${getMainHeaderString("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${textureLoad};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FromPixels.js
function fromPixels3(args) {
  const { inputs, backend: backend3, attrs } = args;
  let { pixels } = inputs;
  const { numChannels } = attrs;
  if (pixels == null) {
    throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  }
  const isVideo = typeof HTMLVideoElement !== "undefined" && pixels instanceof HTMLVideoElement;
  const isImage = typeof HTMLImageElement !== "undefined" && pixels instanceof HTMLImageElement;
  const isCanvas = typeof HTMLCanvasElement !== "undefined" && pixels instanceof HTMLCanvasElement || typeof OffscreenCanvas !== "undefined" && pixels instanceof OffscreenCanvas;
  const isImageBitmap = typeof ImageBitmap !== "undefined" && pixels instanceof ImageBitmap;
  const [width, height] = isVideo ? [
    pixels.videoWidth,
    pixels.videoHeight
  ] : [pixels.width, pixels.height];
  const outputShape = [height, width, numChannels];
  const importVideo = env().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE") && isVideo;
  const isVideoOrImage = isVideo || isImage;
  if (isImageBitmap || isCanvas || isVideoOrImage) {
    let resource;
    if (importVideo) {
      resource = backend3.device.importExternalTexture({ source: pixels });
    } else {
      if (isVideoOrImage) {
        const newWillReadFrequently = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
        if (fromPixels2DContext3 == null || newWillReadFrequently !== willReadFrequently2) {
          willReadFrequently2 = newWillReadFrequently;
          fromPixels2DContext3 = document.createElement("canvas").getContext("2d", { willReadFrequently: willReadFrequently2 });
        }
        fromPixels2DContext3.canvas.width = width;
        fromPixels2DContext3.canvas.height = height;
        fromPixels2DContext3.drawImage(pixels, 0, 0, width, height);
        pixels = fromPixels2DContext3.canvas;
      }
      const usage = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING;
      const format = "rgba8unorm";
      const texture = backend3.textureManager.acquireTexture(outputShape[1], outputShape[0], format, usage);
      backend3.queue.copyExternalImageToTexture({ source: pixels }, { texture }, [outputShape[1], outputShape[0]]);
      resource = texture;
    }
    const size = exports_util.sizeFromShape(outputShape);
    const strides = exports_util.computeStrides(outputShape);
    const program = new FromPixelsProgram2(outputShape, numChannels, importVideo);
    const uniformData = [
      { type: "uint32", data: [size] },
      { type: "uint32", data: [numChannels] },
      { type: "uint32", data: [...strides] }
    ];
    const input2 = backend3.makeTensorInfo([height, width], "int32");
    const info = backend3.tensorMap.get(input2.dataId);
    info.resource = resource;
    const result = backend3.runWebGPUProgram(program, [input2], "int32", uniformData);
    backend3.disposeData(input2.dataId);
    return result;
  }
  const imageData = pixels.data;
  let pixelArray = imageData;
  if (numChannels != null && numChannels !== 4) {
    pixelArray = new Uint8Array(pixels.width * pixels.height * numChannels);
    const dataLength = imageData.length;
    let j = 0;
    for (let i = 0;i < dataLength; i++) {
      if (i % 4 < numChannels) {
        pixelArray[j++] = imageData[i];
      }
    }
  }
  const output = backend3.makeTensorInfo(outputShape, "int32", new Int32Array(pixelArray));
  backend3.uploadToGPU(output.dataId);
  return output;
}
var fromPixelsConfig2 = {
  kernelName: FromPixels,
  backendName: "webgpu",
  kernelFunc: fromPixels3
};
var fromPixels2DContext3;
var willReadFrequently2 = env().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FusedBatchNorm.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/batchnorm_webgpu.js
init_dist();
class BatchNormProgram2 {
  constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape) {
    this.uniforms = "varianceEpsilon : f32,";
    this.workgroupSize = [128, 1, 1];
    this.size = true;
    this.variableNames = ["x", "mean", "variance"];
    exports_backend_util.assertAndGetBroadcastShape(xShape, meanShape);
    exports_backend_util.assertAndGetBroadcastShape(xShape, varianceShape);
    this.outputShape = xShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    if (offsetShape != null) {
      exports_backend_util.assertAndGetBroadcastShape(xShape, offsetShape);
      this.variableNames.push("offset");
    }
    if (scaleShape != null) {
      exports_backend_util.assertAndGetBroadcastShape(xShape, scaleShape);
      this.variableNames.push("scale");
    }
    this.offsetShape = offsetShape;
    this.scaleShape = scaleShape;
    this.shaderKey = "batchNorm";
  }
  getUserCode() {
    let offsetSnippet = "0.0";
    if (this.offsetShape != null) {
      offsetSnippet = "getOffsetByOutputIndex(index)";
    }
    let scaleSnippet = "1.0";
    if (this.scaleShape != null) {
      scaleSnippet = "getScaleByOutputIndex(index)";
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${offsetSnippet};
          let scaleValue = ${scaleSnippet};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FusedBatchNorm.js
var fusedBatchNormConfig = {
  kernelName: FusedBatchNorm,
  backendName: "webgpu",
  kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
    const { x, scale: scale2, offset, mean: mean8, variance } = inputs;
    const { varianceEpsilon } = attrs;
    const webGPUBackend = backend3;
    const batchNormInputs = [x, mean8, variance];
    let offsetShape = null;
    if (offset != null) {
      offsetShape = offset.shape;
      batchNormInputs.push(offset);
    }
    let scaleShape = null;
    if (scale2 != null) {
      scaleShape = scale2.shape;
      batchNormInputs.push(scale2);
    }
    const program = new BatchNormProgram2(x.shape, mean8.shape, variance.shape, offsetShape, scaleShape);
    const uniformData = [{ type: "float32", data: [varianceEpsilon] }];
    return webGPUBackend.runWebGPUProgram(program, batchNormInputs, x.dtype, uniformData);
  }
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FusedConv2D.js
init_dist();
function fusedConv2d2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad9, dataFormat, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  const $dataFormat = exports_backend_util.convertConv2DDataFormat(dataFormat);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, dilations, pad9, dimRoundingMode, false, $dataFormat);
  return conv2DImpl({
    x,
    filter,
    convInfo,
    backend: backend3,
    bias,
    preluActivationWeights,
    leakyreluAlpha,
    activation: activation2
  });
}
var fusedConv2DConfig3 = {
  kernelName: FusedConv2D,
  backendName: "webgpu",
  kernelFunc: fusedConv2d2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/FusedDepthwiseConv2D.js
init_dist();
function fusedDepthwiseConv2D3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, filter, bias, preluActivationWeights } = inputs;
  const { strides, pad: pad9, dilations, dimRoundingMode, activation: activation2, leakyreluAlpha } = attrs;
  let $dilations = dilations;
  if ($dilations == null) {
    $dilations = [1, 1];
  }
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, $dilations), () => "Error in depthwiseConv2d: Either strides or dilations must be " + `1. Got strides ${strides} and dilations '${$dilations}'`);
  const convInfo = exports_backend_util.computeConv2DInfo(x.shape, filter.shape, strides, $dilations, pad9, dimRoundingMode, true);
  const programInputs = [x, filter];
  const hasBias = bias != null;
  const hasPreluActivationWeights = preluActivationWeights != null;
  if (hasBias) {
    programInputs.push(bias);
  }
  if (hasPreluActivationWeights) {
    programInputs.push(preluActivationWeights);
  }
  const dimensions = [
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] }
  ];
  let program;
  if (convInfo.outHeight > 4 && convInfo.outWidth > 4 && convInfo.strideWidth <= 2 && convInfo.inChannels === convInfo.outChannels && convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 && convInfo.inChannels % 4 === 0) {
    program = new DepthwiseConv2DVec4Program(convInfo, hasBias, activation2, hasPreluActivationWeights);
    dimensions.push({ type: "int32", data: [program.virtualWidth] });
  } else {
    program = new DepthwiseConv2DProgram2(convInfo, hasBias, activation2, hasPreluActivationWeights);
    dimensions.push({ type: "int32", data: [convInfo.filterHeight] }, { type: "int32", data: [convInfo.filterWidth] }, { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] }, {
      type: "int32",
      data: [convInfo.dilationHeight, convInfo.dilationWidth]
    });
  }
  if (activation2 === "leakyrelu") {
    dimensions.push({ type: "float32", data: [leakyreluAlpha] });
    program.uniforms += " alpha : f32,";
  }
  const result = backend3.runWebGPUProgram(program, programInputs, "float32", dimensions);
  return result;
}
var fusedDepthwiseConv2DConfig3 = {
  kernelName: FusedDepthwiseConv2D,
  backendName: "webgpu",
  kernelFunc: fusedDepthwiseConv2D3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/GatherNd.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/gather_nd_webgpu.js
class GatherNDProgram2 {
  constructor(sliceDim, shape) {
    this.variableNames = ["A", "indices"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `gathernd_${sliceDim}`;
    this.sliceDim = sliceDim;
    this.uniforms = `sliceDim : i32, strides : ${getCoordsDataType2(sliceDim)},`;
  }
  getUserCode() {
    let strideString;
    if (this.sliceDim > 1) {
      strideString = "uniforms.strides[j]";
    } else {
      strideString = "uniforms.strides";
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${strideString};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/GatherNd.js
function gatherNd3(args) {
  const { inputs, backend: backend3 } = args;
  const { params, indices } = inputs;
  const indicesShape = indices.shape;
  const sliceRank = indicesShape[indicesShape.length - 1];
  const paramsSize = exports_util.sizeFromShape(params.shape);
  const [resultShape, numSlices, sliceSize, strides] = exports_backend_util.prepareAndValidate(params, indices);
  const flattenIndices = reshape80({ inputs: { x: indices }, backend: backend3, attrs: { shape: [numSlices, sliceRank] } });
  const flattenX = reshape80({
    inputs: { x: params },
    backend: backend3,
    attrs: { shape: [exports_util.sizeFromShape(params.shape) / sliceSize, sliceSize] }
  });
  if (backend3.shouldExecuteOnCPU([params, indices]) || params.dtype === "string") {
    const indicesData = backend3.readSync(indices.dataId);
    const paramsBuf = backend3.bufferSync(params);
    const outValue = gatherNdImplCPU2(indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize, strides, params.shape, paramsSize);
    return backend3.makeTensorInfo(resultShape, params.dtype, outValue.values);
  }
  const program = new GatherNDProgram2(sliceRank, [numSlices, sliceSize]);
  const uniformData = [{ type: "int32", data: [sliceRank] }, { type: "int32", data: strides }];
  const res = backend3.runWebGPUProgram(program, [flattenX, flattenIndices], flattenX.dtype, uniformData);
  const reshaped = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape: resultShape } });
  backend3.disposeData(flattenIndices.dataId);
  backend3.disposeData(flattenX.dataId);
  backend3.disposeData(res.dataId);
  return reshaped;
}
var gatherNdConfig3 = {
  kernelName: GatherNd,
  backendName: "webgpu",
  kernelFunc: gatherNd3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/GatherV2.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/gather_webgpu.js
function getSourceCoords4(aShape) {
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
  const sourceCoords = [];
  for (let i = 0;i < aShape.length; i++) {
    if (i === 2) {
      sourceCoords.push("indexZ");
    } else {
      sourceCoords.push(`${currentCoords[i]}`);
    }
  }
  return sourceCoords.join();
}

class GatherProgram2 {
  constructor(aShape, outputShape) {
    this.variableNames = ["A", "indices"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = aShape.slice();
    this.aShape = aShape;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `gather`;
  }
  getUserCode() {
    const sourceCoords = getSourceCoords4(this.aShape);
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${sourceCoords}));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/GatherV2.js
function gatherV23(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, indices } = inputs;
  const { axis, batchDims } = attrs;
  const parsedAxis = exports_util.parseAxisParam(axis, x.shape)[0];
  const shapeInfo = exports_backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);
  const indicesSize = exports_util.sizeFromShape(indices.shape);
  const toDispose = [];
  const flattenX = reshape80({
    inputs: { x },
    backend: backend3,
    attrs: {
      shape: [
        shapeInfo.batchSize,
        shapeInfo.outerSize,
        shapeInfo.dimSize,
        shapeInfo.sliceSize
      ]
    }
  });
  const flattenIndex = reshape80({
    inputs: { x: indices },
    backend: backend3,
    attrs: { shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize] }
  });
  toDispose.push(flattenX);
  toDispose.push(flattenIndex);
  const flattenOutputShape = [
    shapeInfo.batchSize,
    shapeInfo.outerSize,
    indicesSize / shapeInfo.batchSize,
    shapeInfo.sliceSize
  ];
  if (backend3.shouldExecuteOnCPU([x, indices])) {
    const indicesTensorData = backend3.tensorMap.get(flattenIndex.dataId);
    const indicesValues = indicesTensorData.values;
    const indicesBuffer = buffer(flattenIndex.shape, flattenIndex.dtype, indicesValues);
    const flattenXTensorData = backend3.tensorMap.get(flattenX.dataId);
    const xValues = flattenXTensorData.values;
    const xBuffer = buffer(flattenX.shape, flattenX.dtype, xValues);
    const outBuf = gatherV2ImplCPU2(xBuffer, indicesBuffer, flattenOutputShape);
    toDispose.forEach((t) => backend3.disposeData(t.dataId));
    return backend3.makeTensorInfo(shapeInfo.outputShape, outBuf.dtype, outBuf.values);
  }
  const program = new GatherProgram2(flattenX.shape, flattenOutputShape);
  const res = backend3.runWebGPUProgram(program, [flattenX, flattenIndex], flattenX.dtype);
  toDispose.push(res);
  const reshaped = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape: shapeInfo.outputShape } });
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return reshaped;
}
var gatherV2Config3 = {
  kernelName: GatherV2,
  backendName: "webgpu",
  kernelFunc: gatherV23
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Greater.js
init_dist();
var greater14 = binaryKernelFunc3({
  opType: BinaryOpType.GREATER,
  cpuKernelImpl: greaterImplCPU2,
  dtype: "bool"
});
var greaterConfig3 = {
  kernelName: Greater,
  backendName: "webgpu",
  kernelFunc: greater14
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/GreaterEqual.js
init_dist();
var greaterEqual4 = binaryKernelFunc3({
  opType: BinaryOpType.GREATER_EQUAL,
  dtype: "bool",
  cpuKernelImpl: greaterEqualImplCPU2
});
var greaterEqualConfig3 = {
  kernelName: GreaterEqual,
  backendName: "webgpu",
  kernelFunc: greaterEqual4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/IFFT.js
init_dist();
function ifft7(args) {
  const { inputs, backend: backend3 } = args;
  const { input: input2 } = inputs;
  return fftImpl3(input2, true, backend3);
}
var ifftConfig3 = {
  kernelName: IFFT,
  backendName: "webgpu",
  kernelFunc: ifft7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/IsFinite.js
init_dist();
var isFinite5 = unaryKernelFunc3({ opType: UnaryOpType.IS_FINITE, dtype: "bool" });
var isFiniteConfig3 = {
  kernelName: IsFinite,
  backendName: "webgpu",
  kernelFunc: isFinite5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/IsInf.js
init_dist();
var isInf4 = unaryKernelFunc3({ opType: UnaryOpType.IS_INF, dtype: "bool" });
var isInfConfig3 = {
  kernelName: IsInf,
  backendName: "webgpu",
  kernelFunc: isInf4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/IsNaN.js
init_dist();
var isNaN5 = unaryKernelFunc3({ opType: UnaryOpType.IS_NAN, dtype: "bool" });
var isNaNConfig3 = {
  kernelName: IsNan,
  backendName: "webgpu",
  kernelFunc: isNaN5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LeakyRelu.js
init_dist();
function leakyRelu4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { alpha } = attrs;
  const uniformData = [{ type: "float32", data: [alpha] }];
  const program = new UnaryOpProgram2(x.shape, UnaryOpType.LEAKYRELU, "alpha : f32,");
  return backend3.runWebGPUProgram(program, [x], "float32", uniformData);
}
var leakyReluConfig3 = {
  kernelName: LeakyRelu,
  backendName: "webgpu",
  kernelFunc: leakyRelu4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Less.js
init_dist();
var less9 = binaryKernelFunc3({ opType: BinaryOpType.LESS, dtype: "bool", cpuKernelImpl: lessImplCPU2 });
var lessConfig3 = {
  kernelName: Less,
  backendName: "webgpu",
  kernelFunc: less9
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LessEqual.js
init_dist();
var lessEqual4 = binaryKernelFunc3({
  opType: BinaryOpType.LESS_EQUAL,
  dtype: "bool",
  cpuKernelImpl: lessEqualImplCPU2
});
var lessEqualConfig3 = {
  kernelName: LessEqual,
  backendName: "webgpu",
  kernelFunc: lessEqual4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LinSpace.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/lin_space_webgpu.js
class LinSpaceProgram {
  constructor(shape) {
    this.variableNames = [];
    this.outputShape = [];
    this.uniforms = "start : f32, step : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [shape];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "linSpace";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LinSpace.js
function linSpace3(args) {
  const { backend: backend3, attrs } = args;
  const { start, stop, num } = attrs;
  const step9 = (stop - start) / (num - 1);
  const program = new LinSpaceProgram(num);
  const uniformData = [{ type: "float32", data: [start] }, { type: "float32", data: [step9] }];
  return backend3.runWebGPUProgram(program, [], "float32", uniformData);
}
var linSpaceConfig3 = {
  kernelName: LinSpace,
  backendName: "webgpu",
  kernelFunc: linSpace3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Log.js
init_dist();
var log11 = unaryKernelFunc3({ opType: UnaryOpType.LOG, cpuKernelImpl: logImplCPU2 });
var logConfig3 = {
  kernelName: Log,
  backendName: "webgpu",
  kernelFunc: log11
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Log1p.js
init_dist();
var log1p6 = unaryKernelFunc3({ opType: UnaryOpType.LOG1P });
var log1pConfig3 = {
  kernelName: Log1p,
  backendName: "webgpu",
  kernelFunc: log1p6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LogicalAnd.js
init_dist();
var logicalAnd4 = binaryKernelFunc3({ opType: BinaryOpType.LOGICAL_AND, dtype: "bool" });
var logicalAndConfig3 = {
  kernelName: LogicalAnd,
  backendName: "webgpu",
  kernelFunc: logicalAnd4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LogicalNot.js
init_dist();
var logicalNot4 = unaryKernelFunc3({ opType: UnaryOpType.LOGICAL_NOT });
var logicalNotConfig3 = {
  kernelName: LogicalNot,
  backendName: "webgpu",
  kernelFunc: logicalNot4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LogicalOr.js
init_dist();
var logicalOr4 = binaryKernelFunc3({ opType: BinaryOpType.LOGICAL_OR });
var logicalOrConfig3 = {
  kernelName: LogicalOr,
  backendName: "webgpu",
  kernelFunc: logicalOr4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LRN.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/lrn_webgpu.js
init_dist();
var powOperatorSnippet = `
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;

class LRNProgram2 {
  constructor(xShape) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = xShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "lrn";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${powOperatorSnippet}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;
    return userCode;
  }
}

class LRNSharedProgram {
  constructor(xShape, radius) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,";
    this.workgroupSize = [256, 1, 1];
    this.maxAllowRadius = 16;
    exports_util.assert(radius <= this.maxAllowRadius, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${radius}`);
    this.outputShape = xShape;
    this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius;
    this.dispatchLayout = { x: [3], y: [2], z: [0, 1] };
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, [
      this.elementsPerWorkgroup,
      this.workgroupSize[1],
      this.workgroupSize[2]
    ]);
    this.shaderKey = "lrn_shared";
  }
  getUserCode() {
    const userCode = `
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${getMainHeaderString()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${powOperatorSnippet}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LRN.js
function lrn2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  let program;
  if (depthRadius > 16) {
    program = new LRNProgram2(x.shape);
  } else {
    program = new LRNSharedProgram(x.shape, depthRadius);
  }
  const uniformData = [
    { type: "int32", data: [depthRadius] },
    { type: "float32", data: [bias] },
    { type: "float32", data: [alpha] },
    { type: "float32", data: [beta] }
  ];
  const res = backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
  return res;
}
var lrnConfig = {
  kernelName: LRN,
  backendName: "webgpu",
  kernelFunc: lrn2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LRNGrad.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/lrn_grad_webgpu.js
class LRNGradProgram2 {
  constructor(inputShape) {
    this.outputShape = [];
    this.variableNames = ["inputImage", "outputImage", "dy"];
    this.uniforms = "depthRadius : i32, bias : f32, alpha : f32, beta : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = inputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "lrn_grad";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/LRNGrad.js
function lrnGrad2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, y, dy: dy2 } = inputs;
  const { depthRadius, bias, alpha, beta } = attrs;
  const program = new LRNGradProgram2(x.shape);
  const uniformData = [
    { type: "int32", data: [depthRadius] },
    { type: "float32", data: [bias] },
    { type: "float32", data: [alpha] },
    { type: "float32", data: [beta] }
  ];
  const res = backend3.runWebGPUProgram(program, [x, y, dy2], x.dtype, uniformData);
  return res;
}
var lrnGradConfig2 = {
  kernelName: LRNGrad,
  backendName: "webgpu",
  kernelFunc: lrnGrad2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Maximum.js
init_dist();
var maximum9 = binaryKernelFunc3({
  opType: BinaryOpType.MAX,
  cpuKernelImpl: maximumImplCPU2
});
var maximumConfig3 = {
  kernelName: Maximum,
  backendName: "webgpu",
  kernelFunc: maximum9
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MaxPool.js
init_dist();
function maxPool4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = 1;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  return poolImpl(x, convInfo, "max", backend3);
}
var maxPoolConfig3 = {
  kernelName: MaxPool,
  backendName: "webgpu",
  kernelFunc: maxPool4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MaxPool3D.js
init_dist();
function maxPool3d3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { filterSize, strides, pad: pad9, dataFormat, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode, dataFormat);
  const maxPoolProgram = new Pool3DProgram2(convInfo, "max");
  const dimensions = [
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    {
      type: "int32",
      data: [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left]
    },
    {
      type: "int32",
      data: [convInfo.inDepth, convInfo.inHeight, convInfo.inWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth,
        convInfo.effectiveFilterHeight,
        convInfo.effectiveFilterWidth
      ]
    }
  ];
  return backend3.runWebGPUProgram(maxPoolProgram, [x], x.dtype, dimensions);
}
var maxPool3DConfig3 = {
  kernelName: MaxPool3D,
  backendName: "webgpu",
  kernelFunc: maxPool3d3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MaxPool3DGrad.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/max_pool_backprop_webgpu.js
class MaxPool2DBackpropProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy", "maxPos"];
    this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "maxPool2DBackprop";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    return userCode;
  }
}

class MaxPool3DBackpropProgram2 {
  constructor(convInfo) {
    this.variableNames = ["dy", "maxPos"];
    this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = convInfo.inShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "maxPool3DBackprop";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MaxPool3DGrad.js
function maxPool3DGrad3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2 } = inputs;
  const x = input2;
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const dilations = [1, 1, 1];
  const convInfo = exports_backend_util.computePool3DInfo(x.shape, filterSize, strides, dilations, pad9, dimRoundingMode);
  const maxPool3dPositionsProgram = new Pool3DProgram2(convInfo, "max", true);
  let uniformData = [
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    {
      type: "int32",
      data: [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left]
    },
    {
      type: "int32",
      data: [convInfo.inDepth, convInfo.inHeight, convInfo.inWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth,
        convInfo.effectiveFilterHeight,
        convInfo.effectiveFilterWidth
      ]
    }
  ];
  const maxPool3dPositions2 = backend3.runWebGPUProgram(maxPool3dPositionsProgram, [x], "int32", uniformData);
  const maxPool3dBackpropProgram = new MaxPool3DBackpropProgram2(convInfo);
  uniformData = [
    {
      type: "int32",
      data: [convInfo.strideDepth, convInfo.strideHeight, convInfo.strideWidth]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth - 1 - convInfo.padInfo.front,
        convInfo.effectiveFilterHeight - 1 - convInfo.padInfo.top,
        convInfo.effectiveFilterWidth - 1 - convInfo.padInfo.left
      ]
    },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterDepth,
        convInfo.effectiveFilterHeight,
        convInfo.effectiveFilterWidth
      ]
    },
    { type: "int32", data: [convInfo.outDepth] },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] }
  ];
  const result = backend3.runWebGPUProgram(maxPool3dBackpropProgram, [dy2, maxPool3dPositions2], x.dtype, uniformData);
  backend3.disposeData(maxPool3dPositions2.dataId);
  return result;
}
var maxPool3DGradConfig4 = {
  kernelName: MaxPool3DGrad,
  backendName: "webgpu",
  kernelFunc: maxPool3DGrad3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MaxPoolGrad.js
init_dist();
function maxPoolGrad4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { dy: dy2, input: input2, output } = inputs;
  const x = input2;
  assertNotComplex3([input2, output], "maxPoolGrad");
  const { filterSize, strides, pad: pad9, dimRoundingMode } = attrs;
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, 1, pad9, dimRoundingMode);
  const maxPoolPositionsProgram = new Pool2DProgram2(convInfo, "max", true);
  let uniformData = [
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] },
    {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    }
  ];
  const maxPoolPositions2 = backend3.runWebGPUProgram(maxPoolPositionsProgram, [x], "int32", uniformData);
  const maxPoolBackpropProgram = new MaxPool2DBackpropProgram2(convInfo);
  uniformData = [
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    {
      type: "int32",
      data: [
        convInfo.effectiveFilterHeight - 1 - convInfo.padInfo.top,
        convInfo.effectiveFilterWidth - 1 - convInfo.padInfo.left
      ]
    },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    },
    { type: "int32", data: [convInfo.outHeight] },
    { type: "int32", data: [convInfo.outWidth] }
  ];
  const result = backend3.runWebGPUProgram(maxPoolBackpropProgram, [dy2, maxPoolPositions2], x.dtype, uniformData);
  backend3.disposeData(maxPoolPositions2.dataId);
  return result;
}
var maxPoolGradConfig4 = {
  kernelName: MaxPoolGrad,
  backendName: "webgpu",
  kernelFunc: maxPoolGrad4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MaxPoolWithArgmax.js
init_dist();
init_dist();
function maxPoolWithArgmax2(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { filterSize, strides, pad: pad9, includeBatchInIndex } = attrs;
  const { x } = inputs;
  exports_util.assert(x.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${x.shape.length}.`);
  const dilations = [1, 1];
  exports_util.assert(exports_backend_util.eitherStridesOrDilationsAreOne(strides, dilations), () => "Error in maxPool: Either strides or dilations must be 1. " + `Got strides ${strides} and dilations '${dilations}'`);
  const convInfo = exports_backend_util.computePool2DInfo(x.shape, filterSize, strides, dilations, pad9);
  const uniformData = [
    { type: "int32", data: [convInfo.strideHeight, convInfo.strideWidth] },
    { type: "int32", data: [convInfo.padInfo.top, convInfo.padInfo.left] },
    { type: "int32", data: [convInfo.dilationHeight, convInfo.dilationWidth] },
    { type: "int32", data: [convInfo.inHeight, convInfo.inWidth] },
    {
      type: "int32",
      data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]
    }
  ];
  let program = new Pool2DProgram2(convInfo, "max", false);
  const poolOutput = backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
  program = new Pool2DProgram2(convInfo, "max", true, true, includeBatchInIndex);
  const indexOutput = backend3.runWebGPUProgram(program, [x], "int32", uniformData);
  return [poolOutput, indexOutput];
}
var maxPoolWithArgmaxConfig3 = {
  kernelName: MaxPoolWithArgmax,
  backendName: "webgpu",
  kernelFunc: maxPoolWithArgmax2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Min.js
init_dist();
function min8(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  return reduce9(x, axis, keepDims, "min", backend3);
}
var minConfig3 = {
  kernelName: Min,
  backendName: "webgpu",
  kernelFunc: min8
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Minimum.js
init_dist();
var minimum9 = binaryKernelFunc3({
  opType: BinaryOpType.MIN,
  cpuKernelImpl: minimumImplCPU2
});
var minimumConfig3 = {
  kernelName: Minimum,
  backendName: "webgpu",
  kernelFunc: minimum9
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MirrorPad.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/mirror_pad_webgpu.js
class MirrorPadProgram2 {
  constructor(xShape, paddings, mode) {
    this.uniforms = "";
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = paddings.map((p4, i) => p4[0] + xShape[i] + p4[1]);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.xShape = xShape;
    paddings.map((_, i) => {
      this.uniforms += ` pad${i} : vec2<i32>,`;
    });
    this.offset = mode === "reflect" ? 0 : 1;
    this.shaderKey = `mirrorPad_${mode}`;
  }
  getUserCode() {
    const rank = this.xShape.length;
    const start = this.xShape.map((_, i) => `uniforms.pad${i}[0]`).join(",");
    const end = this.xShape.map((_, i) => `uniforms.pad${i}[0] + uniforms.xShape${rank > 1 ? `[${i}]` : ""}`).join(",");
    const shaderStart = rank === 1 ? "start" : "start[i]";
    const shaderEnd = rank === 1 ? "end" : "end[i]";
    const shaderOutC = rank === 1 ? "outC" : "outC[i]";
    const dtype = getCoordsDataType2(rank);
    const unpackedCoords = rank > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank) : "coords";
    return `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let start = ${dtype}(${start});
          let end = ${dtype}(${end});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${rank}; i = i + 1) {
            if (${shaderOutC} < ${shaderStart}) {
              ${shaderOutC} = ${shaderStart} * 2 - ${shaderOutC} - ${this.offset};
            } else if(${shaderOutC} >= ${shaderEnd}) {
              ${shaderOutC} = (${shaderEnd} - 1) * 2 - ${shaderOutC} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${unpackedCoords}));
        }
      }
    `;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/MirrorPad.js
var mirrorPadConfig3 = {
  kernelName: MirrorPad,
  backendName: "webgpu",
  kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
    const { x } = inputs;
    const { paddings, mode } = attrs;
    const webGPUBackend = backend3;
    const uniformData = paddings.map((p4) => {
      return { type: "int32", data: [p4[0], p4[1]] };
    });
    const program = new MirrorPadProgram2(x.shape, paddings, mode);
    const output = webGPUBackend.runWebGPUProgram(program, [x], x.dtype, uniformData);
    return output;
  }
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Mod.js
init_dist();
var mod6 = binaryKernelFunc3({ opType: BinaryOpType.MOD });
var modConfig3 = {
  kernelName: Mod,
  backendName: "webgpu",
  kernelFunc: mod6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Multinomial.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/multinomial_webgpu.js
class MultinomialProgram2 {
  constructor(batchSize, numSamples) {
    this.variableNames = ["probs"];
    this.outputShape = [];
    this.uniforms = "seed : f32, numOutcomes: i32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [batchSize, numSamples];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "multinomial";
  }
  getUserCode() {
    const userCode = `
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Softmax.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/softmax_webgpu.js
class SoftmaxProgram {
  constructor(outputShape) {
    this.variableNames = ["logits"];
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = [this.outputShape[0], 1, 1];
    if (this.outputShape[1] >= 4096) {
      this.workgroupSize = [256, 1, 1];
    } else {
      this.workgroupSize = [64, 1, 1];
    }
    this.shaderKey = "softmax";
  }
  getUserCode() {
    const userCode = `
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${getMainHeaderString("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Softmax.js
function softmax6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { logits } = inputs;
  const { dim } = attrs;
  const logitsReshaped = reshape80({
    inputs: { x: logits },
    backend: backend3,
    attrs: {
      shape: [
        exports_util.sizeFromShape(logits.shape) / logits.shape[dim],
        logits.shape[dim]
      ]
    }
  });
  const program = new SoftmaxProgram(logitsReshaped.shape);
  const res = backend3.runWebGPUProgram(program, [logitsReshaped], logits.dtype);
  const resReshaped = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape: logits.shape } });
  backend3.disposeData(logitsReshaped.dataId);
  backend3.disposeData(res.dataId);
  return resReshaped;
}
var softmaxConfig3 = {
  kernelName: Softmax,
  backendName: "webgpu",
  kernelFunc: softmax6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Multinomial.js
function multinomial4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { logits } = inputs;
  const { numSamples, seed, normalized } = attrs;
  const probs = normalized ? logits : softmax6({ inputs: { logits }, backend: backend3, attrs: { dim: logits.shape.length - 1 } });
  const batchSize = probs.shape[0];
  const numOutcomes = probs.shape[1];
  const program = new MultinomialProgram2(batchSize, numSamples);
  const uniformData = [{ type: "float32", data: [seed] }, { type: "int32", data: [numOutcomes] }];
  const res = backend3.runWebGPUProgram(program, [probs], "int32", uniformData);
  if (!normalized) {
    backend3.disposeData(probs.dataId);
  }
  return res;
}
var multinomialConfig3 = {
  kernelName: Multinomial,
  backendName: "webgpu",
  kernelFunc: multinomial4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Neg.js
init_dist();
function neg23(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (backend3.shouldExecuteOnCPU([x])) {
    const xData = backend3.tensorMap.get(x.dataId);
    const [outValues, newShape] = negImplCPU2(xData.values, x.shape, x.dtype);
    return backend3.makeTensorInfo(newShape, x.dtype, outValues);
  }
  const program = new UnaryOpProgram2(x.shape, UnaryOpType.NEG);
  return backend3.runWebGPUProgram(program, [x], x.dtype);
}
var negConfig3 = {
  kernelName: Neg,
  backendName: "webgpu",
  kernelFunc: neg23
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/NonMaxSuppressionV3.js
init_dist();
function nonMaxSuppressionV33(args) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. " + "Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold } = attrs;
  const boxesVals = backend3.readSync(boxes.dataId);
  const scoresVals = backend3.readSync(scores.dataId);
  const { selectedIndices } = exports_kernel_impls.nonMaxSuppressionV3Impl(boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);
  return backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices));
}
var nonMaxSuppressionV3Config3 = {
  kernelName: NonMaxSuppressionV3,
  backendName: "webgpu",
  kernelFunc: nonMaxSuppressionV33
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/NonMaxSuppressionV5.js
init_dist();
function nonMaxSuppressionV53(args) {
  console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. " + "Call tf.nonMaxSuppressionAsync() instead");
  const { inputs, backend: backend3, attrs } = args;
  const { boxes, scores } = inputs;
  const { maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma } = attrs;
  const boxesVals = backend3.readSync(boxes.dataId);
  const scoresVals = backend3.readSync(scores.dataId);
  const maxOutputSizeVal = maxOutputSize;
  const iouThresholdVal = iouThreshold;
  const scoreThresholdVal = scoreThreshold;
  const softNmsSigmaVal = softNmsSigma;
  const { selectedIndices, selectedScores } = exports_kernel_impls.nonMaxSuppressionV5Impl(boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal, scoreThresholdVal, softNmsSigmaVal);
  return [
    backend3.makeTensorInfo([selectedIndices.length], "int32", new Int32Array(selectedIndices)),
    backend3.makeTensorInfo([selectedScores.length], "float32", new Float32Array(selectedScores))
  ];
}
var nonMaxSuppressionV5Config3 = {
  kernelName: NonMaxSuppressionV5,
  backendName: "webgpu",
  kernelFunc: nonMaxSuppressionV53
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/OneHot.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/onehot_webgpu.js
class OneHotProgram2 {
  constructor(numIndices, depth) {
    this.variableNames = ["x"];
    this.uniforms = "onValue : f32, offValue : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [numIndices, depth];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "onehot";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/OneHot.js
function oneHot4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { indices } = inputs;
  const { dtype, depth, onValue, offValue } = attrs;
  const indicesSize = exports_util.sizeFromShape(indices.shape);
  const program = new OneHotProgram2(indicesSize, depth);
  const reshaped = reshape80({ inputs: { x: indices }, backend: backend3, attrs: { shape: [indicesSize] } });
  const uniformData = [{ type: "float32", data: [onValue] }, { type: "float32", data: [offValue] }];
  const result = backend3.runWebGPUProgram(program, [reshaped], dtype, uniformData);
  backend3.disposeData(reshaped.dataId);
  const outShape = [...indices.shape, depth];
  const out = reshape80({ inputs: { x: result }, backend: backend3, attrs: { shape: outShape } });
  backend3.disposeData(result.dataId);
  return out;
}
var oneHotConfig3 = {
  kernelName: OneHot,
  backendName: "webgpu",
  kernelFunc: oneHot4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/OnesLike.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ZerosLike.js
init_dist();
function zerosLike4(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (x.dtype === "complex64") {
    const realPart = real7({ inputs: { input: x }, backend: backend3 });
    const r = zerosLike4({ inputs: { x: realPart }, backend: backend3 });
    const imagPart = imag7({ inputs: { input: x }, backend: backend3 });
    const i = zerosLike4({ inputs: { x: imagPart }, backend: backend3 });
    const result = complex10({ inputs: { real: r, imag: i }, backend: backend3 });
    backend3.disposeData(realPart.dataId);
    backend3.disposeData(r.dataId);
    backend3.disposeData(imagPart.dataId);
    backend3.disposeData(i.dataId);
    return result;
  } else {
    return fill8({
      attrs: {
        shape: x.shape,
        dtype: x.dtype,
        value: x.dtype === "string" ? "" : 0
      },
      backend: backend3
    });
  }
}
var zerosLikeConfig3 = {
  kernelName: ZerosLike,
  backendName: "webgpu",
  kernelFunc: zerosLike4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/OnesLike.js
function onesLike4(args) {
  const { inputs, backend: backend3 } = args;
  const { x } = inputs;
  if (x.dtype === "string") {
    throw new Error("onesLike is not supported under string dtype");
  } else if (x.dtype === "complex64") {
    const realPart = real7({ inputs: { input: x }, backend: backend3 });
    const r = onesLike4({ inputs: { x: realPart }, backend: backend3 });
    const imagPart = imag7({ inputs: { input: x }, backend: backend3 });
    const i = zerosLike4({ inputs: { x: imagPart }, backend: backend3 });
    const result = complex10({ inputs: { real: r, imag: i }, backend: backend3 });
    backend3.disposeData(realPart.dataId);
    backend3.disposeData(r.dataId);
    backend3.disposeData(imagPart.dataId);
    backend3.disposeData(i.dataId);
    return result;
  } else {
    return fill8({ attrs: { shape: x.shape, dtype: x.dtype, value: 1 }, backend: backend3 });
  }
}
var onesLikeConfig3 = {
  kernelName: OnesLike,
  backendName: "webgpu",
  kernelFunc: onesLike4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Pack.js
init_dist();
function pack3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { axis } = attrs;
  if (inputs.length === 1) {
    return expandDims5({ inputs: { input: inputs[0] }, backend: backend3, attrs: { dim: axis } });
  }
  const shape = inputs[0].shape;
  const dtype = inputs[0].dtype;
  inputs.forEach((t) => {
    exports_util.assertShapesMatch(shape, t.shape, "All tensors passed to stack must have matching shapes");
    exports_util.assert(dtype === t.dtype, () => "All tensors passed to stack must have matching dtypes");
  });
  const intermediateTensorInfos = [];
  const expandedTensors = inputs.map((t) => {
    const expandedT = expandDims5({ inputs: { input: t }, backend: backend3, attrs: { dim: axis } });
    intermediateTensorInfos.push(expandedT);
    return expandedT;
  });
  const result = concat16({ inputs: expandedTensors, backend: backend3, attrs: { axis } });
  intermediateTensorInfos.forEach((t) => backend3.disposeData(t.dataId));
  return result;
}
var packConfig3 = {
  kernelName: Pack,
  backendName: "webgpu",
  kernelFunc: pack3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/PadV2.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/pad_webgpu.js
function padCommon(shape, fillZero = false) {
  const rank = shape.length;
  const type = getCoordsDataType2(rank);
  const start = shape.map((_, i) => `uniforms.pad${i}[0]`).join(",");
  const end = shape.map((_, i) => `uniforms.pad${i}[0] + uniforms.xShape${rank > 1 ? `[${i}]` : ""}`).join(",");
  const startValue = rank > 1 ? `${type}(${start})` : `${start}`;
  const endValue = rank > 1 ? `${type}(${end})` : `${end}`;
  const leftPadCondition = rank > 1 ? `any(paddedCoords < start)` : `paddedCoords < start`;
  const rightPadCondition = rank > 1 ? `any(paddedCoords >= end)` : `paddedCoords >= end`;
  const unpackedCoords = rank > 1 ? ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, rank) : "coords";
  return `
        let start = ${startValue};
        let end = ${endValue};
        if (${leftPadCondition} || ${rightPadCondition}) {
          setOutputAtIndex(index, ${fillZero ? 0 : "uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${unpackedCoords}));
        }
  `;
}

class PadProgram2 {
  constructor(xShape, paddings) {
    this.variableNames = ["x"];
    this.uniforms = "constantValue : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = paddings.map((p4, i) => p4[0] + xShape[i] + p4[1]);
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    paddings.map((_, i) => {
      this.uniforms += ` pad${i} : vec2<i32>,`;
    });
    this.xShape = xShape;
    this.shaderKey = "pad";
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${padCommon(this.xShape)}
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/PadV2.js
var padV23 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { paddings, constantValue } = attrs;
  if (paddings.every((p4) => exports_util.arraysEqual(p4, [0, 0]))) {
    return identity4({ inputs: { x }, backend: backend3 });
  }
  if (exports_util.sizeFromShape(x.shape) === 0) {
    const outputShape = paddings.map((p4, i) => p4[0] + x.shape[i] + p4[1]);
    return fill8({
      backend: backend3,
      attrs: { shape: outputShape, value: constantValue, dtype: x.dtype }
    });
  }
  const uniformData = [{ type: "float32", data: [constantValue] }];
  paddings.map((p4) => uniformData.push({ type: "int32", data: [p4[0], p4[1]] }));
  const program = new PadProgram2(x.shape, paddings);
  return backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
};
var padV2Config3 = {
  kernelName: PadV2,
  backendName: "webgpu",
  kernelFunc: padV23
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Pow.js
init_dist();
var pow11 = binaryKernelFunc3({
  opType: BinaryOpType.POW
});
var powConfig3 = {
  kernelName: Pow,
  backendName: "webgpu",
  kernelFunc: pow11
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Prelu.js
init_dist();
function prelu8(args) {
  const { inputs, backend: backend3 } = args;
  const { x, alpha } = inputs;
  const program = new BinaryOpProgram2(BinaryOpType.PRELU, x.shape, alpha.shape);
  return backend3.runWebGPUProgram(program, [x, alpha], "float32");
}
var preluConfig3 = {
  kernelName: Prelu,
  backendName: "webgpu",
  kernelFunc: prelu8
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Prod.js
init_dist();
function prod6(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { axis, keepDims } = attrs;
  return reduce9(x, axis, keepDims, "prod", backend3);
}
var prodConfig3 = {
  kernelName: Prod,
  backendName: "webgpu",
  kernelFunc: prod6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Range.js
init_dist();
var range7 = (args) => {
  const { backend: backend3, attrs } = args;
  const { start, stop, step: step9, dtype } = attrs;
  const values = rangeImplCPU2(start, stop, step9, dtype);
  return backend3.makeTensorInfo([values.length], dtype, values);
};
var rangeConfig3 = {
  kernelName: Range,
  backendName: "webgpu",
  kernelFunc: range7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/RealDiv.js
init_dist();
var realDiv2 = binaryKernelFunc3({ opType: BinaryOpType.DIV });
var realDivConfig3 = {
  kernelName: RealDiv,
  backendName: "webgpu",
  kernelFunc: realDiv2
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Reciprocal.js
init_dist();
var reciprocal5 = unaryKernelFunc3({ opType: UnaryOpType.RECIPROCAL });
var reciprocalConfig3 = {
  kernelName: Reciprocal,
  backendName: "webgpu",
  kernelFunc: reciprocal5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Relu.js
init_dist();
var relu11 = unaryKernelFunc3({ opType: UnaryOpType.RELU });
var reluConfig3 = {
  kernelName: Relu,
  backendName: "webgpu",
  kernelFunc: relu11
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Relu6.js
init_dist();
var relu67 = unaryKernelFunc3({ opType: UnaryOpType.RELU6 });
var relu6Config3 = {
  kernelName: Relu6,
  backendName: "webgpu",
  kernelFunc: relu67
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeBilinear.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/resize_bilinear_webgpu.js
class ResizeBilinearProgram2 {
  constructor(inputShape, newHeight, newWidth) {
    this.variableNames = ["x"];
    this.uniforms = "adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [inputShape[0], newHeight, newWidth, inputShape[3]];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = `resizeBilinear`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeBilinear.js
function resizeBilinear5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images } = inputs;
  const { alignCorners, size, halfPixelCenters } = attrs;
  const [newHeight, newWidth] = size;
  const adjustHeight = alignCorners && newHeight > 1 ? 1 : 0;
  const adjustWidth = alignCorners && newWidth > 1 ? 1 : 0;
  const halfPixelCentersValue = halfPixelCenters ? 0.5 : 0;
  const uniformData = [
    { type: "float32", data: [adjustHeight, adjustWidth] },
    { type: "float32", data: [halfPixelCentersValue] }
  ];
  const program = new ResizeBilinearProgram2(images.shape, newHeight, newWidth);
  return backend3.runWebGPUProgram(program, [images], "float32", uniformData);
}
var resizeBilinearConfig3 = {
  kernelName: ResizeBilinear,
  backendName: "webgpu",
  kernelFunc: resizeBilinear5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeBilinearGrad.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/resize_bilinear_backprop_webgpu.js
class ResizeBilinearBackpropProgram2 {
  constructor(inputShape, alignCorners) {
    this.variableNames = ["dy"];
    this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = inputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.alignCorners = alignCorners;
    this.shaderKey = `resizeBilinearBackprop_${alignCorners}`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeBilinearGrad.js
function resizeBilinearGrad3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images, dy: dy2 } = inputs;
  const { alignCorners } = attrs;
  const [, xHeight, xWidth] = images.shape;
  const [, yHeight, yWidth] = dy2.shape;
  const effectiveXSize = [
    alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
    alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
  ];
  const effectiveYSize = [
    alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
    alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
  ];
  const heightScale = effectiveXSize[0] / effectiveYSize[0];
  const widthScale = effectiveXSize[1] / effectiveYSize[1];
  const invHeightScale = 1 / heightScale;
  const invWidthScale = 1 / widthScale;
  const winHeight = Math.ceil(invHeightScale) * 2 + 2;
  const winWidth = Math.ceil(invWidthScale) * 2 + 2;
  const program = new ResizeBilinearBackpropProgram2(images.shape, alignCorners);
  const uniformData = [
    { type: "int32", data: effectiveXSize },
    { type: "int32", data: effectiveYSize },
    { type: "float32", data: [heightScale] },
    { type: "float32", data: [widthScale] },
    { type: "float32", data: [invHeightScale] },
    { type: "float32", data: [invWidthScale] },
    { type: "int32", data: [winHeight] },
    { type: "int32", data: [winWidth] }
  ];
  return backend3.runWebGPUProgram(program, [dy2], dy2.dtype, uniformData);
}
var resizeBilinearGradConfig4 = {
  kernelName: ResizeBilinearGrad,
  backendName: "webgpu",
  kernelFunc: resizeBilinearGrad3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeNearestNeighbor.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/resize_nearest_neighbor_webgpu.js
class ResizeNearestNeighborProgram2 {
  constructor(inputShape, newHeight, newWidth, halfPixelCenters) {
    this.variableNames = ["x"];
    this.uniforms = "adjustHeightWidth : vec2<f32>, roundBase : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = [inputShape[0], newHeight, newWidth, inputShape[3]];
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.halfPixelCenters = halfPixelCenters;
    this.shaderKey = `resizeNearest_${halfPixelCenters}`;
  }
  getUserCode() {
    let sourceFracIndexRC;
    if (this.halfPixelCenters) {
      sourceFracIndexRC = `max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC` + `, vec2<f32>(0.0))`;
    } else {
      sourceFracIndexRC = `vec2<f32>(rc) * effectiveInputOverOutputRatioRC`;
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${sourceFracIndexRC};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeNearestNeighbor.js
function resizeNearestNeighbor4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images } = inputs;
  const { alignCorners, halfPixelCenters, size } = attrs;
  const [newHeight, newWidth] = size;
  const adjustHeight = alignCorners && newHeight > 1 ? 1 : 0;
  const adjustWidth = alignCorners && newWidth > 1 ? 1 : 0;
  const roundBase = alignCorners ? 0.5 : 0;
  const uniformData = [
    { type: "float32", data: [adjustHeight, adjustWidth] },
    { type: "float32", data: [roundBase] }
  ];
  const program = new ResizeNearestNeighborProgram2(images.shape, newHeight, newWidth, halfPixelCenters);
  return backend3.runWebGPUProgram(program, [images], images.dtype, uniformData);
}
var resizeNearestNeighborConfig3 = {
  kernelName: ResizeNearestNeighbor,
  backendName: "webgpu",
  kernelFunc: resizeNearestNeighbor4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeNearestNeighborGrad.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/resize_nearest_neighbor_backprop_webgpu.js
class ResizeNearestNeigborBackpropProgram2 {
  constructor(inputShape, alignCorners) {
    this.variableNames = ["dy"];
    this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = inputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.alignCorners = alignCorners;
    this.shaderKey = `resizeNearestNeigborBackprop_${alignCorners}`;
  }
  getUserCode() {
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners ? "floor(sourceFracRow + 0.5)" : "floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners ? "floor(sourceFracCol + 0.5)" : "floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ResizeNearestNeighborGrad.js
function resizeNearestNeighborGrad3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { images, dy: dy2 } = inputs;
  const { alignCorners } = attrs;
  const [, xHeight, xWidth] = images.shape;
  const [, yHeight, yWidth] = dy2.shape;
  const effectiveXSize = [
    alignCorners && yHeight > 1 ? xHeight - 1 : xHeight,
    alignCorners && yWidth > 1 ? xWidth - 1 : xWidth
  ];
  const effectiveYSize = [
    alignCorners && yHeight > 1 ? yHeight - 1 : yHeight,
    alignCorners && yWidth > 1 ? yWidth - 1 : yWidth
  ];
  const heightScale = effectiveXSize[0] / effectiveYSize[0];
  const widthScale = effectiveXSize[1] / effectiveYSize[1];
  const invHeightScale = 1 / heightScale;
  const invWidthScale = 1 / widthScale;
  const winHeight = Math.ceil(invHeightScale) * 2 + 2;
  const winWidth = Math.ceil(invWidthScale) * 2 + 2;
  const program = new ResizeNearestNeigborBackpropProgram2(images.shape, alignCorners);
  const uniformData = [
    { type: "int32", data: effectiveXSize },
    { type: "int32", data: effectiveYSize },
    { type: "float32", data: [invHeightScale] },
    { type: "float32", data: [invWidthScale] },
    { type: "int32", data: [winHeight] },
    { type: "int32", data: [winWidth] }
  ];
  return backend3.runWebGPUProgram(program, [dy2], dy2.dtype, uniformData);
}
var resizeNearestNeighborGradConfig4 = {
  kernelName: ResizeNearestNeighborGrad,
  backendName: "webgpu",
  kernelFunc: resizeNearestNeighborGrad3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Reverse.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/reverse_webgpu.js
class ReverseProgram2 {
  constructor(xShape) {
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = xShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.uniforms = ` axis : vec4<i32>,`;
    this.shaderKey = "reverse";
  }
  getUserCode() {
    const reverseCoordsSnippet = `
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    `;
    const userCode = `
      ${reverseCoordsSnippet}
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Reverse.js
function reverse12(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { dims } = attrs;
  const xRank = x.shape.length;
  if (xRank === 0) {
    return identity4({ inputs: { x }, backend: backend3 });
  }
  const xShape = x.shape;
  const xShape4D = [1, 1, 1, 1];
  xShape.forEach((d, i) => {
    const index = i + 4 - xRank;
    xShape4D[index] = d;
  });
  const axes = exports_util.parseAxisParam(dims, x.shape);
  const dims4D = [0, 0, 0, 0];
  axes.forEach((ax) => {
    const index = ax + 4 - xRank;
    dims4D[index] = 1;
  });
  const uniformData = [{ type: "int32", data: dims4D }];
  const xReshaped = reshape80({ inputs: { x }, backend: backend3, attrs: { shape: xShape4D } });
  const program = new ReverseProgram2(xShape4D);
  const values = backend3.runWebGPUProgram(program, [xReshaped], xReshaped.dtype, uniformData);
  backend3.disposeData(xReshaped.dataId);
  const result = reshape80({ inputs: { x: values }, backend: backend3, attrs: { shape: xShape } });
  backend3.disposeData(values.dataId);
  return result;
}
var reverseConfig3 = {
  kernelName: Reverse,
  backendName: "webgpu",
  kernelFunc: reverse12
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/RotateWithOffset.js
init_dist();
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/rotate_webgpu.js
class RotateProgram2 {
  constructor(imageShape, fillValue) {
    this.outputShape = [];
    this.variableNames = ["x"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = imageShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.uniforms = `centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`;
    this.shaderKey = "rotate";
    this.outputShape = imageShape;
    if (typeof fillValue === "number") {
      this.uniforms += ` fillValue : f32,`;
      this.fillSnippet = `var outputValue = uniforms.fillValue;`;
      this.shaderKey += "_float";
    } else {
      this.uniforms += ` fillValue : vec3<f32>,`;
      this.fillSnippet = `var outputValue = uniforms.fillValue[coords[3]];`;
      this.shaderKey += "_vec3";
    }
  }
  getUserCode() {
    const userCode = `
        ${getMainHeaderString("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/RotateWithOffset.js
var rotateWithOffsetConfig3 = {
  kernelName: RotateWithOffset,
  backendName: "webgpu",
  kernelFunc: ({ inputs, attrs, backend: backend3 }) => {
    const { image: image2 } = inputs;
    const { radians, fillValue, center } = attrs;
    const webgpuBackend = backend3;
    const program = new RotateProgram2(image2.shape, fillValue);
    const [centerX, centerY] = exports_backend_util.getImageCenter(center, image2.shape[1], image2.shape[2]);
    const uniformData = [
      { type: "float32", data: [centerX] },
      { type: "float32", data: [centerY] },
      { type: "float32", data: [Math.sin(radians)] },
      { type: "float32", data: [Math.cos(radians)] }
    ];
    if (typeof fillValue === "number") {
      uniformData.push({ type: "float32", data: [Number.parseFloat(fillValue.toFixed(2))] });
    } else {
      uniformData.push({ type: "float32", data: fillValue });
    }
    const output = webgpuBackend.runWebGPUProgram(program, [image2], image2.dtype, uniformData);
    return output;
  }
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Round.js
init_dist();
var round7 = unaryKernelFunc3({ opType: UnaryOpType.ROUND });
var roundConfig3 = {
  kernelName: Round,
  backendName: "webgpu",
  kernelFunc: round7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Rsqrt.js
init_dist();
var rsqrt6 = unaryKernelFunc3({ opType: UnaryOpType.RSQRT, cpuKernelImpl: rsqrtImplCPU2 });
var rsqrtConfig3 = {
  kernelName: Rsqrt,
  backendName: "webgpu",
  kernelFunc: rsqrt6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ScatterNd.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/scatter_webgpu.js
class ScatterProgram2 {
  constructor(flattenXShape, sliceDim, indicesRank, updatesRank, strides, shape, outputDtype, sumDupeIndices = true) {
    this.variableNames = ["updates", "indices"];
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.outputShape = shape;
    this.type = outputDtype;
    this.sumDupeIndices = sumDupeIndices;
    this.dispatchLayout = flatDispatchLayout(flattenXShape);
    this.dispatch = computeDispatch(this.dispatchLayout, flattenXShape, this.workgroupSize);
    this.sliceDimGreaterThanOne = sliceDim > 1;
    this.shaderKey = `scatter_${indicesRank}_${updatesRank}_${this.sliceDimGreaterThanOne}_${outputDtype}_${sumDupeIndices}_${strides.length}`;
    const stridesType = getCoordsDataType2(strides.length);
    this.uniforms = `sliceDim : i32, strides: ${stridesType}, updatesSize: i32,`;
    this.updatesRank = updatesRank;
    this.indicesRank = indicesRank;
  }
  getUserCode() {
    let indicesString = "";
    if (this.indicesRank === 1) {
      indicesString = "coords[0]";
    } else if (this.indicesRank === 2) {
      indicesString = "coords[0], j";
    }
    const indicesSnippet = `getIndices(${indicesString})`;
    const strideString = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides";
    let outCoordsString = "";
    let getUpdatesCoordsFromFlatIndex = "";
    if (this.dispatchLayout.x.length === 1) {
      outCoordsString = "flattenedIndex";
      getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `;
    } else if (this.dispatchLayout.x.length === 2) {
      outCoordsString = "vec2<i32>(flattenedIndex, coords[1])";
      getUpdatesCoordsFromFlatIndex = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `;
    }
    const updatesString = Array.from({ length: this.updatesRank }, (_, idx) => `coords[${idx}]`);
    const updatesSnippet = `getUpdates(${updatesString.join(", ")})`;
    const userCode = `
    ${getUpdatesCoordsFromFlatIndex}
      ${getMainHeaderString("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${indicesSnippet}));
            flattenedIndex = flattenedIndex + indexInside * ${strideString};
          }
          let updateValue =
              ${dataTypeToGPUType(this.type)}(${updatesSnippet});
          let flatIndex = getOutputIndexFromCoords(${outCoordsString});

          ${this.sumDupeIndices ? atomicAddSnippet("&result[flatIndex]", "updateValue", this.type) : `atomicStore(&result[flatIndex], bitcast<i32>(updateValue));`}
        }
      }`;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/ScatterNd.js
function scatterNd3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { indices, updates } = inputs;
  const { shape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(updates, indices, shape);
  const flattenShape = [outputSize / sliceSize, sliceSize];
  if (outputSize === 0) {
    return backend3.makeTensorInfo(shape, indices.dtype);
  }
  const flattenIndices = reshape80({ inputs: { x: indices }, backend: backend3, attrs: { shape: [numUpdates, sliceRank] } });
  const flattenX = reshape80({ inputs: { x: updates }, backend: backend3, attrs: { shape: [numUpdates, sliceSize] } });
  const type = flattenX.dtype;
  const output = fill8({ backend: backend3, attrs: { shape: flattenShape, value: 0, dtype: type } });
  const size = exports_util.sizeFromShape(flattenX.shape);
  const uniformData = [
    { type: "int32", data: [sliceRank] },
    { type: "int32", data: strides },
    { type: "int32", data: [size] }
  ];
  const program = new ScatterProgram2(flattenX.shape, sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape, type);
  const res = backend3.runWebGPUProgram(program, [flattenX, flattenIndices], type, uniformData, output);
  const reshaped = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape } });
  backend3.disposeData(flattenIndices.dataId);
  backend3.disposeData(flattenX.dataId);
  backend3.disposeData(res.dataId);
  return reshaped;
}
var scatterNdConfig3 = {
  kernelName: ScatterNd,
  backendName: "webgpu",
  kernelFunc: scatterNd3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SearchSorted.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/search_sorted_webgpu.js
class SearchSortedProgram2 {
  constructor(outputShape, side) {
    this.outputShape = [];
    this.variableNames = ["sortedSequence", "values"];
    this.uniforms = "numInputs : i32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.side = side;
    this.shaderKey = `search_sorted_${side}`;
  }
  getUserCode() {
    const boundComparator = this.side === "left" ? "<" : "<=";
    const userCode = `
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${boundComparator} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SearchSorted.js
function searchSorted4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { sortedSequence, values } = inputs;
  const { side } = attrs;
  const program = new SearchSortedProgram2([values.shape[0], values.shape[1]], side);
  const uniformData = [{ type: "int32", data: [sortedSequence.shape[1]] }];
  return backend3.runWebGPUProgram(program, [sortedSequence, values], "int32", uniformData);
}
var searchSortedConfig3 = {
  kernelName: SearchSorted,
  backendName: "webgpu",
  kernelFunc: searchSorted4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Select.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/select_webgpu.js
class SelectProgram2 {
  constructor(cRank, shape, rank) {
    this.variableNames = ["c", "a", "b"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.cRank = cRank;
    this.rank = rank;
    this.shaderKey = "select";
  }
  getUserCode() {
    let cCoords;
    let abCoords;
    if (this.rank > 4) {
      throw Error(`Where for rank ${this.rank} is not yet supported`);
    }
    if (this.rank === 1) {
      abCoords = `resRC`;
      cCoords = `resRC`;
    } else {
      const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
      const cCoordVars = [];
      const abCoordVars = [];
      for (let i = 0;i < this.outputShape.length; i++) {
        abCoordVars.push(`${currentCoords[i]}`);
        if (i < this.cRank) {
          cCoordVars.push(`${currentCoords[i]}`);
        }
      }
      cCoords = cCoordVars.join();
      abCoords = abCoordVars.join();
    }
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${cCoords});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${abCoords}));
          } else {
            setOutputAtIndex(index, getB(${abCoords}));
          }
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Select.js
function select4(args) {
  const { inputs, backend: backend3 } = args;
  const { condition, t, e } = inputs;
  const program = new SelectProgram2(condition.shape.length, t.shape, t.shape.length);
  return backend3.runWebGPUProgram(program, [condition, t, e], upcastType(t.dtype, e.dtype));
}
var selectConfig3 = {
  kernelName: Select,
  backendName: "webgpu",
  kernelFunc: select4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Selu.js
init_dist();
var selu6 = unaryKernelFunc3({ opType: UnaryOpType.SELU });
var seluConfig3 = {
  kernelName: Selu,
  backendName: "webgpu",
  kernelFunc: selu6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sigmoid.js
init_dist();
var sigmoid9 = unaryKernelFunc3({ opType: UnaryOpType.SIGMOID });
var sigmoidConfig3 = {
  kernelName: Sigmoid,
  backendName: "webgpu",
  kernelFunc: sigmoid9
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sign.js
init_dist();
var sign5 = unaryKernelFunc3({ opType: UnaryOpType.SIGN });
var signConfig3 = {
  kernelName: Sign,
  backendName: "webgpu",
  kernelFunc: sign5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sin.js
init_dist();
var sin6 = unaryKernelFunc3({ opType: UnaryOpType.SIN });
var sinConfig3 = {
  kernelName: Sin,
  backendName: "webgpu",
  kernelFunc: sin6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sinh.js
init_dist();
var sinh6 = unaryKernelFunc3({ opType: UnaryOpType.SINH });
var sinhConfig3 = {
  kernelName: Sinh,
  backendName: "webgpu",
  kernelFunc: sinh6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Softplus.js
init_dist();
var softplus6 = unaryKernelFunc3({ opType: UnaryOpType.SOFTPLUS });
var softplusConfig3 = {
  kernelName: Softplus,
  backendName: "webgpu",
  kernelFunc: softplus6
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SpaceToBatchND.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/space_to_batchND_webgpu.js
class SpaceToBatchNDProgram {
  constructor(xShape, paddedXShape, paddings, reshapedPaddedXShape, newDim, paddedXShapeStridesShapeLength) {
    this.variableNames = ["x"];
    this.outputShape = [];
    this.uniforms = "";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    const outputShape = new Array(reshapedPaddedXShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = reshapedPaddedXShape[newDim[i]];
    }
    this.outputShape = outputShape;
    this.newDim = newDim;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.xShape = xShape;
    this.paddedXShape = paddedXShape;
    this.uniforms += `reshapedPaddedXShape : ${getCoordsDataType2(reshapedPaddedXShape.length)}, paddedXShapeStrides : ${getCoordsDataType2(paddedXShapeStridesShapeLength)}, `;
    paddings.map((_, i) => {
      this.uniforms += ` pad${i} : vec2<i32>,`;
    });
    this.shaderKey = `spaceToBatchND_${newDim}`;
  }
  getUserCode() {
    const dtype = getCoordsDataType2(this.outputShape.length);
    const switched = getSwitchedCoords2(this.newDim);
    const userCode = `
      ${getCoordsFromIndexSnippet(this.paddedXShape, "PaddedX")}
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${dtype}(${switched}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${padCommon(this.xShape, true)}
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SpaceToBatchND.js
var spaceToBatchND4 = (args) => {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { blockShape, paddings } = attrs;
  exports_util.assert(x.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not " + "implemented yet");
  const prod7 = blockShape.reduce((a, b) => a * b);
  const completePaddings = [[0, 0]];
  completePaddings.push(...paddings);
  for (let i = 1 + blockShape.length;i < x.shape.length; ++i) {
    completePaddings.push([0, 0]);
  }
  const paddedXShape = completePaddings.map((p4, i) => p4[0] + x.shape[i] + p4[1]);
  const reshapedPaddedShape = exports_backend_util.getReshaped(paddedXShape, blockShape, prod7, false);
  const permutedReshapedPaddedPermutation = exports_backend_util.getPermuted(reshapedPaddedShape.length, blockShape.length, false);
  const flattenShape = exports_backend_util.getReshapedPermuted(paddedXShape, blockShape, prod7, false);
  const paddedXShapeStrides = exports_util.computeStrides(paddedXShape);
  const program = new SpaceToBatchNDProgram(x.shape, paddedXShape, completePaddings, reshapedPaddedShape, permutedReshapedPaddedPermutation, paddedXShapeStrides.length);
  const uniformData = [
    { type: "int32", data: reshapedPaddedShape },
    { type: "int32", data: paddedXShapeStrides }
  ];
  completePaddings.map((p4) => uniformData.push({ type: "int32", data: [p4[0], p4[1]] }));
  const paddedXT = backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
  const result = reshape80({ inputs: { x: paddedXT }, backend: backend3, attrs: { shape: flattenShape } });
  backend3.disposeData(paddedXT.dataId);
  return result;
};
var spaceToBatchNDConfig3 = {
  kernelName: SpaceToBatchND,
  backendName: "webgpu",
  kernelFunc: spaceToBatchND4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SparseSegmentMean.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/sparse_segment_reduce.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/sparse_segment_reduce_webgpu.js
class SparseSegmentSumProgram {
  constructor(outShape, sparseSize, outputDtype) {
    this.variableNames = ["input", "indices", "segmentIds"];
    this.outputShape = [];
    this.uniforms = "segmentSize : i32, sparseSize : i32,";
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.outputShape = outShape;
    this.type = outputDtype;
    this.dispatchLayout = flatDispatchLayout([sparseSize]);
    this.dispatch = computeDispatch(this.dispatchLayout, [sparseSize], this.workgroupSize);
    this.shaderKey = "sparseSegmentSum";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${atomicAddSnippet("&result[outIndex]", "value", this.type)}
      }
    }
  `;
    return userCode;
  }
}

class SparseSegmentIdCountProgram {
  constructor(outShape, segmentIdsShape) {
    this.variableNames = ["segmentIds"];
    this.outputShape = [];
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.outputShape = [outShape];
    this.dispatchLayout = flatDispatchLayout(segmentIdsShape);
    this.dispatch = computeDispatch(this.dispatchLayout, segmentIdsShape, this.workgroupSize);
    this.shaderKey = "sparseSegmentIdCountProgram";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${atomicAddSnippet("&result[segmentId]", "1", "int32")}
      }
    }
  `;
    return userCode;
  }
}

class SparseSegmentMeanProgram {
  constructor(outShape, outputDtype) {
    this.variableNames = ["segmentSum", "sameSegmentIdCount"];
    this.outputShape = [];
    this.uniforms = "segmentSize : i32";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = outShape;
    this.type = outputDtype;
    this.dispatchLayout = flatDispatchLayout(outShape);
    this.dispatch = computeDispatch(this.dispatchLayout, outShape, this.workgroupSize);
    this.shaderKey = "sparseSegmentMean";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type === "float32" ? "setOutputAtIndex(index, segmentSum[index] / f32(count));" : "setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernel_utils/sparse_segment_reduce.js
function sparseSegmentReduce(input2, indices, segmentIds, isSum = false, backend3) {
  const inputSize = exports_util.sizeFromShape(input2.shape);
  const segmentSize = inputSize / input2.shape[0];
  const dtype = input2.dtype;
  const numIndices = exports_util.sizeFromShape(indices.shape);
  const $segmentIds = backend3.readSync(segmentIds.dataId);
  const lastSegmentIdPlusOne = numIndices > 0 ? $segmentIds[numIndices - 1] + 1 : 0;
  const outputRows = lastSegmentIdPlusOne;
  let program;
  const outputShape = input2.shape.slice();
  outputShape[0] = outputRows;
  const sparseSize = numIndices * segmentSize;
  const sparseSegmentSum4 = fill8({ backend: backend3, attrs: { shape: outputShape, value: 0, dtype } });
  program = new SparseSegmentSumProgram(outputShape, sparseSize, dtype);
  let uniformData = [
    { type: "int32", data: [segmentSize] },
    { type: "int32", data: [sparseSize] }
  ];
  const $sparseSegmentSum = backend3.runWebGPUProgram(program, [input2, indices, segmentIds], dtype, uniformData, sparseSegmentSum4);
  if (isSum) {
    return $sparseSegmentSum;
  }
  const sparseSegmentIdCount = fill8({ backend: backend3, attrs: { shape: [outputRows], value: 0, dtype: "int32" } });
  program = new SparseSegmentIdCountProgram(outputRows, segmentIds.shape);
  const $sparseSegmentIdCount = backend3.runWebGPUProgram(program, [segmentIds], "int32", null, sparseSegmentIdCount);
  const sparseSegmentMean4 = fill8({ backend: backend3, attrs: { shape: outputShape, value: 0, dtype } });
  program = new SparseSegmentMeanProgram(outputShape, dtype);
  uniformData = [{ type: "int32", data: [segmentSize] }];
  const $sparseSegmentMean = backend3.runWebGPUProgram(program, [$sparseSegmentSum, $sparseSegmentIdCount], dtype, uniformData, sparseSegmentMean4);
  backend3.disposeData($sparseSegmentSum.dataId);
  backend3.disposeData($sparseSegmentIdCount.dataId);
  return $sparseSegmentMean;
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SparseSegmentMean.js
function sparseSegmentMean4(args) {
  const { inputs, backend: backend3 } = args;
  const { data, indices, segmentIds } = inputs;
  return sparseSegmentReduce(data, indices, segmentIds, false, backend3);
}
var sparseSegmentMeanConfig3 = {
  kernelName: SparseSegmentMean,
  backendName: "webgpu",
  kernelFunc: sparseSegmentMean4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SparseSegmentSum.js
init_dist();
function sparseSegmentSum4(args) {
  const { inputs, backend: backend3 } = args;
  const { data, indices, segmentIds } = inputs;
  return sparseSegmentReduce(data, indices, segmentIds, true, backend3);
}
var sparseSegmentSumConfig3 = {
  kernelName: SparseSegmentSum,
  backendName: "webgpu",
  kernelFunc: sparseSegmentSum4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SparseToDense.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Tile.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/tile_webgpu.js
function getSourceCoords5(rank, uniformPrefix = "") {
  if (rank >= 5) {
    throw Error(`Tile for rank ${rank} is not yet supported`);
  }
  if (rank === 1) {
    return `(resRC % ${uniformPrefix}aShape)`;
  }
  const currentCoords = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"];
  const sourceCoords = [];
  for (let i = 0;i < rank; i++) {
    sourceCoords.push(`(${currentCoords[i]} % ${uniformPrefix}aShape[${i}])`);
  }
  return sourceCoords.join();
}

class TileProgram2 {
  constructor(aShape, reps) {
    this.variableNames = ["A"];
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    const outputShape = new Array(aShape.length);
    for (let i = 0;i < outputShape.length; i++) {
      outputShape[i] = aShape[i] * reps[i];
    }
    this.outputShape = outputShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.rank = this.outputShape.length;
    this.shaderKey = "tile";
  }
  getUserCode() {
    const sourceCoords = getSourceCoords5(this.rank, "uniforms.");
    const userCode = `
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${sourceCoords}));
        }
      }
    `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Tile.js
function tile10(params) {
  const { inputs, backend: backend3, attrs } = params;
  const { x } = inputs;
  const { reps } = attrs;
  if (backend3.shouldExecuteOnCPU([x]) || x.dtype === "string" || x.shape.length >= 5) {
    const data = backend3.readSync(x.dataId);
    const value = x.dtype === "string" ? data.map((d) => exports_util.decodeString(d)) : data;
    const buf = buffer(x.shape, x.dtype, value);
    const outBuf = tileImplCPU2(buf, reps);
    return backend3.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);
  }
  const program = new TileProgram2(x.shape, reps);
  const output = backend3.runWebGPUProgram(program, [x], x.dtype);
  return output;
}
var tileConfig3 = {
  kernelName: Tile,
  backendName: "webgpu",
  kernelFunc: tile10
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SparseToDense.js
function sparseToDense4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { sparseIndices, sparseValues, defaultValue } = inputs;
  const { outputShape } = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(sparseValues, sparseIndices, outputShape);
  const sumDupeIndices = false;
  if (sparseValues.dtype === "string") {
    const indicesBuf = backend3.bufferSync(sparseIndices);
    const updatesBuf = backend3.bufferSync(sparseValues);
    const $defaultValue2 = exports_util.decodeString(backend3.readSync(defaultValue.dataId)[0]);
    const outBuf = scatterImplCPU2(indicesBuf, updatesBuf, outputShape, outputSize, sliceSize, numUpdates, sliceRank, strides, $defaultValue2, sumDupeIndices);
    return backend3.makeTensorInfo(outputShape, outBuf.dtype, outBuf.values);
  }
  const flattenShape = [outputSize / sliceSize, sliceSize];
  const $sparseIndices = reshape80({
    inputs: { x: sparseIndices },
    backend: backend3,
    attrs: { shape: [numUpdates, sliceRank] }
  });
  const $sparseValues = sparseValues.shape.length ? reshape80({
    inputs: { x: sparseValues },
    backend: backend3,
    attrs: { shape: [numUpdates, sliceSize] }
  }) : identity4({ inputs: { x: sparseValues }, backend: backend3 });
  const type = $sparseValues.dtype;
  const zero = backend3.makeTensorInfo([], type, exports_util.makeZerosTypedArray(1, type));
  const $defaultValue = reshape80({
    inputs: { x: defaultValue },
    backend: backend3,
    attrs: { shape: Array(flattenShape.length).fill(1) }
  });
  const $denseValues = tile10({ inputs: { x: $defaultValue }, backend: backend3, attrs: { reps: flattenShape } });
  const size = exports_util.sizeFromShape([numUpdates, sliceSize]);
  const uniformData = [
    { type: "int32", data: [sliceRank] },
    { type: "int32", data: strides },
    { type: "int32", data: [size] }
  ];
  switch (numUpdates) {
    case 0:
      break;
    case 1:
      if (true) {
        const program = new ScatterProgram2([numUpdates, sliceSize], sliceRank, $sparseIndices.shape.length, $sparseValues.shape.length, strides, flattenShape, type, sumDupeIndices);
        backend3.runWebGPUProgram(program, [$sparseValues, $sparseIndices], type, uniformData, $denseValues);
      }
      break;
    default:
      if (true) {
        const program = new ScatterProgram2([numUpdates, sliceSize], sliceRank, $sparseIndices.shape.length, zero.shape.length, strides, flattenShape, type, sumDupeIndices);
        backend3.runWebGPUProgram(program, [zero, $sparseIndices], type, uniformData, $denseValues);
      }
      {
        const program = new ScatterProgram2([numUpdates, sliceSize], sliceRank, $sparseIndices.shape.length, $sparseValues.shape.length, strides, flattenShape, type);
        backend3.runWebGPUProgram(program, [$sparseValues, $sparseIndices], type, uniformData, $denseValues);
      }
  }
  const denseValues = reshape80({ inputs: { x: $denseValues }, backend: backend3, attrs: { shape: outputShape } });
  backend3.disposeData($sparseIndices.dataId);
  backend3.disposeData($sparseValues.dataId);
  backend3.disposeData($defaultValue.dataId);
  backend3.disposeData(zero.dataId);
  backend3.disposeData($denseValues.dataId);
  return denseValues;
}
var sparseToDenseConfig3 = {
  kernelName: SparseToDense,
  backendName: "webgpu",
  kernelFunc: sparseToDense4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SplitV.js
init_dist();
function splitV3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { numOrSizeSplits, axis } = attrs;
  const $axis = exports_util.parseAxisParam(axis, x.shape)[0];
  const splitSizes = exports_backend_util.prepareSplitSize(x, numOrSizeSplits, $axis);
  const xRank = x.shape.length;
  const begin = new Array(xRank).fill(0);
  const size = x.shape.slice();
  return splitSizes.map((s) => {
    const sliceSize = [...size];
    sliceSize[$axis] = s;
    const sliceT = slice18({ inputs: { x }, backend: backend3, attrs: { begin, size: sliceSize } });
    begin[$axis] += s;
    return sliceT;
  });
}
var splitVConfig3 = {
  kernelName: SplitV,
  backendName: "webgpu",
  kernelFunc: splitV3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sqrt.js
init_dist();
var sqrt14 = unaryKernelFunc3({ opType: UnaryOpType.SQRT });
var sqrtConfig3 = {
  kernelName: Sqrt,
  backendName: "webgpu",
  kernelFunc: sqrt14
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Square.js
init_dist();
var squareConfig3 = {
  kernelName: Square,
  backendName: "webgpu",
  kernelFunc: ({ inputs, backend: backend3 }) => {
    const { x } = inputs;
    const webGPUBackend = backend3;
    const program = new UnaryOpProgram2(x.shape, UnaryOpType.SQUARE);
    return webGPUBackend.runWebGPUProgram(program, [x], x.dtype);
  }
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/SquaredDifference.js
init_dist();
var squaredDifference4 = binaryKernelFunc3({
  opType: BinaryOpType.SQUARED_DIFFERENCE
});
var squaredDifferenceConfig3 = {
  kernelName: SquaredDifference,
  backendName: "webgpu",
  kernelFunc: squaredDifference4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Step.js
init_dist();
function step9({ inputs, attrs, backend: backend3 }) {
  const { x } = inputs;
  const program = new UnaryOpProgram2(x.shape, UnaryOpType.STEP, "stepAlpha : f32,");
  const uniformData = [{ type: "float32", data: [attrs.alpha] }];
  return backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
}
var stepConfig3 = {
  kernelName: Step,
  backendName: "webgpu",
  kernelFunc: step9
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/StridedSlice.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/strided_slice_webgpu.js
class StridedSliceProgram2 {
  constructor(destSize) {
    this.variableNames = ["x"];
    this.workPerThread = 1;
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = destSize;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize, [this.workPerThread, 1, 1]);
    const dtype = getCoordsDataType2(this.outputShape.length);
    this.uniforms = `begin : ${dtype},  strides : ${dtype}, `;
    this.shaderKey = "stridedSlice";
  }
  getUserCode() {
    const rank = this.outputShape.length;
    let newCoords = "";
    if (rank === 1) {
      newCoords = "coords * uniforms.strides + uniforms.begin";
    } else {
      let outputAxis = 0;
      newCoords = this.outputShape.map((_, i) => {
        outputAxis++;
        return this.outputShape.length === 1 ? `coords * uniforms.strides[${i}] + uniforms.begin[${i}]` : `coords[${outputAxis - 1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`;
      }).join(",");
    }
    const userCode = `
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${newCoords}));
         }
       }
     `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/StridedSlice.js
function stridedSlice4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask } = attrs;
  const { finalShapeSparse, finalShape, isIdentity, sliceDim0, isSimpleSlice, begin: $begin, end: $end, strides: $strides } = exports_slice_util.sliceInfo(x.shape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
  let result;
  if (isIdentity) {
    result = reshape80({ inputs: { x }, backend: backend3, attrs: { shape: finalShape } });
  } else if (sliceDim0 || isSimpleSlice) {
    exports_util.assert(x.shape.length >= 1, () => `Input must have rank at least 1, got: ${x.shape.length}`);
    const size = exports_slice_util.computeOutShape($begin, $end, $strides);
    const sliced = slice18({ inputs: { x }, backend: backend3, attrs: { begin: $begin, size } });
    result = reshape80({ inputs: { x: sliced }, backend: backend3, attrs: { shape: finalShape } });
    backend3.disposeData(sliced.dataId);
  } else {
    const shouldExecuteOnCPU = backend3.shouldExecuteOnCPU([x]);
    if (shouldExecuteOnCPU) {
      const values = backend3.readSync(x.dataId);
      const xBuf = buffer(x.shape, x.dtype, values);
      const resultValues = stridedSliceImplCPU2(finalShapeSparse, xBuf, $strides, $begin);
      result = backend3.makeTensorInfo(finalShape, x.dtype, resultValues.values);
    } else {
      const program = new StridedSliceProgram2(finalShapeSparse);
      const uniformData = [{ type: "int32", data: $begin }, { type: "int32", data: $strides }];
      const resultValues = backend3.runWebGPUProgram(program, [x], x.dtype, uniformData);
      result = reshape80({ inputs: { x: resultValues }, backend: backend3, attrs: { shape: finalShape } });
      backend3.disposeData(resultValues.dataId);
    }
  }
  return result;
}
var stridedSliceConfig3 = {
  kernelName: StridedSlice,
  backendName: "webgpu",
  kernelFunc: stridedSlice4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/StringNGrams.js
init_dist();
function stringNGrams4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { separator, nGramWidths, leftPad, rightPad: rightPad2, padWidth, preserveShortSequences } = attrs;
  const { data, dataSplits } = inputs;
  const $data = backend3.readSync(data.dataId);
  const $dataSplits = backend3.readSync(dataSplits.dataId);
  const [nGrams, nGramsSplits] = stringNGramsImplCPU2($data, $dataSplits, separator, nGramWidths, leftPad, rightPad2, padWidth, preserveShortSequences);
  return [
    backend3.makeTensorInfo([nGrams.length], "string", nGrams),
    backend3.makeTensorInfo(dataSplits.shape, "int32", nGramsSplits)
  ];
}
var stringNGramsConfig3 = {
  kernelName: StringNGrams,
  backendName: "webgpu",
  kernelFunc: stringNGrams4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Sub.js
init_dist();
var sub35 = binaryKernelFunc3({ opType: BinaryOpType.SUB, cpuKernelImpl: subImplCPU2, supportsComplex: true });
var subConfig3 = {
  kernelName: Sub,
  backendName: "webgpu",
  kernelFunc: sub35
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Tan.js
init_dist();
var tan5 = unaryKernelFunc3({ opType: UnaryOpType.TAN });
var tanConfig3 = {
  kernelName: Tan,
  backendName: "webgpu",
  kernelFunc: tan5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Tanh.js
init_dist();
var tanh7 = unaryKernelFunc3({ opType: UnaryOpType.TANH });
var tanhConfig3 = {
  kernelName: Tanh,
  backendName: "webgpu",
  kernelFunc: tanh7
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/TensorScatterUpdate.js
init_dist();
function tensorScatterUpdate4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { tensor: tensor153, indices, updates } = inputs;
  const {} = attrs;
  const { sliceRank, numUpdates, sliceSize, strides, outputSize } = exports_backend_util.calculateShapes(updates, indices, tensor153.shape);
  const flattenShape = [outputSize / sliceSize, sliceSize];
  if (outputSize === 0) {
    return backend3.makeTensorInfo(tensor153.shape, indices.dtype);
  }
  const toDispose = [];
  const flattenIndices = reshape80({ inputs: { x: indices }, backend: backend3, attrs: { shape: [numUpdates, sliceRank] } });
  toDispose.push(flattenIndices);
  const flattenX = reshape80({ inputs: { x: updates }, backend: backend3, attrs: { shape: [numUpdates, sliceSize] } });
  toDispose.push(flattenX);
  const flattenTensor = reshape80({ inputs: { x: tensor153 }, backend: backend3, attrs: { shape: flattenShape } });
  toDispose.push(flattenTensor);
  const output = tile10({
    inputs: { x: flattenTensor },
    backend: backend3,
    attrs: { reps: Array(flattenShape.length).fill(1) }
  });
  const program = new ScatterProgram2([numUpdates, sliceSize], sliceRank, flattenIndices.shape.length, flattenX.shape.length, strides, flattenShape, tensor153.dtype, false);
  const size = exports_util.sizeFromShape([numUpdates, sliceSize]);
  const uniformData = [
    { type: "int32", data: [sliceRank] },
    { type: "int32", data: strides },
    { type: "int32", data: [size] }
  ];
  const res = backend3.runWebGPUProgram(program, [flattenX, flattenIndices], flattenTensor.dtype, uniformData, output);
  toDispose.push(res);
  const reshaped = reshape80({ inputs: { x: res }, backend: backend3, attrs: { shape: tensor153.shape } });
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return reshaped;
}
var tensorScatterUpdateConfig3 = {
  kernelName: TensorScatterUpdate,
  backendName: "webgpu",
  kernelFunc: tensorScatterUpdate4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/TopK.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/top_k_webgpu.js
class SwapProgram2 {
  constructor(shape) {
    this.variableNames = ["x", "indices"];
    this.workgroupSize = [256, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.uniforms = `inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`;
    this.shaderKey = "swap";
  }
  getUserCode() {
    const userCode = `
        ${getMainHeaderString("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    return userCode;
  }
}

class MergeProgram2 {
  constructor(shape) {
    this.variableNames = ["x", "indices"];
    this.workgroupSize = [256, 1, 1];
    this.size = true;
    this.outputShape = shape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.uniforms = `inputSize : i32, firstPass : i32, k : i32,`;
    this.shaderKey = "merge";
  }
  getUserCode() {
    const userCode = `
        ${getMainHeaderString("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/TopK.js
function disposeIntermediateTensorInfoOrNull2(backend3, tensorInfo) {
  if (tensorInfo !== null) {
    backend3.disposeData(tensorInfo.dataId);
  }
}
function roundUpToPow22(num) {
  let pow22 = 1;
  while (pow22 < num) {
    pow22 *= 2;
  }
  return pow22;
}
function topK3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x } = inputs;
  const { k, sorted } = attrs;
  const xShape = x.shape;
  const lastDim = xShape[xShape.length - 1];
  if (backend3.shouldExecuteOnCPU([x])) {
    const xVals = backend3.readSync(x.dataId);
    const [allTopKVals, allTopKIndices] = topKImplCPU2(xVals, xShape, x.dtype, k, sorted);
    return [
      backend3.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),
      backend3.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)
    ];
  }
  if (k === 0) {
    xShape[xShape.length - 1] = 0;
    return [
      backend3.makeTensorInfo(xShape, x.dtype, []),
      backend3.makeTensorInfo(xShape, "int32", [])
    ];
  }
  if (lastDim === 1) {
    return [
      x,
      fill8({ attrs: { shape: xShape, dtype: "int32", value: 0 }, backend: backend3 })
    ];
  }
  const xSize = exports_util.sizeFromShape(xShape);
  const batch = xSize / lastDim;
  const x2D = reshape80({ inputs: { x }, attrs: { shape: [batch, lastDim] }, backend: backend3 });
  const kPow2 = roundUpToPow22(k);
  const lastDimPow2 = roundUpToPow22(lastDim);
  let indices = null;
  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];
  const runSwap = (dir, inc, shape) => {
    const inputs2 = getInputs();
    const program = new SwapProgram2(shape);
    const firstPass = indices === null ? 1 : 0;
    const uniformDataSwap = [
      { type: "int32", data: [lastDim] },
      { type: "int32", data: [firstPass] },
      { type: "float32", data: [Number.NEGATIVE_INFINITY] },
      { type: "int32", data: [dir] },
      { type: "int32", data: [inc] }
    ];
    const prevIndices2 = indices;
    indices = backend3.runWebGPUProgram(program, inputs2, "int32", uniformDataSwap);
    disposeIntermediateTensorInfoOrNull2(backend3, prevIndices2);
  };
  for (let len = 1;len < kPow2; len *= 2) {
    const dir = len * 2;
    for (let inc = len;inc >= 1; inc /= 2) {
      runSwap(dir, inc, [batch, lastDimPow2]);
    }
  }
  for (let indicesSize = lastDimPow2;indicesSize > kPow2; indicesSize /= 2) {
    const inputs2 = getInputs();
    const mergeProgram = new MergeProgram2([batch, indicesSize / 2]);
    const firstPass = indices === null ? 1 : 0;
    const uniformDataMerge = [
      { type: "int32", data: [lastDim] },
      { type: "int32", data: [firstPass] },
      { type: "int32", data: [kPow2] }
    ];
    const prevIndices2 = indices;
    indices = backend3.runWebGPUProgram(mergeProgram, inputs2, "int32", uniformDataMerge);
    disposeIntermediateTensorInfoOrNull2(backend3, prevIndices2);
    const len = kPow2 / 2;
    const dir = len * 2;
    for (let inc = len;inc >= 1; inc /= 2) {
      runSwap(dir, inc, indices.shape);
    }
  }
  let prevIndices = indices;
  indices = slice18({ inputs: { x: indices }, backend: backend3, attrs: { begin: 0, size: [batch, k] } });
  disposeIntermediateTensorInfoOrNull2(backend3, prevIndices);
  let values = gatherV23({ inputs: { x: x2D, indices }, backend: backend3, attrs: { axis: 1, batchDims: 1 } });
  disposeIntermediateTensorInfoOrNull2(backend3, x2D);
  const newShape = xShape.slice(0, -1);
  newShape.push(k);
  prevIndices = indices;
  indices = reshape80({ inputs: { x: indices }, attrs: { shape: newShape }, backend: backend3 });
  disposeIntermediateTensorInfoOrNull2(backend3, prevIndices);
  const prevValues = values;
  values = reshape80({ inputs: { x: values }, attrs: { shape: newShape }, backend: backend3 });
  disposeIntermediateTensorInfoOrNull2(backend3, prevValues);
  return [values, indices];
}
var topKConfig3 = {
  kernelName: TopK,
  backendName: "webgpu",
  kernelFunc: topK3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Transform.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/transform_webgpu.js
class TransformProgram2 {
  constructor(outShape) {
    this.variableNames = ["Image", "Transforms"];
    this.uniforms = "interpolationModeId : i32, fillModeId : i32, fillValue : f32,";
    this.workgroupSize = [64, 1, 1];
    this.size = true;
    this.outputShape = outShape;
    this.dispatchLayout = flatDispatchLayout(this.outputShape);
    this.dispatch = computeDispatch(this.dispatchLayout, this.outputShape, this.workgroupSize);
    this.shaderKey = "transform";
  }
  getUserCode() {
    const userCode = `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${getMainHeaderString("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Transform.js
function transform5(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { image: image2, transforms } = inputs;
  const { interpolation, fillMode, fillValue, outputShape } = attrs;
  const [batch, imageHeight, imageWidth, numChannels] = image2.shape;
  const [outHeight, outWidth] = outputShape != null ? outputShape : [imageHeight, imageWidth];
  const outShape = [
    batch,
    outHeight,
    outWidth,
    numChannels
  ];
  const program = new TransformProgram2(outShape);
  const interpolationModeId = interpolation === "nearest" ? 1 : 2;
  let fillModeId;
  switch (fillMode) {
    case "constant":
      fillModeId = 1;
      break;
    case "reflect":
      fillModeId = 2;
      break;
    case "wrap":
      fillModeId = 3;
      break;
    case "nearest":
      fillModeId = 4;
      break;
    default:
      fillModeId = 1;
      break;
  }
  const uniformData = [
    { type: "int32", data: [interpolationModeId] },
    { type: "int32", data: [fillModeId] },
    { type: "float32", data: [fillValue] }
  ];
  return backend3.runWebGPUProgram(program, [image2, transforms], "float32", uniformData);
}
var transformConfig3 = {
  kernelName: Transform,
  backendName: "webgpu",
  kernelFunc: transform5
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/Unpack.js
init_dist();
function unpack3(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { value } = inputs;
  let { axis } = attrs;
  if (axis < 0) {
    axis += value.shape.length;
  }
  const x = value;
  const xRank = x.shape.length;
  const num = value.shape[axis];
  const outShape = new Array(xRank - 1);
  let outIndex = 0;
  for (let i = 0;i < xRank; i++) {
    if (i !== axis) {
      outShape[outIndex++] = x.shape[i];
    }
  }
  const toDispose = [];
  const begin = new Array(xRank).fill(0);
  const size = x.shape.slice();
  size[axis] = 1;
  const res = new Array(num);
  for (let i = 0;i < res.length; i++) {
    begin[axis] = i;
    const sliced = slice18({ inputs: { x }, backend: backend3, attrs: { begin, size } });
    const reshaped = reshape80({ inputs: { x: sliced }, backend: backend3, attrs: { shape: outShape } });
    res[i] = reshaped;
    toDispose.push(sliced);
  }
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return res;
}
var unpackConfig3 = {
  kernelName: Unpack,
  backendName: "webgpu",
  kernelFunc: unpack3
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/UnsortedSegmentSum.js
init_dist();

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/unsorted_segment_sum_webgpu.js
class UnsortedSegmentSumProgram {
  constructor(inShape, outShape, outputDtype) {
    this.outputShape = [];
    this.variableNames = ["x", "segmentIds"];
    this.uniforms = "numSegments : i32, xSize: i32,";
    this.workgroupSize = [64, 1, 1];
    this.atomic = true;
    this.outputShape = outShape;
    this.dispatchLayout = flatDispatchLayout(inShape);
    this.dispatch = computeDispatch(this.dispatchLayout, inShape, this.workgroupSize);
    if (outputDtype !== "float32" && outputDtype !== "int32") {
      throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${outputDtype} type.`);
    }
    this.type = outputDtype;
    this.shaderKey = "unsortedSegmentSum";
  }
  getUserCode() {
    const userCode = `
    ${getMainHeaderString("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${atomicAddSnippet("&result[flatIndex]", "value", this.type)}
        }
      }
    }
  `;
    return userCode;
  }
}

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/kernels/UnsortedSegmentSum.js
function unsortedSegmentSum4(args) {
  const { inputs, backend: backend3, attrs } = args;
  const { x, segmentIds } = inputs;
  const { numSegments } = attrs;
  const xRank = x.shape.length;
  const toDispose = [];
  let axis = 0;
  const permutation = exports_backend_util.getAxesPermutation([axis], xRank);
  let permutedX = x;
  if (permutation != null) {
    permutedX = transpose13({ inputs: { x }, backend: backend3, attrs: { perm: permutation } });
    toDispose.push(permutedX);
    axis = exports_backend_util.getInnerMostAxes(1, xRank)[0];
  }
  const outShape = exports_backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);
  const inSize = exports_util.sizeFromShape([permutedX.shape[axis]]);
  const a2D = reshape80({ inputs: { x: permutedX }, backend: backend3, attrs: { shape: [-1, inSize] } });
  toDispose.push(a2D);
  const dtype = x.dtype;
  const shape = [a2D.shape[0], numSegments];
  const output = fill8({ backend: backend3, attrs: { shape, value: 0, dtype } });
  const program = new UnsortedSegmentSumProgram(a2D.shape, shape, dtype);
  const uniformData = [
    { type: "int32", data: [numSegments] },
    { type: "int32", data: [exports_util.sizeFromShape(a2D.shape)] }
  ];
  const segResult = backend3.runWebGPUProgram(program, [a2D, segmentIds], dtype, uniformData, output);
  const reshaped = reshape80({ inputs: { x: segResult }, backend: backend3, attrs: { shape: outShape } });
  toDispose.push(segResult);
  let result = reshaped;
  if (permutation != null) {
    toDispose.push(reshaped);
    const perm = exports_backend_util.getUndoAxesPermutation(permutation);
    result = transpose13({ inputs: { x: result }, backend: backend3, attrs: { perm } });
  }
  toDispose.forEach((t) => backend3.disposeData(t.dataId));
  return result;
}
var unsortedSegmentSumConfig3 = {
  kernelName: UnsortedSegmentSum,
  backendName: "webgpu",
  kernelFunc: unsortedSegmentSum4
};

// node_modules/@tensorflow/tfjs-backend-webgpu/dist/register_all_kernels.js
var kernelConfigs3 = [
  _fusedMatMulConfig3,
  absConfig3,
  acosConfig3,
  acoshConfig3,
  addConfig3,
  addNConfig3,
  allConfig3,
  anyConfig3,
  argMaxConfig3,
  argMinConfig3,
  asinConfig3,
  asinhConfig3,
  atanConfig3,
  atan2Config3,
  atanhConfig3,
  avgPoolConfig3,
  avgPool3DConfig3,
  avgPool3DGradConfig4,
  avgPoolGradConfig4,
  batchMatMulConfig3,
  batchToSpaceNDConfig3,
  bincountConfig3,
  broadcastArgsConfig3,
  castConfig3,
  ceilConfig3,
  clipByValueConfig3,
  complexConfig3,
  complexAbsConfig3,
  concatConfig3,
  conv2DConfig3,
  conv2DBackpropFilterConfig3,
  conv2DBackpropInputConfig3,
  conv3DConfig3,
  conv3DBackpropFilterV2Config3,
  conv3DBackpropInputV2Config2,
  cosConfig3,
  coshConfig3,
  cropAndResizeConfig3,
  cumprodConfig3,
  cumsumConfig3,
  denseBincountConfig3,
  depthToSpaceConfig3,
  depthwiseConv2dNativeBackpropFilterConfig3,
  depthwiseConv2dNativeBackpropInputConfig3,
  depthwiseConv2dNativeConfig3,
  diagConfig3,
  dilation2DConfig3,
  dilation2DBackpropFilterConfig2,
  dilation2DBackpropInputConfig2,
  drawConfig2,
  einsumConfig3,
  eluConfig3,
  eluGradConfig4,
  equalConfig3,
  erfConfig3,
  expConfig3,
  expandDimsConfig3,
  expm1Config3,
  fftConfig3,
  fillConfig3,
  flipLeftRightConfig3,
  fromPixelsConfig2,
  floorConfig3,
  floorDivConfig3,
  fusedBatchNormConfig,
  fusedConv2DConfig3,
  fusedDepthwiseConv2DConfig3,
  gatherNdConfig3,
  gatherV2Config3,
  greaterConfig3,
  greaterEqualConfig3,
  identityConfig3,
  ifftConfig3,
  imagConfig3,
  isFiniteConfig3,
  isInfConfig3,
  isNaNConfig3,
  leakyReluConfig3,
  lessConfig3,
  lessEqualConfig3,
  linSpaceConfig3,
  log1pConfig3,
  logConfig3,
  logicalAndConfig3,
  logicalNotConfig3,
  logicalOrConfig3,
  lrnConfig,
  lrnGradConfig2,
  maxConfig3,
  maximumConfig3,
  maxPoolConfig3,
  maxPoolGradConfig4,
  maxPool3DConfig3,
  maxPool3DGradConfig4,
  maxPoolWithArgmaxConfig3,
  meanConfig3,
  minConfig3,
  minimumConfig3,
  mirrorPadConfig3,
  modConfig3,
  multinomialConfig3,
  multiplyConfig3,
  negConfig3,
  nonMaxSuppressionV3Config3,
  nonMaxSuppressionV5Config3,
  notEqualConfig3,
  oneHotConfig3,
  onesLikeConfig3,
  packConfig3,
  padV2Config3,
  powConfig3,
  preluConfig3,
  prodConfig3,
  rangeConfig3,
  realConfig3,
  realDivConfig3,
  reciprocalConfig3,
  reluConfig3,
  relu6Config3,
  reshapeConfig3,
  resizeBilinearConfig3,
  resizeBilinearGradConfig4,
  resizeNearestNeighborConfig3,
  resizeNearestNeighborGradConfig4,
  reverseConfig3,
  rotateWithOffsetConfig3,
  roundConfig3,
  rsqrtConfig3,
  scatterNdConfig3,
  searchSortedConfig3,
  selectConfig3,
  seluConfig3,
  sigmoidConfig3,
  signConfig3,
  sinConfig3,
  sinhConfig3,
  sliceConfig3,
  stepConfig3,
  stridedSliceConfig3,
  stringNGramsConfig3,
  softmaxConfig3,
  softplusConfig3,
  spaceToBatchNDConfig3,
  sparseSegmentMeanConfig3,
  sparseSegmentSumConfig3,
  sparseToDenseConfig3,
  splitVConfig3,
  sqrtConfig3,
  squareConfig3,
  squaredDifferenceConfig3,
  subConfig3,
  sumConfig3,
  tanConfig3,
  tanhConfig3,
  tensorScatterUpdateConfig3,
  tileConfig3,
  topKConfig3,
  transformConfig3,
  transposeConfig3,
  unpackConfig3,
  unsortedSegmentSumConfig3,
  zerosLikeConfig3
];
for (const kernelConfig of kernelConfigs3) {
  registerKernel(kernelConfig);
}

// src/engine/schemata.ts
var exports_schemata = {};
__export(exports_schemata, {
  synthFs: () => synthFs,
  speakerVoiceSchema: () => speakerVoiceSchema,
  speakerIds: () => speakerIds,
  speakerIdEnumSchema: () => speakerIdEnumSchema,
  pointsSchema: () => pointsSchema,
  pointYSchema: () => pointYSchema,
  pointXSchema: () => pointXSchema,
  pointSchema: () => pointSchema,
  noteSchema: () => noteSchema,
  kanas: () => kanas,
  kanaRecordSchema: () => kanaRecordSchema,
  kanaEnumSchema: () => kanaEnumSchema,
  envRecordSchema: () => envRecordSchema,
  envLenSchema: () => envLenSchema,
  envKeys: () => envKeys,
  envKeyVolumes: () => envKeyVolumes,
  envKeyEnumSchema: () => envKeyEnumSchema,
  bpmSchema: () => bpmSchema
});

// node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? undefined : errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet(receiver, state6, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state6 === "function" ? receiver !== state6 || !f : !state6.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state6.get(receiver);
}
function __classPrivateFieldSet(receiver, state6, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state6 === "function" ? receiver !== state6 || !f : !state6.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state6.set(receiver, value), value;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== undefined ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}\$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}\$`);
}
function isValidIP(ip, version13) {
  if ((version13 === "v4" || !version13) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version13 === "v6" || !version13) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step10) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step10.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step10.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util64.objectKeys(b);
    const sharedKeys = util64.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p4 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p4.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p22 = typeof p4 === "string" ? { message: p4 } : p4;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var util64;
(function(util65) {
  util65.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util65.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util65.assertNever = assertNever;
  util65.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util65.getValidEnumValues = (obj) => {
    const validKeys = util65.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util65.objectValues(filtered);
  };
  util65.objectValues = (obj) => {
    return util65.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util65.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util65.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util65.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util65.joinValues = joinValues;
  util65.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util64 || (util64 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util64.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util64.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json20 = JSON.stringify(obj, null, 2);
  return json20.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub36) => {
      this.issues = [...this.issues, sub36];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util64.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub36 of this.issues) {
      if (sub36.path.length > 0) {
        fieldErrors[sub36.path[0]] = fieldErrors[sub36.path[0]] || [];
        fieldErrors[sub36.path[0]].push(mapper(sub36));
      } else {
        formErrors.push(mapper(sub36));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util64.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util64.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util64.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util64.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util64.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util64.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input2) {
    return getParsedType(input2.data);
  }
  _getOrReturnCtx(input2, ctx) {
    return ctx || {
      common: input2.parent.common,
      data: input2.data,
      parsedType: getParsedType(input2.data),
      schemaErrorMap: this._def.errorMap,
      path: input2.path,
      parent: input2.parent
    };
  }
  _processInputParams(input2) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input2.parent.common,
        data: input2.data,
        parsedType: getParsedType(input2.data),
        schemaErrorMap: this._def.errorMap,
        path: input2.path,
        parent: input2.parent
      }
    };
  }
  _parseSync(input2) {
    const result = this._parse(input2);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input2) {
    const result = this._parse(input2);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform6) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform6 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}\$`);

class ZodString extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = String(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input2.data.length < check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input2.data.length > check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input2.data.length > check.value;
        const tooSmall = input2.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input2.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input2.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input2.data = input2.data.trim();
      } else if (check.kind === "includes") {
        if (!input2.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input2.data = input2.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input2.data = input2.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input2.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input2.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input2.data, check.version)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util64.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      local: (_b = options === null || options === undefined ? undefined : options.local) !== null && _b !== undefined ? _b : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min9 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min9 === null || ch.value > min9)
          min9 = ch.value;
      }
    }
    return min9;
  }
  get maxLength() {
    let max11 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max11 === null || ch.value < max11)
          max11 = ch.value;
      }
    }
    return max11;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = Number(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util64.isInteger(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input2.data < check.value : input2.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input2.data > check.value : input2.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input2.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input2.data)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util64.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min9 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min9 === null || ch.value > min9)
          min9 = ch.value;
      }
    }
    return min9;
  }
  get maxValue() {
    let max11 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max11 === null || ch.value < max11)
          max11 = ch.value;
      }
    }
    return max11;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util64.isInteger(ch.value));
  }
  get isFinite() {
    let max11 = null, min9 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min9 === null || ch.value > min9)
          min9 = ch.value;
      } else if (ch.kind === "max") {
        if (max11 === null || ch.value < max11)
          max11 = ch.value;
      }
    }
    return Number.isFinite(min9) && Number.isFinite(max11);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = BigInt(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input2.data < check.value : input2.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input2.data > check.value : input2.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input2.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util64.assertNever(check);
      }
    }
    return { status: status.value, value: input2.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min9 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min9 === null || ch.value > min9)
          min9 = ch.value;
      }
    }
    return min9;
  }
  get maxValue() {
    let max11 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max11 === null || ch.value < max11)
          max11 = ch.value;
      }
    }
    return max11;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = Boolean(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input2) {
    if (this._def.coerce) {
      input2.data = new Date(input2.data);
    }
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input2.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input2.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input2.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input2, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util64.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input2.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min9 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min9 === null || ch.value > min9)
          min9 = ch.value;
      }
    }
    return min9 != null ? new Date(min9) : null;
  }
  get maxDate() {
    let max11 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max11 === null || ch.value < max11)
          max11 = ch.value;
      }
    }
    return max11 != null ? new Date(max11) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input2) {
    return OK(input2.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input2) {
    return OK(input2.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input2) {
    const ctx = this._getOrReturnCtx(input2);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input2.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input2) {
    const { ctx, status } = this._processInputParams(input2);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util64.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input2);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input2);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d2;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== undefined ? _d2 : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util64.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util64.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util64.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util64.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util64.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types6, params) => {
  return new ZodUnion({
    options: types6,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util64.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input2) {
    if (input2.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input2.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, undefined);
  }
  _parse(input2) {
    if (typeof input2.data !== "string") {
      const ctx = this._getOrReturnCtx(input2);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util64.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input2.data)) {
      const ctx = this._getOrReturnCtx(input2);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input2.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = new WeakMap;
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, undefined);
  }
  _parse(input2) {
    const nativeEnumValues = util64.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input2);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util64.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util64.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util64.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input2.data)) {
      const expectedValues = util64.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input2.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = new WeakMap;
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base6 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base6))
          return base6;
        const result = effect.transform(base6.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base6) => {
          if (!isValid(base6))
            return base6;
          return Promise.resolve(effect.transform(base6.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util64.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input2);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input2);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input2) {
    const parsedType = this._getType(input2);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input2);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input2.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input2) {
    const { ctx } = this._processInputParams(input2);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input2) {
    const { status, ctx } = this._processInputParams(input2);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input2) {
    const result = this._def.innerType._parse(input2);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util64;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/engine/schemata.ts
var checkEven = (value) => value % 2 === 0;
var evenMsg = (value) => ({ message: `${value} is not an even number` });
var synthFs = 96000;
var kanas = [
  "\u3001",
  "\u304D\u3083",
  "\u304D\u3085",
  "\u304D\u3047",
  "\u304D\u3087",
  "\u304E\u3083",
  "\u304E\u3085",
  "\u304E\u3047",
  "\u304E\u3087",
  "\u304F\u308E",
  "\u3050\u308E",
  "\u3057\u3083",
  "\u3057",
  "\u3057\u3085",
  "\u3057\u3047",
  "\u3057\u3087",
  "\u3061\u3083",
  "\u3061",
  "\u3061\u3085",
  "\u3061\u3047",
  "\u3061\u3087",
  "\u3064\u3041",
  "\u3064\u3043",
  "\u3064",
  "\u3064\u3047",
  "\u3064\u3049",
  "\u3066\u3083",
  "\u3066\u3085",
  "\u3066\u3087",
  "\u3067\u3083",
  "\u3067\u3085",
  "\u3067\u3087",
  "\u306B\u3083",
  "\u306B\u3085",
  "\u306B\u3047",
  "\u306B\u3087",
  "\u3072\u3083",
  "\u3072\u3085",
  "\u3072\u3047",
  "\u3072\u3087",
  "\u3073\u3083",
  "\u3073\u3085",
  "\u3073\u3047",
  "\u3073\u3087",
  "\u3074\u3083",
  "\u3074\u3085",
  "\u3074\u3047",
  "\u3074\u3087",
  "\u307F\u3083",
  "\u307F\u3085",
  "\u307F\u3047",
  "\u307F\u3087",
  "\u308A\u3083",
  "\u308A\u3085",
  "\u308A\u3047",
  "\u308A\u3087",
  "\u3063",
  "\u3044\u3047",
  "\u304B",
  "\u304D",
  "\u304F",
  "\u3051",
  "\u3053",
  "\u3055",
  "\u3059\u3043",
  "\u3059",
  "\u305B",
  "\u305D",
  "\u305F",
  "\u3066\u3043",
  "\u3068\u3045",
  "\u3066",
  "\u3068",
  "\u306A",
  "\u306B",
  "\u306C",
  "\u306D",
  "\u306E",
  "\u306F",
  "\u3072",
  "\u3078",
  "\u307B",
  "\u307E",
  "\u307F",
  "\u3080",
  "\u3081",
  "\u3082",
  "\u3084",
  "\u3086",
  "\u3088",
  "\u3089",
  "\u308A",
  "\u308B",
  "\u308C",
  "\u308D",
  "\u308F",
  "\u3046\u3043",
  "\u3046\u3047",
  "\u3046\u3049",
  "\u3075\u3041",
  "\u3075\u3043",
  "\u3075",
  "\u3075\u3047",
  "\u3075\u3049",
  "\u3094\u3041",
  "\u3094\u3043",
  "\u3094",
  "\u3094\u3047",
  "\u3094\u3049",
  "\u304C",
  "\u304E",
  "\u3050",
  "\u3052",
  "\u3054",
  "\u3056",
  "\u305A\u3043",
  "\u305A",
  "\u305C",
  "\u305E",
  "\u3058\u3083",
  "\u3058",
  "\u3058\u3085",
  "\u3058\u3047",
  "\u3058\u3087",
  "\u3060",
  "\u3067\u3043",
  "\u3069\u3045",
  "\u3067",
  "\u3069",
  "\u3070",
  "\u3073",
  "\u3076",
  "\u3079",
  "\u307C",
  "\u3071",
  "\u3074",
  "\u3077",
  "\u307A",
  "\u307D",
  "\u3042",
  "\u3044",
  "\u3046",
  "\u3048",
  "\u304A",
  "\u3093"
];
var envKeys = [
  "a",
  "i",
  "u",
  "e",
  "o",
  "k",
  "s",
  "t",
  "n",
  "h",
  "m",
  "y",
  "r",
  "w",
  "g",
  "z",
  "d",
  "b",
  "p",
  "v",
  "q"
];
var envKeyVolumes = {
  a: 1,
  i: 1,
  u: 1,
  e: 1,
  o: 1,
  k: 0.8,
  s: 0.8,
  t: 0.8,
  n: 0.8,
  h: 0.8,
  m: 0.8,
  y: 0.8,
  r: 0.8,
  w: 0.8,
  g: 0.8,
  z: 0.8,
  d: 0.8,
  b: 0.8,
  p: 0.8,
  v: 0.8,
  q: 0
};
var speakerIds = [
  "laychie",
  "layney"
];
var kanaEnumSchema = z.enum(kanas);
var envKeyEnumSchema = z.enum(envKeys);
var speakerIdEnumSchema = z.enum(speakerIds);
var pointXSchema = z.number().min(0).max(48000);
var pointYSchema = z.number().min(0).max(1);
var pointSchema = z.tuple([pointXSchema, pointYSchema]);
var pointsSchema = z.array(pointSchema);
var envRecordSchema = z.record(envKeyEnumSchema, pointsSchema);
var envLenSchema = z.object({ envKey: envKeyEnumSchema, len: z.number().min(0).nullable() });
var kanaRecordSchema = z.record(kanaEnumSchema, z.array(envLenSchema));
var bpmSchema = z.number().min(1);
var noteSchema = z.object({
  lyric: z.enum([...kanas, ...envKeys]),
  pitch: z.number().int().min(0).max(127),
  begin: z.number().int().min(0),
  end: z.number().int().min(0),
  f0Seg: z.number().min(0.1).max(10).array(),
  volumeSeg: z.number().min(0).max(1).array(),
  phonemeTimings: z.number().array()
});
var speakerVoiceSchema = z.object({
  id: speakerIdEnumSchema,
  name: z.string(),
  fs: z.literal(48000),
  segLen: z.number().int().min(120).refine(checkEven, evenMsg),
  shiftLen: z.number().int().min(1),
  shiftNum: z.number().int().min(0),
  envelopes: envRecordSchema,
  kanas: kanaRecordSchema
});
{
  const _ = true;
}
{
  const _ = true;
}
{
  const _ = true;
}
{
  const _ = true;
}
{
  const _ = true;
}
{
  const _ = true;
}

// src/engine/utils.ts
var exports_utils = {};
__export(exports_utils, {
  tick2sec: () => tick2sec,
  sum: () => sum30,
  seq2seg: () => seq2seg,
  seg2seq: () => seg2seq,
  sec2tick: () => sec2tick,
  rfftfreq: () => rfftfreq,
  resample: () => resample,
  raw2wav: () => raw2wav,
  pitch2freq: () => pitch2freq,
  linspace: () => linspace2,
  interp: () => interp,
  int: () => int5,
  freq2pitch: () => freq2pitch,
  computeSeq2segLen: () => computeSeq2segLen,
  computeSeg2seqLen: () => computeSeg2seqLen,
  checkPositiveInt: () => checkPositiveInt,
  checkNonNegativeInt: () => checkNonNegativeInt,
  canUseWebGPU: () => canUseWebGPU,
  avg: () => avg,
  argMin: () => argMin5,
  argMax: () => argMax5
});
init_dist7();
function checkPositiveInt(value) {
  z.number().int().positive().parse(value);
}
function checkNonNegativeInt(value) {
  z.number().int().nonnegative().parse(value);
}
function int5(value) {
  return Math.floor(value);
}
function seq2seg(sequence, segLen, hopLen) {
  checkPositiveInt(segLen);
  checkPositiveInt(hopLen);
  const sequenceLen = sequence.shape[0];
  const segmentsLen = computeSeq2segLen(sequenceLen, segLen, hopLen);
  const segments = [];
  for (let i = 0;i < segmentsLen; i++) {
    const begin = hopLen * i;
    const end = begin + segLen;
    let segment = sequence.slice(begin >= 0 ? begin : 0, end <= sequenceLen ? segLen : sequenceLen - begin);
    const segmentLen = segment.shape[0];
    if (segmentLen < segLen) {
      const padding2 = zeros([segLen - segmentLen, ...sequence.shape.slice(1)]);
      segment = segment.concat(padding2);
      padding2.dispose();
    }
    segments.push(segment);
  }
  const concatenated = tidy(() => {
    const concatenated2 = concat(segments).reshape([segmentsLen, segLen]);
    dispose(segments);
    return concatenated2;
  });
  return concatenated;
}
function seg2seq(segments, segLen, hopLen) {
  checkPositiveInt(segLen);
  checkPositiveInt(hopLen);
  const segmentsLen = segments.shape[0];
  const sequenceLen = computeSeg2seqLen(segmentsLen, segLen, hopLen);
  let sequence = zeros([sequenceLen, ...segments.shape.slice(2)]);
  for (let i = 0;i < segmentsLen; i++) {
    const begin = hopLen * i;
    const end = begin + segLen;
    const segment = segments.slice(i, 1).reshape([-1, ...segments.shape.slice(2)]);
    const paddingBefore = zeros([begin, ...segment.shape.slice(1)]);
    const paddingAfter = zeros([sequenceLen - end, ...segment.shape.slice(1)]);
    sequence = tidy(() => {
      const merged = add2(sequence, concat([paddingBefore, segment, paddingAfter]));
      sequence.dispose();
      segment.dispose();
      paddingBefore.dispose();
      paddingAfter.dispose();
      return merged;
    });
  }
  return sequence;
}
function computeSeq2segLen(sequenceLen, segLen, hopLen) {
  checkPositiveInt(sequenceLen);
  checkPositiveInt(segLen);
  checkPositiveInt(hopLen);
  if (sequenceLen >= segLen && hopLen > 0) {
    return Math.ceil(sequenceLen / hopLen - segLen / hopLen + 1);
  } else {
    return 1;
  }
}
function computeSeg2seqLen(segmentsLen, segLen, hopLen) {
  checkPositiveInt(segmentsLen);
  checkPositiveInt(segLen);
  checkPositiveInt(hopLen);
  return hopLen * (segmentsLen - 1) + segLen;
}
function raw2wav(raw, fs, channels, dtype) {
  checkPositiveInt(fs);
  checkPositiveInt(channels);
  const length = raw.byteLength;
  const fileSize = 36 + length;
  const fmtChunkBytes = 16;
  const formatCode = dtype === Float32Array ? 3 : 1;
  const bytesPerElement2 = dtype.BYTES_PER_ELEMENT;
  const dataRate = fs * bytesPerElement2 * channels;
  const blockSize = bytesPerElement2 * channels;
  const bitDepth = 8 * bytesPerElement2;
  const headerSize = 44;
  const header = new ArrayBuffer(headerSize);
  const view = new DataView(header);
  const writeStringToView = (offset, string2, view2) => {
    [...string2].forEach((char, index) => {
      view2.setUint8(offset + index, char.charCodeAt(0));
    });
  };
  writeStringToView(0, "RIFF", view);
  view.setUint32(4, fileSize, true);
  writeStringToView(8, "WAVE", view);
  writeStringToView(12, "fmt ", view);
  view.setUint32(16, fmtChunkBytes, true);
  view.setUint16(20, formatCode, true);
  view.setUint16(22, channels, true);
  view.setUint32(24, fs, true);
  view.setUint32(28, dataRate, true);
  view.setUint16(32, blockSize, true);
  view.setUint16(34, bitDepth, true);
  writeStringToView(36, "data", view);
  view.setUint32(40, length, true);
  const headerDtyped = new dtype(header);
  const wav = new dtype(headerDtyped.length + raw.length);
  wav.set(headerDtyped, 0);
  wav.set(raw, headerDtyped.length);
  return wav;
}
function rfftfreq(n, d) {
  const N4 = Math.floor(n / 2) + 1;
  return [...new Array(N4)].map((_, i) => i / (n * d));
}
function linspace2(begin, end, num) {
  checkPositiveInt(num);
  if (num === 1) {
    return [(begin + end) / 2];
  }
  const linspace3 = [...new Array(num)].map((_, index) => {
    return begin + (end - begin) * (index / (num - 1));
  });
  return linspace3;
}
function interp(x, y, z2) {
  if (x.length !== y.length) {
    throw new Error('number of elements in "x" and "y" do not match');
  }
  const length = x.length;
  const lastIndex = length - 1;
  const num = z2.length;
  const interpolated = [...new Array(num)].fill(0);
  for (let i = 0;i < num; i++) {
    let x02 = null;
    let y0 = null;
    let x1 = null;
    let y1 = null;
    for (let j = 0;j < length; j++) {
      if (z2[i] >= x[j] && j < lastIndex && z2[i] < x[j + 1]) {
        x02 = x[j];
        y0 = y[j];
        x1 = x[j + 1];
        y1 = y[j + 1];
        break;
      }
      if (j === lastIndex && z2[i] === x[j]) {
        interpolated[i] = y[j];
        break;
      }
    }
    if (x02 !== null && y0 !== null && x1 !== null && y1 !== null) {
      interpolated[i] = y0 + (y1 - y0) * (z2[i] - x02) / (x1 - x02);
    }
  }
  return interpolated;
}
function resample(data, num) {
  checkNonNegativeInt(num);
  if (num === 0) {
    return [];
  }
  if (data.length === 1) {
    return [...new Array(num)].map(() => data[0]);
  }
  const x = linspace2(0, 1, data.length);
  const y = data;
  const z2 = linspace2(0, 1, num);
  return interp(x, y, z2);
}
function sum30(x) {
  return x.reduce((sum31, y) => sum31 + y, 0);
}
function avg(x) {
  return sum30(x) / x.length;
}
function argMax5(x) {
  return x.map((value, index) => {
    return { value, index };
  }).reduce((min9, element) => element.value > min9.value ? element : min9).index;
}
function argMin5(x) {
  return x.map((value, index) => {
    return { value, index };
  }).reduce((max11, element) => element.value < max11.value ? element : max11).index;
}
function tick2sec(tick, bpm) {
  return 60 * 1000 / bpm * (tick / 480) / 1000;
}
function sec2tick(sec, bpm) {
  return 1000 * sec * 480 / (60 * 1000 / bpm);
}
function pitch2freq(pitch) {
  return 2 ** ((pitch - 69) / 12) * 440;
}
function freq2pitch(freq) {
  return 69 + 12 * Math.log2(freq / 440);
}
var canUseWebGPU = "gpu" in navigator;

// src/engine/speakers/laychie.ts
var fs = 48000;
var laychieVoice = {
  id: "laychie",
  name: "\u30EC\u30A4\u30C1\u30FC",
  fs,
  segLen: int5(fs * 0.01),
  shiftLen: 10,
  shiftNum: 1,
  envelopes: {
    a: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.62], [800, 0.75], [1200, 1], [1600, 0.88], [2000, 0.31], [2400, 0.08], [2800, 0.03], [3200, 0.03], [3600, 0.08], [4000, 0.24], [5100, 0.3], [6400, 0.27], [8000, 0.1], [10600, 0.05], [12000, 0]],
    i: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.13], [1200, 0.06], [2000, 0.06], [2800, 0.13], [3700, 0.27], [4600, 0.75], [5900, 0.26], [7000, 0.15], [8500, 0.07], [9300, 0.07], [10600, 0.1], [11700, 0.05], [12000, 0]],
    u: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.5], [1200, 0.19], [1600, 0.19], [2000, 0.63], [2400, 0.18], [2800, 0.09], [3200, 0.05], [3600, 0.05], [4000, 0.09], [4600, 0.25], [5500, 0.75], [6800, 0.25], [7600, 0.15], [9300, 0.06], [10500, 0.1], [11700, 0.06], [12000, 0]],
    e: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.62], [800, 1], [1200, 0.32], [1600, 0.12], [2000, 0.06], [2400, 0.06], [2800, 0.12], [3500, 0.33], [4100, 0.75], [5000, 0.32], [5800, 0.18], [7900, 0.11], [10700, 0.07], [12000, 0]],
    o: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.94], [800, 1], [1200, 0.88], [1600, 0.38], [2000, 0.19], [2400, 0.08], [3000, 0.04], [3600, 0.08], [4000, 0.25], [5200, 0.29], [6700, 0.25], [7600, 0.1], [9000, 0.06], [10500, 0.1], [11700, 0.05], [12000, 0]],
    k: [[0, 0], [800, 0.18], [1600, 0.25], [2000, 0.44], [2400, 1], [2800, 0.37], [3200, 0.16], [3600, 0.08], [4300, 0.06], [5200, 0.09], [5800, 0.28], [6400, 0.36], [7000, 0.28], [7300, 0.13], [7800, 0.4], [8400, 0.5], [9100, 0.39], [1e4, 0.1], [10800, 0.04], [12000, 0]],
    s: [[0, 0], [400, 0.06], [2800, 0.14], [4900, 0.31], [6000, 0.48], [7100, 0.76], [8400, 1], [9300, 0.76], [9900, 0.37], [10900, 0.13], [12000, 0]],
    t: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.56], [800, 0.62], [1200, 1], [1600, 0.33], [2000, 0.18], [3800, 0.08], [6200, 0.2], [7400, 0.76], [9700, 0.93], [11300, 0.23], [12000, 0]],
    n: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.25], [1200, 0.16], [1600, 0.1], [3000, 0.04], [12000, 0]],
    h: [[0, 0], [800, 0.18], [1200, 0.69], [1600, 0.9], [2800, 1], [4400, 0.9], [5600, 0.69], [7500, 0.25], [9300, 0.07], [12000, 0]],
    m: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.25], [1200, 0.5], [1600, 0.09], [3200, 0.04], [12000, 0]],
    y: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.53], [1200, 0.34], [2000, 0.09], [2800, 0.24], [3200, 0.48], [4400, 0.45], [5600, 0.25], [6400, 0.05], [12000, 0]],
    r: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [1200, 0.62], [1600, 0.12], [2000, 0.12], [2400, 0.32], [2800, 0.13], [3600, 0.06], [4000, 0.13], [4400, 0.29], [7100, 0.08], [8300, 0.12], [12000, 0]],
    w: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.5], [1200, 0.75], [1600, 0.25], [2000, 0.5], [2800, 0.12], [3600, 0.38], [5200, 0.06], [6800, 0.25], [8900, 0], [10300, 0.14], [12000, 0]],
    g: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.62], [1200, 0.56], [2000, 0.62], [2400, 1], [2800, 0.37], [3200, 0.16], [3600, 0.08], [4300, 0.06], [5200, 0.09], [5800, 0.28], [6400, 0.36], [7000, 0.28], [7300, 0.13], [7800, 0.4], [8400, 0.5], [9100, 0.39], [1e4, 0.1], [10800, 0.04], [12000, 0]],
    z: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.75], [800, 0.06], [2000, 0.1], [2800, 0.25], [3600, 0.12], [5900, 0.24], [7500, 0.56], [9000, 1], [10500, 0.35], [12000, 0]],
    d: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.25], [1600, 0.06], [5200, 0.06], [6300, 0.13], [8300, 1], [10300, 0.3], [12000, 0]],
    b: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [1600, 0.38], [2400, 0.25], [3600, 0.21], [4800, 0.21], [7000, 0.31], [7800, 0.63], [8600, 0.31], [12000, 0]],
    p: [[0, 0], [2000, 0.06], [2400, 1], [2800, 0.06], [12000, 0]],
    v: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.5], [1600, 0.31], [2000, 0.31], [2400, 0.75], [3200, 0.25], [3600, 0.21], [4800, 0.21], [7000, 0.31], [8600, 0.31], [12000, 0]],
    q: [[0, 0], [12000, 0]]
  },
  kanas: {
    "\u3042": [
      { envKey: "a", len: null }
    ],
    "\u3044": [
      { envKey: "i", len: null }
    ],
    "\u3046": [
      { envKey: "u", len: null }
    ],
    "\u3048": [
      { envKey: "e", len: null }
    ],
    "\u304A": [
      { envKey: "o", len: null }
    ],
    "\u304B": [
      { envKey: "k", len: 0.015 },
      { envKey: "a", len: null }
    ],
    "\u304D": [
      { envKey: "k", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u304F": [
      { envKey: "k", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3051": [
      { envKey: "k", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u3053": [
      { envKey: "k", len: 0.015 },
      { envKey: "o", len: null }
    ],
    "\u3055": [
      { envKey: "s", len: 0.04 },
      { envKey: "a", len: null }
    ],
    "\u3057": [
      { envKey: "s", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u3059": [
      { envKey: "s", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u305B": [
      { envKey: "s", len: 0.04 },
      { envKey: "e", len: null }
    ],
    "\u305D": [
      { envKey: "s", len: 0.04 },
      { envKey: "o", len: null }
    ],
    "\u305F": [
      { envKey: "t", len: 0.01 },
      { envKey: "a", len: null }
    ],
    "\u3061": [
      { envKey: "t", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u3064": [
      { envKey: "t", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u3066": [
      { envKey: "t", len: 0.01 },
      { envKey: "e", len: null }
    ],
    "\u3068": [
      { envKey: "t", len: 0.01 },
      { envKey: "o", len: null }
    ],
    "\u306A": [
      { envKey: "n", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u306B": [
      { envKey: "n", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u306C": [
      { envKey: "n", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u306D": [
      { envKey: "n", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u306E": [
      { envKey: "n", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u306F": [
      { envKey: "h", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u3072": [
      { envKey: "h", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3075": [
      { envKey: "h", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3078": [
      { envKey: "h", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u307B": [
      { envKey: "h", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u307E": [
      { envKey: "m", len: 0.015 },
      { envKey: "a", len: null }
    ],
    "\u307F": [
      { envKey: "m", len: 0.015 },
      { envKey: "i", len: null }
    ],
    "\u3080": [
      { envKey: "m", len: 0.01 },
      { envKey: "u", len: null }
    ],
    "\u3081": [
      { envKey: "m", len: 0.03 },
      { envKey: "e", len: null }
    ],
    "\u3082": [
      { envKey: "m", len: 0.03 },
      { envKey: "o", len: null }
    ],
    "\u3084": [
      { envKey: "y", len: 0.03 },
      { envKey: "a", len: null }
    ],
    "\u3086": [
      { envKey: "y", len: 0.03 },
      { envKey: "u", len: null }
    ],
    "\u3088": [
      { envKey: "y", len: 0.03 },
      { envKey: "o", len: null }
    ],
    "\u3089": [
      { envKey: "r", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u308A": [
      { envKey: "r", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u308B": [
      { envKey: "r", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u308C": [
      { envKey: "r", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u308D": [
      { envKey: "r", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u308F": [
      { envKey: "w", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u3046\u3043": [
      { envKey: "w", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3046\u3047": [
      { envKey: "w", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u3046\u3049": [
      { envKey: "w", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u3093": [
      { envKey: "n", len: null }
    ],
    "\u304C": [
      { envKey: "g", len: 0.015 },
      { envKey: "a", len: null }
    ],
    "\u304E": [
      { envKey: "g", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3050": [
      { envKey: "g", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3052": [
      { envKey: "g", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u3054": [
      { envKey: "g", len: 0.015 },
      { envKey: "o", len: null }
    ],
    "\u3056": [
      { envKey: "z", len: 0.04 },
      { envKey: "a", len: null }
    ],
    "\u3058": [
      { envKey: "z", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u305A": [
      { envKey: "z", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u305C": [
      { envKey: "z", len: 0.04 },
      { envKey: "e", len: null }
    ],
    "\u305E": [
      { envKey: "z", len: 0.04 },
      { envKey: "o", len: null }
    ],
    "\u3060": [
      { envKey: "d", len: 0.01 },
      { envKey: "a", len: null }
    ],
    "\u3067\u3043": [
      { envKey: "d", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u3069\u3045": [
      { envKey: "d", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u3067": [
      { envKey: "d", len: 0.01 },
      { envKey: "e", len: null }
    ],
    "\u3069": [
      { envKey: "d", len: 0.01 },
      { envKey: "o", len: null }
    ],
    "\u3070": [
      { envKey: "b", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u3073": [
      { envKey: "b", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3076": [
      { envKey: "b", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3079": [
      { envKey: "b", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u307C": [
      { envKey: "b", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u3071": [
      { envKey: "p", len: 0.005 },
      { envKey: "a", len: null }
    ],
    "\u3074": [
      { envKey: "p", len: 0.005 },
      { envKey: "i", len: null }
    ],
    "\u3077": [
      { envKey: "p", len: 0.005 },
      { envKey: "u", len: null }
    ],
    "\u307A": [
      { envKey: "p", len: 0.005 },
      { envKey: "e", len: null }
    ],
    "\u307D": [
      { envKey: "p", len: 0.005 },
      { envKey: "o", len: null }
    ],
    "\u3094\u3041": [
      { envKey: "v", len: 0.03 },
      { envKey: "a", len: null }
    ],
    "\u3094\u3043": [
      { envKey: "v", len: 0.03 },
      { envKey: "i", len: null }
    ],
    "\u3094": [
      { envKey: "v", len: 0.03 },
      { envKey: "u", len: null }
    ],
    "\u3094\u3047": [
      { envKey: "v", len: 0.03 },
      { envKey: "e", len: null }
    ],
    "\u3094\u3049": [
      { envKey: "v", len: 0.03 },
      { envKey: "o", len: null }
    ],
    "\u304D\u3083": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u304D\u3085": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u304D\u3047": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u304D\u3087": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3057\u3083": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3059\u3043": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3057\u3085": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3057\u3047": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3057\u3087": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3061\u3083": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3061\u3085": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3061\u3047": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3061\u3087": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3064\u3041": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3064\u3043": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3068\u3045": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3064\u3047": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3064\u3049": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3066\u3083": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "a", len: null }
    ],
    "\u3066\u3043": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "i", len: null }
    ],
    "\u3066\u3085": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "u", len: null }
    ],
    "\u3066\u3087": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "o", len: null }
    ],
    "\u306B\u3083": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u306B\u3085": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u306B\u3047": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u306B\u3087": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3072\u3083": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3072\u3085": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3072\u3047": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3072\u3087": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u307F\u3083": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u307F\u3085": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u307F\u3047": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u307F\u3087": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u308A\u3083": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u308A\u3085": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u308A\u3047": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u308A\u3087": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u304E\u3083": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u304E\u3085": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u304E\u3047": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u304E\u3087": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3058\u3083": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u305A\u3043": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3058\u3085": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3058\u3047": [
      { envKey: "z", len: 0.03 },
      { envKey: "i", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3058\u3087": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3067\u3083": [
      { envKey: "d", len: 0.025 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3067\u3085": [
      { envKey: "d", len: 0.025 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3067\u3087": [
      { envKey: "d", len: 0.025 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3073\u3083": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3073\u3085": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3073\u3047": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3073\u3087": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3074\u3083": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3074\u3085": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3074\u3047": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3074\u3087": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3075\u3041": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3075\u3043": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3075\u3047": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3075\u3049": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3044\u3047": [
      { envKey: "i", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u304F\u308E": [
      { envKey: "k", len: 0.03 },
      { envKey: "w", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3050\u308E": [
      { envKey: "g", len: 0.03 },
      { envKey: "w", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3063": [
      { envKey: "q", len: null }
    ],
    "\u3001": [
      { envKey: "q", len: null }
    ]
  }
};

// src/engine/speakers/layney.ts
var fs2 = 48000;
var layneyVoice = {
  id: "layney",
  name: "\u30EC\u30A4\u30CB\u30FC",
  fs: fs2,
  segLen: int5(fs2 * 0.01),
  shiftLen: 10,
  shiftNum: 1,
  envelopes: {
    a: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.59], [800, 0.7], [1200, 1], [1600, 0.97], [2000, 0.9], [2400, 0.12], [2800, 0.06], [3800, 0.06], [4500, 0.12], [5200, 0.5], [6000, 0.12], [7000, 0.06], [12000, 0]],
    i: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.17], [1200, 0.06], [1600, 0.03], [2400, 0.03], [3800, 0.06], [4500, 0.12], [5200, 0.5], [6000, 0.12], [7000, 0.06], [12000, 0]],
    u: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [1200, 0.24], [1600, 0.31], [2000, 0.43], [2400, 0.11], [2800, 0.05], [3800, 0.05], [4500, 0.12], [5200, 0.5], [6000, 0.12], [7000, 0.06], [12000, 0]],
    e: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.69], [800, 1], [1200, 0.06], [3800, 0.06], [4500, 0.12], [5200, 0.5], [6000, 0.12], [7000, 0.06], [12000, 0]],
    o: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.75], [800, 1], [1200, 0.93], [1600, 0.38], [2000, 0.12], [2400, 0.06], [3800, 0.06], [4500, 0.12], [5200, 0.5], [6000, 0.12], [7000, 0.06], [12000, 0]],
    k: [[0, 0], [800, 0.18], [1600, 0.25], [2000, 0.44], [2400, 1], [2800, 0.37], [3200, 0.16], [3600, 0.08], [4300, 0.06], [5200, 0.09], [5800, 0.28], [6400, 0.36], [7000, 0.28], [7300, 0.13], [7800, 0.4], [8400, 0.5], [9100, 0.39], [1e4, 0.1], [10800, 0.04], [12000, 0]],
    s: [[0, 0], [400, 0.06], [2800, 0.14], [4900, 0.31], [6000, 0.48], [7100, 0.76], [8400, 1], [9300, 0.76], [9900, 0.37], [10900, 0.13], [12000, 0]],
    t: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.56], [800, 0.62], [1200, 1], [1600, 0.33], [2000, 0.18], [3800, 0.08], [6200, 0.2], [7400, 0.76], [9700, 0.93], [11300, 0.23], [12000, 0]],
    n: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.25], [1200, 0.16], [1600, 0.1], [3000, 0.04], [12000, 0]],
    h: [[0, 0], [800, 0.18], [1200, 0.69], [1600, 0.9], [2800, 1], [4400, 0.9], [5600, 0.69], [7500, 0.25], [9300, 0.07], [12000, 0]],
    m: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.25], [1200, 0.5], [1600, 0.09], [3200, 0.04], [12000, 0]],
    y: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.53], [1200, 0.34], [2000, 0.09], [2800, 0.24], [3200, 0.48], [4400, 0.45], [5600, 0.25], [6400, 0.05], [12000, 0]],
    r: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [1200, 0.62], [1600, 0.12], [2000, 0.12], [2400, 0.32], [2800, 0.13], [3600, 0.06], [4000, 0.13], [4400, 0.29], [7100, 0.08], [8300, 0.12], [12000, 0]],
    w: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.5], [1200, 0.75], [1600, 0.25], [2000, 0.5], [2800, 0.12], [3600, 0.38], [5200, 0.06], [6800, 0.25], [8900, 0], [10300, 0.14], [12000, 0]],
    g: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.62], [1200, 0.56], [2000, 0.62], [2400, 1], [2800, 0.37], [3200, 0.16], [3600, 0.08], [4300, 0.06], [5200, 0.09], [5800, 0.28], [6400, 0.36], [7000, 0.28], [7300, 0.13], [7800, 0.4], [8400, 0.5], [9100, 0.39], [1e4, 0.1], [10800, 0.04], [12000, 0]],
    z: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 0.75], [800, 0.06], [2000, 0.1], [2800, 0.25], [3600, 0.12], [5900, 0.24], [7500, 0.56], [9000, 1], [10500, 0.35], [12000, 0]],
    d: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.25], [1600, 0.06], [5200, 0.06], [6300, 0.13], [8300, 1], [10300, 0.3], [12000, 0]],
    b: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [1600, 0.38], [2400, 0.25], [3600, 0.21], [4800, 0.21], [7000, 0.31], [7800, 0.63], [8600, 0.31], [12000, 0]],
    p: [[0, 0], [2000, 0.06], [2400, 1], [2800, 0.06], [12000, 0]],
    v: [[0, 0], [1, 0.1], [100, 0.1], [300, 0.25], [400, 1], [800, 0.5], [1600, 0.31], [2000, 0.31], [2400, 0.75], [3200, 0.25], [3600, 0.21], [4800, 0.21], [7000, 0.31], [8600, 0.31], [12000, 0]],
    q: [[0, 0], [12000, 0]]
  },
  kanas: {
    "\u3042": [
      { envKey: "a", len: null }
    ],
    "\u3044": [
      { envKey: "i", len: null }
    ],
    "\u3046": [
      { envKey: "u", len: null }
    ],
    "\u3048": [
      { envKey: "e", len: null }
    ],
    "\u304A": [
      { envKey: "o", len: null }
    ],
    "\u304B": [
      { envKey: "k", len: 0.015 },
      { envKey: "a", len: null }
    ],
    "\u304D": [
      { envKey: "k", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u304F": [
      { envKey: "k", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3051": [
      { envKey: "k", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u3053": [
      { envKey: "k", len: 0.015 },
      { envKey: "o", len: null }
    ],
    "\u3055": [
      { envKey: "s", len: 0.04 },
      { envKey: "a", len: null }
    ],
    "\u3057": [
      { envKey: "s", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u3059": [
      { envKey: "s", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u305B": [
      { envKey: "s", len: 0.04 },
      { envKey: "e", len: null }
    ],
    "\u305D": [
      { envKey: "s", len: 0.04 },
      { envKey: "o", len: null }
    ],
    "\u305F": [
      { envKey: "t", len: 0.01 },
      { envKey: "a", len: null }
    ],
    "\u3061": [
      { envKey: "t", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u3064": [
      { envKey: "t", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u3066": [
      { envKey: "t", len: 0.01 },
      { envKey: "e", len: null }
    ],
    "\u3068": [
      { envKey: "t", len: 0.01 },
      { envKey: "o", len: null }
    ],
    "\u306A": [
      { envKey: "n", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u306B": [
      { envKey: "n", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u306C": [
      { envKey: "n", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u306D": [
      { envKey: "n", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u306E": [
      { envKey: "n", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u306F": [
      { envKey: "h", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u3072": [
      { envKey: "h", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3075": [
      { envKey: "h", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3078": [
      { envKey: "h", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u307B": [
      { envKey: "h", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u307E": [
      { envKey: "m", len: 0.015 },
      { envKey: "a", len: null }
    ],
    "\u307F": [
      { envKey: "m", len: 0.015 },
      { envKey: "i", len: null }
    ],
    "\u3080": [
      { envKey: "m", len: 0.01 },
      { envKey: "u", len: null }
    ],
    "\u3081": [
      { envKey: "m", len: 0.03 },
      { envKey: "e", len: null }
    ],
    "\u3082": [
      { envKey: "m", len: 0.03 },
      { envKey: "o", len: null }
    ],
    "\u3084": [
      { envKey: "y", len: 0.03 },
      { envKey: "a", len: null }
    ],
    "\u3086": [
      { envKey: "y", len: 0.03 },
      { envKey: "u", len: null }
    ],
    "\u3088": [
      { envKey: "y", len: 0.03 },
      { envKey: "o", len: null }
    ],
    "\u3089": [
      { envKey: "r", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u308A": [
      { envKey: "r", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u308B": [
      { envKey: "r", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u308C": [
      { envKey: "r", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u308D": [
      { envKey: "r", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u308F": [
      { envKey: "w", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u3046\u3043": [
      { envKey: "w", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3046\u3047": [
      { envKey: "w", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u3046\u3049": [
      { envKey: "w", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u3093": [
      { envKey: "n", len: null }
    ],
    "\u304C": [
      { envKey: "g", len: 0.015 },
      { envKey: "a", len: null }
    ],
    "\u304E": [
      { envKey: "g", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3050": [
      { envKey: "g", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3052": [
      { envKey: "g", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u3054": [
      { envKey: "g", len: 0.015 },
      { envKey: "o", len: null }
    ],
    "\u3056": [
      { envKey: "z", len: 0.04 },
      { envKey: "a", len: null }
    ],
    "\u3058": [
      { envKey: "z", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u305A": [
      { envKey: "z", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u305C": [
      { envKey: "z", len: 0.04 },
      { envKey: "e", len: null }
    ],
    "\u305E": [
      { envKey: "z", len: 0.04 },
      { envKey: "o", len: null }
    ],
    "\u3060": [
      { envKey: "d", len: 0.01 },
      { envKey: "a", len: null }
    ],
    "\u3067\u3043": [
      { envKey: "d", len: 0.04 },
      { envKey: "i", len: null }
    ],
    "\u3069\u3045": [
      { envKey: "d", len: 0.04 },
      { envKey: "u", len: null }
    ],
    "\u3067": [
      { envKey: "d", len: 0.01 },
      { envKey: "e", len: null }
    ],
    "\u3069": [
      { envKey: "d", len: 0.01 },
      { envKey: "o", len: null }
    ],
    "\u3070": [
      { envKey: "b", len: 0.025 },
      { envKey: "a", len: null }
    ],
    "\u3073": [
      { envKey: "b", len: 0.025 },
      { envKey: "i", len: null }
    ],
    "\u3076": [
      { envKey: "b", len: 0.025 },
      { envKey: "u", len: null }
    ],
    "\u3079": [
      { envKey: "b", len: 0.025 },
      { envKey: "e", len: null }
    ],
    "\u307C": [
      { envKey: "b", len: 0.025 },
      { envKey: "o", len: null }
    ],
    "\u3071": [
      { envKey: "p", len: 0.005 },
      { envKey: "a", len: null }
    ],
    "\u3074": [
      { envKey: "p", len: 0.005 },
      { envKey: "i", len: null }
    ],
    "\u3077": [
      { envKey: "p", len: 0.005 },
      { envKey: "u", len: null }
    ],
    "\u307A": [
      { envKey: "p", len: 0.005 },
      { envKey: "e", len: null }
    ],
    "\u307D": [
      { envKey: "p", len: 0.005 },
      { envKey: "o", len: null }
    ],
    "\u3094\u3041": [
      { envKey: "v", len: 0.03 },
      { envKey: "a", len: null }
    ],
    "\u3094\u3043": [
      { envKey: "v", len: 0.03 },
      { envKey: "i", len: null }
    ],
    "\u3094": [
      { envKey: "v", len: 0.03 },
      { envKey: "u", len: null }
    ],
    "\u3094\u3047": [
      { envKey: "v", len: 0.03 },
      { envKey: "e", len: null }
    ],
    "\u3094\u3049": [
      { envKey: "v", len: 0.03 },
      { envKey: "o", len: null }
    ],
    "\u304D\u3083": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u304D\u3085": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u304D\u3047": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u304D\u3087": [
      { envKey: "k", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3057\u3083": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3059\u3043": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3057\u3085": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3057\u3047": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3057\u3087": [
      { envKey: "s", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3061\u3083": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3061\u3085": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3061\u3047": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3061\u3087": [
      { envKey: "t", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3064\u3041": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3064\u3043": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3068\u3045": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3064\u3047": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3064\u3049": [
      { envKey: "t", len: 0.03 },
      { envKey: "u", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3066\u3083": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "a", len: null }
    ],
    "\u3066\u3043": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "i", len: null }
    ],
    "\u3066\u3085": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "u", len: null }
    ],
    "\u3066\u3087": [
      { envKey: "t", len: 0.03 },
      { envKey: "e", len: 0.01 },
      { envKey: "y", len: 0.01 },
      { envKey: "o", len: null }
    ],
    "\u306B\u3083": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u306B\u3085": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u306B\u3047": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u306B\u3087": [
      { envKey: "n", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3072\u3083": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3072\u3085": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3072\u3047": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3072\u3087": [
      { envKey: "h", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u307F\u3083": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u307F\u3085": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u307F\u3047": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u307F\u3087": [
      { envKey: "m", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u308A\u3083": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u308A\u3085": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u308A\u3047": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u308A\u3087": [
      { envKey: "r", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u304E\u3083": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u304E\u3085": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u304E\u3047": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u304E\u3087": [
      { envKey: "g", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3058\u3083": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u305A\u3043": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3058\u3085": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3058\u3047": [
      { envKey: "z", len: 0.03 },
      { envKey: "i", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3058\u3087": [
      { envKey: "z", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3067\u3083": [
      { envKey: "d", len: 0.025 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3067\u3085": [
      { envKey: "d", len: 0.025 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3067\u3087": [
      { envKey: "d", len: 0.025 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3073\u3083": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3073\u3085": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3073\u3047": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3073\u3087": [
      { envKey: "b", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3074\u3083": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3074\u3085": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "u", len: null }
    ],
    "\u3074\u3047": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3074\u3087": [
      { envKey: "p", len: 0.015 },
      { envKey: "y", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3075\u3041": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3075\u3043": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "i", len: null }
    ],
    "\u3075\u3047": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u3075\u3049": [
      { envKey: "h", len: 0.015 },
      { envKey: "u", len: 0.02 },
      { envKey: "o", len: null }
    ],
    "\u3044\u3047": [
      { envKey: "i", len: 0.03 },
      { envKey: "y", len: 0.02 },
      { envKey: "e", len: null }
    ],
    "\u304F\u308E": [
      { envKey: "k", len: 0.03 },
      { envKey: "w", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3050\u308E": [
      { envKey: "g", len: 0.03 },
      { envKey: "w", len: 0.02 },
      { envKey: "a", len: null }
    ],
    "\u3063": [
      { envKey: "q", len: null }
    ],
    "\u3001": [
      { envKey: "q", len: null }
    ]
  }
};

// src/engine/engine.ts
class PoinoSingEngine {
  constructor() {
  }
  init() {
    return Promise.resolve().then(() => {
      if (!canUseWebGPU) {
        return Promise.reject("WebGPU is not available in this environment");
      }
      return setBackend("webgpu");
    }).then(() => ready()).then(() => {
      const backend3 = backend2();
      backend3.bufferManager._releaseBuffer = backend3.bufferManager.releaseBuffer;
      function releaseBuffer(buffer9, reuse = false) {
        return this._releaseBuffer(buffer9, reuse);
      }
      backend3.bufferManager.releaseBuffer = releaseBuffer;
    });
  }
  synthesizeNote(bpm, note, speakerVoice) {
    return new Promise((resolve, reject) => {
      tidy(() => {
        this._synthesizeNote(bpm, note, speakerVoice).then(resolve).catch(reject);
      });
    });
  }
  static getSpeakers() {
    return {
      laychie: laychieVoice,
      layney: layneyVoice
    };
  }
  _synthesizeNote(bpm, note, speakerVoice) {
    bpmSchema.parse(bpm);
    noteSchema.parse(note);
    speakerVoiceSchema.parse(speakerVoice);
    const voice = speakerVoice;
    const fs3 = speakerVoice.fs;
    const lyric = note.lyric;
    const phonemeTimingsLen = note.phonemeTimings.length;
    const phonemes = [];
    const phonemeTimings = [];
    if (kanas.includes(lyric)) {
      const kana = voice.kanas[lyric];
      const envsLen = kana?.length || 0;
      if (phonemeTimingsLen !== envsLen) {
        throw new Error(`number of elements in "phonemeTimingsLen" and "envsLen" do not match. expect ${envsLen}, but got ${phonemeTimingsLen}.`);
      }
      kana?.forEach(({ envKey }) => phonemes.push(envKey));
      note.phonemeTimings.toSorted((a, b) => a - b).forEach((tick) => phonemeTimings.push(tick));
    } else {
      const expect2 = 1;
      if (phonemeTimingsLen !== expect2) {
        throw new Error(`value of "phonemeTimingsLen" is invalid. expect ${expect2}, but got ${phonemeTimingsLen}.`);
      }
      phonemes.push(lyric);
      phonemeTimings.push(note.phonemeTimings[0]);
    }
    const offsetTick = phonemeTimings[0];
    const durationTick = Math.max(note.end - note.begin, 0) + Math.max(-offsetTick, 0);
    const duration = tick2sec(durationTick, bpm);
    const waveLen = int5(fs3 * duration);
    if (waveLen <= 0) {
      const raw = new Float32Array;
      return Promise.resolve({
        wave: raw,
        offset: 0
      });
    }
    if (["\u3001", "q"].includes(lyric)) {
      const raw = new Float32Array(waveLen);
      return Promise.resolve({
        wave: raw,
        offset: 0
      });
    }
    const pitch = note.pitch;
    const f0Seg = note.f0Seg;
    const volumeSeg = note.volumeSeg;
    const phonemeTimingPercent = phonemeTimings.map((tick) => tick2sec(tick + -offsetTick, bpm) / duration);
    const wave = tidy(() => {
      return this.synthWave(duration, pitch, f0Seg, volumeSeg, phonemeTimingPercent, phonemes, voice);
    });
    return new Promise((resolve, reject) => {
      try {
        const raw = wave.dataSync();
        resolve({
          wave: raw,
          offset: offsetTick
        });
      } catch (e) {
        reject(e);
      }
      wave.dispose();
    });
  }
  synthWave(duration, pitch, f0Seg, volSeg, timingPercent, phonemes, voice) {
    const fsMag = synthFs / voice.fs;
    const fs3 = int5(voice.fs * fsMag);
    const segLen = int5(voice.segLen * fsMag);
    const specLen = segLen % 2 === 0 ? segLen / 2 + 1 : (segLen + 1) / 2;
    const shiftLen = int5(voice.shiftLen * fsMag);
    const shiftNum = voice.shiftNum;
    const waveLen = int5(fs3 * duration);
    const freq = pitch2freq(pitch);
    const specs = Object.fromEntries(Object.keys(voice.envelopes).filter((key) => phonemes.includes(key)).map((key) => {
      const envKey = key;
      const env2 = voice.envelopes[envKey];
      if (env2 === undefined) {
        return [
          envKey,
          linspace2(0, 0, specLen)
        ];
      }
      const x = [];
      const y = [];
      const z2 = linspace2(0, fs3 / 2, specLen);
      env2.forEach((point) => {
        x.push(point[0]);
        y.push(Math.pow(10, point[1]) - 1);
      });
      const interpolated = interp(x, y, z2);
      return [
        envKey,
        interpolated
      ];
    }));
    const voicedAp = (f0) => {
      const f0Mag = 20;
      const ratio = f0 * f0Mag / (fs3 / 2);
      const tanhMag = 10;
      const apMag = 0.6;
      return tidy(() => {
        return mul(div(add2(tanh2(linspace(-ratio * tanhMag, (1 - ratio) * tanhMag, specLen)), 1), 2), apMag);
      });
    };
    const unvoicedAp = () => {
      const apMag = 0.6;
      return fill([specLen], apMag);
    };
    let wave = zeros([waveLen]);
    let position = 0;
    let prevEnvKey = null;
    let prevSegment = null;
    let prevSegmentPosition = 0;
    const a4Pitch = 69;
    const a4Freq = pitch2freq(a4Pitch);
    const segmentDisposingThreshold = Math.round(fs3 / a4Freq);
    const rfftFreqs = rfftfreq(segLen, 1 / fs3);
    const specSplitFrerq = 1000;
    const specSplitFrerqIndex = argMin5(rfftFreqs.map((rfftFreq) => Math.abs(rfftFreq - specSplitFrerq)));
    const window2 = signal.hammingWindow(segLen);
    while (position + segLen + shiftLen * shiftNum < waveLen) {
      const percent = position / waveLen;
      const f0 = f0Seg[int5(f0Seg.length * percent)] * freq;
      const indexApproximate = timingPercent.findLastIndex((_percent) => _percent <= percent);
      if (indexApproximate === -1)
        break;
      const envKey = phonemes[indexApproximate];
      let disposeSegment;
      if (envKey !== prevEnvKey) {
        disposeSegment = true;
      } else if (position - prevSegmentPosition < segmentDisposingThreshold) {
        disposeSegment = false;
      } else {
        disposeSegment = true;
      }
      let segment;
      if (disposeSegment) {
        if (prevSegment !== null) {
          prevSegment.dispose();
        }
        const spec = specs[envKey];
        const specLowAvg = avg(spec.slice(0, specSplitFrerqIndex));
        const specHighAvg = avg(spec.slice(specSplitFrerqIndex));
        const ap2 = specHighAvg > specLowAvg ? unvoicedAp() : voicedAp(f0);
        const phase = tidy(() => {
          const phase2 = mul(randomUniform([specLen], 0, 2 * Math.PI), ap2);
          ap2.dispose();
          return phase2;
        });
        segment = tidy(() => {
          const ifft8 = reshape(spectral.irfft(mul(complex(zerosLike(spec), spec), complex(cos(phase), sin(phase)))), [segLen]);
          const leftBegin = segLen / 2;
          const leftLen = segLen / 2;
          const rightBegin = 0;
          const rightLen = segLen / 2;
          const edited = mul(concat([
            ifft8.slice(leftBegin, leftLen),
            ifft8.slice(rightBegin, rightLen)
          ]), window2);
          const reverbed = tidy(() => {
            let reverbed2 = zeros([segLen + shiftLen * shiftNum]);
            for (let i = 0;i < shiftNum + 1; i++) {
              const sliced = reverbed2.slice(shiftLen * i, segLen);
              const added = add2(sliced, edited);
              const indices = tensor2d([...new Array(segLen)].map((_, j) => shiftNum * i + j), [segLen, 1], "int32");
              const updated = tensorScatterUpdate(reverbed2, indices, added);
              sliced.dispose();
              added.dispose();
              indices.dispose();
              reverbed2.dispose();
              reverbed2 = updated;
            }
            return reverbed2;
          });
          phase.dispose();
          ifft8.dispose();
          edited.dispose();
          return reverbed;
        });
        prevEnvKey = envKey;
        prevSegment = segment;
        prevSegmentPosition = position;
      } else {
        segment = prevSegment;
      }
      wave = tidy(() => {
        const volume = envKeyVolumes[envKey] * (0.5 + Math.sin(Math.PI * (Math.log10(percent * 9 + 1) / Math.log10(10))) * 0.5);
        const max11 = max(abs(segment));
        const adjuster = divNoNan([volume], max11);
        const adjusted = mul(segment, adjuster);
        const begin = position;
        const end = begin + segLen + shiftLen * shiftNum;
        const padBefore = zeros([begin]);
        const padAfter = zeros([waveLen - end]);
        const merged = add2(wave, concat([
          padBefore,
          adjusted,
          padAfter
        ]));
        wave.dispose();
        max11.dispose();
        adjuster.dispose();
        adjusted.dispose();
        padBefore.dispose();
        padAfter.dispose();
        return merged;
      });
      position += Math.min(Math.round(fs3 / f0), fs3);
    }
    prevSegment?.dispose();
    window2.dispose();
    wave = tidy(() => {
      const indices = [...new Array(int5(waveLen / fsMag))].map((_, i) => int5(i * fsMag));
      const resampled = gather(wave, indices);
      wave.dispose();
      return resampled;
    });
    const volSegResampled = resample(volSeg, wave.shape[0]);
    wave = tidy(() => {
      const adjusted = mul(wave, volSegResampled);
      wave.dispose();
      return adjusted;
    });
    return wave;
  }
}
// src/utils.ts
function downloadFile(fileName, url) {
  const a = document.createElement("a");
  a.download = fileName;
  a.href = url;
  a.click();
  a.remove();
}
function openFileDialog(accept = "", multiple = false) {
  return new Promise((resolve, reject) => {
    const input2 = document.createElement("input");
    input2.type = "file";
    input2.accept = accept;
    input2.multiple = multiple;
    input2.addEventListener("change", () => {
      if (input2.files === null || input2.files.length <= 0) {
        reject("file missing");
      } else {
        resolve(multiple ? Array.from(input2.files) : input2.files[0]);
      }
    }, { once: true });
    input2.addEventListener("cancel", () => {
      reject("was canceled");
    }, { once: true });
    input2.click();
    input2.remove();
  });
}
function readFile(file, mode) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader;
    reader.addEventListener("load", () => {
      if (reader.result === null) {
        reject("reader result is null");
        return;
      }
      resolve(reader.result);
    }, { once: true });
    reader.addEventListener("error", () => {
      reject(reader.error);
    }, { once: true });
    if (mode === "text") {
      reader.readAsText(file);
    } else {
      reader.readAsArrayBuffer(file);
    }
  });
}
function alert(message) {
  if (Array.isArray(message)) {
    const joined = message.join("\n");
    window.alert(joined);
  } else {
    window.alert(message);
  }
}
function drawWave(fs3, dataArray) {
  return new Promise((resolve, reject) => {
    if (dataArray.length <= 0) {
      throw new Error("dataArray length is less than or equal to zero");
    }
    if (!dataArray.every((data) => data.length === dataArray[0].length)) {
      throw new Error("elements of dataArray are of different lengths");
    }
    const length = dataArray[0].length;
    const merged = new Float32Array(length);
    for (let i = 0;i < dataArray.length; i++) {
      const data = dataArray[i];
      for (let j = 0;j < length; j++) {
        merged[j] += data[j] / dataArray.length;
      }
    }
    const sampleSec = 0.1;
    const sampleLength = Math.floor(fs3 * sampleSec);
    const volumes = [];
    for (let i = 0;i < length; i += sampleLength) {
      const begin = i;
      const end = begin + sampleLength;
      const sliced = merged.slice(begin, end);
      if (sliced.length <= 0)
        continue;
      const sorted = sliced.toSorted((a, b) => b - a);
      const max11 = sorted[0];
      const min9 = sorted.slice(-1)[0];
      volumes.push({ max: max11, min: min9 });
    }
    const oneSideHeight = 64;
    const width = volumes.length;
    const height = oneSideHeight * 2;
    const canvas = new OffscreenCanvas(width, height);
    const ctx = canvas.getContext("2d");
    if (ctx === null) {
      throw new Error("ctx is null");
    }
    ctx.fillStyle = "black";
    for (let i = 0;i < volumes.length; i++) {
      const vol = volumes[i];
      const x = i;
      const y = oneSideHeight - vol.max * oneSideHeight;
      const w = 1;
      const h = vol.max * oneSideHeight + -vol.min * oneSideHeight;
      ctx.fillRect(x, y, w, h);
    }
    canvas.convertToBlob().then((blob) => {
      const url = URL.createObjectURL(blob);
      resolve(url);
    }).catch(reject);
  });
}
function drawSpec(fs3, dataArray) {
  return new Promise((resolve, reject) => {
    if (dataArray.length <= 0) {
      throw new Error("dataArray length is less than or equal to zero");
    }
    if (!dataArray.every((data) => data.length === dataArray[0].length)) {
      throw new Error("elements of dataArray are of different lengths");
    }
    const length = dataArray[0].length;
    const merged = new Float32Array(length);
    for (let i = 0;i < dataArray.length; i++) {
      const data = dataArray[i];
      for (let j = 0;j < length; j++) {
        merged[j] += data[j] / dataArray.length;
      }
    }
    Promise.resolve().then(() => (init_dist7(), exports_dist3)).then((tf) => {
      const segLen = exports_utils.int(fs3 * 0.1);
      const hopLen = exports_utils.int(fs3 * 0.025);
      const waveSeq = tf.tensor(merged);
      const waveSegs = exports_utils.seq2seg(waveSeq, segLen, hopLen);
      const waveSegsWindowed = tf.tidy(() => {
        const window2 = tf.signal.hammingWindow(segLen);
        const windowed = tf.mul(waveSegs, window2);
        window2.dispose();
        waveSeq.dispose();
        waveSegs.dispose();
        return windowed;
      });
      const specSegs = tf.tidy(() => {
        const specs = tf.abs(tf.spectral.rfft(waveSegsWindowed));
        waveSegsWindowed.dispose();
        return specs;
      });
      const numKey = 132;
      const height = numKey * 6;
      const step10 = numKey / height;
      const freqsLog = [...new Array(height)].map((_, i) => exports_utils.pitch2freq(step10 * i));
      const freqsLinear = exports_utils.rfftfreq(segLen, 1 / fs3);
      const width = specSegs.shape[0];
      const data = specSegs.arraySync();
      specSegs.dispose();
      const interpolated = data.map((spec) => exports_utils.interp(freqsLinear, spec, freqsLog));
      const canvas = new OffscreenCanvas(width, height);
      const ctx = canvas.getContext("2d");
      const maxValue = 300;
      if (ctx === null) {
        throw new Error("ctx is null");
      }
      for (let i = 0;i < width; i++) {
        for (let j = 0;j < height; j++) {
          const value = interpolated[i][j];
          ctx.fillStyle = `rgba(0, 0, 0, ${value / maxValue})`;
          const x = i;
          const y = height - (j + 1);
          ctx.fillRect(x, y, 1, 1);
        }
      }
      return canvas.convertToBlob();
    }).then((blob) => {
      const url = URL.createObjectURL(blob);
      resolve(url);
    }).catch(reject);
  });
}
function kata2hira(kata) {
  return kata.replace(new RegExp("[\u30A1-\u30FC]", "gm"), (match) => {
    const code = match.charCodeAt(0) - 96;
    return String.fromCharCode(code);
  });
}
function note2hash(note) {
  const hash = [
    note.id,
    note.lyric,
    note.pitch,
    note.begin,
    note.end,
    note.f0Seg.reduce((sum31, value) => sum31 + value, 0),
    note.volumeSeg.reduce((sum31, value) => sum31 + value, 0),
    note.phonemeTimings.reduce((sum31, value) => sum31 + value, 0)
  ].join(":");
  return hash;
}
var isFirefox = () => CSS.supports("-moz-transform", "none");
var uuid = () => crypto.randomUUID();
var now2 = () => Date.now();

// src/worker.ts
function checkBackend(id) {
  try {
    const result = exports_utils.canUseWebGPU;
    postMessage(id, true, result);
  } catch (e) {
    console.error(e);
    postMessage(id, false, e);
  }
}
function init(id) {
  engine196.init().then(() => {
    postMessage(id, true, null);
  }).catch((e) => {
    console.error(e);
    postMessage(id, false, e);
  });
}
function synthNote(id, data) {
  engine196.synthesizeNote(data.bpm, data.note, speakers[data.speakerId]).then((result) => {
    postMessage(id, true, result);
  }).catch((e) => {
    console.error(e);
    postMessage(id, false, e);
  });
}
function drawWave2(id, data) {
  drawWave(data.fs, data.dataArray).then((url) => {
    postMessage(id, true, url);
  }).catch((e) => {
    console.error(e);
    postMessage(id, false, e);
  });
}
function drawSpec2(id, data) {
  drawSpec(data.fs, data.dataArray).then((url) => {
    postMessage(id, true, url);
  }).catch((e) => {
    console.error(e);
    postMessage(id, false, e);
  });
}
function postMessage(id, success, data) {
  const result = {
    id,
    type: success ? "success" : "error",
    data
  };
  self.postMessage(result);
}
var engine196 = new PoinoSingEngine;
var speakers = PoinoSingEngine.getSpeakers();
var synthDataSchema = z.object({
  bpm: exports_schemata.bpmSchema,
  note: exports_schemata.noteSchema,
  speakerId: exports_schemata.speakerIdEnumSchema
});
var waveDrawDataSchema = z.object({
  fs: z.number().min(1),
  dataArray: z.instanceof(Float32Array).array()
});
var specDrawDataSchema = z.object({
  fs: z.number().min(1),
  dataArray: z.instanceof(Float32Array).array()
});
var messageSchema = z.union([
  z.object({
    id: z.string(),
    type: z.literal("engine:backend:check"),
    data: z.null()
  }),
  z.object({
    id: z.string(),
    type: z.literal("engine:init"),
    data: z.null()
  }),
  z.object({
    id: z.string(),
    type: z.literal("engine:synth"),
    data: synthDataSchema
  }),
  z.object({
    id: z.string(),
    type: z.literal("wave:draw"),
    data: waveDrawDataSchema
  }),
  z.object({
    id: z.string(),
    type: z.literal("spec:draw"),
    data: specDrawDataSchema
  })
]);
{
  const _ = true;
}
{
  const _ = true;
}
{
  const _ = true;
}
{
  const _ = true;
}
self.addEventListener("message", (event) => {
  const result = messageSchema.safeParse(event.data);
  if (!result.success) {
    postMessage(null, false, result.error);
    return;
  }
  const message = event.data;
  switch (message.type) {
    case "engine:backend:check":
      checkBackend(message.id);
      break;
    case "engine:init":
      init(message.id);
      break;
    case "engine:synth":
      synthNote(message.id, message.data);
      break;
    case "wave:draw":
      drawWave2(message.id, message.data);
      break;
    case "spec:draw":
      drawSpec2(message.id, message.data);
      break;
  }
});
var worker_default = {};
export {
  worker_default as default
};
